OPTION STRICT
OPTION DEFINT
'====================
' OTYA WINDOW SYSTEM 
'====================
'グローバルへんすうのていぎ
VAR WIN_BKGND,WIN_BTNBACK,WIN_SELCOL,WIN_SELTXTCOL,WIN_WORKSPACECOL
VAR WIN_ACTVCAPCOL
VAR WIN_INACTVCAPCOL
VAR WIN_ACTVCAPTXTCOL
VAR WIN_INACTVCAPTXTCOL
VAR OTW_ENABLE_SHADOW
VAR OTW_INIT,OTW_MOUSESP,OTW_SHADOWSP,OTW_MOVWINSP,OTW_MOVWINCOL
VAR OTW_MOVWIN_USESP
VAR OTW_MOVWIN_HNDLR$
VAR OTW_MOVWIN_INIT
VAR OTW_MOVWIN_NUWID
VAR OTW_MOVWIN_X
VAR OTW_MOVWIN_Y
VAR OTW_MOVWIN_DX
VAR OTW_MOVWIN_DY
VAR OTW_MOVWIN_W
VAR OTW_MOVWIN_H
VAR OTW_MOVWIN_SX
VAR OTW_MOVWIN_SY
VAR OTW_MOVWIN_SW
VAR OTW_MOVWIN_SH
VAR OTW_CLIPMODE
'1:MOV
'2:RESIZE
VAR OTW_MOVWINFLG
VAR OTW_MOUSEX
VAR OTW_MOUSEY
VAR OTW_MOUSEX#,OTW_MOUSEY#
VAR OTW_LASTUPD
VAR OTW_FNT[0,0]
VAR OTW_FNTPAL[0]
VAR OTW_FNTTBL[0]
VAR OTW_CONSOLEPAL[0]
'=======================
'        WINDOW         
'=======================
VAR WIN_MAX,WIN_MSGMAX
DIM WIN_NAME$  [0]
DIM WIN_WID    [0]
DIM WIN_X      [0]
DIM WIN_Y      [0]
DIM WIN_WIDTH  [0]
DIM WIN_HEIGHT [0]
DIM WIN_AX     [0]
DIM WIN_AY     [0]
DIM WIN_AW     [0]
DIM WIN_AH     [0]
DIM WIN_RX     [0]
DIM WIN_RY     [0]
DIM WIN_RFX    [0]
DIM WIN_RFY    [0]
DIM WIN_FX     [0]
DIM WIN_FY     [0]
DIM WIN_FW1    [0]
DIM WIN_FH1    [0]
DIM WIN_FW2    [0]
DIM WIN_FH2    [0]
DIM WIN_AFW    [0]
DIM WIN_AFH    [0]
DIM WIN_CTL    [0]
DIM WIN_PID    [0]
DIM WIN_NUPID  [0]
VAR WIN_VARSIZ
DIM WIN_VAR    [0,0]
DIM WIN_NEXT   [0]
DIM WIN_PREV   [0]
DIM WIN_CHILD  [0]
DIM WIN_PARENT [0]
DIM WIN_BEGIN  [0]
DIM WIN_SP     [0]
DIM WIN_MENU   [0]
DIM WIN_GROUP  [0]
DIM WIN_GNEXT  [0]
DIM WIN_GPREV  [0]
DIM WIN_GPARENT[0]
DIM WIN_STYLE  [0]
DIM WIN_BACKGND[0]
DIM WIN_IMAGE  [0]
'QUEUE
DIM WIN_MSGS   [0]
DIM WIN_MSGE   [0]
DIM WIN_MSGBUF [0,0,0]
DIM WIN_MSGCNT [0,0]
DIM WIN_USER   [0,0]
DIM WIN_HIDE   [0]
DIM WIN_MINW   [0]
DIM WIN_MINH   [0]
'for IM
DIM WIN_CURX   [0]
DIM WIN_CURY   [0]
DIM WIN_IM     [0]

DIM WIN_TIMER  [0]
DIM WIN_PROP   [0]
DIM WIN_PRC    [0]
DIM WIN_CURSOR [0]
VAR WIN_FREE
VAR WIN_WIDCNT
VAR WIN_MSGARGSIZE
VAR WIDSHIFT
VAR NUWIDMASK
VAR WIN_FRAMEFLG
'DRAW PAGE
VAR OTW_DP
'SHOW PAGE
VAR OTW_SP
'BUFFER PAGE
VAR OTW_BP
'GPAGE
VAR OTW_GP
VAR OTW_DDRAWPAGE
'VAR WIN_FWIDTH1
'VAR WIN_FHEIGHT1
'VAR WIN_FWIDTH2
'VAR WIN_FHEIGHT2
'H1
'          
'
'          
'          
'          
'          
'          
'H2
'⇔⇔
'W1         W2
'
VAR WIN_STYLE_NONE
VAR WIN_STYLE_MODAL
VAR WIN_STYLE_RESIZ
VAR WIN_STYLE_TRANS
VAR WIN_STYLE_HIDE
VAR WIN_STYLE_OWNERDRAW
VAR WIN_STYLE_MINMAX
VAR WIN_STYLE_TOOL
VAR WIN_STYLE_NCLIP
VAR WIN_STYLE_NARROW
VAR WIN_STYLE_TOPMST
VAR WIN_STYLE_NEVERACTV
VAR WIN_STYLE_MAX
VAR WIN_STYLE_MIN
VAR WIN_STYLE_DCLS
VAR WIN_STYLE_DMAX
VAR WIN_STYLE_DMIN
VAR WIN_STYLE_DIS
VAR WIN_ACTIVENUWID
VAR WIN_INPUTNUWID
'DOUBLE CLICK
'まえ CLICK した WINDOW
VAR OTW_LCLKWND
'そのFRAME
VAR OTW_LCLKF
VAR OTW_RCLKWND
VAR OTW_RCLKF
'なんFRAMEまで DOUBLE CLICKか
VAR OTW_DBLCLKF
'MOUSEのずれのキョヨウはんい
VAR OTW_DBLCLKXY
VAR OTW_DBLCLKX
VAR OTW_DBLCLKY

VAR OTW_SMOOTH_MOVE_WINDOW
VAR WIN_SHELL$
VAR WIN_IM$

VAR OTW_INSPECTWIN

VAR OTW_CONF_KEY$[0]
VAR OTW_CONF_VALUE$[0]

DEF OTW_WIN_INITARRAY
 PrintConsoleln "Init window..."
 VAR FM=FREEMEM
 OTW_DBLCLKF=30
 OTW_DBLCLKXY=4'±4
 WIN_STYLE_MODAL=1
 WIN_STYLE_RESIZ=2
 WIN_STYLE_TRANS=4
 WIN_STYLE_HIDE=8
 WIN_STYLE_OWNERDRAW=16
 WIN_STYLE_MINMAX=32
 WIN_STYLE_TOOL=64
 WIN_STYLE_NARROW=128
 WIN_STYLE_NCLIP=256
 WIN_STYLE_TOPMST=512
 WIN_STYLE_NEVERACTV=1024
 WIN_STYLE_MAX=2048
 WIN_STYLE_MIN=4096
 WIN_STYLE_DCLS=8192
 WIN_STYLE_DMAX=16384
 WIN_STYLE_DMIN=32768
 WIN_STYLE_DIS=65536
'WIN_FWIDTH1=0
'WIN_FHEIGHT1=10
'WIN_FWIDTH2=0
'WIN_FHEIGHT2=0
 WIN_MAX=256
 WIN_MSGMAX=64
 WIN_MSGARGSIZE=3
 WIDSHIFT=12
 NUWIDMASK=4095
 WIN_FRAMEFLG=32768
 WIN_VARSIZ=8
 WIN_NAME$     =NewArray$(WIN_MAX)
 WIN_WID       =NewArray(WIN_MAX)
 WIN_X         =NewArray(WIN_MAX)
 WIN_Y         =NewArray(WIN_MAX)
 WIN_WIDTH     =NewArray(WIN_MAX)
 WIN_HEIGHT    =NewArray(WIN_MAX)
 WIN_AX        =NewArray(WIN_MAX)
 WIN_AY        =NewArray(WIN_MAX)
 WIN_AW        =NewArray(WIN_MAX)
 WIN_AH        =NewArray(WIN_MAX)
 WIN_RX        =NewArray(WIN_MAX)
 WIN_RY        =NewArray(WIN_MAX)
 WIN_RFX       =NewArray(WIN_MAX)
 WIN_RFY       =NewArray(WIN_MAX)
 WIN_FX        =NewArray(WIN_MAX)
 WIN_FY        =NewArray(WIN_MAX)
 WIN_FW1       =NewArray(WIN_MAX)
 WIN_FH1       =NewArray(WIN_MAX)
 WIN_FW2       =NewArray(WIN_MAX)
 WIN_FH2       =NewArray(WIN_MAX)
 WIN_AFW       =NewArray(WIN_MAX)
 WIN_AFH       =NewArray(WIN_MAX)
 WIN_CTL       =NewArray(WIN_MAX)
 WIN_PID       =NewArray(WIN_MAX)
 WIN_NUPID     =NewArray(WIN_MAX)
 WIN_VAR       =NewArray2(WIN_MAX,WIN_VARSIZ)
 WIN_NEXT      =NewArray(WIN_MAX)
 WIN_PREV      =NewArray(WIN_MAX)
 WIN_CHILD     =NewArray(WIN_MAX)
 WIN_PARENT    =NewArray(WIN_MAX)
 WIN_BEGIN     =NewArray(WIN_MAX)
 WIN_SP        =NewArray(WIN_MAX)
 WIN_HIDE      =NewArray(WIN_MAX)
 WIN_MINW      =NewArray(WIN_MAX)
 WIN_MINH      =NewArray(WIN_MAX)
 WIN_MENU      =NewArray(WIN_MAX)
 WIN_GROUP     =NewArray(WIN_MAX)
 WIN_GNEXT     =NewArray(WIN_MAX)
 WIN_GPREV     =NewArray(WIN_MAX)
 WIN_GPARENT   =NewArray(WIN_MAX)
 WIN_STYLE     =NewArray(WIN_MAX)
 WIN_IMAGE     =NewArray(WIN_MAX)
 WIN_BACKGND   =NewArray(WIN_MAX)
 WIN_CURX      =NewArray(WIN_MAX)
 WIN_CURY      =NewArray(WIN_MAX)
 WIN_IM        =NewArray(WIN_MAX)
 WIN_MSGS      =NewArray(WIN_MAX)
 WIN_MSGE      =NewArray(WIN_MAX)
 WIN_MSGBUF    =NewArray3(WIN_MAX,WIN_MSGMAX,WIN_MSGARGSIZE)
 OTW_TIMER_INIT
 WIN_TIMER     =NewArray(WIN_MAX)
 OTW_PROP_INIT
 WIN_PROP      =NewArray(WIN_MAX)
 WIN_PRC       =NewArray(WIN_MAX)
 WIN_CURSOR    =NewArray(WIN_MAX)
 'WIN_MSGCNT    =NewArray2(WIN_MAX,CTL_HANDLER_MAX)
 WIN_FREE=1
 OTW_INITLIST WIN_NEXT
 OTW_MENU_INITARRAY
 OTW_IMAGE_INITARRAY
 WIN_WID[0]=&Hdeadbeef
END
VAR WIN_ROOTWND
VAR WIN_ROOTWND2
DIM IMAGE_PTR[0]
DIM IMAGE_HEIGHT[0]
DIM IMAGE_WIDTH[0]
DIM IMAGE_ID[0]
DIM IMAGE_NEXT[0]
DIM IMAGE_HOTX[0]
DIM IMAGE_HOTY[0]
DIM IMAGE_ATTR[0]
VAR IMAGE_MAX
VAR IMAGE_IDCNT
VAR IMAGE_FREE
VAR IMAGE_NOALLOC
VAR IMAGE_INVALIDID
VAR IMAGE_ATTR_2DIM'1
VAR IMAGE_ATTR_1DIM'0
VAR IMAGE_ATTR_LOG'0
VAR IMAGE_ATTR_PHY'2
VAR IMAGE_ATTR_HIDESHDW'4
DEF OTW_IMAGE_INITARRAY
 IMAGE_NOALLOC=1
 IMAGE_INVALIDID=2
 IMAGE_MAX=256
 IMAGE_IDCNT=1
 IMAGE_FREE=1
 IMAGE_PTR=NewArray(IMAGE_MAX)
 IMAGE_WIDTH=NewArray(IMAGE_MAX)
 IMAGE_HEIGHT=NewArray(IMAGE_MAX)
 IMAGE_ID=NewArray(IMAGE_MAX)
 IMAGE_NEXT=NewArray(IMAGE_MAX)
 IMAGE_HOTX=NewArray(IMAGE_MAX)
 IMAGE_HOTY=NewArray(IMAGE_MAX)
 IMAGE_ATTR=NewArray(IMAGE_MAX)
 OTW_INITLIST IMAGE_NEXT
 IMAGE_ATTR_2DIM=1
 IMAGE_ATTR_1DIM=0
 IMAGE_ATTR_LOG=0
 IMAGE_ATTR_PHY=2
 IMAGE_ATTR_HIDESHDW=4
END
'=======================
'MENU
'=======================
'Item
DIM MENU_INAME$[0]
DIM MENU_INEXT[0]
DIM MENU_IPREV[0]
DIM MENU_ICHILD[0]
DIM MENU_IPARENT[0]
DIM MENU_ISTYLE[0]
DIM MENU_IVAR[0]
VAR MENU_ITEMMAX
VAR MENU_ITEMFREE

DIM MENU_WIDTH[0]
DIM MENU_HEIGHT[0]
DIM MENU_NUWID[0]
DIM MENU_OWNER[0]
DIM MENU_ITEM[0]
DIM MENU_SHOW[0]
DIM MENU_NEXT[0]
DIM MENU_LAST[0]
DIM MENU_TYPE[0]
'Select
DIM MENU_SEL[0]
DIM MENU_ID[0]
DIM MENU_CHECKROW[0]
VAR MENU_MAX
VAR MENU_IDCNT
VAR MENU_FREE
VAR MENUCTL
VAR MENU_STYLE_SEPARATOR
VAR MENU_SEPARATOR_HEIGHT
VAR MENU_STYLE_CHILD
VAR MENU_STYLE_RADIO
VAR MENU_STYLE_CHECK
VAR MENU_STYLE_CHECKED
VAR MENU_STYLE_DISABLED
VAR MENU_CHILD_MARK_W
VAR MENU_CHILD_MARK_H
VAR MENU_CHECK_W
VAR MENU_RADIO_W
VAR MENU_NOTIFID
VAR MENU_NOALLOC
VAR MENU_INVALIDID
VAR MENU_NOITEM
VAR MENU_CURRENT
VAR MENU_TYPE_NONE
VAR MENU_TYPE_BAR
DEF OTW_MENU_INITARRAY
 PrintConsoleln "Init menu..."
 MENU_ITEMMAX=1024
 MENU_INAME$=NewArray$(MENU_ITEMMAX)
 MENU_INEXT=NewArray(MENU_ITEMMAX)
 MENU_IPREV=NewArray(MENU_ITEMMAX)
 MENU_ICHILD=NewArray(MENU_ITEMMAX)
 MENU_IPARENT=NewArray(MENU_ITEMMAX)
 MENU_ISTYLE=NewArray(MENU_ITEMMAX)
 MENU_STYLE_SEPARATOR=1
 MENU_SEPARATOR_HEIGHT=4
 MENU_STYLE_CHILD=2
 MENU_STYLE_RADIO=4
 MENU_STYLE_CHECK=8
 MENU_STYLE_CHECKED=16
 MENU_STYLE_DISABLED=32
 MENU_CHILD_MARK_W=4
 MENU_CHILD_MARK_H=4
 MENU_IVAR=NewArray(MENU_ITEMMAX)
 OTW_INITLIST MENU_INEXT
 MENU_ITEMFREE=1
 MENU_MAX=256
 MENU_WIDTH=NewArray(MENU_MAX)
 MENU_HEIGHT=NewArray(MENU_MAX)
 MENU_NUWID=NewArray(MENU_MAX)
 MENU_OWNER=NewArray(MENU_MAX)
 MENU_ITEM=NewArray(MENU_MAX)
 MENU_LAST=NewArray(MENU_MAX)
 MENU_SEL=NewArray(MENU_MAX)
 MENU_SHOW=NewArray(MENU_MAX)
 MENU_CHECKROW=NewArray(MENU_MAX)
 MENU_TYPE=NewArray(MENU_MAX)
 MENU_IDCNT=0
 MENU_ID=NewArray(MENU_MAX)
 MENU_NEXT=MENU_ITEM
 OTW_INITLIST MENU_NEXT
 MENU_FREE=1
 MENU_CHECK_W=8
 MENU_RADIO_W=8
 MENU_NOTIFID=&HDEADFEED
 MENU_NOALLOC=&H5001
 MENU_INVALIDID=&H5002
 MENU_NOITEM=&H5003
 MENU_CURRENT=0
 MENU_TYPE_NONE=0
 MENU_TYPE_BAR=1
END
'FILE
VAR ASSOC_LEN
DIM ASSOC_TYP$[0]
DIM ASSOC_EXT$[0]
DIM ASSOC_NAME$[0]
'OTW.CONF
'TXT:EXT=PROGRAM
DEF OTW_ASSOC_INIT
 ASSOC_TYP$=NewArray$(0)
 ASSOC_EXT$=NewArray$(0)
 ASSOC_NAME$=NewArray$(0)
 ASSOC_LEN=0
 VAR E=AssociateFile("*","","EDITORSEL")
 E=AssociateFile("/","","OTYFIL")
 VAR I
 FOR I=0TO LEN(OTW_CONF_KEY$)-1
  VAR K$=OTW_CONF_KEY$[I]
  IF INSTR(K$,"TXT:")==0THEN
   VAR EXT$=MID$(K$,4,&H7FFFFFFF)
   E=AssociateFile("*",EXT$,OTW_CONF_VALUE$[I])
   CONTINUE
  ENDIF
  IF INSTR(K$,"DAT:")==0THEN
   EXT$=MID$(K$,4,&H7FFFFFFF)
   E=AssociateFile(" ",EXT$,OTW_CONF_VALUE$[I])
   CONTINUE
  ENDIF
 NEXT
END
DEF GetAssociatedIndex(TYP$,EXT$)
 VAR I
 EXT$=ToUpper$(EXT$)
 FOR I=0TO ASSOC_LEN-1
  IF ASSOC_EXT$[I]==EXT$&&ASSOC_TYP$[I]==TYP$THEN 
   RETURN I
  ENDIF
 NEXT
 RETURN -1
END
COMMON DEF GetAssociatedProgram$(TYP$,EXT$)
 VAR I=GetAssociatedIndex(TYP$,EXT$)
 IF I!=-1THEN RETURN ASSOC_NAME$[I]
 'unknown EXT
 IF LEN(EXT$)THEN
  RETURN GetAssociatedProgram$(TYP$,"")
 ENDIF
 RETURN ""
END
COMMON DEF AssociateFile(TYP$,EXT$,NAME$)
 VAR I=GetAssociatedIndex(TYP$,EXT$)
 IF I!=-1THEN
  ASSOC_NAME$[I]=NAME$
  RETURN 0
 ENDIF
 PUSH ASSOC_EXT$,EXT$
 PUSH ASSOC_TYP$,TYP$
 PUSH ASSOC_NAME$,NAME$
 INC ASSOC_LEN
 RETURN 0
END
'HOGE
COMMON DEF ExecFile(F$)
 VAR TYPE$,E
 F$=GetAbsolutePath$(F$)
 GetFileType F$ OUT TYPE$,E
 IF E THEN RETURN E
 VAR EXT$=GetFileExtension$(F$)
 VAR PRG$=GetAssociatedProgram$(TYPE$,EXT$)
 VAR PRC
 NewProcess PRG$,EscapeArg$(F$) OUT PRC,E
 IF E THEN RETURN E
 RETURN 0
END

'IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
' ExitProcess 1
'ENDIF
VAR OTWRunning
COMMON DEF IsWinRunning()
 RETURN OTWRunning
END
'=======================
'CONTROL
'=======================
VAR CTL_MAX
VAR CTL_HANDLER_MAX
DIM CTL_NAME$    [0]
DIM CTL_CID      [0]
DIM CTL_DAT      [0]
DIM CTL_FW1      [0]
DIM CTL_FH1      [0]
DIM CTL_FW2      [0]
DIM CTL_FH2      [0]
DIM CTL_NEXT     [0]
DIM CTL_PARENTCTL[0]
DIM CTL_HANDLER$ [0,0]
DIM CTL_IMPLICIT [0,0]
'FOR CHILD CONTROL
DIM CTL_CIMPLICIT[0,0]
DIM CTL_NDHNDLR[0]
VAR CTL_FREE
VAR CTL_CIDCNT
VAR CTL_PAINTHANDLER
COMMON DEF RepaintControlEvent()
 RETURN CTL_PAINTHANDLER
END
VAR CTL_LBTNUPHANDLER
VAR CTL_LBTNDWNHANDLER
VAR CTL_RBTNUPHANDLER
VAR CTL_RBTNDWNHANDLER
VAR CTL_FRMBTNHANDLER
VAR CTL_DRWFRMHANDLER
VAR CTL_NOTIFHANDLER
VAR CTL_KEYHANDLER
VAR CTL_BTNHANDLER
VAR CTL_CHFOCUSHANDLER
VAR CTL_MOUSEMVHANDLER
VAR CTL_FRMMOUSEMVHANDLER
VAR CTL_CREATEHANDLER
VAR CTL_STRNOTIFHANDLER
VAR CTL_DELETEHANDLER
VAR CTL_LDBLCLKHANDLER
VAR CTL_MSLEAVEHANDLER
VAR CTL_RESIZEHANDLER
VAR CTL_FRMPAINTHANDLER
VAR CTL_CHLDWNDHANDLER
VAR CTL_PRNTWNDHANDLER
VAR CTL_QUERYFRMHANDLER
VAR CTL_CTXMENUHANDLER
VAR CTL_CHINPUTHANDLER
VAR CTL_LBTNFLG
VAR CTL_RBTNFLG
VAR CTL_BTNDWNFLG
VAR CTL_BTNUPFLG
VAR CTL_LEAVEFLG
VAR CTL_DBLFLG
VAR CTL_WINDOWCTL
VAR CTL_BUTTONCTL
VAR CTL_TGLBTNCTL
VAR CTL_TXTBOXCTL
VAR CTL_LABELCTL
VAR CTL_VSCRBARCTL
VAR CTL_NUMUPDWNCTL
VAR CTL_DRPDWNCTL

VAR CTL_LSTBOXCTL
VAR CTL_DRPDWNBOXCTL
'CONTROL STYLE
'クリックしてもFOCUSしない
VAR CTL_STYLE_NCFOCUS

VAR CTL_MSGBOXCTL

VAR CTL_HSCRBARCTL

VAR WINCTL_CAPCY
VAR WINCTL_MENUCY
VAR WINCTL_NARROW_CAPCY
VAR WINCTL_CAPICON_WIDTH
VAR WINCTL_HIT_CLS
VAR WINCTL_HIT_MAX
VAR WINCTL_HIT_MIN
VAR WINCTL_HIT_CAP
'B1  B2  B3
'  
'B4    B5
'  
'B5  B7  B8
VAR WINCTL_HIT_B1
VAR WINCTL_HIT_B2
VAR WINCTL_HIT_B3
VAR WINCTL_HIT_B4
VAR WINCTL_HIT_B5
VAR WINCTL_HIT_B6
VAR WINCTL_HIT_B7
VAR WINCTL_HIT_B8
VAR WINCTL_HIT_CAPICON

VAR WINCTL_DRW_ALL
VAR WINCTL_DRW_CAP
VAR WINCTL_DRW_BORDER
VAR WINCTL_DRW_MENU

VAR WINCTL_SYSMENU
VAR WINCTL_MENU_RESTORE
VAR WINCTL_MENU_MINIMIZE
VAR WINCTL_MENU_MAXIMIZE
VAR WINCTL_MENU_CLOSE

VAR TXTBOX_WV_CX
VAR TXTBOX_WV_SX
VAR TXTBOX_WV_EX
VAR TXTBOX_WV_OFFX
VAR TXTBOX_MENU
VAR TXTBOX_MENU_COPY
VAR TXTBOX_MENU_CUT
VAR TXTBOX_MENU_PASTE
VAR TXTBOX_MENU_SELALL
DEF OTW_CTL_INITARRAY
 PrintConsoleln "Init control..."
 CTL_STYLE_NCFOCUS=1
 CTL_MAX=64
 CTL_HANDLER_MAX=24
 WIN_MSGCNT    =NewArray2(WIN_MAX,CTL_HANDLER_MAX)
 CTL_NAME$     =NewArray$(CTL_MAX)
 CTL_DAT       =NewArray(CTL_MAX)
 CTL_FW1       =NewArray(CTL_MAX)
 CTL_FH1       =NewArray(CTL_MAX)
 CTL_FW2       =NewArray(CTL_MAX)
 CTL_FH2       =NewArray(CTL_MAX)
 CTL_CID       =NewArray(CTL_MAX)
 CTL_NEXT      =NewArray(CTL_MAX)
 CTL_PARENTCTL =NewArray(CTL_MAX)
 CTL_HANDLER$  =NewArray2$(CTL_MAX,CTL_HANDLER_MAX)
 CTL_IMPLICIT  =NewArray2(CTL_MAX,CTL_HANDLER_MAX)
 CTL_CIMPLICIT =NewArray2(CTL_MAX,CTL_HANDLER_MAX)
 CTL_NDHNDLR=NewArray(CTL_MAX)
 CTL_FREE=1
 OTW_INITLIST CTL_NEXT
 VAR E
 NewControl "WINDOW" OUT CTL_WINDOWCTL,E
 NewControl "BUTTON" OUT CTL_BUTTONCTL,E
 NewControl "TXTBOX" OUT CTL_TXTBOXCTL,E
 NewControl "LABEL" OUT CTL_LABELCTL,E
 NewControl "VSCRBAR" OUT CTL_VSCRBARCTL,E
 NewControl "HSCRBAR" OUT CTL_HSCRBARCTL,E
 CTL_PAINTHANDLER=0
 'CTL_NDHNDLR[CTL_PAINTHANDLER]=TRUE
 CTL_LBTNDWNHANDLER=1
 CTL_LBTNUPHANDLER=2
 CTL_RBTNUPHANDLER=3
 CTL_RBTNDWNHANDLER=4

 CTL_FRMBTNHANDLER=5
 CTL_NOTIFHANDLER=6
 CTL_KEYHANDLER=7
 CTL_BTNHANDLER=8
 CTL_CHFOCUSHANDLER=9
 CTL_MOUSEMVHANDLER=10
 CTL_FRMMOUSEMVHANDLER=11
 CTL_CREATEHANDLER=12
 CTL_STRNOTIFHANDLER=13
 CTL_DELETEHANDLER=14
 CTL_LDBLCLKHANDLER=15
 CTL_MSLEAVEHANDLER=16
 CTL_RESIZEHANDLER=17
 CTL_FRMPAINTHANDLER=18
 CTL_CHLDWNDHANDLER=19
 CTL_PRNTWNDHANDLER=20
 CTL_QUERYFRMHANDLER=21
 CTL_CTXMENUHANDLER=22
 CTL_CHINPUTHANDLER=23
 'A1=,A2=bit16~31Y,Xbit0~15
 CTL_LBTNFLG=4
 CTL_RBTNFLG=8
 CTL_BTNDWNFLG=1
 CTL_BTNUPFLG=2
 CTL_LEAVEFLG=64
 CTL_DBLFLG=128
' CTL_DRWFRMHANDLER=3
'E=SetControlFrameSize(CTL_WINDOWCTL,WIN_FWIDTH1,WIN_FHEIGHT1,WIN_FWIDTH2,WIN_FHEIGHT2)
'E=SetControlFrameSize(CTL_WINDOWCTL,1,12,1,1)
 E=SetControlFrameSize(CTL_WINDOWCTL,1,12,1,1)
 E=SetControlQueryFrameHandler(CTL_WINDOWCTL,"WindowQueryFrame")
 E=SetControlPainter(CTL_WINDOWCTL,"WindowPainter")
 E=SetControlFramePainter(CTL_WINDOWCTL,"WindowFramePainter")
 E=SetControlLMouseDownHandler(CTL_WINDOWCTL,"WindowLMouseDown")
 E=SetControlClickFrameHandler(CTL_WINDOWCTL,"WindowClickFrame")
 E=SetControlMMoveFrameHandler(CTL_WINDOWCTL,"WindowMMoveFrame")
 E=SetControlChFocusHandler(CTL_WINDOWCTL,"WindowChFocus")
 E=SetControlChildWindowHandler(CTL_WINDOWCTL,"WindowChildWindow")
 E=SetControlParentWindowHandler(CTL_WINDOWCTL,"WindowParentWindow")
 E=SetControlNotifHandler(CTL_WINDOWCTL,"WindowNotif")
 E=SetControlHandlerImplicit(CTL_WINDOWCTL,CTL_NOTIFHANDLER,TRUE)
 WINCTL_CAPCY=10
 WINCTL_MENUCY=10
 WINCTL_NARROW_CAPCY=5
 WINCTL_CAPICON_WIDTH=7
 WINCTL_HIT_CLS=1
 WINCTL_HIT_MAX=2
 WINCTL_HIT_MIN=3
 WINCTL_HIT_CAP=4
 WINCTL_HIT_B1 =5
 WINCTL_HIT_B2 =6
 WINCTL_HIT_B3 =7
 WINCTL_HIT_B4 =8
 WINCTL_HIT_B5 =9
 WINCTL_HIT_B6 =10
 WINCTL_HIT_B7 =11
 WINCTL_HIT_B8 =12
 WINCTL_HIT_CAPICON=13
 WINCTL_DRW_ALL=-1
 WINCTL_DRW_CAP=1
 WINCTL_DRW_BORDER=2
 WINCTL_DRW_MENU=4
 NewMenu OUT WINCTL_SYSMENU,E
 WINCTL_MENU_RESTORE=&H52FC8461
 AddMenuItem WINCTL_SYSMENU,"Restore",WINCTL_MENU_RESTORE
 WINCTL_MENU_MINIMIZE=&H52FC8464
 AddMenuItem WINCTL_SYSMENU,"Minimize",WINCTL_MENU_MINIMIZE
 WINCTL_MENU_MAXIMIZE=&H52FC8465
 AddMenuItem WINCTL_SYSMENU,"Maximize",WINCTL_MENU_MAXIMIZE
 AddMenuItemSeparator WINCTL_SYSMENU
 WINCTL_MENU_CLOSE=&H52FC8466
 AddMenuItem WINCTL_SYSMENU,"Close",WINCTL_MENU_CLOSE
 E=SetControlPainter(CTL_BUTTONCTL,"ButtonPainter")
 E=SetControlLMouseUpHandler(CTL_BUTTONCTL,"ButtonLMouseUP")
 E=SetControlLMouseDownHandler(CTL_BUTTONCTL,"ButtonLMouseDown")
 E=SetControlPainter(CTL_TXTBOXCTL,"TextBoxPainter")
 E=SetControlLMouseDownHandler(CTL_TXTBOXCTL,"TextBoxLMouseDown")
 E=SetControlLDoubleClickHandler(CTL_TXTBOXCTL,"TextBoxLDoubleClick")
 E=SetControlLMouseUpHandler(CTL_TXTBOXCTL,"TextBoxLMouseUp")
 E=SetControlMouseMoveHandler(CTL_TXTBOXCTL,"TextBoxMouseMove")
 E=SetControlKeyHandler(CTL_TXTBOXCTL,"TextBoxKey")
 E=SetControlButtonHandler(CTL_TXTBOXCTL,"TextBoxButton")
 E=SetControlChFocusHandler(CTL_TXTBOXCTL,"TextBoxChFocus")
 E=SetControlContextMenuHandler(CTL_TXTBOXCTL,"TextBoxContextMenu")
 E=SetControlNotifHandler(CTL_TXTBOXCTL,"TextBoxNotif")
 E=SetControlCreateHandler(CTL_TXTBOXCTL,"TextBoxCreate")
 NewMenu OUT TXTBOX_MENU,E
 TXTBOX_MENU_COPY=1
 AddMenuItem TXTBOX_MENU,"Copy",TXTBOX_MENU_COPY
 TXTBOX_MENU_CUT=2
 AddMenuItem TXTBOX_MENU,"Cut",TXTBOX_MENU_CUT
 TXTBOX_MENU_PASTE=3
 AddMenuItem TXTBOX_MENU,"Paste",TXTBOX_MENU_PASTE
 AddMenuItemSeparator TXTBOX_MENU
 TXTBOX_MENU_SELALL=4
 AddMenuItem TXTBOX_MENU,"Select all",TXTBOX_MENU_SELALL

 E=SetControlPainter(CTL_LABELCTL,"LabelPainter")
 TXTBOX_WV_CX=1
 TXTBOX_WV_SX=2
 TXTBOX_WV_EX=3
 TXTBOX_WV_OFFX=4

 E=SetControlPainter(CTL_VSCRBARCTL,"VSCRBARPainter")
 E=SetControlLMouseUpHandler(CTL_VSCRBARCTL,"VSCRBARLMouseUP")
 E=SetControlLMouseDownHandler(CTL_VSCRBARCTL,"VSCRBARLMouseDown")
 E=SetControlParentWindowHandler(CTL_VSCRBARCTL,"VSCRBARPARENT")


 ExtendControl "ToggleButton",CTL_BUTTONCTL OUT CTL_TGLBTNCTL,E
 E=SetControlLMouseUpHandler(CTL_TGLBTNCTL,"ToggleButtonLMouseUP")
 E=SetControlLMouseDownHandler(CTL_TGLBTNCTL,"ToggleButtonLMouseDown")

 ExtendControl "NUMUPDWN",CTL_TXTBOXCTL OUT CTL_NUMUPDWNCTL,E
 E=SetControlLMouseUpHandler(CTL_NUMUPDWNCTL,"NumUpDownLMouseUP")
 E=SetControlLMouseDownHandler(CTL_NUMUPDWNCTL,"NumUpDownLMouseDown")
 E=SetControlPainter(CTL_NUMUPDWNCTL,"NumUpDownPainter")
 E=SetControlKeyHandler(CTL_NUMUPDWNCTL,"NumUpDownKey")
 E=SetControlCreateHandler(CTL_NUMUPDWNCTL,"NumUpDownCreate")
 'MENU
 NewControl"POPUPMENU" OUT MENUCTL,E
 E=SetControlPainter(MENUCTL,"MenuPainter")
 E=SetControlMouseMoveHandler(MENUCTL,"MenuMouseMove")
 E=SetControlMouseLeaveHandler(MENUCTL,"MenuMouseLeave")
 E=SetControlLMouseUpHandler(MENUCTL,"MenuLMouseUp")
 E=SetControlChInputHandler(MENUCTL,"MenuChFocus")
 E=SetControlNotifHandler(MENUCTL,"MenuNotif")
 E=SetControlDeleteHandler(MENUCTL,"MenuDelete")


 OTW_CTL_LIST
 NewControl "DROPDOWNLIST" OUT CTL_DRPDWNCTL,E
 E=SetControlPainter(CTL_DRPDWNCTL,"DropDownListPainter")
 E=SetControlLMouseDownHandler(CTL_DRPDWNCTL,"DropDownListLMD")
 E=SetControlLMouseUpHandler(CTL_DRPDWNCTL,"DropDownListLMU")
 E=SetControlNotifHandler(CTL_DRPDWNCTL,"DropDownListNotif")
 E=SetControlDeleteHandler(CTL_DRPDWNCTL,"DropDownListDelete")

 ExtendControl "DROPDOWNLISTBOX",GetListBoxControl() OUT CTL_DRPDWNBOXCTL,E
 E=SetControlChInputHandler(CTL_DRPDWNBOXCTL,"DropDownListBoxChFocus")
 E=SetControlChildWindowHandler(CTL_DRPDWNBOXCTL,"DropDownListBoxCWIN")

 'MESSAGE BOX
 ExtendControl "MESSAGEBOX",GetWindowControl() OUT CTL_MSGBOXCTL,E
 E=SetControlCreateHandler(CTL_MSGBOXCTL,"MessageBoxOnCreate")
 E=SetControlNotifHandler(CTL_MSGBOXCTL,"MessageBoxOnNotif")

 E=SetControlPainter(CTL_HSCRBARCTL,"HSCRBARPainter")
 E=SetControlLMouseUpHandler(CTL_HSCRBARCTL,"HSCRBARLMouseUP")
 E=SetControlLMouseDownHandler(CTL_HSCRBARCTL,"HSCRBARLMouseDown")
 E=SetControlParentWindowHandler(CTL_HSCRBARCTL,"HSCRBARPARENT")

 PrintConsoleln "Init textbox..."
 INIT_TXTBOXEX
 CTL_CID[0]=&Hdeadbeef
END
DIM LISTSTR$[0]
DIM LISTSTRNEXT[0]
DIM LISTSTRPREV[0]
DIM LISTSTRPARENT[0]
DIM LISTSTRCHILD[0]
VAR LISTSTR_FREE
VAR LISTSTR_MAX
DEF OTW_CTL_LIST
 LISTSTR_MAX=256
 LISTSTR$=NewArray$(LISTSTR_MAX)
 LISTSTRNEXT=NewArray(LISTSTR_MAX)
 LISTSTRPREV=NewArray(LISTSTR_MAX)
 OTW_INITLIST LISTSTRNEXT
 LISTSTR_FREE=1
 LISTBOX_INIT_WV
 VAR E
 NewControl "LSTBOX" OUT CTL_LSTBOXCTL,E
 E=SetControlPainter(CTL_LSTBOXCTL,"ListBoxPainter")
 E=SetControlCreateHandler(CTL_LSTBOXCTL,"ListBoxCreate")
 E=SetControlNotifHandler(CTL_LSTBOXCTL,"ListBoxNotif")
 E=SetControlLMouseDownHandler(CTL_LSTBOXCTL,"ListBoxLMD")
 E=SetControlLDoubleClickHandler(CTL_LSTBOXCTL,"ListBoxLMD")
 E=SetControlDeleteHandler(CTL_LSTBOXCTL,"ListBoxDelete")
 E=SetControlResizeHandler(CTL_LSTBOXCTL,"ListBoxResize")
 E=SetControlButtonHandler(CTL_LSTBOXCTL,"ListBoxButton")
END
DEF OTW_INITLIST ARY[]
 VAR I
 FOR I=1TO LEN(ARY)-2
  ARY[I]=I+1
 NEXT
END
VAR IM_MAX
VAR IM_FREE
VAR IM_IDCNT
DIM IM_NEXT[0]
DIM IM_ID[0]
DIM IM_KEY_HANDLER$[0]
DIM IM_DEL_HANDLER$[0]
'IM>
DEF OTW_IM_INITARRAY
 IM_MAX=5
 IM_NEXT=NewArray(IM_MAX)
 IM_ID=NewArray(IM_MAX)
 IM_KEY_HANDLER$=NewArray$(IM_MAX)
 IM_DEL_HANDLER$=NewArray$(IM_MAX)
 IM_IDCNT=1
 OTW_INITLIST IM_NEXT
 IM_FREE=1
 SetKeyboardMode TRUE
END
VAR IM_NOALLOC
VAR IM_INVALIDID
COMMON DEF CheckIM(IM)
 RETURN IM_ID[IM AND 4095]==IM>>12
END
COMMON DEF SetIMKeyHandler(IM,FUNC$)
 IF!CheckIM(IM)THEN
  RETURN IM_INVALIDID
 ENDIF
 VAR NIM=IM AND 4095
 IM_KEY_HANDLER$[NIM]=FUNC$
 RETURN 0
END
COMMON DEF SetIMDeleteHandler(IM,FUNC$)
 IF!CheckIM(IM)THEN
  RETURN IM_INVALIDID
 ENDIF
 VAR NIM=IM AND 4095
 IM_DEL_HANDLER$[NIM]=FUNC$
 RETURN 0
END
COMMON DEF DeleteIM IM OUT ERR
 IF!CheckIM(IM)THEN
  ERR=IM_INVALIDID
  RETURN
 ENDIF
 VAR NIM=IM AND 4095
 IM_ID[NIM]=0
 IM_NEXT[NIM]=IM_FREE
 IF CHKCALL(IM_DEL_HANDLER$[NIM])THEN
  CALL IM_DEL_HANDLER$[NIM],IM
 ENDIF
 IM_KEY_HANDLER$[NIM]=""
 IM_DEL_HANDLER$[NIM]=""
 ERR=0
 IM_FREE=NIM
END
DEF DeleteAllIM OUT ERR
 VAR L=LEN(IM_ID)-1,I
 ERR=0
 FOR I=0TO L
  VAR ID=IM_ID[I]
  IF!ID THEN CONTINUE
  ERR=DeleteIM(ID<<12 OR I)
  IF ERR THEN RETURN
 NEXT
END
COMMON DEF NewIM OUT IM,ERR
 IM=IM_FREE
 IF!IM THEN
  ERR=IM_NOALLOC
  RETURN
 ENDIF
 IM_ID[IM]=IM_IDCNT
 INC IM_IDCNT
 IM_FREE=IM_NEXT[IM_FREE]
 ERR=0
 IM=IM_ID[IM]<<12 OR IM
END
COMMON DEF ProcessIM(IM)
 IF!CheckIM(IM)THEN
  RETURN IM_INVALIDID
 ENDIF
 VAR NIM=IM AND 4095
 VAR KH$=IM_KEY_HANDLER$[NIM]
 WHILE 1
  VAR INK$=INKEY$()
  IF!LEN(INK$)THEN RETURN 0
  CALL KH$,IM,ASC(INK$)
 WEND
 RETURN 0
END
'IM->PROGRAM
COMMON DEF SendIMText(IM,TEXT$)
 VAR I
 FOR I=0TO LEN(TEXT$)-1
  VOID SendKeyWindow(NUWIDToWND(WIN_INPUTNUWID),ASC(TEXT$[I]))
 NEXT
 RETURN 0
END
VAR IM_KBDMODE
COMMON DEF SetKeyboardMode FLG
 IM_KBDMODE=FLG
END
VAR WIN_NOALLOC
VAR WIN_INVALIDID
VAR WIN_EVENTERR
'びょうが ふか
VAR WIN_NODRAW
VAR WIN_DISABLED
VAR CTL_NOALLOC
VAR CTL_INVALIDID
VAR TIMER_INVALIDID
DEF OTW_INIT_ERR
 WIN_NOALLOC=&H1
 WIN_INVALIDID=&H2
 WIN_EVENTERR=&H3
 WIN_NODRAW=&H4
 WIN_DISABLED=&H5
 CTL_NOALLOC=&H2001
 CTL_INVALIDID=&H2002
 IM_NOALLOC=&H3001
 IM_INVALIDID=&H3002
 TIMER_INVALIDID=&H4001
END
'======
'TIMER
'======
DIM TIMER_WND[0]
DIM TIMER_TIMEOUT[0]
DIM TIMER_ARG[0]
DIM TIMER_FUNC$[0]
DIM TIMER_NEXT[0]
DIM TIMER_PREV[0]
DIM TIMER_ID[0]
DIM TIMER_TM[0]
VAR TIMER_MAX
VAR TIMER_FREE
VAR TIMER_IDCNT
DEF OTW_TIMER_INIT
 TIMER_MAX=16
 TIMER_WND=NewArray(TIMER_MAX)
 TIMER_TIMEOUT=NewArray(TIMER_MAX)
 TIMER_ARG=NewArray(TIMER_MAX)
 TIMER_FUNC$=NewArray$(TIMER_MAX)
 TIMER_NEXT=NewArray(TIMER_MAX)
 TIMER_PREV=NewArray(TIMER_MAX)
 TIMER_ID=NewArray(TIMER_MAX)
 TIMER_TM=NewArray(TIMER_MAX)
 TIMER_IDCNT=1
 TIMER_FREE=1
 OTW_INITLIST TIMER_NEXT
END

DIM PROP_NAME$ [0]
DIM PROP_VAL   [0]
DIM PROP_VAL$  [0]
DIM PROP_VAL#  [0]
DIM PROP_NEXT  [0]
DIM PROP_PREV  [0]
VAR PROP_FREE
DEF OTW_PROP_INIT
 PROP_NAME$=NewArray$(1)
 PROP_VAL=NewArray(1)
 PROP_VAL$=NewArray$(1)
 PROP_VAL#=NewArray#(1)
 PROP_NEXT=NewArray(1)
 PROP_PREV=NewArray(1)
 PROP_FREE=0
END

DEF ALLOC_PROP(N$)
 IF PROP_FREE THEN
  VAR I=PROP_FREE
  PROP_FREE=PROP_NEXT[I]
  PROP_NAME$[I]=N$
  RETURN I
 ELSE
  PUSH PROP_NAME$,N$
  PUSH PROP_VAL$,NULL$()
  PUSH PROP_VAL,0
  PUSH PROP_VAL#,0
  PUSH PROP_NEXT,0
  PUSH PROP_PREV,0
  RETURN LEN(PROP_NEXT)-1
 ENDIF
END
DEF FREE_PROP I
 IF!PROP_FREE THEN
  PROP_NEXT[I]=0
  PROP_PREV[I]=0
  PROP_VAL [I]=0
  PROP_VAL#[I]=0
  PROP_VAL$[I]=NULL$()
  PROP_NAME$[I]=NULL$()
  PROP_FREE=I
  RETURN
 ENDIF
 VAR PN=PROP_NEXT[I]
 VAR PP=PROP_PREV[I]
 IF PP THEN
  PROP_NEXT[PP]=PN
 ENDIF
 IF PN THEN
  PROP_PREV[PN]=PP
 ENDIF
 PROP_NEXT[I]=PROP_FREE
 PROP_PREV[I]=0
 PROP_VAL [I]=0
 PROP_VAL#[I]=0
 PROP_VAL$[I]=NULL$()
 PROP_NAME$[I]=NULL$()
 PROP_FREE=I
END
DEF DUMP_PROP NUWID
 IF!WIN_PROP[NUWID]THEN
  RETURN
 ENDIF
 VAR P=WIN_PROP[NUWID]
 WHILE P
  ?PROP_NAME$[P],PROP_VAL[P],PROP_VAL$[P],PROP_VAL#[P]
  P=PROP_NEXT[P]
 WEND
END
DEF SEARCH_PROP(NUWID,N$)
 IF!WIN_PROP[NUWID]THEN
  WIN_PROP[NUWID]=ALLOC_PROP(N$)
  PROP_NEXT[WIN_PROP[NUWID]]=0
  PROP_PREV[WIN_PROP[NUWID]]=0
  RETURN WIN_PROP[NUWID]
 ENDIF
 VAR P=WIN_PROP[NUWID]
 WHILE P
  IF PROP_NAME$[P]==N$ THEN
   RETURN P
  ENDIF
  P=PROP_NEXT[P]
 WEND
 P=WIN_PROP[NUWID]
 VAR AP=ALLOC_PROP(N$)
 PROP_NEXT[AP]=P
 PROP_PREV[P]=AP
 WIN_PROP[NUWID]=AP
 RETURN AP
END
DEF TRY_SEARCH_PROP(NUWID,N$)
 IF!WIN_PROP[NUWID]THEN
  RETURN 0
 ENDIF
 VAR P=WIN_PROP[NUWID]
 WHILE P
  IF PROP_NAME$[P]==N$ THEN
   RETURN P
  ENDIF
  P=PROP_NEXT[P]
 WEND
 RETURN 0
END
COMMON DEF SetProp$ WND,N$,V$
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 PROP_VAL$[P]=V$
END
COMMON DEF SetProp# WND,N$,V#
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 PROP_VAL#[P]=V#
END
COMMON DEF SetProp WND,N$,V
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 PROP_VAL[P]=V
END
COMMON DEF SetProp2$(WND,N$,V$)
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 VAR O$=PROP_VAL$[P]
 PROP_VAL$[P]=V$
 RETURN O$
END
COMMON DEF SetProp2#(WND,N$,V#)
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 VAR O#=PROP_VAL#[P]
 PROP_VAL#[P]=V#
 RETURN O#
END
COMMON DEF SetProp2(WND,N$,V)
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 VAR O=PROP_VAL[P]
 PROP_VAL[P]=V
 RETURN O
END
COMMON DEF GetProp$(WND,N$)
 IF!CheckWindow(WND)THEN
  RETURN NULL$()
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 RETURN PROP_VAL$[P]
END
COMMON DEF GetProp#(WND,N$)
 IF!CheckWindow(WND)THEN
  RETURN NULL$()
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP#(NUWID,N$)
 RETURN PROP_VAL#[P]
END
COMMON DEF TryGetProp WND,N$ OUT V,F
 IF!CheckWindow(WND)THEN
  V=0
  F=FALSE
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 IF P THEN
  V=0
  F=FALSE
  RETURN
 ENDIF
 V=PROP_VAL[P]
 F=TRUE
END
COMMON DEF TryGetProp# WND,N$ OUT V#,F
 IF!CheckWindow(WND)THEN
  V#=0.0
  F=FALSE
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 IF P THEN
  V#=0.0
  F=FALSE
  RETURN
 ENDIF
 V#=PROP_VAL#[P]
 F=TRUE
END
COMMON DEF TryGetProp$ WND,N$ OUT V$,F
 IF!CheckWindow(WND)THEN
  V$=NULL$()
  F=FALSE
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 IF P THEN
  V$=NULL$()
  F=FALSE
  RETURN
 ENDIF
 V$=PROP_VAL$[P]
 F=TRUE
END
COMMON DEF GetProp(WND,N$)
 IF!CheckWindow(WND)THEN
  RETURN NULL$()
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=SEARCH_PROP(NUWID,N$)
 RETURN PROP_VAL[P]
END
COMMON DEF RemoveProp WND,NAME$
 IF!CheckWindow(WND)THEN
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR P=WIN_PROP[NUWID]
 WHILE P
  IF PROP_NAME$[P]==NAME$ THEN
   IF WIN_PROP[NUWID]==P THEN
    WIN_PROP[NUWID]=PROP_NEXT[P]
   ENDIF
   FREE_PROP P
   IF WIN_PROP[NUWID]==PROP_NEXT[WIN_PROP[NUWID]]THEN STOP
   RETURN
  ENDIF
  P=PROP_NEXT[P]
 WEND
END
COMMON DEF HasProp(WND,NAME$)
 IF!CheckWindow(WND)THEN
  RETURN FALSE
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 IF!WIN_PROP[NUWID]THEN
  RETURN FALSE
 ENDIF
 VAR P=WIN_PROP[NUWID]
 WHILE P
  IF PROP_NAME$[P]==NAME$ THEN
   RETURN TRUE
  ENDIF
  P=PROP_NEXT[P]
 WEND
 RETURN FALSE
END
COMMON DEF SetTimer WND,TIMEOUT,ARG,FUNC$ OUT TIMER,ERR
 IF!CheckWindow(WND)THEN
  ERR=WIN_INVALIDID
  TIMER=0
 ENDIF
 ERR=0
 VAR NUWID=WND AND NUWIDMASK
 VAR OT=WIN_TIMER[NUWID] AND NUWIDMASK
 TIMER=ToTimer(NewTimer(WND,TIMEOUT,OT,0,ARG,FUNC$))
 WIN_TIMER[NUWID]=TIMER
END
COMMON DEF CheckTimer(T)
 RETURN TIMER_ID[T AND NUWIDMASK]==T>>WIDSHIFT
END
DEF DeleteWindowTimers(WND)
 IF!CheckWindow(WND)THEN
  RETURN WIN_INVALIDID
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 VAR TIMER=WIN_TIMER[NUWID]
 VAR T=TIMER AND NUWIDMASK
 WHILE T
  VOID DeleteTimer(ToTimer(T))
  TIMER=WIN_TIMER[NUWID]
  T=TIMER AND NUWIDMASK
 WEND
 RETURN 0
END
COMMON DEF DeleteTimer(TIMER)
 IF!CheckTimer(TIMER)THEN
  RETURN TIMER_INVALIDID
 ENDIF
 VAR T=TIMER AND NUWIDMASK
 IF!CheckWindow(TIMER_WND[T])THEN
  RETURN WIN_INVALIDID
 ENDIF
 IF TIMER_PREV[T]THEN
  TIMER_NEXT[TIMER_PREV[T]]=TIMER_NEXT[T]
 ENDIF
 IF TIMER_NEXT[T]THEN
  TIMER_PREV[TIMER_NEXT[T]]=TIMER_PREV[T]
 ENDIF
 
 VAR NW=TIMER_WND[T]AND NUWIDMASK
 IF (WIN_TIMER[NW]AND NUWIDMASK)==T THEN
  WIN_TIMER[NW]=ToTimer(TIMER_NEXT[T])
 ENDIF
 TIMER_NEXT[T]=TIMER_FREE
 TIMER_FREE=T
END
DEF ToTimer(T)
 RETURN TIMER_ID[T]<<WIDSHIFT OR T
END
DEF NewTimer(WND,TIMEOUT,NXT,PREV,ARG,FUNC$)
 IF!TIMER_FREE THEN
  TIMER_FREE=LEN(TIMER_WND)
  PUSH TIMER_WND,0
  PUSH TIMER_TIMEOUT,0
  PUSH TIMER_ARG,0
  PUSH TIMER_FUNC$,FUNC$
  PUSH TIMER_NEXT,0
  PUSH TIMER_PREV,0
  PUSH TIMER_NEXT,0
  PUSH TIMER_ID,0
  PUSH TIMER_TM,0
 ENDIF
 TIMER_WND[TIMER_FREE]=WND
 TIMER_TIMEOUT[TIMER_FREE]=TIMEOUT
 TIMER_PREV[TIMER_FREE]=PREV
 TIMER_ARG[TIMER_FREE]=ARG
 TIMER_FUNC$[TIMER_FREE]=FUNC$
 TIMER_ID[TIMER_FREE]=TIMER_IDCNT
 IF NXT THEN
  TIMER_PREV[NXT]=TIMER_FREE
 ENDIF
 IF PREV THEN
  TIMER_NEXT[PREV]=TIMER_FREE
 ENDIF
 VAR R=TIMER_FREE
 TIMER_FREE=TIMER_NEXT[TIMER_FREE]
 TIMER_NEXT[R]=NXT
 TIMER_IDCNT=TIMER_IDCNT+1
 TIMER_TM[R]=MILLISEC
 RETURN R
END
'======
'END TIMER
'======

COMMON DEF GetWindowControl()
 RETURN CTL_WINDOWCTL
END
COMMON DEF GetButtonControl()
 RETURN CTL_BUTTONCTL
END
COMMON DEF GetToggleButtonControl()
 RETURN CTL_TGLBTNCTL
END
COMMON DEF GetTextBoxControl()
 RETURN CTL_TXTBOXCTL
END
COMMON DEF GetLabelControl()
 RETURN CTL_LABELCTL
END
COMMON DEF GetVScrollBarControl()
 RETURN CTL_VSCRBARCTL
END
COMMON DEF GetListBoxControl()
 RETURN CTL_LSTBOXCTL
END
COMMON DEF GetNumUpDownControl()
 RETURN CTL_NUMUPDWNCTL
END
COMMON DEF GetDropDownListControl()
 RETURN CTL_DRPDWNCTL
END
COMMON DEF GetHScrollBarControl()
 RETURN CTL_HSCRBARCTL
END
'CONTROL
COMMON DEF FindControl(NAME$)
 VAR I
 FOR I=0TO CTL_MAX-1
  IF CTL_NAME$[I]==NAME$THEN RETURN CTL_CID[I]<<12OR I
 NEXT
 RETURN 0
END
COMMON DEF NewControl NAME$ OUT CTL,ERR
 IF!CTL_FREE THEN
  ERR=CTL_NOALLOC
  CTL=0
  RETURN
 ENDIF
 INC CTL_CIDCNT
 ERR=0
 CTL=CIDNUCIDToCTL(CTL_FREE,CTL_CIDCNT)
 CTL_FREE=CTL_NEXT[CTL_FREE]
 CTL_CID[CTL AND 4095]=CTL_CIDCNT
 CTL_NEXT[CTL AND 4095]=0
 CTL_NAME$[CTL AND 4095]=NAME$
 CTL_HANDLER$[CTL AND 4095,CTL_CHLDWNDHANDLER]="ControlDefChildWinHandler"
END
COMMON DEF ExtendControl NAME$,PARENT OUT CTL,ERR
 IF!CheckControl(PARENT)THEN
  CTL=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 NewControl NAME$ OUT CTL,ERR
 IF ERR THEN RETURN
 VAR NUCID=CTL AND 4095
 CTL_PARENTCTL[NUCID]=PARENT
 VAR I,P=PARENT AND 4095
 FOR I=0TO CTL_HANDLER_MAX-1
  CTL_HANDLER$[NUCID,I]=CTL_HANDLER$[P,I]
  CTL_IMPLICIT[NUCID,I]=CTL_CIMPLICIT[P,I]
 NEXT
 CTL_FW1[NUCID]=CTL_FW1[P]
 CTL_FH1[NUCID]=CTL_FH1[P]
 CTL_FW2[NUCID]=CTL_FW2[P]
 CTL_FH2[NUCID]=CTL_FH2[P]
END
COMMON DEF CheckControl(CTL)
 RETURN CTL_CID[CTL AND 4095]==CTL>>12
END
COMMON DEF DeleteControl(CTL)
 IF!CheckControl(CTL) THEN RETURN CTL_INVALIDID
 VAR NUCID=CTL AND 4095,CID=CTL>>12
 CTL_NEXT[NUCID]=CTL_FREE
 CTL_FREE=NUCID
 CTL_CID[NUCID]=0
 CTL_FW1[NUCID]=0
 CTL_FH1[NUCID]=0
 CTL_FW2[NUCID]=0
 CTL_FH2[NUCID]=0
 CTL_DAT[NUCID]=0
 CTL_NAME$[NUCID]=""
 VAR I
 FOR I=0TO CTL_HANDLER_MAX-1
  CTL_HANDLER$[NUCID,I]=NULL$()
  CTL_IMPLICIT[NUCID,I]=0
  CTL_CIMPLICIT[NUCID,I]=0
 NEXT
END
COMMON DEF IsControlExtend(CTL,PARENT)
 IF!CheckControl(CTL) THEN RETURN 0
 IF!CheckControl(PARENT) THEN RETURN 0
 VAR N=CTL AND 4095
 VAR P=PARENT AND 4095
 WHILE N
  IF N==P THEN RETURN 1
  N=CTL_PARENTCTL[N]AND 4095
 WEND
 RETURN 0
END
COMMON DEF GetControlName$(CTL)
 IF!CheckControl(CTL) THEN RETURN""
 RETURN CTL_NAME$[CTL AND 4095]
END
COMMON DEF SetControlHandlerImplicit(CTL,TYPE,IMPLICIT)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_CIMPLICIT[CTL AND 4095,TYPE]=IMPLICIT
 RETURN 0
END
COMMON DEF SetControlPainter(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_PAINTHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlFramePainter(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_FRMPAINTHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlLMouseUpHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_LBTNUPHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlLMouseDownHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_LBTNDWNHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlRMouseUpHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_RBTNUPHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlRMouseDownHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_RBTNDWNHANDLER]=HANDLER$
 RETURN 0
END
DEF SetControlClickFrameHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_FRMBTNHANDLER]=HANDLER$
 RETURN 0
END
DEF SetControlMMoveFrameHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_FRMMOUSEMVHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlNotificationHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_NOTIFHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlNotifHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_NOTIFHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlKeyHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_KEYHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlButtonHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_BTNHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlChFocusHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CHFOCUSHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlMouseMoveHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_MOUSEMVHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlCreateHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CREATEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlStrNotifHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_STRNOTIFHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlDeleteHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_DELETEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlLDoubleClickHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_LDBLCLKHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlMouseLeaveHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_MSLEAVEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlResizeHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_RESIZEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlChildWindowHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CHLDWNDHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlParentWindowHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_PRNTWNDHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlQueryFrameHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_QUERYFRMHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlContextMenuHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CTXMENUHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlChInputHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CHINPUTHANDLER]=HANDLER$
 RETURN 0
END
DEF SetControlFrameSize(CTL,W1,H1,W2,H2)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 VAR C=CTL AND 4095
 CTL_FW1[C]=W1
 CTL_FH1[C]=H1
 CTL_FW2[C]=W2
 CTL_FH2[C]=H2
 RETURN 0
END
DEF CIDNUCIDToCTL(CID,NUCID)
 RETURN CID<<12OR NUCID
END
'Clipboard API
'ClearClipboard<-じゅうよう
'                Setしただけでは ほかの しゅるいの データが のこる
'->ClipboardSetText
VAR CLPBRD
VAR CLPBRDCTXT
VAR CLPBRDCFIL
VAR CLPBRDFIL$
VAR CLPBRDFILCUT
VAR CLPBRD$
VAR CLPBRD#
VAR CLPBRDPTR
DIM CLPBRDTYPE$[0]
DIM CLPBRDDATA$[0]
DEF CLIPBOARD_INIT
 CLPBRDTYPE$=NewArray$(0)
 CLPBRDDATA$=NewArray$(0)
END
COMMON DEF ClearClipboard
 CLPBRDCTXT=FALSE
 CLPBRDCFIL=FALSE
 IF LEN(CLPBRDTYPE$)THEN
  CLPBRDTYPE$=NewArray$(0)
  CLPBRDDATA$=NewArray$(0)
 ENDIF
END
COMMON DEF ClipboardContainsText()
 RETURN CLPBRDCTXT
END
COMMON DEF ClipboardGetText$()
 IF CLPBRDCTXT THEN RETURN CLPBRD$
 RETURN ""
END
COMMON DEF ClipboardSetText V$
 CLPBRDCTXT=1
 CLPBRD$=V$
END
'TYPE$:RichText
COMMON DEF ClipboardSetData$ TYPE$,V$
 VAR I'LINEAR
 FOR I=0TO LEN(CLPBRDTYPE$)-1
  IF CLPBRDTYPE$[I]==TYPE$THEN
   CLPBRDDATA$[I]=V$
   RETURN
  ENDIF
 NEXT
 PUSH CLPBRDDATA$,V$
 PUSH CLPBRDTYPE$,TYPE$
END
COMMON DEF ClipboardGetData$ TYPE$ OUT DATA$,CONTAINS
 VAR I'LINEAR
 FOR I=0TO LEN(CLPBRDTYPE$)-1
  IF CLPBRDTYPE$[I]==TYPE$THEN
   DATA$=CLPBRDDATA$[I]
   CONTAINS=TRUE
   RETURN
  ENDIF
 NEXT
 CONTAINS=FALSE
 DATA$=""
END
COMMON DEF ClipboardContainsFile()
 RETURN CLPBRDCFIL
END
COMMON DEF ClipboardGetFile OUT ISCUT,PATH$
 IF CLPBRDCFIL THEN
  PATH$=CLPBRDFIL$
  ISCUT=CLPBRDFILCUT
  RETURN
 ENDIF
 ISCUT=FALSE
 PATH$=""
END
COMMON DEF ClipboardSetFile ISCUT,PATH$
 CLPBRDFIL$=GetAbsolutePath$(PATH$)
 CLPBRDFILCUT=ISCUT
 CLPBRDCFIL=TRUE
END
COMMON DEF LoadGRPImage FIL$ OUT IMG,E
 NewImage 512,512 OUT IMG,E
 VAR I=IMG AND 4095
 LoadData FIL$,GetSBArray(IMAGE_PTR[I])
END
COMMON DEF LoadImage FIL$,W,H OUT IMG,E
 VAR FILE$
 NewImage ImageAttrPhy1Dim(),NewArray2(W,H),W,H OUT IMG,E
 IF E THEN
  IMG=0
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 LoadData FIL$,GetSBArray(IMAGE_PTR[I]) OUT E
END
COMMON DEF LoadImage2 FIL$,W,H OUT IMG,E
 VAR FILE$
 NewImage ImageAttrPhy1Dim(),NewArray(W*H),W,H OUT IMG,E
 IF E THEN
  IMG=0
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 LoadData FIL$,GetSBArray(IMAGE_PTR[I]) OUT E
END
COMMON DEF SaveImage(IMG,FIL$)
 IF!CheckImage(IMG)THEN RETURN IMAGE_INVALIDID
 VAR I=IMG AND 4095
 IF 0THEN DIM BUF[0]
 BUF=NewArray2(GetImageWidth(IMG),GetImageHeight(IMG))
 COPY BUF,GetSBArray(IMAGE_PTR[I])
 RETURN SaveData(FIL$,BUF)
END
COMMON DEF ImageAttr2Dim()
 RETURN IMAGE_ATTR_2DIM'1
END
COMMON DEF ImageAttr1Dim()
 RETURN IMAGE_ATTR_1DIM'0
END
COMMON DEF ImageAttrLogColor()
 RETURN IMAGE_ATTR_LOG'0
END
COMMON DEF ImageAttrPhysicalColor()
 RETURN IMAGE_ATTR_PHY'2
END
COMMON DEF ImageAttrPhy1Dim()
 RETURN IMAGE_ATTR_PHY OR IMAGE_ATTR_1DIM'2
END
COMMON DEF ImageAttrHideShadow()
 RETURN IMAGE_ATTR_HIDESHDW'4
END
COMMON DEF NewImage ATTR,ARRAY,WIDTH,HEIGHT OUT IMG,E
 IF !IMAGE_FREE THEN IMG=0:E=IMAGE_NOALLOC:RETURN
 VAR PTR=AllocSBArray()
 IF PTR==-1 THEN IMG=0:E=IMAGE_NOALLOC:RETURN
 INC IMAGE_IDCNT
 IMAGE_ID[IMAGE_FREE]=IMAGE_IDCNT
 IMAGE_WIDTH[IMAGE_FREE]=WIDTH
 IMAGE_HEIGHT[IMAGE_FREE]=HEIGHT
 IMAGE_HOTX[IMAGE_FREE]=0
 IMAGE_HOTY[IMAGE_FREE]=0
 IMAGE_PTR[IMAGE_FREE]=PTR
 IMAGE_ATTR[IMAGE_FREE]=ATTR
 IMG=IMAGE_FREE OR IMAGE_IDCNT<<12
 IMAGE_FREE=IMAGE_NEXT[IMAGE_FREE]
 SetSBArray PTR,ARRAY
 E=0
 RETURN
END
COMMON DEF CheckImage(IMG)
 RETURN IMAGE_ID[IMG AND 4095]==IMG>>12
END
COMMON DEF DeleteImage(IMG)
 IF!CheckImage(IMG)THEN RETURN IMAGE_INVALIDID
 VAR I=IMG AND 4095
 FreeSBArray IMAGE_PTR[I]
 IMAGE_NEXT[I]=IMAGE_FREE
 IMAGE_FREE=I
 RETURN 0
END
COMMON DEF GLOADImage X,Y,IMG,TF
 IF!CheckImage(IMG)THEN RETURN
 VAR I=IMG AND 4095
 GLOAD X,Y,IMAGE_WIDTH[I],IMAGE_HEIGHT[I],GetSBArray(IMAGE_PTR[I]),IMAGE_ATTR[I],TF
END
COMMON DEF GLOADImagePalette X,Y,IMG,PAL,TF
 IF!CheckImage(IMG)THEN RETURN
 VAR I=IMG AND 4095
 GLOAD X,Y,IMAGE_WIDTH[I],IMAGE_HEIGHT[I],GetSBArray(IMAGE_PTR[I]),PAL,TF
END
COMMON DEF GSAVEImage X,Y,IMG
 IF!CheckImage(IMG)THEN RETURN
 VAR I=IMG AND 4095
 GSAVE X,Y,IMAGE_WIDTH[I],IMAGE_HEIGHT[I],GetSBArray(IMAGE_PTR[I]),IMAGE_ATTR[I]
END
COMMON DEF GetImageSize IMG OUT W,H,ERR
 IF!CheckImage(IMG)THEN
  ERR=IMAGE_INVALIDID
  W=0H=0
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 W=IMAGE_WIDTH[I]
 H=IMAGE_HEIGHT[I]
 ERR=0
END
COMMON DEF GetImageWidth(IMG)
 IF!CheckImage(IMG)THEN
  RETURN 0
 ENDIF
 VAR I=IMG AND 4095
 RETURN IMAGE_WIDTH[I]
END
COMMON DEF GetImageHeight(IMG)
 IF!CheckImage(IMG)THEN
  RETURN 0
 ENDIF
 VAR I=IMG AND 4095
 RETURN IMAGE_HEIGHT[I]
END
COMMON DEF GetImageArray IMG OUT ARY,ERR
 IF!CheckImage(IMG)THEN
  ERR=IMAGE_INVALIDID
  ARY=NewArray(0)
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 ARY=GetSBArray(IMAGE_PTR[I])
 ERR=0
END
COMMON DEF GetImageHotspot IMG OUT X,Y,ERR
 IF!CheckImage(IMG)THEN
  ERR=IMAGE_INVALIDID
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 X=IMAGE_HOTX[I]
 Y=IMAGE_HOTY[I]
 ERR=0
END
COMMON DEF SetImageHotspot IMG,X,Y OUT ERR
 IF!CheckImage(IMG)THEN
  ERR=IMAGE_INVALIDID
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 IMAGE_HOTX[I]=X
 IMAGE_HOTY[I]=Y
 ERR=0
END
COMMON DEF GetImageFormat IMG OUT DIMEN,PHY,ERR
 IF!CheckImage(IMG)THEN
  DIMEN=0
  PHY=0
  ERR=IMAGE_INVALIDID
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 IF(IMAGE_ATTR[I]AND IMAGE_ATTR_2DIM)THEN
  DIMEN=2
 ELSE
  DIMEN=1
 ENDIF
 IF(IMAGE_ATTR[I]AND IMAGE_ATTR_PHY)THEN
  PHY=TRUE
 ELSE
  PHY=FALSE
 ENDIF
 ERR=0
END
COMMON DEF GetImageAttr IMG OUT ATTR,ERR
 IF!CheckImage(IMG)THEN
  ATTR=0
  ERR=IMAGE_INVALIDID
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 ERR=0
 ATTR=IMAGE_ATTR[I]
END
COMMON DEF SetImageAttr IMG,ATTR OUT ERR
 IF!CheckImage(IMG)THEN
  ERR=IMAGE_INVALIDID
  RETURN
 ENDIF
 VAR I=IMG AND 4095
 ERR=0
 IMAGE_ATTR[I]=ATTR
END
COMMON DEF RotateImage IMG,FLG OUT NEW_IMG,ERR
 VAR ROT=FLG AND &B000110
 VAR W,H
 VAR DIMEN,PHY
 VAR OHX,OHY
 NEW_IMG=0
 GetImageSize IMG OUT W,H,ERR
 VAR OW=W,OH=H
 IF ERR THEN RETURN
 GetImageHotspot IMG OUT OHX,OHY,ERR
 IF ERR THEN RETURN
 VAR HX=OHX,HY=OHY
 GetImageFormat IMG OUT DIMEN,PHY,ERR
 IF ERR THEN RETURN
 IF ROT==#SPROT90 THEN
  SWAP W,H
 ELSEIF ROT==#SPROT270 THEN
  SWAP W,H
 ENDIF
 IF 0THEN DIM NEWARY[0]
 NEWARY=NewArray(W*H)
 NewImage ImageAttrPhy1Dim(),NEWARY,W,H OUT NEW_IMG,ERR
 IF ERR THEN RETURN
 IF 0THEN DIM ARY[0]
 GetImageArray IMG OUT ARY,ERR
 IF ERR THEN RETURN
 VAR X,Y
 IF ROT==#SPROT90 THEN
  FOR Y=0TO OH-1
   FOR X=0TO OW-1
    NEWARY[(W-1-Y)+X*W]=ARY[X+Y*OW]
   NEXT
  NEXT
  HX=W-1-OHY
  HY=OHX
 ELSEIF ROT==#SPROT180 THEN
  FOR Y=0TO OH-1
   FOR X=0TO OW-1
    NEWARY[(W-1-X)+(H-1-Y)*W]=ARY[X+Y*OW]
   NEXT
  NEXT
  HX=W-1-OHX
  HY=H-1-OHY
 ELSEIF ROT==#SPROT270 THEN
  FOR Y=0TO OH-1
   FOR X=0TO OW-1
    NEWARY[Y+(OW-1-X)*W]=ARY[X+Y*OW]
   NEXT
  NEXT
  HX=OHY
  HY=OW-1-OHX
 ELSE
  COPY NEWARY,ARY
  HX=OHX
  HY=OHY
 ENDIF
 IF FLG AND #SPREVH THEN
  VAR O=(W DIV 2)
  FOR Y=0TO H-1
   FOR X=0TO O-1
    SWAP NEWARY[X+Y*W],NEWARY[(W-1-X)+Y*W]
   NEXT
  NEXT
  HX=W-1-OHX
  HY=OHY
 ENDIF
 IF FLG AND #SPREVV THEN
  O=(H DIV 2)
  FOR Y=0TO O-1
   FOR X=0TO W-1
    SWAP NEWARY[X+Y*W],NEWARY[X+(H-1-Y)*W]
   NEXT
  NEXT
  HY=H-1-OHY
  HX=OHX
 ENDIF
 SetImageHotspot NEW_IMG,HX,HY OUT ERR
END
COMMON DEF NewImageFromDATA OUT IMG,ERR
 IF 0THEN DIM ARY[0]
 VAR W,H
 NewImageArrayFromDATA 1,TRUE OUT ARY,W,H
 NewImage ImageAttrPhy1Dim(),ARY,W,H OUT IMG,ERR
END
COMMON DEF NewImageArrayFromDATA D,PHYSICAL OUT ARY,W,H
 DIM C$[0]
 DIM C[0]
 WHILE 1
  VAR D$,DAT
  READ D$
  IF!LEN(D$)THEN BREAK
  READ DAT
  PUSH C$,D$
  IF PHYSICAL THEN
   DAT=RGBToShort(DAT)
  ENDIF
  PUSH C,DAT
 WEND
 VAR X,Y,Z
 READ W,H
 
 IF 0THEN DIM IMG[0]
 IF D==2 THEN
  IMG=NewArray2(W,H)
 ELSE
  IMG=NewArray(W*H)
 ENDIF
 ARY=IMG
 FOR Y=0TO H-1
  READ D$
  FOR X=0TO W-1
   VAR CHIP$=D$[X]
   FOR Z=0TO LEN(C$)-1
    IF CHIP$==C$[Z]THEN
     IF D==2 THEN
      IMG[X,Y]=C[Z]
     ELSE
      IMG[X+Y*W]=C[Z]
     ENDIF
     BREAK
    ENDIF
   NEXT
  NEXT
 NEXT
 RETURN IMG
END
COMMON DEF NewMenu OUT MENU,E
 IF !MENU_FREE THEN MENU=0:E=MENU_NOALLOC:RETURN
 INC MENU_IDCNT
 E=0
 MENU_ID[MENU_FREE]=MENU_IDCNT
 MENU_HEIGHT[MENU_FREE]=4
 MENU_WIDTH[MENU_FREE]=0
 MENU_CHECKROW[MENU_FREE]=FALSE
 MENU_TYPE[MENU_FREE]=MENU_TYPE_NONE
 VAR M=MENU_FREE
 MENU=MENU_FREE OR MENU_IDCNT<<12
 MENU_FREE=MENU_NEXT[MENU_FREE]
 MENU_ITEM[M]=0'(MENU_ITEM=MENU_NEXT)
END
COMMON DEF SetMenuBar MENU,WND
 NOIMPL FORMAT$("NOIMPL SetMenuBar %D,%D",MENU,WND)
END
'===
'ShowContextMenu
'MOUSEノCOORDニMENUヲSHOW
'===
COMMON DEF ShowContextMenu MENU,WND
 VAR X=GetMouseX()
 VAR Y=GetMouseY()
 ShowMenuXY MENU,WND,X,Y
END
COMMON DEF ShowMenuXY2 MENU,WND,X,Y
 IF!CheckMenu(MENU)THEN RETURN
 Y=Y-MENU_HEIGHT[MENU AND 4095]
 ShowMenuXY MENU,WND,X,Y
END
COMMON DEF ShowMenu MENU,WND,X,Y
 ShowMenuXY MENU,WND,GetWindowAX(WND)+X,GetWindowAY(WND)+Y
END
COMMON DEF ShowMenuEx MENU,WND,X,Y,X_2,Y_2
 ShowMenuXYEx MENU,WND,GetWindowAX(WND)+X,GetWindowAY(WND)+Y,GetWindowAX(WND)+X_2,GetWindowAY(WND)+Y_2
END
COMMON DEF IsMenuShown(MENU)
 IF!CheckMenu(MENU)THEN RETURN
 MENU=MENU AND 4095
 RETURN !!MENU_SHOW[MENU]
END
COMMON DEF ShowMenuXY MENU,WND,X,Y
 ShowMenuXYEx MENU,WND,X,Y,X,Y
END
COMMON DEF ShowMenuXYEx MENU,WND,X,Y,X_2,Y_2
 IF!CheckMenu(MENU)THEN RETURN
 VAR OLDMN=GetMenuFromWindow(MENU_CURRENT)
 IF OLDMN THEN
  VOID DeleteWindow(MENU_CURRENT)
 ENDIF
 MENU_CURRENT=0
 MENU=MENU AND 4095
 VAR PARENT=WIN_ROOTWND'GetRootWindow()
 VAR PW=GetWindowWidth(PARENT)
 VAR PH=GetWindowHeight(PARENT)
 VAR WIDTH=MENU_WIDTH[MENU]
 VAR HEIGHT=MENU_HEIGHT[MENU]
 IF Y+HEIGHT>=PH THEN
  Y=Y_2-HEIGHT
 ENDIF
 IF X+WIDTH >=PW THEN
  X=X_2-WIDTH
 ENDIF
 VAR W=WND AND NUWIDMASK
 VAR E
 NewStyleWindow MENUCTL,"",X,Y,MENU_WIDTH[MENU],MENU_HEIGHT[MENU],PARENT,WindowFrontFlag(),WindowTopMostStyle()OR WindowNeverActiveStyle()OUT MENU_NUWID[MENU],E
 VOID JoinWindowGroup(WND,MENU_NUWID[MENU])
 SetWindowVar MENU_NUWID[MENU],0,MENU
 MENU_CURRENT=MENU_NUWID[MENU]
 MENU_NUWID[MENU]=MENU_NUWID[MENU]AND NUWIDMASK
 MENU_SHOW[MENU]=WND
END
DEF ShowSubMenu PMENU,MENU,Y
 IF!CheckMenu(MENU)THEN RETURN
 PMENU=PMENU AND 4095
 MENU=MENU AND 4095
 VAR WND=NUWIDToWND(MENU_NUWID[PMENU])
 VAR X=GetWindowWidth(WND)
 INC X,WIN_AX[MENU_NUWID[PMENU]]
 INC Y,WIN_AY[MENU_NUWID[PMENU]]
 VAR PARENT=WIN_ROOTWND'GetRootWindow()
 VAR PW=GetWindowWidth(PARENT)
 VAR PH=GetWindowHeight(PARENT)
 VAR WIDTH=MENU_WIDTH[MENU]
 VAR HEIGHT=MENU_HEIGHT[MENU]
 IF Y+HEIGHT>=PH THEN
  Y=PH-HEIGHT
 ENDIF
 IF X+WIDTH >=PW THEN
  X=PW-WIDTH
 ENDIF
 VAR W=WND AND NUWIDMASK
 VAR E
 NewStyleWindow MENUCTL,"",X,Y,MENU_WIDTH[MENU],MENU_HEIGHT[MENU],PARENT,WindowFrontFlag(),WindowTopMostStyle()OR WindowNeverActiveStyle()OUT MENU_NUWID[MENU],E
 VOID JoinWindowGroup(WND,MENU_NUWID[MENU])
 SetWindowVar MENU_NUWID[MENU],0,MENU
 MENU_NUWID[MENU]=MENU_NUWID[MENU]AND NUWIDMASK
 MENU_SHOW[MENU]=MENU_SHOW[PMENU]'WND
 MENU_TYPE[MENU]=MENU_TYPE[PMENU]
END
DEF NewMenuItem(STR$,PREV,STYLE)
 VAR I=MENU_ITEMFREE
 IF!I THEN RETURN 0
 MENU_INAME$[I]=STR$
 MENU_IPREV[I]=PREV
 IF PREV THEN MENU_INEXT[PREV]=I
 MENU_IPARENT[I]=PREV
 MENU_ITEMFREE=MENU_INEXT[I]
 MENU_INEXT[I]=0
 MENU_ISTYLE[I]=STYLE
 RETURN I
END
COMMON DEF GetWindowMenu(WND)
 RETURN WIN_MENU[WND AND NUWIDMASK]
END
COMMON DEF AddMenuItem MENU,STR$,IVAR
 AddMenuItemStyle MENU,STR$,IVAR,0'STYLE
END
DEF MENU_CALC_ITEM_WIDTH N,STR$,STYLE OUT W
 '3 IS MENU WIDTH
 W=LEN(STR$)*8+3
 IF STYLE AND MENU_STYLE_CHILD THEN
  W=W+MENU_CHILD_MARK_W
 ENDIF
 IF STYLE AND MENU_STYLE_RADIO THEN
  IF !MENU_CHECKROW[N]THEN INC MENU_WIDTH[N],MENU_CHECK_W
  MENU_CHECKROW[N]=TRUE
 ELSEIF STYLE AND MENU_STYLE_CHECK THEN
  IF !MENU_CHECKROW[N]THEN INC MENU_WIDTH[N],MENU_CHECK_W
  MENU_CHECKROW[N]=TRUE
 ENDIF
 IF MENU_CHECKROW[N]THEN INC W,MENU_CHECK_W

END
DEF MENU_ITEM_UPDATE N,I,STR$,RMSTYLE,NEWSTYLE,STRMOD
 VAR W
 MENU_ISTYLE[I]=(MENU_ISTYLE[I] AND NOT RMSTYLE)OR NEWSTYLE
 IF STRMOD THEN
  MENU_INAME$[I]=STR$
 ENDIF
 MENU_CALC_ITEM_WIDTH N,MENU_INAME$[I],MENU_ISTYLE[I] OUT W
 IF MENU_WIDTH[N]<W THEN
  MENU_WIDTH[N]=W
 ENDIF
END
COMMON DEF SetMenuItem MENU,STR$,IVAR
 SetMenuItemStyle MENU,STR$,IVAR,0,0,TRUE
END
COMMON DEF DisableMenuItem MENU,IVAR
 SetMenuItemStyle MENU,"",IVAR,0,MENU_STYLE_DISABLED,FALSE
END
COMMON DEF EnableMenuItem MENU,IVAR
 SetMenuItemStyle MENU,"",IVAR,MENU_STYLE_DISABLED,0,FALSE
END
DEF SetMenuItemStyle MENU,STR$,IVAR,RMSTYLE,NEWSTYLE,STRMOD
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 VAR I=MENU_ITEM[N]
 WHILE I
  IF MENU_IVAR[I]==IVAR THEN
   MENU_ITEM_UPDATE N,I,STR$,RMSTYLE,NEWSTYLE,STRMOD
   RETURN
  ENDIF
  I=MENU_INEXT[I]
 WEND
END
'COMMON?
DEF AddMenuItemStyle MENU,STR$,IVAR,STYLE
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 VAR I=NewMenuItem(STR$,MENU_LAST[N],STYLE)
 IF!MENU_LAST[N]THEN
  MENU_LAST[N]=I
  MENU_ITEM[N]=I
 ELSE
  MENU_LAST[N]=I
 ENDIF
 MENU_IVAR[I]=IVAR
 IF STYLE AND MENU_STYLE_SEPARATOR THEN
  INC MENU_HEIGHT[N],MENU_SEPARATOR_HEIGHT
 ELSE
  INC MENU_HEIGHT[N],8
 ENDIF
 VAR W
 MENU_CALC_ITEM_WIDTH N,STR$,STYLE OUT W
 IF MENU_WIDTH[N]<W THEN
  MENU_WIDTH[N]=W
 ENDIF
END
COMMON DEF AddMenuItemSeparator MENU
 AddMenuItemStyle MENU,"",0,MENU_STYLE_SEPARATOR'STYLE
END
COMMON DEF AddSubMenuItem MENU,STR$,SUBMENU
 AddMenuItemStyle MENU,STR$,0,MENU_STYLE_CHILD
 VAR N=MENU AND 4095
 IF!MENU_LAST[N]THEN RETURN
 MENU_ICHILD[MENU_LAST[N]]=SUBMENU' AND 4095
END
COMMON DEF AddSubMenuItemID MENU,STR$,SUBMENU,IVAR
 AddMenuItemStyle MENU,STR$,IVAR,MENU_STYLE_CHILD
 VAR N=MENU AND 4095
 IF!MENU_LAST[N]THEN RETURN
 MENU_ICHILD[MENU_LAST[N]]=SUBMENU' AND 4095
END
COMMON DEF AddRadioMenuItem MENU,STR$,IVAR,CHECKED
 VAR S=MENU_STYLE_RADIO
 IF CHECKED THEN S=S OR MENU_STYLE_CHECKED
 AddMenuItemStyle MENU,STR$,IVAR,S
 VAR N=MENU AND 4095
 IF!MENU_LAST[N]THEN RETURN
END
COMMON DEF IsCheckedMenuItem(MENU,IVAR)
 VAR N=MENU AND 4095
 VAR I=MENU_ITEM[N]
 WHILE I
  IF MENU_IVAR[I]==IVAR THEN
   IF MENU_ISTYLE[I]AND MENU_STYLE_CHECKED THEN
    RETURN TRUE
   ENDIF
   RETURN FALSE
  ENDIF
  I=MENU_INEXT[I]
 WEND
 RETURN FALSE
END
COMMON DEF GetSubMenuByPos MENU,POS OUT SUB
 SUB=0
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 VAR I=MENU_ITEM[N]
 VAR J
 WHILE I
  IF POS==J THEN
   IF MENU_ISTYLE[I]AND MENU_STYLE_CHILD THEN
    SUB=MENU_ICHILD[I]
    RETURN
   ENDIF
   RETURN
  ENDIF
  J=J+1
  I=MENU_INEXT[I]
 WEND
END
COMMON DEF GetSubMenuByID MENU,ID OUT SUB
 SUB=0
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 VAR I=MENU_ITEM[N]
 WHILE I
  IF MENU_IVAR[I]==ID THEN
   IF MENU_ISTYLE[I]AND MENU_STYLE_CHILD THEN
    SUB=MENU_ICHILD[I]
    RETURN
   ENDIF
   RETURN
  ENDIF
  I=MENU_INEXT[I]
 WEND
END
COMMON DEF GetCheckedRadioMenuItem MENU,IVAR OUT IVAR2
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 VAR I=MENU_ITEM[N]
 IVAR2=0
 WHILE I
  IF MENU_IVAR[I]==IVAR&&MENU_ISTYLE[I]AND MENU_STYLE_RADIO THEN

   BREAK
  ENDIF
  I=MENU_INEXT[I]
 WEND
 IF!I THEN RETURN
GOTO @P
 WHILE I
  IF!(MENU_ISTYLE[I]AND MENU_STYLE_RADIO)THEN
   I=MENU_INEXT[I]
   BREAK
  ENDIF
  I=MENU_IPREV[I]
 WEND
@P
 WHILE MENU_ISTYLE[I]AND MENU_STYLE_RADIO
  IF MENU_ISTYLE[I]AND MENU_STYLE_CHECKED THEN
   IVAR2=MENU_IVAR[I]
   RETURN
  ENDIF
  I=MENU_INEXT[I]
 WEND
 RETURN
END
COMMON DEF AddCheckMenuItem MENU,STR$,IVAR,CHECKED
 VAR S=MENU_STYLE_CHECK
 IF CHECKED THEN S=S OR MENU_STYLE_CHECKED
 AddMenuItemStyle MENU,STR$,IVAR,S
 VAR N=MENU AND 4095
 IF!MENU_LAST[N]THEN RETURN
END
COMMON DEF CheckMenu(MENU)
 RETURN MENU&&MENU_ID[MENU AND 4095]==MENU>>12
END

DEF MENU_RADIO_UNCHECK S
 VAR I=S
 WHILE 1
  I=MENU_IPREV[I]
  IF!I THEN BREAK
  IF!(MENU_ISTYLE[I]AND MENU_STYLE_RADIO)THEN
   BREAK
  ENDIF
  MENU_ISTYLE[I]=MENU_ISTYLE[I] AND NOT MENU_STYLE_CHECKED
 WEND
 I=S
 WHILE 1
  I=MENU_INEXT[I]
  IF!I THEN BREAK
  IF!(MENU_ISTYLE[I]AND MENU_STYLE_RADIO)THEN
   BREAK
  ENDIF
  MENU_ISTYLE[I]=MENU_ISTYLE[I] AND NOT MENU_STYLE_CHECKED
 WEND
 
END
COMMON DEF EnumerateMenu MENU,C OUT STR$,C2,CHILD,E
 IF!CheckMenu(MENU)THEN
  STR$=""
  C=0
  CHILD=0
  E=MENU_INVALIDID
 ENDIF
 VAR N=MENU AND 4095
 E=0
 IF C==0THEN
  C2=MENU_ITEM[N]
 ELSE
  C2=MENU_INEXT[C]
 ENDIF
 IF C2 THEN
  STR$=MENU_INAME$[C2]
  CHILD=MENU_ICHILD[C2]
 ELSE
  STR$=""
  E=MENU_NOITEM
  CHILD=0
 ENDIF
END
COMMON DEF IsMenuWindow(WND)
 RETURN IsControlExtend(GetControl(WND),MENUCTL)
END
COMMON DEF ContainsSubMenu(MENU,MENUC)
 IF!CheckMenu(MENU)THEN RETURN FALSE
 IF!CheckMenu(MENUC)THEN RETURN FALSE
 VAR N=MENU AND 4095
 VAR I=MENU_ITEM[N]
 WHILE I
  IF MENU_ICHILD[I]==MENUC THEN
   RETURN TRUE
  ENDIF
  I=MENU_INEXT[I]
 WEND
 RETURN FALSE
END
COMMON DEF GetMenuFromWindow(WND)
 IF!IsMenuWindow(WND)THEN RETURN 0
 VAR M=GetWindowVar(WND,0)
 RETURN M OR MENU_ID[M]<<12
END
COMMON DEF GetMenuOwner(MENU)
 IF!CheckMenu(MENU)THEN RETURN FALSE
 VAR N=MENU AND 4095
 RETURN MENU_SHOW[N]
END
COMMON DEF SetMenuType MENU,TYPE
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 MENU_TYPE[N]=TYPE
 RETURN
END
COMMON DEF GetMenuType(MENU)
 IF!CheckMenu(MENU)THEN RETURN MENU_TYPE_NONE
 VAR N=MENU AND 4095
 RETURN MENU_TYPE[N]
END
DEF MenuLMouseUp WND,C,T,X,Y
 VAR M=GetWindowVar(WND,0)
 IF X>0&&Y>0&&X<MENU_WIDTH[M]&&Y<MENU_HEIGHT[M]THEN
  VAR S=MENU_SEL[M]
  IF MENU_ISTYLE[S] AND MENU_STYLE_DISABLED THEN
   RETURN
  ENDIF
  IF!(MENU_ISTYLE[S] AND MENU_STYLE_CHILD)THEN
   IF MENU_ISTYLE[S] AND MENU_STYLE_CHECK THEN
    VAR SF=!(MENU_ISTYLE[S] AND MENU_STYLE_CHECKED)*MENU_STYLE_CHECKED
    MENU_ISTYLE[S]=(MENU_ISTYLE[S]AND NOT MENU_STYLE_CHECKED) OR SF
   ELSEIF MENU_ISTYLE[S] AND MENU_STYLE_RADIO THEN
    MENU_RADIO_UNCHECK S
    MENU_ISTYLE[S]=MENU_ISTYLE[S]OR MENU_STYLE_CHECKED
   
   ENDIF
   VOID SendNotifWindow(GetWindowGroupOwner(WND),MENU_NOTIFID,MENU_IVAR[S])
  ENDIF
 ENDIF
 VAR SW=MENU_SHOW[M]
 VOID DeleteWindow(WND)
 VOID ActiveWindow(SW)
 MENU_SHOW[M]=0
END
DEF MenuChFocus WND,C,T,F,FWND
 IF!F THEN
  IF IsControlExtend(GetControl(FWND),MENUCTL)THEN RETURN
  VAR M=GetWindowVar(WND,0)
  VAR OLDMN=GetMenuFromWindow(MENU_CURRENT)
  IF OLDMN THEN
   VOID DeleteWindow(MENU_CURRENT)
  ENDIF
  MENU_CURRENT=0
  VOID ActiveWindow(MENU_SHOW[M])
  MENU_SHOW[M]=0
 ENDIF
END
COMMON DEF MenuNotifID()
 RETURN MENU_NOTIFID
END
DEF MenuNotif WND,C,T,NID,I
 VAR M=GetWindowVar(WND,0)
 IF NID==MENU_NOTIFID THEN
  VOID SendNotifWindow(GetWindowGroupOwner(WND),MENU_NOTIFID,I)
  VOID DeleteWindow(WND)
 ENDIF
END
DEF MenuDelete WND,C,T,_,__
 VAR M=GetWindowVar(WND,0)
 MENU_SEL[M]=0
 MENU_SHOW[M]=0
 MENU_TYPE[M]=0
END
DEF MenuMouseLeave WND,C,T,X,Y

 VAR M=GetWindowVar(WND,0)
 VAR OS=MENU_SEL[M]
 IF MENU_ICHILD[OS]THEN RETURN
 MenuMouseMove WND,C,T,-100,-100
END
DEF MenuMouseMove WND,C,T,X,Y
 VAR SX=2
 VAR M=GetWindowVar(WND,0)
 VAR I=MENU_ITEM[M],Y1=2,Y2=Y1
 VAR OS=MENU_SEL[M]
 VAR BEG,G,SELF=0'SELECT FLAG
 VAR W=GetWindowWidth(WND)

 VAR IC
 WHILE I
  IF MENU_ISTYLE[I]AND MENU_STYLE_SEPARATOR THEN
   INC Y2,MENU_SEPARATOR_HEIGHT
   GOTO @SKIP2
  ENDIF
  INC Y2,8
  IF Y1<=Y&&Y2>Y THEN
   SELF=1
   IF OS!=I&&!G THEN 
   MENU_SEL[M]=I
   IF MENU_ICHILD[I]THEN
    IC=MENU_ICHILD[I]
    IF CheckMenu(IC)THEN
     ShowSubMenu M,IC,Y1
    ENDIF
   G=0
   ENDIF
   IF!OS THEN BREAK
   ENDIF
  ELSE
   IF I==OS THEN
    IF MENU_ICHILD[OS]THEN
     IC=MENU_ICHILD[OS]
     IF CheckMenu(IC)THEN
      VOID DeleteWindow(NUWIDToWND(MENU_NUWID[IC AND 4095]))
      VOID SetInputWindow(WND)
     ENDIF
    ENDIF
    OS=0
    IF BEG THEN BREAK
    BEG=1
   ENDIF
  ENDIF
'  ENDIF
  @SKIP2
  Y1=Y2
  I=MENU_INEXT[I]
 WEND
 WHILE 0&&I
  IF MENU_ISTYLE[I]AND MENU_STYLE_SEPARATOR THEN
   INC Y2,MENU_SEPARATOR_HEIGHT
   GOTO @SKIP
  ENDIF
  INC Y2,8
  IF Y1<=Y&&Y2>Y THEN
   SELF=1
   IF OS!=I&&!G THEN 
   MENU_SEL[M]=I
   IF!BEG&&GBeginWindow(WND)THEN :'BREAK
   BEG=1
   GFILLWindow WND,SX,Y1,MENU_WIDTH[M]-SX,Y2-1,GetSelectionColor()
   GPRINTWindow WND,SX,Y1,MENU_INAME$[I],GetSelectionTextColor()
   IF MENU_ICHILD[I]THEN
    GTRIWindow WND,W-SX-2,Y1+2,W-SX-2,Y1+6,W-SX,Y1+4,GetSelectionTextColor()
    IC=MENU_ICHILD[I]
    IF CheckMenu(IC)THEN
     ShowSubMenu M,IC,Y1
    ENDIF
   ENDIF
   G=0
   ENDIF
   IF!OS THEN BREAK
  ELSE
   IF I==OS THEN
    IF MENU_ICHILD[OS]THEN
     IC=MENU_ICHILD[OS]
     IF CheckMenu(IC)THEN
      VOID DeleteWindow(NUWIDToWND(MENU_NUWID[IC AND 4095]))
     ENDIF
    ENDIF
    IF!BEG&&GBeginWindow(WND)THEN :'BREAK
    GFILLWindow WND,SX,Y1,MENU_WIDTH[M]-SX,Y2-1,WIN_BKGND
    GPRINTWindow WND,SX,Y1,MENU_INAME$[I],&HFF000000
    IF MENU_ICHILD[I]THEN
     GTRIWindow WND,W-SX-2,Y1+2,W-SX-2,Y1+6,W-SX,Y1+4,#BLACK
    ENDIF
    OS=0
    IF BEG THEN BREAK
    BEG=1
   ENDIF
  ENDIF
  @SKIP
  Y1=Y2
  I=MENU_INEXT[I]
 WEND
 IF!SELF THEN
  MENU_SEL[M]=0
 ENDIF
 IF BEG THEN BEG=GEndWindow(WND)
 VOID RepaintWindow(WND)
END
DEF MenuPainter WND,C,T,XY,WH
 IF GBeginWindow(WND)THEN RETURN
 VAR BKGND=WIN_BKGND
 GCLSWindow WND,BKGND
 VAR SX1=2
 VAR SX=SX1
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)

 VAR M=GetWindowVar(WND,0)
 VAR I=MENU_ITEM[M],Y=2
 VAR SEL=MENU_SEL[M]
 IF MENU_CHECKROW[M]THEN
  SX=SX+MENU_CHECK_W
 ENDIF
 WHILE I
  VAR STY=MENU_ISTYLE[I]
  IF STY AND MENU_STYLE_SEPARATOR THEN
   GLINEWindow WND,SX1+1,Y+1,W-SX1-1,Y+1,RGB(128,128,128)
   GLINEWindow WND,SX1+1,Y+2,W-SX1-1,Y+2,-1
   INC Y,MENU_SEPARATOR_HEIGHT
  ELSE
   VAR TC
   IF SEL==I  THEN
    GFILLWindow WND,SX1,Y,MENU_WIDTH[M]-SX1,Y+7,GetSelectionColor()
    TC=GetSelectionTextColor()
   ELSE
    TC=#BLACK
   ENDIF
   IF MENU_ICHILD[I]THEN
    GTRIWindow WND,W-SX1-2,Y+2,W-SX1-2,Y+6,W-SX1,Y+4,TC
   ENDIF
   IF STY AND MENU_STYLE_CHECKED THEN
    GLINEWindow WND,SX1+1,Y+4,SX1+1,Y+5,TC
    GLINEWindow WND,SX1+6,Y+1,SX1+2,Y+5,TC
    GLINEWindow WND,SX1+6,Y+2,SX1+2,Y+6,TC
   ENDIF
   GPRINTWindow WND,SX,Y,MENU_INAME$[I],TC
   IF STY AND MENU_STYLE_DISABLED THEN
    GPRINTWindow WND,0,Y,""*(W+7 DIV 8),BKGND
   ENDIF
   INC Y,8
  ENDIF
  I=MENU_INEXT[I]
 WEND
 GBOXWindow WND,0,0,W,H,&HFF000000
 GBOXWindow WND,1,1,W-1,H-1,RGB(128,128,128)
 
 GLINEWindow WND,0,0,W-1,0,WIN_BKGND
 GLINEWindow WND,0,0,0,H-1,WIN_BKGND
 
 GLINEWindow WND,1,1,W-2,1,RGB(255,255,255)
 GLINEWindow WND,1,1,1,H-2,RGB(255,255,255)
 VAR E=GEndWindow(WND)
END
'WINDOW
DEF WIDNUWIDToWND(WID,NUWID)
 RETURN WID<<12OR NUWID
END
DEF NUWIDToWND(NUWID)
 IF!NUWID THEN RETURN 0
 RETURN WIN_WID[NUWID]<<12OR NUWID
END
'WND2 Join WND Group
COMMON DEF JoinWindowGroup(WND,WND2)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 IF!CheckWindow(WND2)THEN RETURN WIN_INVALIDID
 VAR NW1=WND AND NUWIDMASK'OW
 VAR NW2=WND2 AND NUWIDMASK'CW
 IF WIN_GROUP[NW1]THEN
  VAR NW3=WIN_GROUP[NW1]
  WIN_GNEXT[NW2]=WIN_GROUP[NW1]
  WIN_GPREV[NW3]=NW2
 ENDIF
 WIN_GPARENT[NW2]=NW1
 WIN_GROUP[NW1]=NW2
 RETURN 0
END
COMMON DEF LeaveWindowGroup WND
 NOIMPL "LeaveWindowGroup"
END
COMMON DEF GetWindowGroupMember(WND)
 RETURN NUWIDToWND(WIN_GROUP[WND AND NUWIDMASK])
END
COMMON DEF GetNextWindowGroupMember(WND)
 VAR NXT=WIN_GNEXT[WND AND NUWIDMASK]
 IF!NXT THEN RETURN 0
 RETURN NUWIDToWND(NXT)
END
COMMON DEF GetPrevWindowGroupMember(WND)
 VAR PRV=WIN_GNEXT[WND AND NUWIDMASK]
 IF!PRV THEN RETURN 0
 RETURN NUWIDToWND(PRV)
END
COMMON DEF GetWindowGroupOwner(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 RETURN NUWIDToWND(WIN_GPARENT[WND AND NUWIDMASK])
END
COMMON DEF GetRootWindow()
 RETURN WIN_ROOTWND2
END
COMMON DEF CheckWindow(WND)
 RETURN (WND AND NUWIDMASK)>0&&(WND AND NUWIDMASK)<LEN(WIN_WID)&&WIN_WID[WND AND NUWIDMASK]==WND>>WIDSHIFT
END
DEF ValidateWND(WND)
 VAR N=WND AND NUWIDMASK
 IF N>0&&N<LEN(WIN_WID)&&WIN_WID[N]==WND>>WIDSHIFT THEN
  RETURN N
 ENDIF
 RETURN 0
END
VAR OTW_TOPLEVELCNT
COMMON DEF WindowBackFlag()
 RETURN 1
END
COMMON DEF WindowFrontFlag()
 RETURN 2
END
COMMON DEF WindowOwnerDrawFlag()
 RETURN 8
END
COMMON DEF WindowToolFlag()
 RETURN 16
END
COMMON DEF WindowDefPosFlag()
 RETURN 32
END

DEF WindowOnCreate WND,CTL,ARG1,ARG2
 VAR NUCID=CTL AND 4095
 IF LEN(CTL_HANDLER$[NUCID,CTL_CREATEHANDLER])THEN
  CALL CTL_HANDLER$[NUCID,CTL_CREATEHANDLER],WND,CTL,CTL_CREATEHANDLER,ARG1,ARG2
 ENDIF
END
DEF WindowCallQueryFrame WND,CTL,ARG1,ARG2 OUT W1,H1,W2,H2
 VAR NUCID=CTL AND 4095
 W1=0
 H1=0
 W2=0
 H2=0
 
 IF LEN(CTL_HANDLER$[NUCID,CTL_QUERYFRMHANDLER])THEN
  CALL CTL_HANDLER$[NUCID,CTL_QUERYFRMHANDLER],WND,CTL,CTL_QUERYFRMHANDLER,ARG1,ARG2 OUT W1,H1,W2,H2
 ENDIF
END
COMMON DEF QueryWindowFrameSize WND OUT W1,H1,W2,H2,E
 W1=0
 H1=0
 W2=0
 H2=0
 VAR N=ValidateWND(WND)
 IF!N THEN
  E=WIN_INVALIDID
  RETURN
 ENDIF
 E=0
 WindowCallQueryFrame WND,WIN_CTL[N],WIN_STYLE[N],0 OUT W1,H1,W2,H2
END
DEF WindowOnDelete NUWID
 VAR CTL=WIN_CTL[NUWID]
 VAR NUCID=CTL AND 4095
 IF LEN(CTL_HANDLER$[NUCID,CTL_DELETEHANDLER])THEN
  CALL CTL_HANDLER$[NUCID,CTL_DELETEHANDLER],NUWIDToWND(NUWID),CTL,CTL_DELETEHANDLER,0,0
 ENDIF
END
COMMON DEF GetWindowMinSize WND OUT W,H
 IF!CheckWindow(WND)THEN
  W=-1
  H=-1
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 W=WIN_MINW[NUWID]
 H=WIN_MINH[NUWID]
 RETURN
END
COMMON DEF SetWindowMinSize WND,W,H
 IF!CheckWindow(WND)THEN RETURN
 VAR NUWID=WND AND NUWIDMASK
 WIN_MINW[NUWID]=W
 WIN_MINH[NUWID]=H
 RETURN
END
DEF GetWindowDefPos PARENT,CTL OUT X,Y,ERR
 VAR P$="NEWWINXY"
 ERR=0
 SplitInt GetProp(PARENT,P$) OUT X,Y
 VAR WAX,WAY,WAW,WAH
 GetWorkArea PARENT OUT WAX,WAY,WAW,WAH,ERR
 IF X<WAX THEN
  X=WAX
 ENDIF
 IF Y<WAY THEN
  Y=WAY
 ENDIF
 VAR TX=X,TY=Y
 VAR NUCID=CTL AND 4095
 VAR BS=CTL_FH1[NUCID]-1
 INC TX,BS
 INC TY,BS
 IF ERR THEN RETURN
 IF TY+BS>=WAY+WAH THEN
  TY=WAY
  INC TX,BS
  IF TX+BS>=WAX+WAW THEN
   TX=WAX
  ENDIF
 ELSEIF TX+BS>=WAX+WAW THEN
   TX=WAX
 ENDIF
 SetProp PARENT,P$,JoinInt(TX,TY)
END
COMMON DEF SetWorkArea WND,X,Y,W,H OUT ERR
 IF!CheckWindow(WND)THEN
  ERR=WIN_INVALIDID
  RETURN
 ENDIF
 SetProp WND,"WKAREAXY",JoinInt(X,Y)
 SetProp WND,"WKAREAWH",JoinInt(W,H)
 ERR=0
END
COMMON DEF GetWorkArea WND OUT X,Y,W,H,ERR
 IF!CheckWindow(WND)THEN
  X=0
  Y=0
  W=0
  H=0
  ERR=WIN_INVALIDID
  RETURN
 ENDIF
 IF!HasProp(WND,"WKAREAXY")||!HasProp(WND,"WKAREAWH")THEN
  X=0
  Y=0
  W=GetWindowWidth(WND)
  H=GetWindowHeight(WND)
  ERR=0
  RETURN
 ENDIF
 SplitInt GetProp(WND,"WKAREAXY") OUT X,Y
 SplitInt GetProp(WND,"WKAREAWH") OUT W,H
 ERR=0
END

COMMON DEF NewWindow CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG OUT WND,ERR
 NewWindowEx CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,0,0,0 OUT WND,ERR
END
COMMON DEF NewWindowEx CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE,A1,A2 OUT WND,ERR
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 IF!CheckWindow(PARENT)THEN
  WND=0
  ERR=WIN_INVALIDID
  RETURN
 ENDIF
 IF!WIN_FREE THEN
  WND=0
  ERR=WIN_NOALLOC
  RETURN
 ENDIF
 'FIXME
 IF FLG AND WindowOwnerDrawFlag()THEN
  STYLE=STYLE OR WIN_STYLE_OWNERDRAW
 ENDIF
 IF FLG AND WindowToolFlag()THEN
  STYLE=STYLE OR WIN_STYLE_TOOL
 ENDIF
 IF FLG AND WindowDefPosFlag()THEN
  GetWindowDefPos PARENT,CTL OUT X,Y,ERR
  IF ERR THEN
   WND=0
   RETURN
  ENDIF
 ENDIF
 VAR NC=CTL AND 4095
 ERR=0
 INC WIN_WIDCNT
 VAR NUWID,WID
 VAR PNUWID=PARENT AND NUWIDMASK
 NUWID=WIN_FREE
 WIN_FREE=WIN_NEXT[WIN_FREE]
 WID=WIN_WIDCNT
 WND=WIDNUWIDToWND(WID,NUWID)
 WIN_WID[NUWID]=WID
 WIN_CTL[NUWID]=CTL
 WIN_NAME$[NUWID]=NAME$
 '
 WIN_X[NUWID]=X
 WIN_Y[NUWID]=Y
 
 WIN_AX[NUWID]=WIN_FX[PNUWID]+X
 WIN_AY[NUWID]=WIN_FY[PNUWID]+Y '
 VAR FW1,FH1,FW2,FH2
 WindowCallQueryFrame 0,CTL,STYLE,0 OUT FW1,FH1,FW2,FH2
 WIN_FW1[NUWID]=FW1
 WIN_FH1[NUWID]=FH1
 WIN_FW2[NUWID]=FW1+FW2
 WIN_FH2[NUWID]=FH1+FH2
 INC WIDTH,WIN_FW2[NUWID]
 WIN_WIDTH[NUWID]=WIDTH
 INC HEIGHT,WIN_FH2[NUWID]
 WIN_HEIGHT[NUWID]=HEIGHT
 WIN_AW[NUWID]=WIN_WIDTH[NUWID]
 WIN_AH[NUWID]=WIN_HEIGHT[NUWID]
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 WIN_NEXT[NUWID]=0
 WIN_PARENT[NUWID]=PARENT AND NUWIDMASK
 WIN_MINW[NUWID]=WIN_FW2[NUWID]
 WIN_MINH[NUWID]=WIN_FH2[NUWID]
 WIN_HIDE[NUWID]=!!(STYLE AND WindowHideStyle())
 IF WIN_STYLE[WIN_PARENT[NUWID]]AND WIN_STYLE_NEVERACTV THEN
  STYLE=STYLE OR WIN_STYLE_NEVERACTV
 ENDIF
 WIN_STYLE[NUWID]=STYLE
 OTW_CLIPWindow NUWID
 IF PNUWID THEN 
  IF FLG AND WindowFrontFlag()THEN
   IF WIN_CHILD[PNUWID]THEN
    VAR N=WIN_CHILD[PNUWID]
    WHILE 1
     IF!WIN_NEXT[N]||(!(FLG AND 1024)&&WIN_STYLE[WIN_NEXT[N]]AND WIN_STYLE_TOPMST)THEN
      WIN_NEXT[NUWID]=WIN_NEXT[N]
      IF WIN_NEXT[N]THEN
       WIN_PREV[WIN_NEXT[N]]=NUWID
      ENDIF
      WIN_NEXT[N]=NUWID
      WIN_PREV[NUWID]=N
      BREAK
     ENDIF
     N=WIN_NEXT[N]
    WEND
   ELSE
    WIN_CHILD[PNUWID]=NUWID
   ENDIF
   OTW_UpdateMap NUWID
  ELSE
   N=WIN_CHILD[PNUWID]
   WIN_CHILD[PNUWID]=NUWID
   OTW_UpdateMap NUWID
   IF N THEN
    WIN_NEXT[NUWID]=N
    WIN_PREV[N]=NUWID
   ENDIF
  ENDIF
 ENDIF
 WIN_MSGS[NUWID]=0
 WIN_CURX[NUWID]=0
 WIN_CURY[NUWID]=0
 WIN_IM[NUWID]=FALSE
 WIN_PRC[NUWID]=GetProcess()
 IF PARENT==WIN_ROOTWND THEN
  SPAllocWindow WND
 ENDIF
 IF STYLE AND WIN_STYLE_HIDE THEN
  WIN_HIDE[NUWID]=1
  IF WIN_SP[NUWID]THEN SPHIDE WIN_SP[NUWID]AND 511
 ELSE
  VOID RepaintWindow(WND)
 ENDIF
 WIN_BACKGND[NUWID]=WIN_BKGND

 VAR MW=47
 IF MW>WIDTH THEN MW=WIDTH
 SetWindowMinSize WND,WIN_FW2[NUWID]+MW,WIN_FH2[NUWID]
 'MENU
 IF STYLE AND WindowMenuStyle() THEN
  NewMenu OUT WIN_MENU[NUWID],ERR
 ENDIF
 'TRANS
 IF STYLE AND 4THEN
  NOIMPL "TRANS
  NewImage ImageAttrPhy1Dim(),WIDTH,HEIGHT,WIN_IMAGE[NUWID]
 ENDIF

 InitWindow WND,A1,A2
 VOID FocusWindow(WND)
END
DEF InitWindow WND,ARG1,ARG2
 IF!CheckWindow(WND)THEN RETURN
 WindowOnCreate WND,WIN_CTL[WND AND NUWIDMASK],ARG1,ARG2
END
COMMON DEF SetWindowBackColor WND,RGB
 IF!CheckWindow(WND)THEN RETURN
 WIN_BACKGND[WND AND NUWIDMASK]=RGB
 VOID RepaintWindow(WND)
END
COMMON DEF GetWindowBackColor(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 RETURN WIN_BACKGND[WND AND NUWIDMASK]
END
DEF SPAllocWindow WND
 INC OTW_TOPLEVELCNT
 VAR SP=2,NUWID=WND AND NUWIDMASK
 IF TRUE THEN
  VAR SP2
  SPSET 2,511,0 OUT SP
  IF OTW_ENABLE_SHADOW THEN
   SPSET 2,511,0 OUT SP2
   SPVAR SP,1,SP2
   SPLINK SP2,SP
   SPSCALE SP2,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
   SPCOLOR SP2,RGB(128,063,063,063)
   SPOFS SP2,3,3,1
   SPHIDE SP2
   SPVAR SP2,0,WND
  ENDIF
  WIN_SP[NUWID]=SP OR 512
 ELSE
 'FOR 3.0.X?
 WHILE SPVAR(SP,0)
  SP=(SP+1)MOD 255
 WEND
 WIN_SP[NUWID]=SP OR 512
 'SPSET SP,WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1,1
 SPSET SP,0
 ENDIF
 SPOFS SP,WIN_AX[NUWID],WIN_AY[NUWID],0
'SPANIM SP,"S",-60,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
'''''' SPSCALE SP,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
 SPSHOW SP
 SPVAR SP,0,WND
 OTW_SPSORT
END
COMMON DEF NewTopLevelMenuWindow CTL,NAME$,WIDTH,HEIGHT OUT WND,ERR
 NewTopLevelStyleWindow CTL,NAME$,WIDTH,HEIGHT,1 OUT WND,ERR
END
COMMON DEF WindowMenuStyle()
 RETURN 1
END
COMMON DEF WindowResizableStyle()
 RETURN 2
END
COMMON DEF WindowTransStyle()
 RETURN 4
END
COMMON DEF WindowHideStyle()
 RETURN 8
END
COMMON DEF WindowMinMaxStyle()
 RETURN WIN_STYLE_MINMAX
END
COMMON DEF WindowNarrowStyle()
 RETURN WIN_STYLE_NARROW
END
COMMON DEF WindowTopMostStyle()
 RETURN WIN_STYLE_TOPMST
END
COMMON DEF WindowNeverActiveStyle()
 RETURN WIN_STYLE_NEVERACTV
END
COMMON DEF WindowMaximizedStyle()
 RETURN WIN_STYLE_MAX
END
COMMON DEF WindowMinimizedStyle()
 RETURN WIN_STYLE_MIN
END
COMMON DEF WindowDisableCloseStyle()
 RETURN WIN_STYLE_DCLS
END
COMMON DEF WindowDisableMaxStyle()
 RETURN WIN_STYLE_DMAX
END
COMMON DEF WindowDisableMinStyle()
 RETURN WIN_STYLE_DMIN
END
COMMON DEF WindowDisabledStyle()
 RETURN WIN_STYLE_DIS
END
COMMON DEF NewStyleWindowArg CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE,A1,A2 OUT WND,ERR
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 VAR NUCID=CTL AND 4095
 IF STYLE AND WIN_STYLE_TOPMST THEN
  VAR FFF=1024
 ENDIF
 NewWindowEx CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG OR FFF,STYLE,A1,A2 OUT WND,ERR
END
COMMON DEF NewStyleWindow CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE OUT WND,ERR
 NewStyleWindowArg CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE,0,0 OUT WND,ERR
END
COMMON DEF NewTopLevelStyleWindowArg CTL,NAME$,WIDTH,HEIGHT,STYLE,A1,A2 OUT WND,ERR
 NewStyleWindowArg CTL,NAME$,0,0,WIDTH,HEIGHT,WIN_ROOTWND2,WindowDefPosFlag() OR WindowFrontFlag(),STYLE,A1,A2 OUT WND,ERR
END
COMMON DEF NewTopLevelStyleWindow CTL,NAME$,WIDTH,HEIGHT,STYLE OUT WND,ERR
 NewTopLevelStyleWindowArg CTL,NAME$,WIDTH,HEIGHT,STYLE,0,0 OUT WND,ERR
END
COMMON DEF NewTopLevelWindow CTL,NAME$,WIDTH,HEIGHT OUT WND,ERR
 IF WIN_ROOTWND THEN
  NewTopLevelStyleWindow CTL,NAME$,WIDTH,HEIGHT,0 OUT WND,ERR
  RETURN
 ENDIF
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 IF!WIN_FREE THEN
  WND=0
  ERR=WIN_NOALLOC
  RETURN
 ENDIF
 ERR=0
' INC OTW_TOPLEVELCNT
 INC WIN_WIDCNT
 VAR NUWID,WID
 NUWID=WIN_FREE
 WIN_FREE=WIN_NEXT[WIN_FREE]
 WID=WIN_WIDCNT
 WND=WIDNUWIDToWND(WID,NUWID)
 WIN_WID[NUWID]=WID
 WIN_CTL[NUWID]=CTL
 WIN_NAME$[NUWID]=NAME$
 '
 WIN_X[NUWID]=0
 WIN_Y[NUWID]=0
 
 WIN_AX[NUWID]=0
 WIN_AY[NUWID]=0
 '
 VAR NUCID=CTL AND 4095
 WIN_WIDTH[NUWID]=WIDTH
 WIN_HEIGHT[NUWID]=HEIGHT
 WIN_FW2[NUWID]=CTL_FW1[NUCID]+CTL_FW2[NUCID]
 WIN_FH2[NUWID]=CTL_FH1[NUCID]+CTL_FH2[NUCID]
 WIN_NEXT[NUWID]=0
 GCLIP 1,0,240,400,480
 VOID RepaintWindow(WND)
 IF!WIN_ROOTWND THEN
  GFILL WIN_AX[NUWID],WIN_AY[NUWID]+240,WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID]+240,ShortToRGB(NUWID)
  GCLIP 1,0,0,400,239
  WIN_AW[NUWID]=WIDTH
  WIN_AH[NUWID]=HEIGHT
  WIN_AFW[NUWID]=WIDTH
  WIN_AFH[NUWID]=HEIGHT
' SPSET SP,WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID],1
' SPSHOW SP
' SPOFS SP,WIN_AX[NUWID],WIN_AY[NUWID],1023
  WIN_ROOTWND2=WND
  RETURN
 ENDIF
 
 VAR ROOTNUWID=WIN_ROOTWND2 AND NUWIDMASK
 VAR C=WIN_CHILD[ROOTNUWID],N
 WIN_PARENT[NUWID]=ROOTNUWID
 IF!C THEN
  WIN_CHILD[ROOTNUWID]=NUWID
 ELSE
  N=C
  WHILE 1
   C=N
   N=WIN_NEXT[N]
   IF!N THEN
    WIN_NEXT[C]=NUWID
    WIN_PREV[NUWID]=C
    BREAK
   ENDIF
  WEND
 ENDIF
 WIN_FW1[NUWID]=CTL_FW1[NUCID]'WIN_TopLevelX
 WIN_FH1[NUWID]=CTL_FH1[NUCID]'WIN_TOPLEVELY
 WIN_AX[NUWID]=0'WIN_TopLevelX
 WIN_AY[NUWID]=0'WIN_TOPLEVELY
 WIN_X[NUWID]=0'WIN_TopLevelX
 WIN_Y[NUWID]=0'WIN_TOPLEVELY
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_RFY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
' WIN_WIDTH[NUWID]=WIDTH+WIN_FWIDTH+
' WIN_HEIGHT[NUWID]=HEIGHT
 
 WIN_HEIGHT[NUWID]=WIN_HEIGHT[NUWID]+CTL_FH1[NUCID]+CTL_FH2[NUCID]
 WIN_WIDTH[NUWID]=WIN_WIDTH[NUWID]+CTL_FW1[NUCID]+CTL_FW2[NUCID]
 WIN_AW[NUWID]=WIN_WIDTH[NUWID]
 WIN_AH[NUWID]=WIN_HEIGHT[NUWID]
 OTW_CLIPWindow NUWID
 OTW_DrawMap NUWID
 GCLIP 1,0,0,400,239
' GFILL WIN_AX[NUWID],WIN_AY[NUWID],WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID],RGB(255,255,255)
 SPAllocWindow WND
 WindowOnCreate WND,CTL
 VOID ActiveWindow(WND)
END
COMMON DEF NewDialogBoxWithArg CTL,NAME$,WIDTH,HEIGHT,OWNER,FLAG,A1,A2 OUT WND,E
 IF!CheckControl(CTL)THEN
  WND=0
  E=CTL_INVALIDID
  RETURN
 ENDIF
 IF!WIN_FREE THEN
  WND=0
  E=WIN_NOALLOC
  RETURN
 ENDIF
 VAR O=OWNER AND NUWIDMASK
 VAR AX=WIN_AX[O]+(WIN_WIDTH[O]-WIDTH)/2
 VAR AY=WIN_AY[O]+(WIN_HEIGHT[O]-HEIGHT)/2
 IF AX<0THEN AX=0
 IF AY<0THEN AY=0
 NewWindowEx CTL,NAME$,AX,AY,WIDTH,HEIGHT,GetRootWindow(),WindowFrontFlag()OR 512,0,A1,A2 OUT WND,E
 IF FLAG THEN
  WIN_STYLE[WND AND NUWIDMASK]=WIN_STYLE[WND AND NUWIDMASK] OR WIN_STYLE_MODAL
  VOID DisableWindow(OWNER)
 ENDIF
 IF E THEN RETURN
 E=JoinWindowGroup(OWNER,WND)
 RETURN
END
COMMON DEF NewDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER,FLAG)
 VAR E
 NewDialogBoxWithArg CTL,NAME$,WIDTH,HEIGHT,OWNER,FLAG,0,0 OUT ,E
 RETURN E
END
COMMON DEF NewModalDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER)
 RETURN NewDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER,1)
END
COMMON DEF NewModelessDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER)
 RETURN NewDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER,0)
END
COMMON DEF MessageBoxOK()
 RETURN 1
END
COMMON DEF MessageBoxError()
 RETURN 2
END
COMMON DEF CalcTextSize TEXT$ OUT W,H
 VAR I,J
 W=0H=0
 VAR LF$=CHR$(10)
 WHILE 1
  J=INSTR(I,TEXT$,LF$)
  IF J==-1THEN
   W=MAX(W,(LEN(TEXT$)-I)*8)
   IF I==LEN(TEXT$)-1THEN BREAK
   INC H,8
   BREAK
  ENDIF
  W=MAX(W,(J-I)*8)
  INC H,8
  I=J+1
 WEND
END
DEF MessageBoxOnNotif WND,CTL,TYP,A1,A2
 IF A2==0THEN
  VOID SendNotifWindow(GetWindowGroupOwner(WND),MessageBoxNotifID(),MessageBoxNotifOK())
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
END
VAR MSGBOX_MARGIN_TOP
VAR MSGBOX_MARGIN_LEFT
DEF MessageBoxOnCreate WND,CTL,TYP,FLAG,TEXT
 VAR TEXT$=GetString$(TEXT)
 VAR TW,TH,BW,BH
 CalcTextSize TEXT$ OUT TW,TH
 VAR LWND,E
 NewWindow GetLabelControl(),TEXT$,MSGBOX_MARGIN_LEFT,MSGBOX_MARGIN_TOP,TW,TH,WND,0 OUT LWND,E
 IF FLAG AND MessageBoxOK()THEN
  CalcTextSize "OK" OUT BW,BH
  'Button margin
  INC BW,4
  INC BH,4
  NewWindow GetButtonControl(),"OK",MSGBOX_MARGIN_LEFT,TH+MSGBOX_MARGIN_LEFT*2,BW,BH,WND,0 OUT LWND,E
 ENDIF
END
COMMON DEF MessageBoxNotifID()
 RETURN &H4D534742
END
COMMON DEF MessageBoxNotifOK()
 RETURN 0
END
COMMON DEF MessageBoxNotifCancel()
 RETURN 1
END
COMMON DEF MessageBox(WND,TITLE$,TEXT$,FLAG)
 'CALC WIDTH
 VAR TW,TH,BW,BH
 CalcTextSize TEXT$ OUT TW,TH
 IF FLAG AND MessageBoxOK()THEN
  'OK
  CalcTextSize "OK" OUT BW,BH
  'Button margin
  INC BW,4
  INC BH,4
 ENDIF
 VAR W=TW+BW,H=BH+TH
 MSGBOX_MARGIN_TOP=4
 MSGBOX_MARGIN_LEFT=4
 INC W,16'MARGIN
 INC H,16'MARGIN
 VAR TEXT=AllocString(TEXT$)
 VAR RET
 NewDialogBoxWithArg CTL_MSGBOXCTL,TITLE$,W,H,WND,TRUE,FLAG,TEXT OUT ,RET
 FreeString TEXT
 RETURN RET
END
COMMON DEF DeleteWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR X=WIN_RX[NUWID],Y=WIN_RY[NUWID],W=WIN_AW[NUWID],H=WIN_AH[NUWID]
 VAR E=DeleteWindowNUWID(NUWID)
 RepaintAllWindow WIN_ROOTWND,X,Y,W,H
 RETURN E
END
DEF OTW_CHECKWIN(N)
 N=WIN_CHILD[N]
 WHILE N
  IF N&&WIN_NEXT[N]&&N!=WIN_PREV[WIN_NEXT[N]]THEN
   RETURN 0
  ENDIF
  N=WIN_NEXT[N]
 WEND
 RETURN 1
END
COMMON DEF HasActiveWindow(WND)
 VAR NUWID=ValidateWND(WND)
 IF!NUWID THEN RETURN FALSE
 RETURN OTWHasActiveWindow(NUWID)
END
DEF OTWHasActiveWindow(NUWID)
 IF WIN_ACTIVENUWID==NUWID THEN RETURN TRUE
 IF WIN_CHILD[NUWID]THEN
  VAR C=WIN_CHILD[NUWID]
  VAR D
  WHILE C
   D=WIN_NEXT[C]
   IF OTWHasActiveWindow(C) THEN RETURN TRUE
   C=D
  WEND
 ENDIF
 RETURN FALSE
END
COMMON DEF IsParentWindow(PARENT,CHILD)
 VAR P=ValidateWND(PARENT)
 IF!P THEN RETURN FALSE
 VAR C=ValidateWND(CHILD)
 IF!C THEN RETURN FALSE
 RETURN OTWIsParentWindow(P,C)
END
DEF OTWIsParentWindow(P,NUWID)
 IF P==NUWID THEN RETURN TRUE
 IF WIN_CHILD[NUWID]THEN
  VAR C=WIN_CHILD[NUWID]
  VAR D
  WHILE C
   D=WIN_NEXT[C]
   IF OTWIsChildWindow(P,C) THEN RETURN TRUE
   C=D
  WEND
 ENDIF
 RETURN FALSE
END
COMMON DEF IsChildWindow(PARENT,CHILD)
 VAR P=ValidateWND(PARENT)
 IF!P THEN RETURN FALSE
 VAR C=ValidateWND(CHILD)
 IF!C THEN RETURN FALSE
 RETURN OTWIsChildWindow(P,C)
END
DEF OTWIsChildWindow(P,NUWID)
 IF P==NUWID THEN RETURN TRUE
 VAR C=WIN_PARENT[NUWID]
 WHILE C
  IF C==P THEN RETURN TRUE
  C=WIN_PARENT[C]
 WEND
 RETURN FALSE
END
DEF DeleteWindowNUWID(NUWID)
 VAR E
 WindowOnDelete NUWID
 IF WIN_WID[NUWID]<=0THEN RETURN WIN_INVALIDID
 IF WIN_STYLE[NUWID]AND WIN_STYLE_MODAL THEN
  VOID EnableWindow(NUWIDToWND(WIN_GPARENT[NUWID]))
 ENDIF
 IF!WIN_GPARENT[NUWID]THEN
  IF WIN_ACTIVENUWID==NUWID THEN
   VOID FocusWindow(NUWIDToWND(WIN_PARENT[NUWID]))
  ENDIF
  IF WIN_INPUTNUWID==NUWID THEN
   VOID SetInputWindow(NUWIDToWND(WIN_PARENT[NUWID]))
  ENDIF
 ENDIF
 IF WIN_GROUP[NUWID]THEN
  VAR G=WIN_GROUP[NUWID]
  WHILE G
   VAR GN=WIN_GNEXT[G]
   VAR ERR=DeleteWindow(NUWIDToWND(G))
   G=GN
  WEND
  WIN_GROUP[NUWID]=0
 ENDIF
 IF WIN_CHILD[NUWID]THEN
  VAR C=WIN_CHILD[NUWID]
  VAR D
  WHILE C
   D=WIN_NEXT[C]
   E=DeleteWindowNUWID(C)
   C=D
  WEND
 ENDIF
 VOID DeleteWindowTimers(NUWIDToWND(NUWID))
 WIN_STYLE[NUWID]=0
 WIN_MENU[NUWID]=0
 WIN_WID[NUWID]=0
 WIN_MSGS[NUWID]=0
 WIN_MSGE[NUWID]=0
 WIN_CURSOR[NUWID]=0

 VAR I
 FOR I=0TO 7
  WIN_VAR[NUWID,I]=0
 NEXT
 FOR I=0TO CTL_HANDLER_MAX-1
  WIN_MSGCNT[NUWID,I]=0
 NEXT
 VAR N=WIN_NEXT[NUWID]
 VAR P=WIN_PREV[NUWID]
 IF WIN_CHILD[WIN_PARENT[NUWID]]==NUWID THEN
  WIN_CHILD[WIN_PARENT[NUWID]]=N
 ENDIF
 IF N THEN
  WIN_PREV[N]=P
 ENDIF
 IF P THEN
  WIN_NEXT[P]=N
 ENDIF
 WIN_NEXT[NUWID]=WIN_FREE
 WIN_PREV[NUWID]=0
 WIN_PARENT[NUWID]=0
 WIN_CHILD[NUWID]=0
 WIN_FREE=NUWID
 VAR NULL$
 WIN_NAME$[NUWID]=NULL$
 IF WIN_SP[NUWID]AND 511THEN
  SPVAR WIN_SP[NUWID]AND 511,0,0
  IF OTW_ENABLE_SHADOW&&SPVAR(WIN_SP[NUWID]AND 511,1)!=-1&&SPVAR(WIN_SP[NUWID]AND 511,1)!=0THEN
   SPVAR SPVAR(WIN_SP[NUWID]AND 511,1),0,0
   SPCLR SPVAR(WIN_SP[NUWID]AND 511,1)
  ENDIF
  SPCLR WIN_SP[NUWID]AND 511
  WIN_SP[NUWID]=0
  DEC OTW_TOPLEVELCNT
  OTW_SPSORT
 ENDIF
 IF WIN_GPARENT[NUWID]THEN
  'NOIMPL "DeleteWindow - Group"
  
  IF WIN_GNEXT[NUWID]THEN
   WIN_GPREV[WIN_GNEXT[NUWID]]=WIN_GPREV[NUWID]
  ENDIF
  IF WIN_GPREV[NUWID]THEN
   WIN_GNEXT[WIN_GPREV[NUWID]]=WIN_GNEXT[NUWID]
  ELSE
   WIN_GROUP[WIN_GPARENT[NUWID]]=WIN_GNEXT[NUWID]
  ENDIF
  IF WIN_ACTIVENUWID==NUWID THEN
   VOID FocusWindow(NUWIDToWND(WIN_GPARENT[NUWID]))
  ENDIF
  IF WIN_INPUTNUWID==NUWID THEN
   VOID SetInputWindow(NUWIDToWND(WIN_GPARENT[NUWID]))
  ENDIF
  WIN_GPARENT[NUWID]=0
  WIN_GPREV[NUWID]=0
  WIN_GNEXT[NUWID]=0
 ENDIF
 IF WIN_PROP[NUWID]THEN
  VAR PROP=WIN_PROP[NUWID]
  WHILE PROP
   VAR NXTPRP=PROP_NEXT[PROP]
   FREE_PROP PROP
   PROP=NXTPRP
  WEND
  WIN_PROP[NUWID]=0
 ENDIF
 WIN_PRC[NUWID]=0
 RETURN 0
END

DEF OTW_SPSORT
 VAR I,Z=0
 VAR F3D=0'-255
 IF OTW_TOPLEVELCNT-1THEN Z=(1022+F3D)/MAX(OTW_TOPLEVELCNT,1)
 VAR NUWID=WIN_CHILD[WIN_ROOTWND AND NUWIDMASK]
'IF!WIN_NEXT[NUWID]THEN I=
 I=1022+F3D
 WHILE NUWID
  I=I-Z
  IF WIN_HIDE[NUWID]THEN
   SPHIDE WIN_SP[NUWID]AND 511
  ELSE
   SPSHOW WIN_SP[NUWID]AND 511
  ENDIF
  SPOFS WIN_SP[NUWID]AND 511,,,MAX(-F3D,-F3D+I)'MAX(-255,-255+I)
'  SPOFS (WIN_SP[NUWID]>>10),,,-255+I+1
  NUWID=WIN_NEXT[NUWID]
 WEND
END
DEF OTW_DrawMap NUWID
 IF WIN_HIDE[NUWID]THEN RETURN
 GPAGE OTW_SP,OTW_DP
 GCLIP 1,0,240,400,480
 GFILL WIN_RX[NUWID],WIN_RY[NUWID]+240,WIN_RX[NUWID]+WIN_AW[NUWID],WIN_RY[NUWID]+WIN_AH[NUWID]+240,ShortToRGB(WIN_FRAMEFLG OR NUWID)
'VAR W=WIN_AW[NUWID]-WIN_FW2[NUWID]
'VAR H=WIN_AH[NUWID]-WIN_FH2[NUWID]
'IF WIN_WIDTH[NUWID]!=WIN_AW[NUWID]THEN INC W,WIN_FW1[NUWID]
'IF WIN_HEIGHT[NUWID]!=WIN_AH[NUWID]THEN INC H,WIN_FH1[NUWID]
'GFILL WIN_RFX[NUWID],WIN_RFY[NUWID]+240,WIN_RFX[NUWID]+W,WIN_RFY[NUWID]+240+H,ShortToRGB(NUWID)
 IF WIN_AFW[NUWID]<0||WIN_AFH[NUWID]<0THEN
  GCLIP 1,0,0,400,239
  RETURN
 ENDIF
 GFILL WIN_RFX[NUWID],WIN_RFY[NUWID]+240,WIN_RFX[NUWID]+WIN_AFW[NUWID],WIN_RFY[NUWID]+240+WIN_AFH[NUWID],ShortToRGB(NUWID)
 GCLIP 1,0,0,400,239
END
COMMON DEF ActiveWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF!IsWindowEnabled(WND)THEN
  OTWBeepWindow NUWID
  RETURN WIN_DISABLED
 ENDIF
 WIN_ACTIVENUWID=NUWID
 WIN_INPUTNUWID=NUWID
 RETURN 0
END
COMMON DEF IsFrontWindow(WND,WND2)
 IF!CheckWindow(WND)THEN RETURN FALSE
 IF!CheckWindow(WND2)THEN RETURN FALSE
 IF GetParentWindow(WND)!=GetParentWindow(WND2)THEN RETURN FALSE
 RETURN _IsFrontWindow(WND AND NUWIDMASK,WND2 AND NUWIDMASK)
END
DEF _IsFrontWindow(N1,N2)
 WHILE N1
  IF N1==N2 THEN
   RETURN TRUE
  ENDIF
  N1=WIN_NEXT[N1]
 WEND
 RETURN FALSE
END
COMMON DEF FrontWindow(WND)
 VAR NUWID=WND AND NUWIDMASK,E
 IF WIN_STYLE[NUWID]AND WIN_STYLE_TOOL THEN
  E=FrontWindow(GetWindowGroupOwner(WND))
  IF!E THEN E=_FrontWindow(WND)
 ELSE
  E=_FrontWindow(WND)
 ENDIF
 RETURN E
END
DEF OTWBeepWindow NUWID
 WHILE NUWID
  IF WIN_STYLE[NUWID]AND WIN_STYLE_DIS THEN
   BEEP
   IF WIN_SP[NUWID]THEN
    SPANIM WIN_SP[NUWID]AND 511,6,-10,RGB(128,128,128),-10,RGB(255,255,255)
   ENDIF
  ENDIF
  NUWID=WIN_PARENT[NUWID]
 WEND
END
DEF _FrontWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR N,C=NUWID'WIN_NEXT[NUWID]
 VAR MOVEF2'TOOL WINDOW
 IF!WIN_NEXT[C]THEN RETURN 0
 VAR TOPMOST=(WIN_STYLE[C]AND WIN_STYLE_TOPMST)
 IF C THEN
  VAR MOVEF=FALSE
  WHILE 1
   IF!WIN_NEXT[C]||(!TOPMOST&&WIN_STYLE[WIN_NEXT[C]]AND WIN_STYLE_TOPMST) THEN
    IF C==NUWID THEN RETURN 0
    IF (WIN_STYLE[C]AND WIN_STYLE_TOOL)&&WIN_GPARENT[C]==NUWID THEN
     MOVEF=FALSE
     MOVEF2=TRUE
     BREAK
    ENDIF
    VAR NUP=WIN_PREV[NUWID]
    VAR NUN=WIN_NEXT[NUWID]
    IF NUP THEN
     WIN_NEXT[NUP]=NUN
    ELSE
    WIN_CHILD[WIN_PARENT[NUWID]]=NUN
    ENDIF
    IF NUN THEN
     IF NUP THEN WIN_NEXT[NUP]=NUN
     WIN_PREV[NUN]=NUP
    ENDIF
    MOVEF=TRUE
    IF WIN_NEXT[C]THEN
     WIN_PREV[WIN_NEXT[C]]=C
    ENDIF
    WIN_NEXT[NUWID]=WIN_NEXT[C]
    WIN_NEXT[C]=NUWID
    WIN_PREV[NUWID]=C
    BREAK
   ENDIF
   C=WIN_NEXT[C]
  WEND
  IF WIN_SP[NUWID] THEN
   OTW_SPSORT
  ENDIF
  IF MOVEF THEN RepaintAllWindow WND,0,0,0,0
  
 ENDIF
 VAR G=WIN_GROUP[NUWID],E
 IF!MOVEF2 THEN
  WHILE G
   IF WIN_STYLE[G]AND WIN_STYLE_TOOL THEN
    IF!_IsFrontWindow(NUWID,G)THEN
     E=_FrontWindow(NUWIDToWND(G))
    ENDIF
   ENDIF
   G=WIN_GNEXT[G]
  WEND
 ENDIF
 VAR HASMODAL
 G=WIN_GROUP[NUWID]
 WHILE G
  IF WIN_STYLE[G]AND WIN_STYLE_MODAL THEN
   BEEP 
   IF WIN_SP[NUWID]THEN
    SPANIM WIN_SP[NUWID]AND 511,6,-10,RGB(128,128,128),-10,RGB(255,255,255)
   ENDIF
   E=FrontWindow(NUWIDToWND(G))
   E=ActiveWindow(NUWIDToWND(G))
   HASMODAL=TRUE
  ENDIF
  G=WIN_GNEXT[G]
 WEND
' IF!HASMODAL THEN E=ActiveWindow(WND)
 RETURN 0
END

DEF RepaintAllWindow WND,X,Y,W,H
 VAR NXT=WND AND NUWIDMASK
 VAR B=NXT
 VAR CLIPMODE=1
 IF!X&&!Y&&!W&&!H THEN CLIPMODE=0
 VAR X2=X+W
 VAR Y2=Y+H
 
   WHILE B
    IF B!=1&&!WIN_HIDE[B] THEN
     IF!CLIPMODE THEN
      VOID RepaintWindow(B OR(WIN_WID[B]<<WIDSHIFT))
      GOTO @CONT
     ENDIF
     VAR FX=WIN_AX[B]+WIN_FW1[B]
     VAR FY=WIN_AY[B]+WIN_FH1[B]
     VAR FW=WIN_WIDTH[B]-WIN_FW2[B]
     VAR FH=WIN_HEIGHT[B]-WIN_FH2[B]
     VAR CX=MAX(X,FX)
     VAR CY=MAX(Y,FY)
     VAR CX2=MIN(X2,FX+FW)
     VAR CY2=MIN(Y2,FY+FH)
     VAR CW=CX2-CX
     VAR CH=CY2-CY
     CX=CX-FX
     CY=CY-FY
     IF CX>=0&&CX<=FW&&CY>=0&&CY<=FH&&CW>=0&&CH>=0THEN
      VOID RepaintWindowWithARect(B OR(WIN_WID[B]<<WIDSHIFT),MAX(0,CX),MAX(0,CY),CW,CH)
     ELSE
      FX=WIN_AX[B]
      FY=WIN_AY[B]
      FW=WIN_WIDTH[B]
      FH=WIN_HEIGHT[B]
      CX=MAX(X,FX)
      CY=MAX(Y,FY)
      CX2=MIN(X2,FX+FW)
      CY2=MIN(Y2,FY+FH)
      CW=CX2-CX
      CH=CY2-CY
      CX=CX-FX
      CY=CY-FY
      
      IF CX>=0&&CX<=FW&&CY>=0&&CY<=FH&&CW>=0&&CH>=0 THEN
       VOID RepaintFrameWindow(B OR(WIN_WID[B]<<WIDSHIFT))
       
      ENDIF
     ENDIF
    ENDIF
    @CONT
    OTW_DrawMap B
    IF WIN_CHILD[B]THEN
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
  '    IF B==NXT THEN BREAK
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN RETURN
 '    IF B==NXT THEN BREAK
    ENDIF
    B=WIN_NEXT[B]
 '   IF B==NXT THEN BREAK
   WEND
'  ENDIF
'  NXT=WIN_NEXT[NXT]
' WEND
END
DEF OTW_CLIPWindow NUWID
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_AW[NUWID]=WIN_WIDTH[NUWID]
 WIN_AH[NUWID]=WIN_HEIGHT[NUWID]
 WIN_AFW[NUWID]=WIN_WIDTH[NUWID]-WIN_FW2[NUWID]
 WIN_AFH[NUWID]=WIN_HEIGHT[NUWID]-WIN_FH2[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 'ひだり はみで の しょり
 IF WIN_RX[NUWID]<WIN_RFX[PNUWID]THEN
  DEC WIN_AW[NUWID],WIN_RFX[PNUWID]-WIN_RX[NUWID]
  WIN_RX[NUWID]=WIN_RFX[PNUWID]
 ENDIF
 IF WIN_RFX[NUWID]<WIN_RFX[PNUWID]THEN
  DEC WIN_AFW[NUWID],WIN_RFX[PNUWID]-WIN_RFX[NUWID]
  WIN_RFX[NUWID]=WIN_RFX[PNUWID]
 ENDIF
 IF WIN_RY[NUWID]<WIN_RFY[PNUWID]THEN
  DEC WIN_AH[NUWID],WIN_RFY[PNUWID]-WIN_RY[NUWID]
  WIN_RY[NUWID]=WIN_RFY[PNUWID]
 ENDIF
 IF WIN_RFY[NUWID]<WIN_RFY[PNUWID]THEN
  DEC WIN_AFH[NUWID],WIN_RFY[PNUWID]-WIN_RFY[NUWID]
  WIN_RFY[NUWID]=WIN_RFY[PNUWID]
 ENDIF
 'みぎ はみで の しょり
 IF WIN_RFX[NUWID]+WIN_AFW[NUWID]>WIN_RFX[PNUWID]+WIN_AFW[PNUWID]THEN
  DEC WIN_AFW[NUWID],(WIN_RFX[NUWID]+WIN_AFW[NUWID])-(WIN_RFX[PNUWID]+WIN_AFW[PNUWID])
 ENDIF
 IF WIN_RX[NUWID]+WIN_AW[NUWID]>WIN_RFX[PNUWID]+WIN_AFW[PNUWID]THEN
  DEC WIN_AW[NUWID],(WIN_RX[NUWID]+WIN_AW[NUWID])-(WIN_RFX[PNUWID]+WIN_AFW[PNUWID])
 ENDIF

 IF WIN_RFY[NUWID]+WIN_AFH[NUWID]>WIN_RFY[PNUWID]+WIN_AFH[PNUWID]THEN
  DEC WIN_AFH[NUWID],(WIN_RFY[NUWID]+WIN_AFH[NUWID])-(WIN_RFY[PNUWID]+WIN_AFH[PNUWID])
 ENDIF
 IF WIN_RY[NUWID]+WIN_AH[NUWID]>WIN_RFY[PNUWID]+WIN_AFH[PNUWID]THEN
  DEC WIN_AH[NUWID],(WIN_RY[NUWID]+WIN_AH[NUWID])-(WIN_RFY[PNUWID]+WIN_AFH[PNUWID])
 ENDIF

 WIN_HIDE[NUWID]=WIN_STYLE[NUWID] AND WIN_STYLE_HIDE
 IF WIN_HIDE[PNUWID]THEN WIN_HIDE[NUWID]=1
 
' IF WIN_STYLE[PNUWID] AND WIN_STYLE_HIDE THEN WIN_HIDE[NUWID]=1
 IF WIN_AH[NUWID]<0THEN
  WIN_HIDE[NUWID]=1
  RETURN
 ENDIF
 IF WIN_AW[NUWID]<0THEN
  WIN_HIDE[NUWID]=1
  RETURN
 ENDIF
END
DEF OTW_CLIPCHILD NUWID
 WHILE NUWID
  OTW_CLIPWINDOW NUWID
  IF WIN_CHILD[NUWID]THEN
   OTW_CLIPCHILD WIN_CHILD[NUWID]
  ENDIF
  NUWID=WIN_NEXT[NUWID]
 WEND
END
DEF OTW_UpdateMap NUWID
 WHILE NUWID
  OTW_DrawMap NUWID
  IF WIN_CHILD[NUWID]THEN
   NUWID=WIN_CHILD[NUWID]
   CONTINUE
  ENDIF
  IF!WIN_NEXT[NUWID]THEN
   WHILE NUWID
    NUWID=WIN_PARENT[NUWID]
    IF WIN_NEXT[NUWID]THEN
     NUWID=WIN_NEXT[NUWID]
     BREAK
    ENDIF
   WEND
   CONTINUE
  ENDIF
  NUWID=WIN_NEXT[NUWID]
 WEND
END
COMMON DEF ShowWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_STYLE[NUWID] AND WIN_STYLE_HIDE THEN
  WIN_HIDE[NUWID]=FALSE
  WIN_STYLE[NUWID]=WIN_STYLE[NUWID] AND NOT WIN_STYLE_HIDE
  IF WIN_SP[NUWID]THEN
   OTW_SPSHOW NUWID
   OTW_SPCHR NUWID
  ENDIF
  ShowChildWindow NUWID
 ELSE
  RETURN 0
 ENDIF
 OTW_UpdateMap NUWID
 RETURN RepaintWindow(WND)
END
DEF HideChildWindow NUWID
 VAR C=WIN_CHILD[NUWID]
 WHILE C
  IF WIN_STYLE[C] AND WIN_STYLE_HIDE THEN
   C=WIN_NEXT[C]
   CONTINUE
  ENDIF
  WIN_HIDE[C]=TRUE
  HideChildWindow C
  C=WIN_NEXT[C]
 WEND
END
DEF ShowChildWindow NUWID
 VAR C=WIN_CHILD[NUWID]
 WHILE C
  IF WIN_STYLE[C] AND WIN_STYLE_HIDE THEN
   C=WIN_NEXT[C]
   CONTINUE
  ENDIF
  WIN_HIDE[C]=FALSE
  VOID RepaintWindow(NUWIDToWND(C))
  ShowChildWindow C
  C=WIN_NEXT[C]
 WEND
END
COMMON DEF HideWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_STYLE[NUWID] AND WIN_STYLE_HIDE THEN RETURN 0
 IF IsActiveWindow(WND)THEN
  WIN_ACTIVENUWID=0
  WIN_INPUTNUWID=0
 ENDIF
 WIN_HIDE[NUWID]=TRUE
 WIN_STYLE[NUWID]=WIN_STYLE[NUWID] OR WIN_STYLE_HIDE
 IF WIN_SP[NUWID]THEN
  OTW_SPHIDE NUWID
 ENDIF
 HideChildWindow NUWID
 RepaintAllWindow GetParentWindow(WND),WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
 RETURN 0
END
COMMON DEF BeginWindowOP(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 RETURN 0
END
COMMON DEF EndWindowOp(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 RepaintAllWindow WND,0,0,0,0
 RETURN 0
END
COMMON DEF MoveWindow2(WND,X,Y)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR MX=X-WIN_X[NUWID],MY=Y-WIN_Y[NUWID]
 IF!MX&&!MY THEN RETURN 0
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_X[NUWID]=X'INC WIN_X[NUWID],MX
 WIN_Y[NUWID]=Y'INC WIN_Y[NUWID],MY
 WIN_AX[NUWID]=WIN_AX[PNUWID]+WIN_FW1[PNUWID]+X
 WIN_AY[NUWID]=WIN_AY[PNUWID]+WIN_FH1[PNUWID]+Y
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 OTW_CLIPWindow NUWID
 VAR NXT=WIN_CHILD[WIN_PARENT[NUWID]],B

 IF!NXT THEN RETURN 0
 B=NXT
 IF WIN_PARENT[NUWID]==(WIN_ROOTWND AND NUWIDMASK) THEN
  IF WIN_SP[NUWID]THEN
   WIN_SP[NUWID]=WIN_SP[NUWID] OR 512
  ENDIF
 ENDIF
 VAR MOVEF=0
 B=WIN_PARENT[NUWID]
   WHILE B
    IF MOVEF THEN
     WIN_AX[B]=WIN_AX[B]+MX
     WIN_AY[B]=WIN_AY[B]+MY
     WIN_FX[B]=WIN_AX[B]+WIN_FW1[B]'+MX
     WIN_FY[B]=WIN_AY[B]+WIN_FH1[B]'+MY
     WIN_RFX[B]=WIN_FX[B]'+MX
     WIN_RFY[B]=WIN_FY[B]'+MY
     WIN_RX[B]=WIN_AX[B]'+MX
     WIN_RY[B]=WIN_AY[B]'+MY
     OTW_CLIPWindow B
     MOVEF=1
    ENDIF
    IF WIN_CHILD[B]THEN
     IF B==NUWID THEN MOVEF=1
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
      IF B==NUWID THEN MOVEF=0
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN RETURN 0
    ENDIF
    B=WIN_NEXT[B]
   WEND
 RETURN 0
END
COMMON DEF MoveWindow(WND,X,Y)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR OX=WIN_AX[NUWID],OY=WIN_AY[NUWID]
 VAR MX=X-WIN_X[NUWID],MY=Y-WIN_Y[NUWID]
' IF!MX&&!MY THEN RETURN 0
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_X[NUWID]=X'INC WIN_X[NUWID],MX
 WIN_Y[NUWID]=Y'INC WIN_Y[NUWID],MY
 WIN_AX[NUWID]=WIN_AX[PNUWID]+WIN_FW1[PNUWID]+X
 WIN_AY[NUWID]=WIN_AY[PNUWID]+WIN_FH1[PNUWID]+Y
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 OTW_CLIPWindow NUWID
 VAR NXT=WIN_CHILD[WIN_PARENT[NUWID]],B
' VOID RepaintWindow(WIN_PARENT[NUWID]OR(WIN_WID[WIN_PARENT[NUWID]]<<WIDSHIFT))

' IF!NXT THEN RETURN 'WIN_
 B=NXT
 IF WIN_PARENT[NUWID]==(WIN_ROOTWND AND NUWIDMASK) THEN
  IF WIN_SP[NUWID]THEN
   WIN_SP[NUWID]=WIN_SP[NUWID] OR 512
  ENDIF
  IF 0THEN
  GPAGE OTW_SP,OTW_GP
  GCOPY OTW_DP,WIN_AX[NUWID]-MX,WIN_AY[NUWID]-MY,WIN_AX[NUWID]-MX+WIN_WIDTH[NUWID],WIN_AY[NUWID]-MY+WIN_HEIGHT[NUWID],WIN_AX[NUWID],WIN_AY[NUWID],0
  GPAGE OTW_SP,OTW_DP
  GFILL WIN_AX[NUWID]-MX,WIN_AY[NUWID]-MY,WIN_AX[NUWID]-MX+WIN_WIDTH[NUWID],WIN_AY[NUWID]-MY+WIN_HEIGHT[NUWID],WIN_BKGND
  GCOPY OTW_GP,WIN_AX[NUWID],WIN_AY[NUWID],WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID],WIN_AX[NUWID],WIN_AY[NUWID],0
  ENDIF
  OTW_SPCHR NUWID
 ENDIF
 OTW_DrawMap WIN_PARENT[NUWID]
 '   B=WIN_CHILD[NXT]
 VAR MOVEF=1
 B=WIN_CHILD[NUWID]
   WHILE B
    IF MOVEF THEN
     WIN_AX[B]=WIN_AX[B]+MX
     WIN_AY[B]=WIN_AY[B]+MY
     WIN_FX[B]=WIN_AX[B]+WIN_FW1[B]'+MX
     WIN_FY[B]=WIN_AY[B]+WIN_FH1[B]'+MY
     WIN_RFX[B]=WIN_FX[B]'+MX
     WIN_RFY[B]=WIN_FY[B]'+MY
     WIN_RX[B]=WIN_AX[B]'+MX
     WIN_RY[B]=WIN_AY[B]'+MY
     OTW_CLIPWindow B
     MOVEF=1
    ENDIF
   VOID RepaintWindow(NUWIDTOWND(B))
    IF WIN_CHILD[B]THEN
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
      IF B==NUWID THEN B=0
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN BREAK
    ENDIF
    B=WIN_NEXT[B]
   WEND
   VOID RepaintWindow(WND)
   RepaintAllWindow NUWIDToWND(WIN_PARENT[NUWID]),OX,OY,WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
 RETURN 0
END
DEF ResizeWindowF(WND,W,H)
 VAR NUWID=WND AND NUWIDMASK
 'ちいさい
 IF W+1<WIN_MINW[NUWID]THEN
  W=WIN_MINW[NUWID]-1
 ENDIF
 IF H+1<WIN_MINH[NUWID]THEN
  H=WIN_MINH[NUWID]-1
 ENDIF
 VOID FireResizeWindow(WND,W-WIN_FW2[NUWID],H-WIN_FH2[NUWID])
 VAR OW=WIN_WIDTH[NUWID]
 VAR OH=WIN_HEIGHT[NUWID]
 WIN_WIDTH[NUWID]=W
 WIN_HEIGHT[NUWID]=H
 OTW_CLIPWindow NUWID
 OTW_CLIPCHILD NUWID
 RepaintAllWindow WND,0,0,0,0
 RepaintAllWindow GetParentWindow(WND),WIN_AX[NUWID],WIN_AY[NUWID],OW,OH
'WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
 RETURN 0
END
DEF MoveResizeWindowF(WND,X,Y,W,H,FW1,FH1,FW2,FH2)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF W+1<WIN_MINW[NUWID]THEN
  W=WIN_MINW[NUWID]-1
 ENDIF
 IF H+1<WIN_MINH[NUWID]THEN
  H=WIN_MINH[NUWID]-1
 ENDIF
 VAR OX=WIN_AX[NUWID],OY=WIN_AY[NUWID]
 VAR MX=X-WIN_X[NUWID],MY=Y-WIN_Y[NUWID]
 IF FW1!=&H7FFFFFFFTHEN
  MX=MX-WIN_FW1[NUWID]+FW1
 ENDIF
 IF FH1!=&H7FFFFFFFTHEN
  MY=MY-WIN_FH1[NUWID]+FH1
 ENDIF
 VAR OW=WIN_WIDTH[NUWID]
 VAR OH=WIN_HEIGHT[NUWID]

 IF!MX&&!MY&&W==OW&&H==OH THEN RETURN 0
 IF FW1!=&H7FFFFFFFTHEN
  WIN_FW1[NUWID]=FW1
 ENDIF
 IF FH1!=&H7FFFFFFFTHEN
  WIN_FH1[NUWID]=FH1
 ENDIF
 IF FW2!=&H7FFFFFFFTHEN
  WIN_FW2[NUWID]=FW2+WIN_FW1[NUWID]
 ENDIF
 IF FH2!=&H7FFFFFFFTHEN
  WIN_FH2[NUWID]=FH2+WIN_FH1[NUWID]
 ENDIF
 VOID FireResizeWindow(WND,W-WIN_FW2[NUWID],H-WIN_FH2[NUWID])
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_WIDTH[NUWID]=W
 WIN_HEIGHT[NUWID]=H
 WIN_X[NUWID]=X'INC WIN_X[NUWID],MX
 WIN_Y[NUWID]=Y'INC WIN_Y[NUWID],MY
 WIN_AX[NUWID]=WIN_AX[PNUWID]+WIN_FW1[PNUWID]+X
 WIN_AY[NUWID]=WIN_AY[PNUWID]+WIN_FH1[PNUWID]+Y
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 OTW_CLIPWindow NUWID
 VAR NXT=WIN_CHILD[WIN_PARENT[NUWID]],B

' IF!NXT THEN RETURN 0
 B=NXT
 IF WIN_PARENT[NUWID]==(WIN_ROOTWND AND NUWIDMASK) THEN
  IF WIN_SP[NUWID]THEN
   WIN_SP[NUWID]=WIN_SP[NUWID] OR 512
  ENDIF
 ENDIF
 VAR MOVEF=0
 B=WIN_PARENT[NUWID]
   WHILE B
    IF MOVEF THEN
     WIN_AX[B]=WIN_AX[B]+MX
     WIN_AY[B]=WIN_AY[B]+MY
     WIN_FX[B]=WIN_AX[B]+WIN_FW1[B]'+MX
     WIN_FY[B]=WIN_AY[B]+WIN_FH1[B]'+MY
     WIN_RFX[B]=WIN_FX[B]'+MX
     WIN_RFY[B]=WIN_FY[B]'+MY
     WIN_RX[B]=WIN_AX[B]'+MX
     WIN_RY[B]=WIN_AY[B]'+MY
     OTW_CLIPWindow B
     MOVEF=1
    ENDIF
    IF WIN_CHILD[B]THEN
     IF B==NUWID THEN MOVEF=1
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
      IF B==NUWID THEN MOVEF=0
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN GOTO @END
    ENDIF
    B=WIN_NEXT[B]
   WEND
   @END
 RepaintAllWindow WND,0,0,0,0
 RepaintAllWindow GetParentWindow(WND),OX,OY,OW,OH
 RETURN 0
END
COMMON DEF ResizeWindow(WND,W,H)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 RETURN ResizeWindowF(WND,W+WIN_FW2[NUWID],H+WIN_FH2[NUWID])
END
COMMON DEF MoveResizeWindow(WND,X,Y,W,H)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 RETURN MoveResizeWindowF(WND,X,Y,W+WIN_FW2[NUWID],H+WIN_FH2[NUWID],&H7FFFFFFF,&H7FFFFFFF,&H7FFFFFFF,&H7FFFFFFF)
END
COMMON DEF SendWindowEvent(WND,TYPE,A1,A2)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF(WIN_MSGS[NUWID]+1)MOD WIN_MSGMAX==WIN_MSGE[NUWID] THEN RETURN WIN_EVENTERR
 IF!LEN(CTL_HANDLER$[WIN_CTL[NUWID]AND 4095,TYPE])THEN RETURN 0
 IF CTL_NDHNDLR[TYPE]THEN
  IF WIN_MSGCNT[NUWID,TYPE]THEN RETURN 0
  'INC WIN_MSGCNT[NUWID,TYPE]
 ENDIF
 IF TYPE==CTL_PAINTHANDLER||TYPE==CTL_FRMPAINTHANDLER THEN
  IF WIN_MSGCNT[NUWID,TYPE]THEN
   VAR I=WIN_MSGE[NUWID]
   WHILE WIN_MSGS[NUWID]!=I
    IF WIN_MSGBUF[NUWID,I,0]==TYPE THEN
     WIN_MSGBUF[NUWID,I,0]=-1
    ENDIF
    I=I+1
    IF I>=WIN_MSGMAX THEN I=0
   WEND
   WIN_MSGCNT[NUWID,TYPE]=0
   A1=0
   A2=0
  ENDIF
  INC WIN_MSGCNT[NUWID,TYPE]
 ENDIF
 WIN_MSGBUF[NUWID,WIN_MSGS[NUWID],0]=TYPE
 WIN_MSGBUF[NUWID,WIN_MSGS[NUWID],1]=A1
 WIN_MSGBUF[NUWID,WIN_MSGS[NUWID],2]=A2
 INC WIN_MSGS[NUWID]
 IF WIN_MSGS[NUWID]>=WIN_MSGMAX THEN WIN_MSGS[NUWID]=0
 RETURN 0
END
DEF RepaintFrameWindow(WND)
 IF WIN_HIDE[WND AND NUWIDMASK]THEN RETURN 0
 RETURN SendWindowEvent(WND,CTL_FRMPAINTHANDLER,0,0)
END
COMMON DEF RepaintWindow(WND)
 IF WIN_HIDE[WND AND NUWIDMASK]THEN RETURN 0
 RETURN SendWindowEvent(WND,CTL_PAINTHANDLER,0,0)
END
COMMON DEF RepaintWindowWithARect(WND,AX,AY,AX2,AY2)
 IF WIN_HIDE[WND AND NUWIDMASK]THEN RETURN 0
 RETURN SendWindowEvent(WND,CTL_PAINTHANDLER,AX OR AY<<16,AX2 OR AY2<<16)
END
COMMON DEF SendNotificationWindow(WND,DAT,DAT2)
 RETURN SendWindowEvent(WND,CTL_NOTIFHANDLER,DAT,DAT2)
END
COMMON DEF SendNotifWindow(WND,DAT,DAT2)
 RETURN SendWindowEvent(WND,CTL_NOTIFHANDLER,DAT,DAT2)
END
COMMON DEF SendKeyWindow(WND,KEY)
 RETURN SendWindowEvent(WND,CTL_KEYHANDLER,KEY,0)
END
COMMON DEF SendButtonWindow(WND,BTN)
 RETURN SendWindowEvent(WND,CTL_BTNHANDLER,BTN,0)
END
COMMON DEF SendChFocusWindow(WND,FLG,FOCUSW)
 RETURN SendWindowEvent(WND,CTL_CHFOCUSHANDLER,FLG,FOCUSW)
END
COMMON DEF SendStrNotifWindow(WND,A1,STR$)
 RETURN SendWindowEvent(WND,CTL_STRNOTIFHANDLER,A1,AllocString(STR$))
END
COMMON DEF GetWindowMouseX(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 VAR NUWID=WND AND NUWIDMASK
 RETURN OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID]
END
COMMON DEF GetWindowMouseY(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 VAR NUWID=WND AND NUWIDMASK
 RETURN OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID]
END
DEF MouseMoveWindow(NUWID)
 IF!IsWindowEnabled(NUWIDToWND(NUWID))THEN RETURN WIN_DISABLED
 RETURN SendWindowEvent(NUWIDToWND(NUWID),CTL_MOUSEMVHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF MouseLeaveWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_MSLEAVEHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF LMouseUpWindow(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_LBTNUPHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF LMouseDownWindow(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_LBTNDWNHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF LDoubleClickWindow(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_LDBLCLKHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF RMouseUpWindow(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_RBTNUPHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF RMouseDownWindow(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_RBTNDWNHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF RDoubleClickWindow(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 'FIXME:RDBLCLK
 RETURN SendWindowEvent(WND,CTL_LDBLCLKHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF MouseMoveWindowOnFrame(NUWID)
 IF!IsWindowEnabled(NUWIDToWND(NUWID))THEN RETURN WIN_DISABLED
 RETURN SendWindowEvent(NUWIDToWND(NUWID),CTL_FRMMOUSEMVHANDLER,0,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF LMouseDownWindowOnFrame(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_LBTNFLG OR CTL_BTNDWNFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF LMouseUpWindowOnFrame(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_LBTNFLG OR CTL_BTNUPFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF RMouseDownWindowOnFrame(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_RBTNFLG OR CTL_BTNDWNFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF LMouseDblClickWindowOnFrame(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_LBTNFLG OR CTL_BTNUPFLG OR CTL_DBLFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF RMouseDblClickWindowOnFrame(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_RBTNFLG OR CTL_BTNDWNFLG OR CTL_DBLFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF RMouseUpWindowOnFrame(WND)
 IF!IsWindowEnabled(WND)THEN RETURN WIN_DISABLED
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_RBTNFLG OR CTL_BTNUPFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF MouseLeaveWindowOnFrame(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMMOUSEMVHANDLER,CTL_LEAVEFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF FireResizeWindow(WND,W,H)
 VAR NUWID=WND AND NUWIDMASK
 VAR CW=WIN_CHILD[NUWID],TYPE=ParentWindowResizeEvent()
 
 WHILE CW
  VAR _=SendParentWindowEvent(NUWIDToWND(CW),TYPE,WND)
  CW=WIN_NEXT[CW]
 WEND
 RETURN SendWindowEvent(WND,CTL_RESIZEHANDLER,0,JoinInt(W,H))
END
DEF SendChildWindowEvent(WND,TYPE,CWND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_CHLDWNDHANDLER,TYPE,CWND)
END
DEF SendParentWindowEvent(WND,TYPE,PWND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_PRNTWNDHANDLER,TYPE,PWND)
END
DEF SendContextMenuEvent(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_CTXMENUHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
COMMON DEF SendChInputWindow(WND,FLG,INPUTW)
 RETURN SendWindowEvent(WND,CTL_CHINPUTHANDLER,FLG,INPUTW)
END

COMMON DEF CallBaseControlHandler(WND,CTL,TYPE,A1,A2)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 IF CTL_IMPLICIT[CTL AND 4095,TYPE]THEN RETURN 0
 CTL=CTL_PARENTCTL[CTL AND 4095]
 IF!CheckControl(CTL)THEN RETURN 0
 IF LEN(CTL_HANDLER$[CTL AND 4095,TYPE])THEN CALL CTL_HANDLER$[CTL AND 4095,TYPE],WND,CTL,TYPE,A1,A2
 RETURN 0
END
COMMON DEF CallControlHandler(WND,CTL,TYPE,A1,A2)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 IF LEN(CTL_HANDLER$[CTL AND 4095,TYPE])THEN CALL CTL_HANDLER$[CTL AND 4095,TYPE],WND,CTL,TYPE,A1,A2
 RETURN 0
END
COMMON DEF PeekWindowEvent(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_MSGS[NUWID]==WIN_MSGE[NUWID]THEN RETURN -1
 RETURN WIN_MSGBUF[NUWID,WIN_MSGE[NUWID],0]
END
DEF OTWCallHandler WND,NUWID,NUCID,TYPE,S,FREE
 IF CTL_IMPLICIT[NUCID,TYPE]THEN
  OTWCallHandler WND,NUWID,CTL_PARENTCTL[NUCID]AND 4095,TYPE,S,FALSE
 ENDIF
 IF TYPE==13THEN
  'CTL_STRNOTIFHANDLER
  CALL CTL_HANDLER$[NUCID,TYPE],WND,WIN_CTL[NUWID],TYPE,WIN_MSGBUF[NUWID,S,1],GetString$(WIN_MSGBUF[NUWID,S,2])
  IF FREE THEN
   FreeString WIN_MSGBUF[NUWID,S,2]
  ENDIF
 ELSE
  CALL CTL_HANDLER$[NUCID,TYPE],WND,WIN_CTL[NUWID],TYPE,WIN_MSGBUF[NUWID,S,1],WIN_MSGBUF[NUWID,S,2]
 ENDIF
END
COMMON DEF UpdateWindowOnly(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_GROUP[NUWID]THEN
  VAR G=WIN_GROUP[NUWID]
  WHILE G
   'TODO:TORIAEZU STACK OVERFLOW TAISAKU
   'IF G==WIN_GROUP[NUWID]THEN BREAK
   IF G==NUWID THEN BREAK
   IF UpdateWindow(G OR WIN_WID[G]<<12)THEN BREAK
   G=WIN_GNEXT[G]
  WEND
 ENDIF
 'TIMER
 IF WIN_TIMER[NUWID]THEN UpdateTimer WND
 IF WIN_MSGS[NUWID]==WIN_MSGE[NUWID]THEN RETURN 0
 VAR NUCID=WIN_CTL[NUWID] AND 4095
 WHILE WIN_MSGS[NUWID]!=WIN_MSGE[NUWID]
 VAR S=WIN_MSGE[NUWID],S2=WIN_MSGS[NUWID]
 VAR TYPE=WIN_MSGBUF[NUWID,S,0]

 INC WIN_MSGE[NUWID]
 IF WIN_MSGE[NUWID]>=WIN_MSGMAX THEN WIN_MSGE[NUWID]=0
 IF TYPE==-1THEN CONTINUE
 OTWCallHandler WND,NUWID,NUCID,TYPE,S,TRUE
 IF WIN_WID[NUWID]<=0THEN RETURN WIN_INVALIDID
 DEC WIN_MSGCNT[NUWID,TYPE]
 IF WIN_BEGIN[NUWID]THEN VOID GEndWindow(WND)
' IF CTL_NDHNDLR[TYPE]THEN
'  DEC WIN_MSGCNT[NUWID,TYPE]
' ENDIF
 'IF S2!=WIN_MSGS[NUWID]THEN BREAK
'BREAK
 WEND
 RETURN 0
END
DEF UpdateTimer WND
 VAR NUWID=WND AND NUWIDMASK
 VAR T=WIN_TIMER[NUWID]AND NUWIDMASK
 VAR M=MILLISEC
 
 WHILE T
  VAR NT=TIMER_NEXT[T]
  IF TIMER_TM[T]+TIMER_TIMEOUT[T]<=M THEN
   VAR TMR=ToTimer(T)
   CALL TIMER_FUNC$[T],WND,TMR,TIMER_ARG[T]
   VOID DeleteTimer(TMR)
   BREAK
  ENDIF
  T=NT
 WEND
END
COMMON DEF UpdateWindow(WND)
 VAR E=UpdateWindowOnly(WND)
 VAR NUWID=WND AND NUWIDMASK
 IF E THEN RETURN E
 @END
 VAR B=WIN_CHILD[NUWID]
 VAR DB=B,PB=NUWID
 WHILE B
  IF B==NUWID THEN BREAK
  E=UpdateWindowOnly(B OR WIN_WID[B]<<WIDSHIFT)
  IF E THEN B=DB
  IF!B THEN B=PB
  IF WIN_CHILD[B]THEN
   B=WIN_CHILD[B]
   CONTINUE
  ENDIF
  IF!WIN_NEXT[B]THEN
   WHILE B
    B=WIN_PARENT[B]
    IF B==NUWID THEN BREAK
    IF WIN_NEXT[B]THEN BREAK
   WEND
   IF!B THEN BREAK
   IF B==NUWID THEN BREAK
   PB=B
   B=WIN_NEXT[B]
   CONTINUE
  ENDIF
  DB=B
  B=WIN_NEXT[B]
 WEND 
 RETURN 0
END

DEF GetWindowFrameWidth(WND)
 RETURN WIN_WIDTH[WND AND NUWIDMASK]
END
DEF GetWindowFrameHeight(WND)
 RETURN WIN_FH1[WND AND NUWIDMASK]'CTL_FH2[NUCID]
END
DEF GetWindowFrameHeight2(WND)
 RETURN WIN_FH2[WND AND NUWIDMASK]'CTL_FH2[NUCID]
END
common def GetWindowName$(wnd)
 if!checkwindow(wnd)then return ""
 return win_name$[wnd and nuwidmask]
end
common def SetWindowName wnd,name$
 if!checkwindow(wnd)then return
 win_name$[wnd and nuwidmask]=name$
end
COMMON DEF GetWindowSize WND,FRM OUT W,H,E
 IF!CheckWindow(WND)THEN
  E=WIN_INVALIDID
  W=0
  H=0
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 E=0
 W=WIN_WIDTH[NUWID]
 H=WIN_HEIGHT[NUWID]
 IF!FRM THEN
  W=W-WIN_FW2[NUWID]
  H=H-WIN_FH2[NUWID]
 ENDIF
END
COMMON DEF GetWindowWidth(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 RETURN WIN_WIDTH[WND AND NUWIDMASK]-WIN_FW2[WND AND NUWIDMASK]
END
COMMON DEF GetWindowHeight(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 RETURN WIN_HEIGHT[WND AND NUWIDMASK]-WIN_FH2[WND AND NUWIDMASK]
END
COMMON DEF GetWindowX(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FX[WND AND NUWIDMASK]
 RETURN WIN_X[WND AND NUWIDMASK]+WIN_FW1[WND AND NUWIDMASK]
END
COMMON DEF GetWindowY(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FY[WND AND NUWIDMASK]
 RETURN WIN_Y[WND AND NUWIDMASK]+WIN_FH1[WND AND NUWIDMASK]
END
'ROOT WINDOWからの ぜっだいざびょう
COMMON DEF GetWindowAX(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FX[WND AND NUWIDMASK]
 RETURN WIN_AX[WND AND NUWIDMASK]+WIN_FW1[WND AND NUWIDMASK]-WIN_AX[WIN_ROOTWND2 AND NUWIDMASK]-WIN_FW1[WIN_ROOTWND2 AND NUWIDMASK]
END
'ROOT WINDOWからの ぜっだいざびょう
COMMON DEF GetWindowAY(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FY[WND AND NUWIDMASK]
 RETURN WIN_AY[WND AND NUWIDMASK]+WIN_FH1[WND AND NUWIDMASK]-WIN_AY[WIN_ROOTWND2 AND NUWIDMASK]-WIN_FH1[WIN_ROOTWND2 AND NUWIDMASK]
END
COMMON DEF GetTrueWindowAX(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 RETURN WIN_AX[WND AND NUWIDMASK]+WIN_FW1[WND AND NUWIDMASK]-WIN_AX[WIN_ROOTWND AND NUWIDMASK]-WIN_FW1[WIN_ROOTWND AND NUWIDMASK]
END
COMMON DEF GetTrueWindowAY(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 RETURN WIN_AY[WND AND NUWIDMASK]+WIN_FH1[WND AND NUWIDMASK]-WIN_AY[WIN_ROOTWND AND NUWIDMASK]-WIN_FH1[WIN_ROOTWND AND NUWIDMASK]
END

'WNDからのWND2のざひょう
COMMON DEF CalcWindowX(WND2,WND)
 IF!CheckWindow(WND)THEN RETURN -1
 IF!CheckWindow(WND2)THEN RETURN -1
 RETURN WIN_AX[WND AND NUWIDMASK]+WIN_FW1[WND AND NUWIDMASK]-WIN_AX[WND2 AND NUWIDMASK]-WIN_FW1[WND2 AND NUWIDMASK]
END
COMMON DEF CalcWindowY(WND2,WND)
 IF!CheckWindow(WND)THEN RETURN -1
 IF!CheckWindow(WND2)THEN RETURN -1
 RETURN WIN_AY[WND AND NUWIDMASK]+WIN_FH1[WND AND NUWIDMASK]-WIN_AY[WND2 AND NUWIDMASK]-WIN_FH1[WND2 AND NUWIDMASK]
END
COMMON DEF GetWindowVar(WND,I)
 RETURN WIN_VAR[WND AND NUWIDMASK,I]
END
COMMON DEF SetWindowVar WND,I,V
 WIN_VAR[WND AND NUWIDMASK,I]=V
END
COMMON DEF GetControl(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 RETURN WIN_CTL[WND AND NUWIDMASK]
END
COMMON DEF IsFocusWindow(WND)
 IF!CheckWindow(WND)THEN RETURN FALSE
 RETURN(WND AND NUWIDMASK)==WIN_ACTIVENUWID
END
DEF OTWHasParentWindowFlag(NUWID,FLG)
 WHILE NUWID
  IF (WIN_STYLE[NUWID]AND FLG)==FLG THEN
   RETURN TRUE
  ENDIF
  NUWID=WIN_PARENT[NUWID]
 WEND
 RETURN FALSE
END
COMMON DEF EnableWindow(WND)
 VAR N=ValidateWND(WND)
 IF!N THEN RETURN WIN_INVALIDID
 WIN_STYLE[N]=WIN_STYLE[N] AND NOT WIN_STYLE_DIS
 RETURN 0
END
COMMON DEF DisableWindow(WND)
 VAR N=ValidateWND(WND)
 IF!N THEN RETURN WIN_INVALIDID
 WIN_STYLE[N]=WIN_STYLE[N] OR WIN_STYLE_DIS
 RETURN 0
END
COMMON DEF IsWindowEnabled(WND)
 VAR N=ValidateWND(WND)
 IF!N THEN RETURN FALSE
 RETURN !OTWHasParentWindowFlag(N,WIN_STYLE_DIS)
END
COMMON DEF SetInputWindow(WND)
 VAR N=ValidateWND(WND)
 IF!N THEN RETURN WIN_INVALIDID
 IF!IsWindowEnabled(WND)THEN
  RETURN WIN_DISABLED
 ENDIF
 VAR OLDI=WIN_INPUTNUWID
 WIN_INPUTNUWID=N
 VAR OLDIW=NUWIDToWND(OLDI)
 VAR E=SendChInputWindow(OLDIW,FALSE,WND)
 E=SendChInputWindow(WND,TRUE,OLDIW)
 E=SendChildWindowEvent(GetParentWindow(WND),WindowInputEvent(),WND)
 E=SendChildWindowEvent(NUWIDToWND(WIN_PARENT[OLDI]),WindowLostInputEvent(),WND)
 RETURN 0
END
COMMON DEF FocusWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF!IsWindowEnabled(WND)THEN
  OTWBeepWindow NUWID
  RETURN WIN_DISABLED
 ENDIF
 VOID SetInputWindow(WND)
 IF WIN_STYLE[NUWID]AND WIN_STYLE_NEVERACTV THEN
  RETURN 0
 ENDIF
 VAR OLD=WIN_ACTIVENUWID
 WIN_ACTIVENUWID=NUWID
 IF OLD==WIN_ACTIVENUWID THEN RETURN 0
 VAR OLDW=NUWIDToWND(OLD)
 IF OLDW&&OLDW==GetCapture() THEN
  VOID ReleaseCapture(OLDW)
 ENDIF
 VAR E=SendChFocusWindow(OLDW,FALSE,WND)
 E=SendChFocusWindow(WND,TRUE,OLDW)

 VAR GRP=GetWindowGroupOwner(WND)
 VAR GRP_OLD=NUWIDToWND(WIN_GPARENT[OLD])
 IF GRP THEN
  VOID SendParentWindowEvent(GRP,WindowGroupActiveEvent(),WND)
 ENDIF
 IF GRP_OLD THEN
  VOID SendParentWindowEvent(GRP_OLD,WindowGroupInactiveEvent(),WND)
 ENDIF
 VOID SendChildWindowEvent(GetParentWindow(WND),WindowActiveEvent(),WND)
 VOID SendChildWindowEvent(NUWIDToWND(WIN_PARENT[OLD]),WindowInactiveEvent(),WND)
 RETURN 0
END
COMMON DEF IsActiveWindow(WND)
 VAR N=(WND AND NUWIDMASK)
 VAR P=WIN_ACTIVENUWID
 WHILE P
  IF P==N THEN RETURN 1
  P=WIN_PARENT[P]
 WEND
 RETURN 0
END
COMMON DEF GetActiveWindow()
 RETURN NUWIDToWND(WIN_ACTIVENUWID)
END
COMMON DEF GetInputWindow()
 RETURN NUWIDToWND(WIN_INPUTNUWID)
END
COMMON DEF SetWindowIMCursor(WND,X,Y)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 WIN_IM[NUWID]=TRUE
 WIN_CURX[NUWID]=X
 WIN_CURY[NUWID]=Y
 RETURN FALSE
END
COMMON DEF GetWindowIMCursor WND OUT X,Y,E
 IF!CheckWindow(WND)THEN
  E=WIN_INVALIDID
  X=0
  Y=0
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 X=WIN_CURX[NUWID]
 Y=WIN_CURY[NUWID]
 E=0
 IF !WIN_IM[NUWID]THEN
  E=TRUE
 ENDIF
END
COMMON DEF SetWindowCursor(WND,IMG)
 VAR NUWID=ValidateWND(WND)
 IF!NUWID THEN RETURN WIN_INVALIDID
 WIN_CURSOR[NUWID]=IMG
 RETURN 0
END
COMMON DEF GetWindowCursor(WND)
 VAR NUWID=ValidateWND(WND)
 IF!NUWID THEN RETURN 0
 RETURN WIN_CURSOR[NUWID]
END
COMMON DEF GetMouseX()
 RETURN OTW_MOUSEX
END
COMMON DEF GetMouseY()
 RETURN OTW_MOUSEY
END
VAR WIN_DRAGHANDLER$
VAR WIN_DRAGHANDLER_A1
VAR WIN_DRAGHANDLER_A2
VAR WIN_DRAGHANDLER_USE
VAR WIN_DRAGHANDLER_WND
VAR WIN_DRG_USE
VAR WIN_DRG_NUSE
DEF SetWindowDragHandler(NAME$,WND,A1,A2)
 IF WIN_DRAGHANDLER_USE&&CheckWindow(WIN_DRAGHANDLER_WND)THEN
  RETURN WIN_DRG_USE
 ENDIF
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 WIN_DRAGHANDLER_USE=TRUE
 WIN_DRAGHANDLER$=NAME$
 WIN_DRAGHANDLER_A1=A1
 WIN_DRAGHANDLER_A2=A2
 WIN_DRAGHANDLER_WND=WND
 RETURN 0
END
DEF ClearWindowDragHandler()
 IF!WIN_DRAGHANDLER_USE THEN RETURN WIN_DRG_NUSE
 WIN_DRAGHANDLER_USE=FALSE
 WIN_DRAGHANDLER$=""
 WIN_DRAGHANDLER_A1=0
 WIN_DRAGHANDLER_A2=0
 WIN_DRAGHANDLER_WND=0
 RETURN 0
END
VAR CAPTURE_WND_FRAME
VAR CAPTURE_WND
COMMON DEF GetCapture OUT WND
 GetCaptureEx OUT WND,
END
COMMON DEF GetCaptureEx OUT WND,FRM
 WND=CAPTURE_WND
 FRM=CAPTURE_WND_FRAME
END
COMMON DEF SetCapture(WND)
 RETURN SetCaptureEx(WND,FALSE)
END
COMMON DEF SetCaptureEx(WND,FRM)
 IF!CheckWindow(WND)THEN RETURN 0
 VAR OLD=CAPTURE_WND
 CAPTURE_WND=WND
 CAPTURE_WND_FRAME=FRM
 RETURN OLD
END
COMMON DEF ReleaseCapture(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 IF CAPTURE_WND!=WND THEN RETURN 0
 CAPTURE_WND=0
 CAPTURE_WND_FRAME=FALSE
 RETURN 1
END
VAR OTW_MOUSECLIPX
VAR OTW_MOUSECLIPY
VAR OTW_MOUSECLIPX2
VAR OTW_MOUSECLIPY2
DEF MouseClip(WND,X,Y,W,H)
 IF !CheckWindow(WND)THEN RETURN WIN_INVALIDID
 OTW_MouseClip GetWindowAX(WND)+X,GetWindowY(WND)+Y,W,H
 RETURN 0
END
DEF OTW_MouseClip X,Y,W,H
 OTW_MOUSECLIPX=X
 OTW_MOUSECLIPY=Y
 OTW_MOUSECLIPX2=W+X
 OTW_MOUSECLIPY2=H+Y
END

DEF MouseClipDef
 OTW_MouseClip 0,0,399,239
END
COMMON DEF GetTextWidth(STR$)
 RETURN LEN(STR$)*8
END
COMMON DEF GetOwnerWindow(WND)
 VAR GO=GetWindowGroupOwner(WND)
 IF GO THEN RETURN GO
 RETURN GetParentWindow(WND)
END
COMMON DEF GetParentWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_PARENT[WND AND NUWIDMASK])
END
COMMON DEF GetChildWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_CHILD[WND AND NUWIDMASK])
END
COMMON DEF GetNextWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_NEXT[WND AND NUWIDMASK])
END
COMMON DEF GetPrevWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_PREV[WND AND NUWIDMASK])
END
COMMON DEF ShowSystemMenu WND,X,Y
 VAR MENU=WINCTL_SYSMENU
 VAR STYLE=GetWindowStyle(WND)
 IF STYLE AND WindowDisableCloseStyle()THEN
  DisableMenuItem MENU,WINCTL_MENU_CLOSE
 ELSE
  EnableMenuItem MENU,WINCTL_MENU_CLOSE
 ENDIF
 IF STYLE AND WindowMaximizedStyle()&&!(STYLE AND WindowDisableMaxStyle())THEN
  EnableMenuItem MENU,WINCTL_MENU_RESTORE
 ELSE
  DisableMenuItem MENU,WINCTL_MENU_RESTORE
 ENDIF
 IF STYLE AND WindowMinMaxStyle()THEN
  IF STYLE AND WindowMaximizedStyle()||STYLE AND WindowDisableMaxStyle() THEN
   DisableMenuItem MENU,WINCTL_MENU_MAXIMIZE
  ELSE
   EnableMenuItem MENU,WINCTL_MENU_MAXIMIZE
  ENDIF
  IF STYLE AND WindowMinimizedStyle()||STYLE AND WindowDisableMinStyle()THEN
   DisableMenuItem MENU,WINCTL_MENU_MINIMIZE
  ELSE
   EnableMenuItem MENU,WINCTL_MENU_MINIMIZE
  ENDIF
 ELSE
  DisableMenuItem MENU,WINCTL_MENU_MAXIMIZE
  DisableMenuItem MENU,WINCTL_MENU_MINIMIZE
 ENDIF
 ShowMenu MENU,WND,X,Y
END
''WINDOW GRAPHIC
VAR GB_WND
VAR WING_SX
VAR WING_SY
COMMON DEF SetWindowDrawPos WND,X,Y
 IF!CheckWindow(WND)THEN RETURN
 VAR NUWID=WND AND NUWIDMASK
 WING_SX=X+WIN_FX[NUWID]
 WING_SY=Y+WIN_FY[NUWID]
END
COMMON DEF GBeginDirect(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 IF WIN_HIDE[WND AND NUWIDMASK]THEN RETURN WIN_NODRAW
 GPAGE OTW_SP,OTW_DDRAWPAGE
 GCLIP 1
 RETURN 0
END
COMMON DEF GetDirectGPAGE WND OUT PAGE1,PAGE2,ERR
 IF!CheckWindow(WND)THEN
  PAGE1=0
  PAGE2=0
  ERR=WIN_INVALIDID
 ENDIF
 ERR=0
 PAGE1=OTW_SP
 PAGE2=OTW_DDRAWPAGE
END
COMMON DEF GEndDirect(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 'VAR NUWID=WND AND NUWIDMASK
 'WIN_BEGIN[NUWID]=TRUE
 'GB_WND=NUWID
 'VAR E=GEndWindow(WND)
 GPAGE OTW_SP,OTW_DP
 GCLIP 1,0,0,399,239
 RETURN 0
END
COMMON DEF GCopyDirect(WND,X1,Y1,X2,Y2,X3,Y3,MODE)
 GPAGE OTW_SP,OTW_BP
 VAR E=GBeginWindow(WND)
 IF E THEN RETURN E
 GCOPY OTW_DDRAWPAGE,X1,Y1,X2,Y2,X3+WING_SX,Y3+WING_SY,MODE
 RETURN 0
END
COMMON DEF CheckGBegin(WND)
 IF!CheckWindow(WND)THEN RETURN FALSE
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_HIDE[NUWID]THEN RETURN FALSE
 RETURN WIN_BEGIN[NUWID]
END
COMMON DEF GBeginWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_HIDE[NUWID]THEN RETURN WIN_NODRAW
 IF WIN_BEGIN[NUWID]==1THEN RETURN WIN_EVENTERR
 IF GB_WND&&GB_WND!=NUWID THEN
  BACKTRACE
  ?"BUGBUG GBegin",GB_WND,WIN_NAME$[GB_WND]
 ENDIF
 VAR AX=WIN_RFX[NUWID]'WIN_FW1[NUWID]
 VAR AY=WIN_RFY[NUWID]'WIN_FH1[NUWID]
 VAR W=WIN_AFW[NUWID]
 VAR H=WIN_AFH[NUWID]
 WING_SX=WIN_FX[NUWID]
 WING_SY=WIN_FY[NUWID]
 IF W<0||H<0THEN RETURN WIN_NODRAW
 GPAGE OTW_SP,OTW_BP
'OTW1C 3.1 の GCLIP BUG の ため
 GCLIP 1,AX,AY,AX+W,AY+H
 IF WIN_BEGIN[NUWID]>=2THEN RETURN 0
 WIN_BEGIN[NUWID]=TRUE
 GB_WND=NUWID
' GCLS
 GFILL AX,AY,AX+W,AY+H,0
 RETURN 0
END
DEF ReGBeginWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 WIN_BEGIN[NUWID]=2
 RETURN GBeginWindow(WND)
END
DEF GBeginFrameWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_BEGIN[NUWID]THEN RETURN WIN_EVENTERR
 WIN_BEGIN[NUWID]=TRUE+TRUE
 IF GB_WND&&GB_WND!=NUWID THEN
  BACKTRACE
  ?"BUGBUG GBegin",GB_WND,WIN_NAME$[GB_WND]
 ENDIF
 VAR AX=WIN_RX[NUWID]
 VAR AY=WIN_RY[NUWID]
 VAR W=WIN_AW[NUWID]'WIN_WIDTH[NUWID]
 VAR H=WIN_AH[NUWID]'WIN_HEIGHT[NUWID]
 WING_SX=WIN_FX[NUWID]
 WING_SY=WIN_FY[NUWID]
 GB_WND=NUWID
 GPAGE OTW_SP,OTW_BP
'OTW1C 3.1 の GCLIP BUG の ため
' GCLIP 1,AX,AY,AX+W,AY+H
' GCLS' WIN_BKGND
 GFILL AX,AY,AX+W,AY+H,0
 RETURN 0
END
DEF GEndWindowSU(WND)
 VAR NUWID=WND AND NUWIDMASK
 WIN_BEGIN[NUWID]=FALSE
 VAR MAP_SY=240
 VAR MAP_SX
 VAR AX=WIN_RX[NUWID]
 VAR AY=WIN_RY[NUWID]
 VAR W=WIN_AW[NUWID]
 VAR H=WIN_AH[NUWID]
 IF WIN_BEGIN[NUWID]!=2THEN
  AX=WIN_RFX[NUWID]
  AY=WIN_RFY[NUWID]
  W=WIN_AFW[NUWID]
  H=WIN_AFH[NUWID]
 ENDIF
 DIM BUFGRP[(W+1)*(H+1)]
 DIM BUFMAP[(W+1)*(H+1)]
 GSAVE AX,AY,W+1,H+1,BUFGRP,1
 GPAGE OTW_SP,OTW_DP
 GSAVE MAP_SX+AX,MAP_SY+AY,W+1,H+1,BUFMAP,1
 ARYOP #AOPSUB,BUFMAP,BUFMAP,NUWID-1
 ARYOP #AOPCLP,BUFMAP,BUFMAP,0,2'2=>ぐうすう=>とうめい
 ARYOP #AOPMUL,BUFGRP,BUFGRP,BUFMAP
 GLOAD AX,AY,W+1,H+1,BUFGRP,1,0
 IF WIN_SP[NUWID]AND 512THEN OTW_SPCHR NUWID
 IF MAINCNT-OTW_LASTUPD>5THEN UpdateMouse
 RETURN 0
END
COMMON DEF DisableWindowClipping(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 WIN_STYLE[WND AND NUWIDMASK]=WIN_STYLE[WND AND NUWIDMASK] OR WIN_STYLE_NCLIP
 RETURN 0
END
COMMON DEF EnableWindowClipping(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 WIN_STYLE[WND AND NUWIDMASK]=WIN_STYLE[WND AND NUWIDMASK] AND NOT WIN_STYLE_NCLIP
 RETURN 0
END
COMMON DEF GEndWindow(WND)
 RETURN GEndWindowEx(WND,TRUE)
END
COMMON DEF GEndWindowEx(WND,CWCF)
 UpdateMouse
 GB_WND=0
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_HIDE[NUWID]THEN RETURN WIN_NODRAW
 IF!WIN_BEGIN[NUWID]THEN RETURN WIN_EVENTERR
 IF OTW_CLIPMODE THEN
  RETURN GEndWindowSU(WND)
 ENDIF
 'ごうせい
 WIN_PARENT[0]=0
 WIN_NEXT[0]=0
 VAR AX=WIN_RX[NUWID]
 VAR AY=WIN_RY[NUWID]
 VAR W=WIN_AW[NUWID]
 VAR H=WIN_AH[NUWID]
 IF WIN_BEGIN[NUWID]!=2THEN
  AX=WIN_RFX[NUWID]
  AY=WIN_RFY[NUWID]
  W=WIN_AFW[NUWID]
  H=WIN_AFH[NUWID]
 ENDIF
 WIN_BEGIN[NUWID]=FALSE
 GCLIP 1,AX,AY,AX+W,AY+H
 VAR PNUWID
 IF CWCF&&WIN_CHILD[NUWID]THEN
  PNUWID=WIN_CHILD[NUWID]
  VAR W2=W,H2=H
  IF W==WIN_WIDTH[NUWID]THEN DEC W,WIN_FW2[NUWID]-WIN_FW1[NUWID]
 IF H==WIN_HEIGHT[NUWID]THEN DEC H,WIN_FH2[NUWID]-WIN_FH1[NUWID]
  GCLIP 1,AX,AY,AX+W,AY+H
  WHILE PNUWID
   IF!WIN_HIDE[PNUWID]THEN GCOPY OTW_DP,WIN_RX[PNUWID],WIN_RY[PNUWID],WIN_RX[PNUWID]+WIN_AW[PNUWID],WIN_RY[PNUWID]+WIN_AH[PNUWID],WIN_RX[PNUWID],WIN_RY[PNUWID],0

   PNUWID=WIN_NEXT[PNUWID]
  WEND
  W=W2
  H=H2
  GCLIP 1,AX,AY,AX+W,AY+H
 ENDIF
 VAR _NUWID=NUWID
 PNUWID=WIN_NEXT[NUWID]
 IF WIN_STYLE[NUWID]AND WIN_STYLE_NCLIP THEN
  PNUWID=WIN_PARENT[_NUWID]
  _NUWID=PNUWID
  PNUWID=WIN_NEXT[PNUWID]
 ENDIF
 WHILE TRUE
  IF!PNUWID THEN
   PNUWID=WIN_PARENT[_NUWID]
   IF!PNUWID THEN BREAK
   _NUWID=PNUWID
   PNUWID=WIN_NEXT[PNUWID]
   CONTINUE
  ENDIF
   IF!WIN_HIDE[PNUWID]THEN GCOPY OTW_DP,WIN_RX[PNUWID],WIN_RY[PNUWID],WIN_RX[PNUWID]+WIN_AW[PNUWID],WIN_RY[PNUWID]+WIN_AH[PNUWID],WIN_RX[PNUWID],WIN_RY[PNUWID],0
  _NUWID=PNUWID
  PNUWID=WIN_NEXT[PNUWID]
 WEND
 'VAR OBP
 'GPAGE OUT ,OBP
 GPAGE OTW_SP,OTW_DP
 GCLIP 1,0,0,399,239
 GCOPY OTW_BP,AX,AY,AX+W,AY+H,AX,AY,0
 IF WIN_SP[NUWID]AND 512THEN OTW_SPCHR NUWID
 IF MAINCNT-OTW_LASTUPD>5THEN UpdateMouse
 RETURN 0
END
DEF OTW_SPCHR NUWID
 VAR SP=WIN_SP[NUWID]AND 511
 IF OTW_ENABLE_SHADOW THEN
  VAR SP2=SPVAR(SP,1)
  IF SP2!=-1THEN
   SPSCALE SP2,WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
   IF!WIN_HIDE[NUWID]THEN
    SPSHOW SP2
   ENDIF
  ENDIF
 ENDIF
 SPSCALE SP,1,1
 SPCHR SP,WIN_RX[NUWID],WIN_RY[NUWID],WIN_AW[NUWID]+1,WIN_AH[NUWID]+1,1
 SPOFS SP,WIN_RX[NUWID],WIN_RY[NUWID]
END
DEF OTW_SPSHOW NUWID
 VAR SP=WIN_SP[NUWID]AND 511
 IF OTW_ENABLE_SHADOW THEN
  VAR SP2=SPVAR(SP,1)
  IF SP2!=-1THEN
   SPSHOW SP2
  ENDIF
 ENDIF
 SPSHOW SP
END
DEF OTW_SPHIDE NUWID
 VAR SP=WIN_SP[NUWID]AND 511
 IF OTW_ENABLE_SHADOW THEN
  VAR SP2=SPVAR(SP,1)
  IF SP2!=-1THEN SPHIDE SP2
 ENDIF
 SPHIDE SP
END
COMMON DEF SetSysWindowProperty WND,P$,V OUT E
 IF!CheckWindow(WND)THEN
  E=WIN_INVALIDID
  RETURN
 ENDIF
 E=0
 VAR NUWID=WND AND NUWIDMASK
 IF P$=="SHADOW"THEN
  IF!OTW_ENABLE_SHADOW THEN RETURN
  VAR SP=WIN_SP[NUWID]AND 511
  IF!SP THEN RETURN
  VAR SP2=SPVAR(SP,1)
  IF V&&SP2 THEN RETURN
  IF V THEN
   SPSET 2,511,0 OUT SP2
   SPVAR SP,1,SP2
   OTW_SPCHR NUWID
   RETURN
  ENDIF
  IF!SP2||SP2==-1 THEN RETURN
  SPCLR SP2
  SPVAR SP,1,-1
  RETURN
 ENDIF
END
COMMON DEF __GPSETWindow__ WND,X,Y,COL
 GPAGE OTW_SP,OTW_DP
 VAR AX=WIN_FX[WND AND NUWIDMASK]+X
 VAR AY=WIN_FY[WND AND NUWIDMASK]+Y
 GCLIP 1
 IF RGBToShort(GSPOIT(AX,AY+240))==(WND AND NUWIDMASK)THEN
  GPSET AX,AY,COL
 ENDIF
END
COMMON DEF GPSETWindow WND,X,Y,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GPSET X+AX,Y+AY,COL
END
COMMON DEF GCLSWindow WND,COL
 GCLS COL
END
COMMON DEF GFILLWindow WND,X,Y,X2,Y2,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GFILL X+AX,Y+AY,X2+AX,Y2+AY,COL
END
COMMON DEF GBOXWindow WND,X,Y,X2,Y2,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GBOX X+AX,Y+AY,X2+AX,Y2+AY,COL
END
COMMON DEF GLINEWindow WND,X,Y,X2,Y2,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GLINE X+AX,Y+AY,X2+AX,Y2+AY,COL
END
COMMON DEF GCIRCLEWindow WND,X,Y,R,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GCIRCLE X+AX,Y+AY,R,COL
END
COMMON DEF GCIRCLE2Window WND,X,Y,R,S,E,F,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GCIRCLE X+AX,Y+AY,R,S,E,F,COL
END
COMMON DEF GTRIWindow WND,X,Y,X2,Y2,X3,Y3,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GTRI X+AX,Y+AY,X2+AX,Y2+AY,X3+AX,Y3+AY,COL
END
COMMON DEF GLOADWindow WND,X,Y,W,H,IMG[],FLG,MODE
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GLOAD X+AX,Y+AY,W,H,IMG,FLG,MODE
END
COMMON DEF GLOADImageWindow WND,X,Y,IMG,F
 GLOADImage X+WING_SX,Y+WING_SY,IMG,F
END
COMMON DEF GLOADImagePaletteWindow WND,X,Y,IMG,PAL,F
 GLOADImagePalette X+WING_SX,Y+WING_SY,IMG,PAL,F
END

COMMON DEF _GSAVEImage IMG,WND,X,Y,W,H,IX,IY
 IF (WND AND NUWIDMASK)==GB_WND THEN RETURN
 IF!CheckImage(IMG)THEN RETURN
 VAR PTR=IMAGE_PTR[IMG AND 4095]+IX*IY
 DIM I[W*H]
 ReadArray PTR,I,0,W*H
 VAR AX=WIN_FX[WND AND NUWIDMASK]
 VAR AY=WIN_FY[WND AND NUWIDMASK]
 GSAVE AX+X,AY+Y,W,H,I,1
 WriteArray PTR,I,0,W*H
END
COMMON DEF GPRINTWindowCC WND,X,Y,STR$,PAL
 GPRINTWindow WND,X,Y,STR$,OTW_CONSOLEPAL[PAL]
END
COMMON DEF GetConsolePalette(PAL)
 RETURN OTW_CONSOLEPAL[PAL]
END
COMMON DEF GLINEArrayMemory PTR,W,H,X,Y,X2,Y2,COL
 COL=RGBToShort(COL)
 IF 0THEN DIM M[0]
 M=GetRawMemory()
 VAR I
 VAR DX=ABS(X2-X)
 VAR DY=ABS(Y2-Y)
 VAR SX,SY
 IF X<X2 THEN SX=1 ELSE SX=-1
 IF Y<Y2 THEN SY=1 ELSE SY=-1
 VAR ERR=DX-DY
 VAR E2
 WHILE 1
  IF X<W&&Y<H&&X>=0&&Y>=0THEN M[PTR+X+Y*W]=COL
  IF X==X2&&Y==Y2 THEN RETURN
  E2=2*ERR
  IF E2>-DY THEN
   DEC ERR,DY
   INC X,SX
  ENDIF
  IF E2<DX THEN
   INC ERR,DX
   INC Y,SY
  ENDIF
 WEND
END
COMMON DEF GLINEArray M,W,H,X,Y,X2,Y2,COL
 COL=RGBToShort(COL)
 VAR I
 VAR DX=ABS(X2-X)
 VAR DY=ABS(Y2-Y)
 VAR SX,SY
 IF X<X2 THEN SX=1 ELSE SX=-1
 IF Y<Y2 THEN SY=1 ELSE SY=-1
 VAR ERR=DX-DY
 VAR E2
 WHILE 1
  IF X<W&&Y<H&&X>=0&&Y>=0THEN M[X+Y*W]=COL
  IF X==X2&&Y==Y2 THEN RETURN
  E2=2*ERR
  IF E2>-DY THEN
   DEC ERR,DY
   INC X,SX
  ENDIF
  IF E2<DX THEN
   INC ERR,DX
   INC Y,SY
  ENDIF
 WEND
END
COMMON DEF GPRINTPWindow WND,X,Y,STR$,COL
 INC X,WING_SX'WIN_FX[WND AND NUWIDMASK]
 INC Y,WING_SY'WIN_FY[WND AND NUWIDMASK]
 IF COL>=0THEN RETURN
 GPRINTP X,Y,STR$,COL
 RETURN
 VAR I
 FOR I=0TO LEN(STR$)-1
  VAR S=ASC(STR$[I])
  GPUTCHR X,Y,S,1,1,COL
  IF S<128THEN X=X+6 ELSE X=X+8
  
 NEXT
 RETURN
END
COMMON DEF GPRINTWindow WND,X,Y,STR$,COL
 INC X,WING_SX'WIN_FX[WND AND NUWIDMASK]
 INC Y,WING_SY'WIN_FY[WND AND NUWIDMASK]
 IF COL AND&HFF000000THEN
  GPUTCHR X,Y,STR$,1,1,COL
 ENDIF
 RETURN
'3.0.x
 VAR L=LEN(STR$)-1,A,I
 FOR I=0TO L
  A=ASC(STR$[I])
  IF A==10THEN Y=Y+8:X=0:CONTINUE
  GPUTCHRWindow WND,X,Y,A,COL
  INC X,8
 NEXT
END
'3x slower
COMMON DEF GPRINTP X,Y,STR$,COL
 VAR L=LEN(STR$),A,I
 WHILE I!=L
  A=ASC(STR$[I])
  GPUTCHR X,Y,A,COL
  IF A>127 THEN
   X=X+8
  ELSE
   X=X+6
  ENDIF
  I=I+1
 WEND
END
COMMON DEF GPRINTBWindow WND,X,Y,STR$,COL,BC
 INC X,WING_SX'WIN_FX[WND AND NUWIDMASK]
 INC Y,WING_SY'WIN_FY[WND AND NUWIDMASK]
 IF BC AND&HFF000000THEN
  GFILL X,Y,X+LEN(STR$)*8-1,Y+7,BC
 ENDIF
 IF COL AND&HFF000000THEN
  GPUTCHR X,Y,STR$,1,1,COL
 ENDIF
 RETURN
'3.0.x
 VAR L=LEN(STR$)-1,A,I
 FOR I=0TO L
  A=ASC(STR$[I])
  IF A==10THEN Y=Y+8:X=0:CONTINUE
  GPUTCHRBWindow WND,X,Y,A,COL,BC
  INC X,8
 NEXT
END
DIM OTW_FNTTMP[0]
COMMON DEF GPUTCHRWindow WND,X,Y,A,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 X=X+AX:Y=Y+AY
 GPUTCHR X,Y,CHR$(A),1,1,COL
 RETURN
'3.0.x
 OTW_FNTPAL[0]=0
 OTW_FNTPAL[1]=COL
 COPY OTW_FNTTMP,0,OTW_FNT,64*OTW_FNTTBL[A],64
 VAR I
 GLOAD X,Y,8,8,OTW_FNTTMP,OTW_FNTPAL,0
END
COMMON DEF GPUTCHRSizeWindow WND,X,Y,A,SX,SY,COL
 GPUTCHR X+WING_SX,Y+WING_SY,CHR$(A),SX,SY,COL
END
COMMON DEF GPUTCHRSize1Window WND,X,Y,A,S,COL
 GPUTCHR X+WING_SX,Y+WING_SY,CHR$(A),S,S,COL
END
COMMON DEF GPUTCHRBWindow WND,X,Y,A,COL,BC
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 X=X+AX:Y=Y+AY
 IF BC AND&HFF000000THEN
  GFILL X,Y,X+7,Y+7,BC
 ENDIF
 GPUTCHR X,Y,CHR$(A),1,1,COL
 RETURN
'3.0.x
 OTW_FNTPAL[0]=BC
 OTW_FNTPAL[1]=COL
 COPY OTW_FNTTMP,0,OTW_FNT,64*OTW_FNTTBL[A],64
 VAR I
 GLOAD X,Y,8,8,OTW_FNTTMP,OTW_FNTPAL,0
END
DEF GetGAreaWindow WND OUT X,Y,W,H,E
 VAR NUWID=ValidateWND(WND)
 X=0Y=0W=0H=0
 IF !NUWID THEN
  E=WIN_INVALIDID
  RETURN
 ENDIF
 IF WIN_BEGIN[NUWID]==1 THEN
  X=WIN_RFX[NUWID]
  Y=WIN_RFY[NUWID]
  W=WIN_AFW[NUWID]
  H=WIN_AFH[NUWID]
 ELSEIF WIN_BEGIN[NUWID]==2 THEN'FRAME
  X=WIN_RX[NUWID]
  Y=WIN_RY[NUWID]
  W=WIN_AW[NUWID]
  H=WIN_AH[NUWID]
 ELSE
  E=WIN_EVENTERR
  RETURN
 ENDIF
 E=0
END
COMMON DEF ClearGCLIPWindow WND
 VAR NUWID=WND AND NUWIDMASK,AX,AY,W,H,E
 GetGAreaWindow WND OUT AX,AY,W,H,E
 GCLIP 1,AX,AY,AX+W,AY+H
END
COMMON DEF GCLIPWindow WND,X1,Y1,X2,Y2
 VAR NUWID=WND AND NUWIDMASK,AX,AY,W,H,E
 GetGAreaWindow WND OUT AX,AY,W,H,E
 IF E THEN RETURN
 IF X1>X2 THEN SWAP X1,X2
 IF Y1>Y2 THEN SWAP Y1,Y2
 GCLIP 1,MIN(MAX(AX,WING_SX+X1),AX+W),MIN(MAX(AY,WING_SY+Y1),AY+H),MIN(MAX(AX,WING_SX+X2),AX+W),MIN(MAX(AY,WING_SY+Y2),AY+H)
END

COMMON DEF GetBackColor()
 RETURN WIN_BKGND
END
COMMON DEF GetSelectionColor()
 RETURN WIN_SELCOL
END
COMMON DEF GetSelectionTextColor()
 RETURN WIN_SELTXTCOL
END
COMMON DEF GetWorkspaceColor()
 RETURN WIN_WORKSPACECOL
END
DEF DesktopPainter WND,CTL,TYPE,A1,A2
RETURN
 VAR E=GBEGINWindow(WND)
 IF E THEN RETURN
 GCLSWindow WND,RGB(0,128,128)
 GFILLWindow WND,0,0,32,32,RGB(255,0,0)
 E=GENDWindow(WND)
END
DEF CalcWindowBorderSize WND,STYLE OUT W1,H1,W2,H2
 'HAS EDGE
 IF STYLE AND WindowMaximizedStyle() THEN
  H1=0
  W1=0
  H2=0
  W2=0
  RETURN
 ENDIF
 IF STYLE AND 2THEN
  H1=3
  W1=3
  H2=3
  W2=3
 ELSE
  H1=1
  W1=1
  H2=1
  W2=1
 ENDIF
END
DEF CalcWindowCaptionHeight WND,STYLE OUT H
 IF STYLE AND WIN_STYLE_NARROW THEN
  H=WINCTL_NARROW_CAPCY
 ELSE
  H=WINCTL_CAPCY
 ENDIF
END
DEF WindowQueryFrame WND,CTL,TYPE,STYLE,ZERO OUT W1,H1,W2,H2
 CalcWindowBorderSize WND,STYLE OUT W1,H1,W2,H2
 VAR CH
 CalcWindowCaptionHeight WND,STYLE OUT CH
 INC H1,CH
 IF STYLE AND 1THEN
  INC H1,WINCTL_MENUCY
 ENDIF
END
DEF WindowPainter WND,CTL,TYPE,A1,A2
 WindowFramePainter WND,CTL,TYPE,A1,A2
 VAR E=ReGBeginWindow(WND)
 IF!E THEN
  GCLSWindow WND,WIN_BACKGND[WND AND NUWIDMASK]
 ENDIF
END
'WINDOW EDGE
'GGGGGGGGGGGGB
'GWWWWWWWWWWgB
'GWGGGGGGGGGgB
'GWG       GgB
'GWG       GgB
'GWG       GgB
'GWG       GgB
'GWG       GgB
'GWGGGGGGGGGgB
'GgggggggggggB
'BBBBBBBBBBBBB
DEF WindowFrame_PtInBox(X,Y,X1,Y1,X2,Y2)
 RETURN X1<=X&&X2>=X&&Y1<=Y&&Y2>=Y
END
DEF WindowFramePainterDrawFrame WND,X1,Y1,X2,Y2,EDGE
 VAR G1=RGB(192,192,192)
 VAR G2=RGB(136,136,136)
 VAR W=RGB(255,255,255)
 IF EDGE THEN
  GBOXWindow WND,X1+2,Y1+2,X2-2,Y2-2,G1
  GBOXWindow WND,X1+1,Y1+1,X2-1,Y2-1,G2
  GLINEWindow WND,X1+1,Y1+1,X2-2,Y1+1,W
  GLINEWindow WND,X1+1,Y1+1,X1+1,Y2-2,W
  GBOXWindow WND,X1,Y1,X2,Y2,#BLACK
  GLINEWindow WND,X1,Y1,X1,Y2-1,G1
  GLINEWindow WND,X1,Y1,X2-1,Y1,G1
 ELSE
  GBOXWindow WND,X1,Y1,X2,Y2,#BLACK
 ENDIF
END
DEF NEW_WINDOW_FRAME_PAINTER WND,DRW,MX,MY,FLG,BGN OUT HIT,BGNED
 HIT=0
 BGNED=BGN
 VAR LCLK=FLG AND CTL_BTNDWNFLG
 VAR ACTV=IsActiveWindow(WND)
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR STYLE=GetWindowStyle(WND)
 VAR CAPW,CAPF
 VAR FW1,FH1,FW2,FH2
 GetWindowFrameSize WND OUT FW1,FH1,FW2,FH2,
 MX=MX-FW1
 MY=MY-FH1
 VAR HASBORDER=!(STYLE AND WindowMaximizedStyle())
 VAR RESIZ=STYLE AND WindowResizableStyle()
 'DRAW BORDER
 IF HASBORDER THEN
  VAR BW1,BH1,BW2,BH2
  VAR BX1=-FW1,BY1=-FH1,BX2=W+FW2,BY2=H+FH2
  CalcWindowBorderSize WND,STYLE OUT BW1,BH1,BW2,BH2
  VAR EDGE=BW1>1
  IF DRW AND WINCTL_DRW_BORDER THEN
   IF !BGNED THEN
    VOID GBeginFrameWindow(WND):BGNED=TRUE
   ENDIF
   WindowFramePainterDrawFrame WND,BX1,BY1,BX2,BY2,EDGE
  ENDIF
  IF!RESIZ THEN @NO_RESIZ
  IF WindowFrame_PtInBox(MX,MY,BX1,BY1,BX1+BW1-1,BY2)THEN
   HIT=WINCTL_HIT_B4
  ENDIF
  IF WindowFrame_PtInBox(MX,MY,BX2-BW2+1,BY1,BX2,BY2)THEN
   HIT=WINCTL_HIT_B5
  ENDIF
  IF WindowFrame_PtInBox(MX,MY,BX1,BY1,BX2,BY1+BH1-1)THEN
   HIT=WINCTL_HIT_B2
  ENDIF
  IF WindowFrame_PtInBox(MX,MY,BX1,BY2-BH2+1,BX2,BY2)THEN
   HIT=WINCTL_HIT_B7
  ENDIF

  VAR BOTH_SIZE=8
  IF HIT>=WINCTL_HIT_B1&&HIT<=WINCTL_HIT_B8 THEN
   IF WindowFrame_PtInBox(MX,MY,BX1,BY1,BX1+BOTH_SIZE,BY1+BOTH_SIZE)THEN
    HIT=WINCTL_HIT_B1
   ENDIF
   IF WindowFrame_PtInBox(MX,MY,BX2-BOTH_SIZE,BY1,BX2,BY1+BOTH_SIZE)THEN
    HIT=WINCTL_HIT_B3
   ENDIF
   IF WindowFrame_PtInBox(MX,MY,BX1,BY2-BOTH_SIZE,BX1+BOTH_SIZE,BY2)THEN
    HIT=WINCTL_HIT_B6
   ENDIF
   IF WindowFrame_PtInBox(MX,MY,BX2-BOTH_SIZE,BY2-BOTH_SIZE,BX2,BY2)THEN
    HIT=WINCTL_HIT_B8
   ENDIF
  ENDIF
  @NO_RESIZ
 ELSE
 ENDIF

 'DRAW CAPTION
 VAR CH
 VAR NRRW=STYLE AND WindowNarrowStyle()
 CalcWindowCaptionHeight WND,STYLE OUT CH
 VAR CAPTX1=-FW1+BW1
 VAR CAPTY1=-FH1+BH1
 VAR CAPTX2=W+FW2-BW2
 VAR CAPTY2=-FH1+BH1+CH-1
 IF WindowFrame_PtInBox(MX,MY,CAPTX1,CAPTY1,CAPTX2,CAPTY2)THEN
  HIT=WINCTL_HIT_CAP
 ENDIF
 IF WindowFrame_PtInBox(MX,MY,CAPTX1,CAPTY1,CAPTX1+WINCTL_CAPICON_WIDTH,CAPTY2)THEN
  HIT=WINCTL_HIT_CAPICON
 ENDIF

 VAR G1=WIN_BKGND
 IF DRW AND WINCTL_DRW_CAP THEN
  VAR OLDCAP=GetProp(WND,"WCAP")
  IF !BGN&&OLDCAP-1==ACTV THEN
   DRW=DRW AND NOT WINCTL_DRW_CAP
  ELSE
   SetProp WND,"WCAP",ACTV+1
   IF !BGNED THEN
    VOID GBeginFrameWindow(WND):BGNED=TRUE
   ENDIF
   VAR CAPCOL
   IF ACTV THEN
    CAPCOL=WIN_ACTVCAPCOL
   ELSE
    CAPCOL=WIN_INACTVCAPCOL
   ENDIF
   GFILLWindow WND,CAPTX1,CAPTY1,CAPTX2,CAPTY2,CAPCOL
   IF EDGE||!HASBORDER THEN
    GLINEWindow WND,CAPTX1,CAPTY2,CAPTX2,CAPTY2,G1
   ELSE
    GLINEWindow WND,CAPTX1,CAPTY2,CAPTX2,CAPTY2,#BLACK
   ENDIF
  ENDIF
 ENDIF
 'DRAW BUTTON
 VAR BW=9
 VAR BH=8
 '_[MARGIN12][MARGIN1]X[MARGIN0]
 VAR MARGIN0=0
 VAR MARGIN1=1
 VAR MARGIN2=0
 BX1=CAPTX2-BW-MARGIN0
 BY1=CAPTY1'+1
 BX2=CAPTX2-MARGIN0
 BY2=BY1+BH
 VAR CAPTX2_NOBTN=CAPTX2-1
 VAR PSH
 VAR HASMINMAX=STYLE AND WindowMinMaxStyle()
 VAR DCLS=STYLE AND WindowDisableCloseStyle()
 IF!NRRW THEN
  PSH=0
  DEC CAPTX2_NOBTN,BW
  IF HASMINMAX THEN
   DEC CAPTX2_NOBTN,(BW+1)*2+MARGIN0+MARGIN1+MARGIN2
  ENDIF
  VAR BCOL1=#WHITE
  VAR BCOL2=#BLACK,BCOL3
  IF DRW AND WINCTL_DRW_CAP THEN
   VAR CAPT
   IF ACTV THEN
    CAPT=WIN_ACTVCAPTXTCOL
   ELSE
    CAPT=WIN_INACTVCAPTXTCOL
   ENDIF
   GCLIPWindow WND,CAPTX1,CAPTY1+1,CAPTX2_NOBTN-1,CAPTY2
   GPRINTWindow WND,CAPTX1,CAPTY1+1,GetWindowName$(WND),CAPT
   ClearGCLIPWindow WND
  ENDIF
  IF WindowFrame_PtInBox(MX,MY,BX1,BY1,BX2,BY2)THEN
   IF DCLS THEN
    HIT=0
   ELSE
    HIT=WINCTL_HIT_CLS
    PSH=LCLK
   ENDIF
  ENDIF
  IF PSH||(DRW AND WINCTL_DRW_CAP)THEN
   IF PSH THEN
    SWAP BCOL1,BCOL2
   ENDIF
   IF !BGNED THEN
    VOID GBeginFrameWindow(WND)
    BGNED=TRUE
   ENDIF
   'x button
   GFILLWindow WND,BX1+1,BY1+1,BX2-1,BY2-1,G1
   INC BX1,PSH:INC BY1,PSH:INC BX2,PSH:INC BY2,PSH
   BCOL3=#BLACK
   IF DCLS THEN BCOL3=RGB(152,152,152)
   '
   GLINEWindow WND,BX1+1,BY1+1,BX2-3,BY2-2,BCOL3
   GLINEWindow WND,BX1+2,BY1+1,BX2-2,BY2-2,BCOL3
   '/
   GLINEWindow WND,BX2-3,BY1+1,BX1+1,BY2-2,BCOL3
   GLINEWindow WND,BX2-2,BY1+1,BX1+2,BY2-2,BCOL3
   DEC BX1,PSH:DEC BY1,PSH:DEC BX2,PSH:DEC BY2,PSH
   GBOXWindow WND,BX1,BY1,BX2,BY2,BCOL2
   GLINEWindow WND,BX1,BY1,BX1,BY2-1,BCOL1
   GLINEWindow WND,BX1,BY1,BX2-1,BY1,BCOL1
  ENDIF

  IF HASMINMAX THEN
   VAR DMIN=STYLE AND WindowDisableMinStyle()
   VAR DMAX=STYLE AND WindowDisableMaxStyle()
   'max
   BX1=BX1-BW-MARGIN1-1
   BX2=BX2-BW-MARGIN1-1
   PSH=0
   IF WindowFrame_PtInBox(MX,MY,BX1,BY1,BX2,BY2)THEN
    IF DMAX THEN
     HIT=0
    ELSE
     HIT=WINCTL_HIT_MAX
     PSH=LCLK
    ENDIF
   ENDIF
   IF (DRW AND WINCTL_DRW_CAP)||PSH THEN
    BCOL1=#WHITE
    BCOL2=#BLACK
    IF PSH THEN
     SWAP BCOL1,BCOL2
    ENDIF
    IF !BGNED THEN
     VOID GBeginFrameWindow(WND)
     BGNED=TRUE
    ENDIF
    GFILLWindow WND,BX1+1,BY1+1,BX2-1,BY2-1,G1
    INC BX1,PSH:INC BY1,PSH:INC BX2,PSH:INC BY2,PSH
    BCOL3=#BLACK
    IF DMAX THEN BCOL3=RGB(152,152,152)
    IF STYLE AND WindowMaximizedStyle()THEN
     GBOXWindow WND,BX1+3,BY1+1,BX1+7,BY1+5,BCOL3
     GFILLWindow WND,BX1+2,BY1+4,BX1+4,BY1+6,G1
     GBOXWindow WND,BX1+1,BY1+3,BX1+5,BY1+7,BCOL3
    ELSE
     GBOXWindow WND,BX1+1,BY1+1,BX2-2,BY2-2,BCOL3
     GLINEWindow WND,BX1+1,BY1+2,BX2-2,BY1+2,BCOL3
    ENDIF
    DEC BX1,PSH:DEC BY1,PSH:DEC BX2,PSH:DEC BY2,PSH
    GBOXWindow WND,BX1,BY1,BX2,BY2,BCOL2
    GLINEWindow WND,BX1,BY1,BX1,BY2-1,BCOL1
    GLINEWindow WND,BX1,BY1,BX2-1,BY1,BCOL1
   ENDIF
   'min
   BX1=BX1-BW-MARGIN2-1
   BX2=BX2-BW-MARGIN2-1
   PSH=0
   IF WindowFrame_PtInBox(MX,MY,BX1,BY1,BX2,BY2)THEN
    IF DMIN THEN
     HIT=0
    ELSE
     HIT=WINCTL_HIT_MIN
     PSH=LCLK
    ENDIF
   ENDIF
   IF (DRW AND WINCTL_DRW_CAP)||PSH THEN
    BCOL1=#WHITE
    BCOL2=#BLACK
    IF PSH THEN
     SWAP BCOL1,BCOL2
    ENDIF
    IF !BGNED THEN
     VOID GBeginFrameWindow(WND)
     BGNED=TRUE
    ENDIF
    GFILLWindow WND,BX1+1,BY1+1,BX2-1,BY2-1,G1
    INC BX1,PSH:INC BY1,PSH:INC BX2,PSH:INC BY2,PSH
    BCOL3=#BLACK
    IF DMIN THEN BCOL3=RGB(152,152,152)
    GLINEWindow WND,BX1+2,BY2-2,BX2-2,BY2-2,BCOL3
    DEC BX1,PSH:DEC BY1,PSH:DEC BX2,PSH:DEC BY2,PSH
    GBOXWindow WND,BX1,BY1,BX2,BY2,BCOL2
    GLINEWindow WND,BX1,BY1,BX1,BY2-1,BCOL1
    GLINEWindow WND,BX1,BY1,BX2-1,BY1,BCOL1
   ENDIF
  ENDIF
 ENDIF
 'DRAW MENU
 IF STYLE AND WindowMenuStyle()THEN
  VAR WMENUSEL=GetProp(WND,"WMENUSEL")
  VAR CMENU=GetMenuFromWindow(GetInputWindow())
  VAR MENUSHOW=IsChildWindow(WND,GetMenuOwner(CMENU))
  IF MENUSHOW THEN
   MENUSHOW=GetMenuType(CMENU)==MENU_TYPE_BAR
   IF !MENUSHOW&&!BGNED THEN
    RETURN
   ENDIF
  ENDIF
  VAR DESELECT
  VAR MENU=GetWindowMenu(WND)
  ACTV=1
  VAR WMENUSEL_NEW
  IF (DRW AND WINCTL_DRW_MENU)&&!BGNED THEN
   VOID GBeginFrameWindow(WND):BGNED=TRUE
  ENDIF
  WindowFrameDrawMenuBar WND,WMENUSEL,CAPTY2,MX,MY,DRW AND WINCTL_DRW_MENU,MENUSHOW,LCLK OUT WMENUSEL_NEW
  IF (DESELECT||ACTV)&&(WMENUSEL_NEW!=WMENUSEL||(WMENUSEL_NEW&&LCLK)) THEN
   SetProp WND,"WMENUSEL",WMENUSEL_NEW
   IF !BGNED THEN
    VOID GBeginFrameWindow(WND)
    BGNED=TRUE
   ENDIF
   WindowFrameDrawMenuBar WND,WMENUSEL_NEW,CAPTY2,MX,MY,TRUE,FALSE,MENUSHOW OUT WMENUSEL_NEW
  ENDIF
 ENDIF
END
DEF WindowFrameDrawMenuBar WND,WMENUSEL,CAPTY2,MX,MY,DRW,CLK,MENUSHOW OUT WMENUSEL_NEW
 WMENUSEL_NEW=0
 VAR W=GetWindowWidth(WND)
 VAR G1=GetBackColor()
 VAR I
 VAR MENUC
 VAR MENU=GetWindowMenu(WND)
 VAR STR$,E
 VAR MENUY=CAPTY2+1
 VAR MENUX=0
 VAR MENU_MARGIN=4
 IF DRW THEN
  GCLIPWindow WND,MENUX,MENUY,MENUX+W,MENUY+WINCTL_MENUCY-1
  GFILLWindow WND,MENUX,MENUY,MENUX+W,MENUY+WINCTL_MENUCY-1,G1
 ENDIF
 WHILE 1
  INC I
  VAR CHILD
  EnumerateMenu MENU,MENUC OUT STR$,MENUC,CHILD,E
  IF!MENUC THEN BREAK
  VAR ITEMW=LEN(STR$)*8+MENU_MARGIN
  VAR PSH=0
  IF WindowFrame_PtInBox(MX,MY,MENUX,MENUY,MENUX+ITEMW-1,MENUY+WINCTL_MENUCY-1)THEN
   WMENUSEL_NEW=I
   IF (MENUSHOW||CLK) THEN
    IF !IsMenuShown(CHILD)THEN
     SetMenuType CHILD,MENU_TYPE_BAR
     ShowMenuEx CHILD,WND,MENUX,MENUY+WINCTL_MENUCY,MENUX,MENUY
    ENDIF
   ENDIF
  ENDIF
  IF DRW THEN
   PSH=IsMenuShown(CHILD)&&GetMenuType(CHILD)==MENU_TYPE_BAR
   VAR TCOL=#BLACK
   GPRINTWindow WND,MENUX+MENU_MARGIN DIV 2+PSH,MENUY+1+PSH,STR$,TCOL
   IF WMENUSEL==I||PSH THEN
    VAR MENUY2=MENUY+WINCTL_MENUCY-1
    VAR MENUX2=MENUX+ITEMW-1
    VAR COL1=#WHITE
    VAR COL2=RGB(136,136,136)
    IF PSH THEN SWAP COL1,COL2
    GBOXWindow WND,MENUX,MENUY,MENUX2,MENUY2,COL1
    GLINEWindow WND,MENUX,MENUY2,MENUX2,MENUY2,COL2
    GLINEWindow WND,MENUX2,MENUY,MENUX2,MENUY2,COL2
   ENDIF
  ENDIF
  MENUX=MENUX+ITEMW
 WEND
 IF DRW THEN
  ClearGCLIPWindow WND
 ENDIF
END
DEF WindowFramePainter WND,CTL,TYPE,A1,A2
 VAR E=GBeginFrameWindow(WND)
 IF E THEN RETURN
 NEW_WINDOW_FRAME_PAINTER WND,WINCTL_DRW_ALL,0,0,0,TRUE OUT ,
 E=ReGBeginWindow(WND)
END

COMMON DEF NewWindowMoveFrame(WND,X,Y,MODE,CALLBACK$)
 IF SetWindowDragHandler(CALLBACK$,WND,X,Y)THEN RETURN -1
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 OTW_MOVWINFLG=MODE
 VAR AX=WIN_AX[NUWID]
 VAR AY=WIN_AY[NUWID]
 INC X,AX
 INC Y,AY
 OTW_MOVWIN_SW=WIN_WIDTH[NUWID]+1
 OTW_MOVWIN_SH=WIN_HEIGHT[NUWID]+1
 OTW_MOVWIN_W=OTW_MOVWIN_SW
 OTW_MOVWIN_H=OTW_MOVWIN_SH
 OTW_MOVWIN_NUWID=NUWID
 OTW_MOVWIN_DX=AX-X
 OTW_MOVWIN_DY=AY-Y
 OTW_MOVWIN_SX=AX
 OTW_MOVWIN_SY=AY
 RETURN 0
END
COMMON DEF ClearWindowMoveFrame(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 OTW_MOVWINFLG=0
 IF OTW_MOVWIN_INIT THEN
  OTW_MOVWIN_INIT=FALSE
  CALL OTW_MOVWIN_HNDLR$,OTW_MOVWIN_SX,OTW_MOVWIN_SY,OTW_MOVWIN_SW,OTW_MOVWIN_SH,OTW_MOVWIN_X,OTW_MOVWIN_Y,OTW_MOVWIN_W,OTW_MOVWIN_H,OTW_MOVWIN_X,OTW_MOVWIN_Y,OTW_MOVWIN_W,OTW_MOVWIN_H,1
 ENDIF
 RETURN 0
END
DEF WindowChFocus WND,CTL,TYPE,A1,A2
 VAR BEG
 IF A1 THEN
  VAR E=FrontWindow(WND)
  NEW_WINDOW_FRAME_PAINTER WND,WINCTL_DRW_CAP,0,0,0,FALSE OUT ,BEG
 ELSE
  NEW_WINDOW_FRAME_PAINTER WND,WINCTL_DRW_CAP,0,0,0,FALSE OUT ,BEG
 ENDIF
 IF BEG THEN BEG=GEndWindow(WND)
END
DEF WindowLMouseDown WND,CTL,TYPE,A1,A2
' VAR E=FrontWindow(WND)
END
COMMON DEF WindowDragFrameCallbackEx WND,X,Y,W,H
 VAR E=MoveResizeWindowF(WND,X,Y,W,H,&H7FFFFFFF,&H7FFFFFFF,&H7FFFFFFF,&H7FFFFFFF)
 E=FrontWindow(WND)
 E=ActiveWindow(WND)
 MouseClipDef
END
DEF WindowFrame_HasFlag(FLG,F)
 RETURN (FLG AND F)==F
END
DEF WindowClickFrame WND,CTL,TYPE,BTN,POS
 VAR FW1,FH1,FW2,FH2
 GetWindowFrameSize WND OUT FW1,FH1,FW2,FH2,
 VAR STYLE=GetWindowStyle(WND)
 VAR MAX=STYLE AND WindowMaximizedStyle()
 VAR HASMINMAX=WindowFrame_HasFlag(GetWindowStyle(WND),WindowMinMaxStyle())
 VAR X,Y
 SplitInt POS OUT X,Y
 VAR HIT,BGN
 NEW_WINDOW_FRAME_PAINTER WND,FALSE,X,Y,BTN,FALSE OUT HIT,BGN
 IF BGN THEN
  VOID GEndWindow(WND)
 ENDIF
 VAR LCLK=WindowFrame_HasFlag(BTN,CTL_LBTNFLG OR CTL_BTNDWNFLG)
 VAR RCLK=WindowFrame_HasFlag(BTN,CTL_RBTNFLG OR CTL_BTNDWNFLG)
 VAR LDBL=WindowFrame_HasFlag(BTN,CTL_LBTNFLG OR CTL_DBLFLG)
 IF (LCLK&&HIT==WINCTL_HIT_CLS)||(LDBL&&HIT==WINCTL_HIT_CAPICON) THEN
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
 IF HIT==WINCTL_HIT_CAPICON THEN
  IF LCLK THEN
   VAR BH,CH
   CalcWindowBorderSize WND,STYLE OUT ,BH,,
   CalcWindowCaptionHeight WND,STYLE OUT CH
   ShowSystemMenu WND,0,-FH1+CH+BH-1
  ENDIF
  RETURN
 ENDIF
 IF RCLK&&HIT==WINCTL_HIT_CAP THEN
  ShowSystemMenu WND,X-FW1,Y-FH1
  RETURN
 ENDIF
 IF LCLK&&HIT==WINCTL_HIT_MIN THEN
  VOID MinimizeWindow(WND)
  RETURN
 ENDIF
 IF HASMINMAX&&((LDBL&&HIT==WINCTL_HIT_CAP)||(LCLK&&HIT==WINCTL_HIT_MAX))THEN
  IF MAX THEN
   VOID RestoreWindow(WND)
  ELSE
   VOID MaximizeWindow(WND)
  ENDIF
  RETURN
 ENDIF
 IF !MAX&&LCLK&&(HIT==WINCTL_HIT_CAP||HIT==WINCTL_HIT_CAPICON) THEN
  VOID NewWindowMoveFrame(WND,X,Y,1,"WindowDragFrameCallbackEx")
  VOID SetCaptureEx(WND,TRUE)
  VAR WX,WY,WW,WH,ERR
  GetWorkArea GetParentWindow(WND) OUT WX,WY,WW,WH,ERR
  IF !ERR THEN
   VOID MouseClip(GetParentWindow(WND),WX,WY,WW,WH)
  ENDIF
 ENDIF
 IF LCLK&&!MAX&&HIT>=WINCTL_HIT_B1&&HIT<=WINCTL_HIT_B8 THEN
  VOID NewWindowMoveFrame(WND,X,Y,HIT-WINCTL_HIT_B1+2,"WindowDragFrameCallbackEx")
  VOID SetCaptureEx(WND,TRUE)
 ENDIF
 RETURN
 IF!IsFocusWindow(WND)THEN RETURN
END
DEF WindowMMoveFrame WND,CTL,TYPE,ET,XY
 VAR X,Y
 SplitInt XY OUT X,Y
 VAR CW,CF
 GetCaptureEx OUT CW,CF
 IF WND==CW&&CF THEN RETURN
 VAR HIT,BGN
 NEW_WINDOW_FRAME_PAINTER WND,FALSE,X,Y,0,FALSE OUT HIT,BGN
 VAR CUR=GetArrowCursor()
 IF HIT==WINCTL_HIT_B1 THEN
  CUR=GetSizeNWSECursor()
 ELSEIF HIT==WINCTL_HIT_B2||HIT==WINCTL_HIT_B7 THEN
  CUR=GetSizeNSCursor()
 ELSEIF HIT==WINCTL_HIT_B3 THEN
  CUR=GetSizeNESWCursor()
 ELSEIF HIT==WINCTL_HIT_B4||HIT==WINCTL_HIT_B5 THEN
  CUR=GetSizeWECursor()
 ELSEIF HIT==WINCTL_HIT_B6 THEN
  CUR=GetSizeNESWCursor()
 ELSEIF HIT==WINCTL_HIT_B8 THEN
  CUR=GetSizeNWSECursor()
 ENDIF
 IF BGN THEN
  VOID GEndWindow(WND)
 ENDIF
 IF ET AND CTL_LEAVEFLG THEN
 ELSE
  VOID SetCursor(CUR)
 ENDIF
END
COMMON DEF MaximizeWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR WS=GetWindowStyle(WND)
 IF WS AND WindowDisableMaxStyle()THEN
  RETURN 0'ERR?
 ENDIF
 SetWindowStyle WND,(WS AND NOT(WindowMinimizedStyle()OR WindowMaximizedStyle()))OR WindowMaximizedStyle()
 VOID SendChildWindowEvent(WND,WindowMaximizeEvent(),WND)
 VOID SendChildWindowEvent(GetParentWindow(WND),WindowMaximizeEvent(),WND)
 RETURN 0
END
COMMON DEF MinimizeWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR WS=GetWindowStyle(WND)
 IF WS AND WindowDisableMinStyle()THEN
  RETURN 0'ERR?
 ENDIF
 SetWindowStyle WND,WS OR WindowMinimizedStyle()
 VOID SendChildWindowEvent(WND,WindowMinimizeEvent(),WND)
 VOID SendChildWindowEvent(GetParentWindow(WND),WindowMinimizeEvent(),WND)
 RETURN 0
END
COMMON DEF RestoreWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR WS=GetWindowStyle(WND)
 'MIN>MAX
 IF WS AND WindowMinimizedStyle()THEN
  SetWindowStyle WND,WS AND NOT WindowMinimizedStyle()
 ELSEIF WS AND WindowMaximizedStyle()THEN
  SetWindowStyle WND,WS AND NOT WindowMaximizedStyle()
 ELSE
  RETURN 0
 ENDIF
 VOID SendChildWindowEvent(WND,WindowRestoreEvent(),WND)
 VOID SendChildWindowEvent(GetParentWindow(WND),WindowRestoreEvent(),WND)
 RETURN 0
END
COMMON DEF WindowMaximizeEvent()
 RETURN 1
END
COMMON DEF WindowMinimizeEvent()
 RETURN 2
END
COMMON DEF WindowActiveEvent()
 RETURN 3
END
COMMON DEF WindowRestoreEvent()
 RETURN 4
END
COMMON DEF WindowInactiveEvent()
 RETURN 5
END
COMMON DEF WindowInputEvent()
 RETURN 6
END
COMMON DEF WindowLostInputEvent()
 RETURN 7
END

COMMON DEF ParentWindowResizeEvent()
 RETURN 1
END
COMMON DEF WindowGroupActiveEvent()
 RETURN 2
END
COMMON DEF WindowGroupInactiveEvent()
 RETURN 3
END
COMMON DEF GetWindowFrameSize WND OUT W1,H1,W2,H2,ERR
 IF!CheckWindow(WND)THEN
  ERR=WIN_INVALIDID
  W1=0
  H1=0
  W2=0
  H2=0
 ENDIF
 VAR N=WND AND NUWIDMASK
 W1=WIN_FW1[N]
 H1=WIN_FH1[N]
 W2=WIN_FW2[N]
 H2=WIN_FH2[N]
 DEC W2,W1
 DEC H2,H1
 ERR=0
END
DEF ControlDefChildWinHandler WND,CTL,TYPE,A1,CWND
 VAR W1,W2,H1,H2,ERR
 IF WND==CWND&&A1==WindowMaximizeEvent()THEN
  GetWindowFrameSize CWND OUT W1,H1,W2,H2,ERR
  VAR WX,WY,WW,WH
  GetWorkArea GetParentWindow(CWND) OUT WX,WY,WW,WH,
  VOID MoveResizeWindow(CWND,WX,WY,WW-W1-W2,WH-H2-H1)

'  VOID MoveResizeWindowF(CWND,WX,WY,WW,WH,0,H1-2,0,0)
'  VOID SetSysWindowProperty(CWND,"SHADOW",FALSE)

  RETURN
 ELSEIF WND==CWND&&A1==WindowMinimizeEvent()THEN
  VOID MoveResizeWindow(CWND,0,GetWindowHeight(GetParentWindow(CWND))-16,32,16)
  RETURN
 ENDIF
 VOID SendChildWindowEvent(GetParentWindow(WND),A1,CWND)
END
DEF WIN_UNPACK_STATE S$ OUT W1,H1,W2,H2,X,Y,W,H
 W1=ASC(S$)
 H1=ASC(S$[1])
 W2=ASC(S$[2])
 H2=ASC(S$[3])
 X=ASC(S$[4])
 Y=ASC(S$[5])
 W=ASC(S$[6])
 H=ASC(S$[7])
END
DEF WIN_PACK_STATE WND,W1,H1,W2,H2 OUT S$
 S$="        "
 S$[0]=CHR$(W1)
 S$[1]=CHR$(H1)
 S$[2]=CHR$(W2)
 S$[3]=CHR$(H2)
 S$[4]=CHR$(GetWindowX(WND)-W1)
 S$[5]=CHR$(GetWindowY(WND)-H1)
 S$[6]=CHR$(GetWindowWidth(WND)+W2+W1)
 S$[7]=CHR$(GetWindowHeight(WND)+H2+H1)
 RETURN S$
END
DEF WindowChildWindow WND,CTL,TYPE,A1,CWND
 IF A1==WindowActiveEvent()THEN
  VOID FrontWindow(WND)
  WindowChFocus WND,CTL,0,TRUE,0
 ELSEIF A1==WindowInactiveEvent()THEN
  WindowChFocus WND,CTL,0,!TRUE,0
 ELSEIF CWND==WND&&A1==WindowMaximizeEvent()THEN
  VAR W1,W2,H1,H2,ERR
  VAR X,Y,W,H

  GetWindowFrameSize CWND OUT W1,H1,W2,H2,ERR
  IF!W1&&!W2 THEN
   RETURN
  ENDIF
  VAR WX,WY,WW,WH,S$
  S$=WIN_PACK_STATE(WND,W1,H1,W2,H2)
  SetProp$ CWND,"WINOLDSTATE",S$
  QueryWindowFrameSize WND OUT W1,H1,W2,H2,ERR
  GetWorkArea GetParentWindow(CWND) OUT WX,WY,WW,WH,
  VOID MoveResizeWindowF(CWND,WX,WY,WW,WH,W1,H1,W2,H2)
  VOID SetSysWindowProperty(CWND,"SHADOW",FALSE)
  RETURN
 ELSEIF A1==WindowMinimizeEvent()THEN
  RETURN
 ELSEIF CWND==WND&&A1==WindowRestoreEvent()THEN
  IF !(GetWindowStyle(CWND)AND WindowHideStyle())THEN
   IF HasProp(CWND,"WINOLDSTATE")THEN
    WIN_UNPACK_STATE GetProp$(CWND,"WINOLDSTATE") OUT W1,H1,W2,H2,X,Y,W,H
    RemoveProp CWND,"WINOLDSTATE"
    VOID MoveResizeWindowF(CWND,X,Y,W,H,W1,H1,W2,H2)
    VOID SetSysWindowProperty(CWND,"SHADOW",!FALSE)
   ENDIF
  ENDIF
  RETURN
 ENDIF
 VOID SendChildWindowEvent(GetParentWindow(WND),A1,CWND)
END
DEF WindowParentWindow WND,CTL,T,TYP,A
 VAR E=CallBaseControlHandler(WND,CTL,T,TYP,A)
 IF TYP==ParentWindowResizeEvent()THEN
  VAR WX,WY,WW,WH,W1,H1,W2,H2,ERR
  IF GetWindowStyle(WND)AND WindowMaximizedStyle()THEN
   QueryWindowFrameSize WND OUT W1,H1,W2,H2,ERR
   GetWorkArea GetParentWindow(WND) OUT WX,WY,WW,WH,
   VOID MoveResizeWindowF(WND,WX,WY,WW,WH,W1,H1,W2,H2)
   RETURN
  ENDIF
 ENDIF
END
DEF WindowNotif WND,CTL,T,A1,A2
 IF A1==MenuNotifID() THEN
  IF A2==WINCTL_MENU_MINIMIZE THEN
   VOID MinimizeWindow(WND)
  ENDIF
  IF A2==WINCTL_MENU_MAXIMIZE THEN
   VOID MaximizeWindow(WND)
  ENDIF
  IF A2==WINCTL_MENU_CLOSE THEN
   VOID DeleteWindow(WND)
  ENDIF
  IF A2==WINCTL_MENU_RESTORE THEN
   VOID RestoreWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF GetWindowStyle(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 RETURN WIN_STYLE[WND AND NUWIDMASK]
END
COMMON DEF SetWindowStyle WND,STYLE
 IF!CheckWindow(WND)THEN RETURN
 VAR NUWID=WND AND NUWIDMASK
 WIN_STYLE[NUWID]=STYLE
END
COMMON DEF IsOwnerDrawWindow(WND)
 RETURN !!(WIN_STYLE[WND AND NUWIDMASK]AND WIN_STYLE_OWNERDRAW)
END
COMMON DEF IsCheckedButton(WND)
 VAR CTL=GetControl(WND)
 IF IsControlExtend(CTL,CTL_BUTTONCTL)THEN
  IF GetWindowVar(WND,1)THEN
   RETURN TRUE
  ENDIF
 ENDIF
 RETURN FALSE
END
COMMON DEF UnCheckButton WND
 VAR CTL=GetControl(WND)
 IF IsControlExtend(CTL,CTL_BUTTONCTL)THEN
  IF GetWindowVar(WND,1)THEN
   SetWindowVar WND,1,FALSE
   VOID RepaintWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF CheckButton WND
 VAR CTL=GetControl(WND)
 IF IsControlExtend(CTL,CTL_BUTTONCTL)THEN
  IF!GetWindowVar(WND,1)THEN
   SetWindowVar WND,1,TRUE
   VOID RepaintWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF UnCheckButtonsGroup WND
 VAR MEMBER=GetWindowGroupMember(WND)
 WHILE MEMBER
  UnCheckButton MEMBER
  ?MEMBER,GetWindowName$(MEMBER)
  MEMBER=GetNextWindowGroupMember(MEMBER)
 WEND
END
DEF ButtonPainter W,C,T,A1,A2
 VAR E=GBeginWindow(W)
 IF E THEN RETURN
 '2:LEFT
 '1:RIGHT
 '0:CENTER
 VAR ALIGN=GetWindowVar(W,2)
 VAR TG=GetWindowVar(W,1)
 VAR HE=GetWindowHeight(W)
 VAR WI=GetWindowWidth(W)
 VAR NA$=GetWindowName$(W)
 VAR B1=RGB(0,0,0)
 VAR B2=-1
 IF TG THEN SWAP B1,B2
 GFILLWindow W,0,0,WI,HE,WIN_BTNBACK
 VAR TX
 ON ALIGN GOTO @CENTER,@RIGHT,@LEFT,@DEFAULT
 @CENTER
 TX=(WI-GetTextWidth(NA$))/2+TG+1
 GOTO @DEFAULT
 @RIGHT
 TX=WI-GetTextWidth(NA$)+TG-1
 GOTO @DEFAULT
 @LEFT
 TX=TG+1
 @DEFAULT
 GPRINTWindow W,TX,(HE-6)/2+TG,NA$,RGB(0,0,0)
 GBOXWindow W,0,0,WI,HE,B1
 GLINEWindow W,0,0,0,HE-1,B2
 GLINEWindow W,0,0,WI-1,0,B2
 IF!IsOwnerDrawWindow(W)THEN
  E=GEndWindow(W)
 ELSE
  SetWindowDrawPos W,1+TG,1+TG
 ENDIF
END
DEF ButtonLMouseUP W,C,T,X,Y
 IF GetWindowVar(W,1)THEN
 VAR E=SendNotificationWindow(GetParentWindow(W),W,GetWindowVar(W,0))
 SetWindowVar W,1,FALSE
 VOID RepaintWindow(W)
 ENDIF
'ButtonPainter W,C,T,0,0
END
DEF ButtonLMouseDown W,C,T,X,Y
 SetWindowVar W,1,TRUE
 VOID RepaintWindow(W)
 VOID SetCapture(W)
END
DEF ToggleButtonLMouseUP W,C,T,X,Y
 VAR E=SendNotificationWindow(GetParentWindow(W),W,GetWindowVar(W,1))
'SetWindowVar W,1,FALSE
 VOID RepaintWindow(W)
'ButtonPainter W,C,T,0,0
END
DEF ToggleButtonLMouseDown W,C,T,X,Y
 VAR F=GetWindowVar(W,1)
 SetWindowVar W,1,!F
 VOID RepaintWindow(W)
 VOID SetCapture(W)
'ButtonPainter W,C,T,0,0
END
COMMON DEF SetButtonAlignLeft WND
 SetWindowVar WND,2,2
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetButtonAlignRight WND
 SetWindowVar WND,2,1
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetButtonAlignCenter WND
 SetWindowVar WND,2,0
 VAR E=RepaintWindow(WND)
END
'PlainTextBox
COMMON DEF SetTextBoxOwnerDraw WND,FLG
 SetWindowVar WND,7,FLG
END
DEF TextBoxGetOffsetX(W)
 RETURN -GetWindowVar(W,TXTBOX_WV_OFFX)+TextBoxGetBorderWidth(W)
END
DEF TextBoxPainter W,C,T,A1,A2
 IF GetWindowVar(W,7)THEN
  VAR E=RepaintWindow(W)'CallControlHandler(W,GetControl(W),T,A1,A2)
  RETURN
 ENDIF
 E=GBeginWindow(W)
 IF E THEN RETURN
 VAR SX,EX,HAS
 TextBoxGetSelection W OUT SX,EX,HAS
 VAR HE=GetWindowHeight(W)
 VAR WI=GetWindowWidth(W)
 VAR NA$=GetWindowName$(W)
 VAR CX=GetWindowVar(W,TXTBOX_WV_CX)
 VAR OFFX=TextBoxGetOffsetX(W)
 VAR OFFY=2
 GFILLWindow W,0,0,WI,HE,-1
 IF HAS&&SX!=EX THEN
  IF SX>EX THEN SWAP SX,EX
  GPRINTWindow W,OFFX,OFFY,MID$(NA$,0,SX),RGB(0,0,0)
  GFILLWindow W,OFFX+SX*8,1,OFFX+EX*8-1,HE-1,GetSelectionColor()
  GPRINTWindow W,OFFX+SX*8,OFFY,MID$(NA$,SX,EX-SX),GetSelectionTextColor()
  GPRINTWindow W,OFFX+EX*8,OFFY,MID$(NA$,EX,&H7FFFFFF),#BLACK
 ELSE
  GPRINTWindow W,OFFX,OFFY,NA$,RGB(0,0,0)
  IF IsFocusWindow(W)THEN
   GFILLWindow W,OFFX+CX*8,OFFY,OFFX+CX*8+1,OFFY+6,RGB(0,0,0)
   E=SetWindowIMCursor(W,OFFX+CX*8+1,OFFY)
  ENDIF
 ENDIF
 GBOXWindow W,0,0,WI,HE,RGB(0,0,0)
 E=GEndWindow(W)
END
DEF TextBoxClearSelection W
 SetWindowVar W,TXTBOX_WV_SX,0
 SetWindowVar W,TXTBOX_WV_EX,0
END
DEF TextBoxSetSelection W,SX,EX
 SetWindowVar W,TXTBOX_WV_SX,SX+1
 SetWindowVar W,TXTBOX_WV_EX,EX+1
END
DEF TextBoxGetSelection W OUT SX,EX,HAS
 GetWindowVar W,TXTBOX_WV_SX OUT SX
 GetWindowVar W,TXTBOX_WV_EX OUT EX
 IF SX&&EX THEN
  HAS=1
 ELSE
  HAS=0
 ENDIF
 DEC SX
 DEC EX
END
DEF TextBoxGetPosFromPoint W,X,Y OUT CX
 VAR L=LEN(GetWindowName$(W))
 CX=MAX(0,MIN((X-TextBoxGetOffsetX(W)) DIV 8,L))
END
DEF TextBoxLMouseUp W,C,T,X,Y
 VAR SX,EX,HAS
 TextBoxGetSelection W OUT SX,EX,HAS
 IF HAS THEN RETURN
 TextBoxClearSelection W
 VOID RepaintWindow(W)
END
DEF TextBoxMouseMove W,C,T,MX,MY
 IF GetCapture()!=W THEN RETURN
 VAR X
 VAR CX=GetWindowVar(W,TXTBOX_WV_CX)
 TextBoxGetPosFromPoint W,MX,MY OUT X
 VAR SX,EX,HAS
 TextBoxGetSelection W OUT SX,EX,HAS
 IF !HAS THEN
  SX=CX
  EX=X
  TextBoxSetSelection W,SX,EX
  VOID RepaintWindow(W)
 ELSEIF HAS&&EX!=X THEN
  EX=X
  TextBoxSetSelection W,SX,EX
  TextBoxAutoScroll W
  VOID RepaintWindow(W)
 ENDIF
END
DEF TextBoxLDoubleClick W,C,T,X,Y
 TextBoxSelectAll W
 VOID RepaintWindow(W)
END
DEF TextBoxLMouseDown W,C,T,X,Y
 VAR CX
 TextBoxGetPosFromPoint W,X,Y OUT CX
 TextBoxClearSelection W
 IF CX!=GetWindowVar(W,TXTBOX_WV_CX) THEN
  SetWindowVar W,1,CX
  VOID RepaintWindow(W)
 ENDIF
 VOID SetCapture(W)
END
DEF TextBoxChFocus W,C,T,X,Y
 TextBoxPainter W,C,T,0,0
END
DEF TextBoxContextMenu W,C,T,X,Y
 ShowMenu TXTBOX_MENU,W,X,Y
END
DEF TextBoxGetBorderWidth(W)
 RETURN 1
END
DEF TextBoxAutoScroll W
 VAR SX,EX,HAS
 TextBoxGetSelection W OUT SX,EX,HAS
 VAR TWIDTH=GetWindowWidth(W)-TextBoxGetBorderWidth(W)*2
 VAR CX=GetWindowVar(W,TXTBOX_WV_CX)
 IF HAS THEN CX=EX
 CX=CX*8
 VAR OFFX=GetWindowVar(W,TXTBOX_WV_OFFX)
 
 IF CX-OFFX-8<0 THEN
  SetWindowVar W,TXTBOX_WV_OFFX,MAX(0,CX-16)
 ENDIF
 IF CX-OFFX+8>=TWIDTH THEN
  SetWindowVar W,TXTBOX_WV_OFFX,CX-TWIDTH+18
 ENDIF
END
DEF TextBoxRemoveSelText W
 VAR T$=GetWindowName$(W)
 VAR SX,EX,SEL
 TextBoxGetSelection W OUT SX,EX,SEL
 IF SEL THEN
  IF SX>EX THEN SWAP SX,EX
  T$=RemoveStr$(T$,SX,EX-SX)
  TextBoxClearSelection W
  SetWindowName W,T$
  SetWindowVar W,TXTBOX_WV_CX,SX
 ENDIF
END
DEF TextBoxGetSelectionText$(W)
 VAR SX,EX,SEL
 TextBoxGetSelection W OUT SX,EX,SEL
 IF!SEL THEN RETURN ""
 IF SX>EX THEN SWAP SX,EX
 RETURN MID$(GetWindowName$(W),SX,EX-SX)
END
DEF TextBoxSelectAll W
 VAR SX,EX,SEL
 TextBoxGetSelection W OUT SX,EX,SEL
 IF SX>EX THEN SWAP SX,EX
 TextBoxSetSelection W,0,LEN(GetWindowName$(W))
END
DEF TextBoxCopy W,CUT
 VAR SX,EX,SEL
 TextBoxGetSelection W OUT SX,EX,SEL
 IF SX>EX THEN SWAP SX,EX
 IF!SEL THEN RETURN
 ClearClipboard
 ClipboardSetText TextBoxGetSelectionText$(W)
 IF CUT THEN
  TextBoxRemoveSelText W
 ENDIF
 TextBoxClearSelection W
END
DEF TextBoxNotif W,C,T,A1,A2
 IF A1==MenuNotifID() THEN
  IF A2==TXTBOX_MENU_COPY||A2==TXTBOX_MENU_CUT THEN
   TextBoxCopy W,A2==TXTBOX_MENU_CUT
   VOID RepaintWindow(W)
  ELSEIF A2==TXTBOX_MENU_PASTE THEN
   TextBoxInsertText W,ClipboardGetText$()
   VOID RepaintWindow(W)
  ELSEIF A2==TXTBOX_MENU_SELALL THEN
   TextBoxSelectAll W
   VOID RepaintWindow(W)
  ENDIF
 ENDIF
END
DEF TextBoxCreate W,C,T,A1,A2
 VOID SetWindowCursor(W,GetBeamCursor())
END
DEF TextBoxInsertText W,K$
 VAR SX,EX,SEL
 TextBoxGetSelection W OUT SX,EX,SEL
 IF SEL THEN
  TextBoxRemoveSelText W
  TextBoxGetSelection W OUT SX,EX,SEL
 ENDIF
 VAR CX=GetWindowVar(W,TXTBOX_WV_CX)
 VAR T$=GetWindowName$(W)
 SetWindowName W,InsertStr$(T$,CX,K$)
 SetWindowVar W,1,CX+1
END
DEF TextBoxKey W,C,T,KEY,A2
 VAR K$=CHR$(KEY)
 TextBoxRemoveSelText W
 IF K$==BS$()THEN
  VAR CX=GetWindowVar(W,TXTBOX_WV_CX)
  IF CX THEN
   VAR T$=GetWindowName$(W)
   SetWindowName W,RemoveStr$(T$,CX-1,1)
   SetWindowVar W,TXTBOX_WV_CX,CX-1
  ENDIF
 ELSE
  TextBoxInsertText W,K$
 ENDIF
 TextBoxAutoScroll W
 TextBoxPainter W,C,T,0,0
END
DEF TextBoxButton W,C,T,B,A2
 VAR CX=GetWindowVar(W,TXTBOX_WV_CX)
 IF B AND 4&&CX THEN
  SetWindowVar W,1,CX-1
  TextBoxClearSelection W
  TextBoxAutoScroll W
  TextBoxPainter W,C,T,0,0
 ENDIF
 IF B AND 8THEN
  IF LEN(GetWindowName$(W))>CX THEN
   SetWindowVar W,1,CX+1
   TextBoxClearSelection W
   TextBoxAutoScroll W
   TextBoxPainter W,C,T,0,0
  ENDIF
 ENDIF
 IF B AND 128THEN
  TextBoxKey W,C,T,ASC(BS$()),0
 ENDIF
END
'1F
COMMON DEF GetNumUpDownValue(WND)
 UpdateNumUpDown WND
 RETURN VAL(GetWindowName$(WND))
END
'?
COMMON DEF SetNumUpDownRange WND,MIN,MAX
 SetWindowVar WND,4,MIN
 SetWindowVar WND,3,MAX
 UpdateNumUpDown WND
END
COMMON DEF UpdateNumUpDown WND
 VAR MIN=GetWindowVar(WND,4)
 VAR MAX=GetWindowVar(WND,3)
 VAR VAL=VAL(GetWindowName$(WND))
 'MIN
 IF VAL<MIN THEN
  VAL=MIN
  SetWindowName WND,STR$(VAL)
  DrawNumUpDown WND,FALSE
 ENDIF
 'MAX
 IF VAL>MAX THEN
  VAL=MAX
  SetWindowName WND,STR$(VAL)
  DrawNumUpDown WND,FALSE
 ENDIF
END
DEF NumUpDownCreate WND,CTL,TYPE,X,Y
 SetTextBoxOwnerDraw WND,TRUE
 SetWindowVar WND,4,&H80000000
 SetWindowVar WND,3,&H7FFFFFFF
END
DEF NumUpDownLMouseUP WND,CTL,TYPE,X,Y
 IF ABS(GetWindowVar(WND,6))==1THEN
  SetWindowVar WND,6,3
 ELSE
  SetWindowVar WND,6,0
 ENDIF
 VAR W=GetWindowWidth(WND)
 VAR BW=8
 VAR H=GetWindowHeight(WND)
 IF GBeginWindow(WND) THEN RETURN
 DrawNumUpDownButton WND,7,H/2,W-7,0,FALSE,TRUE
 DrawNumUpDownButton WND,7,H/2-1,W-7,H/2+1,FALSE,FALSE
 VAR E=GEndWindow(WND)
 E=SendNotificationWindow(GetParentWindow(WND),WND,VAL(GetWindowName$(WND)))
 RETURN
 E=CallBaseControlHandler(WND,CTL,TYPE,X,Y)
END
DEF NUMUPDOWNTimer WND,TIMER,ARG
 NumUpDownLMouseDown WND,000,0000,0,0
END
DEF NumUpDownLMouseDown WND,CTL,TYPE,X,Y
 VAR BTN=GetWindowVar(WND,6)
 IF BTN THEN
  IF BTN!=3THEN
   VAR FRAME=GetWindowVar(WND,5)
   IF MAINCNT-FRAME>=4THEN
    SetWindowVar WND,5,MAINCNT
    VAR VAL=VAL(GetWindowName$(WND))+BTN
    'MIN
    IF VAL<GetWindowVar(WND,4)THEN
     VAL=GetWindowVar(WND,4)
    ENDIF
    'MAX
    IF VAL>GetWindowVar(WND,3)THEN
     VAL=GetWindowVar(WND,3)
    ENDIF
    SetWindowName WND,STR$(VAL)
    DrawNumUpDown WND,FALSE
   ENDIF
   SetTimer WND,16,0,"NUMUPDOWNTimer" OUT ,
   'VOID LMouseDownWindow(WND)
   RETURN
  ELSE
   SetWindowVar WND,6,FALSE
   RETURN
  ENDIF
 ENDIF
 VAR W=GetWindowWidth(WND)
 VAR BW=8
 IF W-BW<=X THEN
  VAR H=GetWindowHeight(WND)
  IF GBeginWindow(WND)THEN RETURN
  IF H/2>=Y THEN
   'UE
   DrawNumUpDownButton WND,7,H/2,W-7,0,TRUE,TRUE
   SetWindowVar WND,6,1
   VOID SetCapture(WND)
   SetTimer WND,16,0,"NUMUPDOWNTimer" OUT ,
   'VOID LMouseDownWindow(WND)
   SetWindowVar WND,5,MAINCNT
  ENDIF
  IF H/2<=Y THEN
   DrawNumUpDownButton WND,7,H/2-1,W-7,H/2+1,TRUE,FALSE
   SetWindowVar WND,6,-1
   VOID SetCapture(WND)
   SetTimer WND,16,0,"NUMUPDOWNTimer" OUT ,
   'VOID LMouseDownWindow(WND)
   SetWindowVar WND,5,MAINCNT
  ENDIF
  VAR E=GEndWindow(WND)
  RETURN
 ENDIF
 E=CallBaseControlHandler(WND,CTL,TYPE,X,Y)
END
DEF DrawNumUpDownButton W,WI,HE,X,Y,PUSH,UPF
 GFILLWindow W,X,Y,X+WI,Y+HE,RGB(192,192,192)
 VAR B1=RGB(0,0,0),B2=-1
 IF PUSH THEN SWAP B1,B2
 GBOXWindow W,X,Y,X+WI,Y+HE,B1
 GLINEWindow W,X,Y,X,Y+HE-1,B2
 GLINEWindow W,X,Y,X+WI-1,Y,B2
 IF UPF THEN
  GTRIWindow W,X+2+PUSH,Y+HE-2+PUSH,X+WI-2+PUSH,Y+HE-2+PUSH,X+(WI-2)/2+2+PUSH,Y+2+PUSH,RGB(0,0,0)
 ELSE
  GTRIWindow W,X+2+PUSH,Y+2+PUSH,X+WI-2+PUSH,Y+2+PUSH,X+(WI-2)/2+2+PUSH,Y+HE-2+PUSH,RGB(0,0,0)
 ENDIF
END
DEF NumUpDownPainter WND,CTL,TYPE,A1,A2
 DrawNumUpDown WND,TRUE
END
DEF DrawNumUpDown WND,BTNDRAWFLG
 VAR E=GBeginWindow(WND)
 IF E THEN RETURN
 VAR H=GetWindowHeight(WND)
 VAR W=GetWindowWidth(WND)
 VAR BW=8
 GFILLWindow WND,0,0,W-8,H,-1
 VAR NA$=GetWindowName$(WND)
 GBOXWindow WND,0,0,W-BW,H,RGB(0,0,0)
 GPRINTWindow WND,1,(H-8) DIV 2+1,NA$,RGB(0,0,0)
 VAR BTN=GetWindowVar(WND,6)
 IF BTNDRAWFLG&&ABS(BTN)!=1THEN
  DrawNumUpDownButton WND,7,H/2,W-7,0,FALSE,TRUE
  DrawNumUpDownButton WND,7,H/2-1,W-7,H/2+1,FALSE,FALSE
 ENDIF
 E=GEndWindow(WND)
END
DEF NumUpDownKey WND,CTL,TYPE,KEY,A2
 IF KEY>=ASC("0")&&KEY<=ASC("9")||KEY==ASC(BS$())THEN VAR E=CallBaseControlHandler(WND,CTL,TYPE,KEY,A2)
 IF KEY==&H0DTHEN
  UpdateNumUpDown WND
  E=SendNotificationWindow(GetParentWindow(WND),WND,VAL(GetWindowName$(WND)))
 ENDIF

END
COMMON DEF SetLabelAlignLeft WND
 SetWindowVar WND,1,0
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetLabelAlignRight WND
 SetWindowVar WND,1,1
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetLabelAlignCenter WND
 SetWindowVar WND,1,2
 VAR E=RepaintWindow(WND)
END
DEF LabelPainter W,CT,T,A1,A2
 VAR E=GBeginWindow(W)
 IF E THEN RETURN
 VAR NA$=GetWindowName$(W)
 VAR HE=GetWindowHeight(W)
 VAR WI=GetWindowWidth(W)
 VAR A=GetWindowVar(W,1)
 GCLSWindow W,GetWindowBackColor(W)
 VAR X,Y,C,I,L=LEN(NA$),HB=WI/8
 IF!HB THEN RETURN
 IF L<HB THEN
  IF A==1THEN X=WI-L*8
  IF A==2THEN X=(WI-L*8)/2
 ENDIF
 DEC L
 FOR I=0TO L
  C=ASC(NA$[I])
  IF C==10THEN INC Y,8:X=0CONTINUE
  IF X>=WI THEN
   INC Y,8:X=0
   IF L-I<HB THEN
    IF A==1THEN X=WI-(L-I+1)*8
    IF A==2THEN X=(WI-(L-I+1)*8)/2
   ENDIF
  ENDIF
  IF Y>=HE THEN BREAK
  GPUTCHRWindow W,X,Y,C,RGB(0,0,0)
  INC X,8
 NEXT
 E=GEndWindow(W)
END
'1:FIRST
'2:LAST
'3:VIEW
'4:VSCRBAR
'5:POS
'6:LEN
'7:SEL
COMMON DEF AddArrayListBoxItem WND,ITEM$
 VAR L=LEN(ITEM$)-1
 VAR I
 FOR I=0TO L
  AddListBoxItem WND,ITEM$[I]
 NEXT
END
COMMON DEF AddListBoxItem WND,ITEM$
 VAR L=GetWindowVar(WND,2)'
 IF!LISTSTR_FREE THEN
  LISTSTR_FREE=LEN(LISTSTR$)
  PUSH LISTSTR$,ITEM$
  PUSH LISTSTRNEXT,0
  PUSH LISTSTRPREV,0
 ENDIF
 IF L THEN LISTSTRNEXT[L]=LISTSTR_FREE
 SetWindowVar WND,2,LISTSTR_FREE
 IF!L THEN
  SetWindowVar WND,1,LISTSTR_FREE
 ENDIF
 LISTSTR$[LISTSTR_FREE]=ITEM$
 LISTSTRPREV[LISTSTR_FREE]=L
 L=LISTSTR_FREE
 LISTSTR_FREE=LISTSTRNEXT[L]
 LISTSTRNEXT[L]=0
 VAR LEN=GetWindowVar(WND,6)+1
 SetWindowVar WND,6,LEN
' VAR S=(GetWindowHeight(WND)-2)DIV 8
' IF LEN>S THEN DEC LEN,S ELSE LEN=0
 SetScrollBarSize GetWindowVar(WND,4),LEN-1
END
DEF LISTBOX_ADJUSTSCRBAR WND
 VAR LEN=GetWindowVar(WND,6)
' VAR S=(GetWindowHeight(WND)-2)DIV 8
' IF LEN>S THEN DEC LEN,S ELSE LEN=0
 VAR SCR=GetWindowVar(WND,4)
 SetScrollBarSize SCR,LEN-1
END
COMMON DEF SelectListBoxItem WND,INDEX
 VAR V=GetWindowVar(WND,1)
 WHILE V
  IF INDEX==0THEN
   SetWindowVar WND,7,V
   BREAK
  ENDIF
  V=LISTSTRNEXT[V]
  DEC INDEX
 WEND
 VOID RepaintWindow(WND)
 LISTBOX_SendChItemEvent WND
END
DEF ListBoxLMD WND,CT,T,X,Y
 VAR W=GetWindowWidth(WND)-1
 VAR H=GetWindowHeight(WND)
 IF X<=0||Y<=0||X>=W||Y>=H THEN RETURN
 VAR V=GetWindowVar(WND,3)
 VAR Y1=1,Y2=1,S=GetWindowVar(WND,7),F,GB
 VAR SELFLG
 WHILE V
  INC Y2,8
  IF Y>=Y1&&Y<Y2 THEN
   SetWindowVar WND,7,V
   IF!GB&&GBeginWindow(WND)THEN RETURN
   GFILLWindow WND,1,Y1,W,Y2-1,GetSelectionColor()
   GPRINTWindow WND,1,Y1,LISTSTR$[V],GetSelectionTextColor()
   F=1
   GB=1
   SELFLG=TRUE
   IF!S THEN BREAK
  ELSE IF V==S THEN
   IF!GB&&GBeginWindow(WND)THEN RETURN
   GB=1
   GFILLWindow WND,1,Y1,W,Y2-1,-1
   GPRINTWindow WND,1,Y1,LISTSTR$[V],RGB(0,0,0)
   S=0
   IF F THEN BREAK
  ENDIF
  ENDIF
  V=LISTSTRNEXT[V]
  INC Y1,8
  Y2=Y1
  IF Y1>=H THEN BREAK
 WEND
 IF GB THEN
  'あとしまつ
  VOID GEndWindow(WND)
 ENDIF
 IF T==CTL_LDBLCLKHANDLER THEN
  IF SELFLG THEN VOID SendNotifWindow(GetOwnerWindow(WND),WND,0)
 ELSE
  LISTBOX_SendChItemEvent WND
 ENDIF
END
DEF LISTBOX_SendChItemEvent WND
 VOID SendNotifWindow(GetOwnerWindow(WND),WND,ListBoxChItem())
END
COMMON DEF ListBoxChItem()
 RETURN 1
END
VAR LISTBOX_WV_LIST
VAR LISTBOX_WV_LAST
VAR LISTBOX_WV_SHOWLIST
VAR LISTBOX_WV_SCRBAR
VAR LISTBOX_WV_POS
VAR LISTBOX_WV_LEN
VAR LISTBOX_WV_SEL
DEF LISTBOX_INIT_WV
 LISTBOX_WV_LIST=1
 LISTBOX_WV_LAST=2
 LISTBOX_WV_SHOWLIST=3
 LISTBOX_WV_SCRBAR=4
 LISTBOX_WV_POS=5
 LISTBOX_WV_LEN=6
 LISTBOX_WV_SEL=7
END
DEF ListBoxDelete WND,CT,T,A1,A2
 VAR L=GetWindowVar(WND,LISTBOX_WV_LIST)
 IF!L THEN RETURN
 WHILE LISTSTRNEXT[L]
  L=LISTSTRNEXT[L]
 WEND
 LISTSTRNEXT[L]=LISTSTR_FREE
 LISTSTR_FREE=GetWindowVar(WND,LISTBOX_WV_LIST)
END
DEF ClearListBox WND
 VAR L=GetWindowVar(WND,LISTBOX_WV_LIST)
 IF!L THEN RETURN
 VAR NULL$
 WHILE LISTSTRNEXT[L]
  LISTSTR$[L]=NULL$
  L=LISTSTRNEXT[L]
 WEND
 LISTSTRNEXT[L]=LISTSTR_FREE
 LISTSTR_FREE=GetWindowVar(WND,LISTBOX_WV_LIST)
 SetWindowVar WND,LISTBOX_WV_SHOWLIST,0
 SetWindowVar WND,LISTBOX_WV_LAST,0
 SetWindowVar WND,LISTBOX_WV_LIST,0
 SetWindowVar WND,LISTBOX_WV_LEN,0
 VOID RepaintWindow(WND)
END
DEF ListBoxNotif WND,CT,T,A1,POS
 VAR OP=GetWindowVar(WND,LISTBOX_WV_POS)
 IF OP==POS THEN RETURN
 VAR SA=POS-OP,I
 SetWindowVar WND,LISTBOX_WV_POS,POS
 VAR V=GetWindowVar(WND,LISTBOX_WV_SHOWLIST)
 IF SA>0THEN
  FOR I=0TO SA-1
   IF!LISTSTRNEXT[V] THEN BREAK
   V=LISTSTRNEXT[V]
  NEXT
 ELSE
  SA=-SA
  FOR I=0TO SA-1
   IF!LISTSTRPREV[V] THEN BREAK
   V=LISTSTRPREV[V]
  NEXT
 ENDIF
 SetWindowVar WND,LISTBOX_WV_SHOWLIST,V
 ListBoxPainter WND,CT,T,0,0
END
DEF ListBoxCreate WND,CT,T,A1,A2
 VAR S,E
 NewVScrollBar WND,0 OUT S,E
 SetWindowVar WND,LISTBOX_WV_SCRBAR,S
END

DEF ListBoxPainter WND,CT,T,A1,A2
 VAR E=GBeginWindow(WND)
 IF E THEN RETURN
 GCLSWindow WND,-1
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR L=GetWindowVar(WND,LISTBOX_WV_SHOWLIST),Y=1
 IF!L THEN
  L=GetWindowVar(WND,LISTBOX_WV_LIST)
  SetWindowVar WND,LISTBOX_WV_SHOWLIST,L
 ENDIF
 VAR S=GetWindowVar(WND,LISTBOX_WV_SEL)
 WHILE L
  IF S==L THEN
   GFILLWindow WND,1,Y,W-1,Y+7,GetSelectionColor()
   GPRINTWindow WND,1,Y,LISTSTR$[L],GetSelectionTextColor()
  ELSE
   GPRINTWindow WND,1,Y,LISTSTR$[L],RGB(0,0,0)
  ENDIF
  INC Y,8
  IF Y>=H THEN BREAK
  L=LISTSTRNEXT[L]
 WEND
 GBOXWindow WND,0,0,W,H,RGB(0,0,0)
 E=GEndWindow(WND)
END
DEF LISTBOX_SEL WND
 VAR V=GetWindowVar(WND,LISTBOX_WV_SHOWLIST)
 VAR S=GetWindowVar(WND,LISTBOX_WV_SEL)
 IF!S THEN
  RETURN
 ENDIF
 VAR H=GetWindowHeight(WND)
 VAR L=GetWindowVar(WND,LISTBOX_WV_SHOWLIST),Y=1
 IF!L THEN
  L=GetWindowVar(WND,LISTBOX_WV_LIST)
  SetWindowVar WND,LISTBOX_WV_SHOWLIST,L
 ENDIF
 IF LISTSTRPREV[L]==S THEN
  SetWindowVar WND,LISTBOX_WV_SHOWLIST,LISTSTRPREV[L]
  VAR SCR=GetWindowVar(WND,LISTBOX_WV_SCRBAR)
  SetScrollBarPosition SCR,GetScrollBarPosition(SCR)-1
  RETURN
 ENDIF
 WHILE L
  IF S==L THEN
   RETURN
  ENDIF
  INC Y,8
  IF Y>=H THEN BREAK
  L=LISTSTRNEXT[L]
 WEND
 IF LISTSTRNEXT[L]==S THEN
  SetWindowVar WND,LISTBOX_WV_SHOWLIST,LISTSTRNEXT[GetWindowVar(WND,LISTBOX_WV_SHOWLIST)]
      SCR=GetWindowVar(WND,LISTBOX_WV_SCRBAR)
  SetScrollBarPosition SCR,GetScrollBarPosition(SCR)+1
  RETURN
 ENDIF
END
COMMON DEF ListBoxButton WND,CTL,T,BTN,__
 VAR V=GetWindowVar(WND,LISTBOX_WV_SHOWLIST)
 VAR S=GetWindowVar(WND,LISTBOX_WV_SEL)
 IF!S THEN
  SetWindowVar WND,LISTBOX_WV_SEL,V
  ListBoxPainter WND,CTL,T,0,0
  RETURN
 ENDIF
 IF BTN==#UP THEN
  IF LISTSTRPREV[S]THEN
   S=LISTSTRPREV[S]
   SetWindowVar WND,LISTBOX_WV_SEL,S
   LISTBOX_SEL WND
   ListBoxPainter WND,CTL,T,0,0
   LISTBOX_SendChItemEvent WND
  ENDIF
 ENDIF
 IF BTN==#DOWN THEN
  IF LISTSTRNEXT[S]THEN
   S=LISTSTRNEXT[S]
   SetWindowVar WND,LISTBOX_WV_SEL,S
   LISTBOX_SEL WND
   ListBoxPainter WND,CTL,T,0,0
   LISTBOX_SendChItemEvent WND
  ENDIF
 ENDIF
END

COMMON DEF ListBoxResize WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 LISTBOX_ADJUSTSCRBAR WND
 'VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF GetListBoxSelectedText$(WND)
 VAR S=GetWindowVar(WND,LISTBOX_WV_SEL)
 IF!S THEN RETURN""
 RETURN LISTSTR$[S]
END
COMMON DEF DrawButton WND,X,Y,W,H,PUSHF
 GFILLWINDOW WND,X,Y,X+W,Y+H,WIN_BTNBACK
 VAR B1C=RGB(255,255,255)
 VAR B2C=RGB(0,0,0)
 IF PUSHF THEN SWAP B1C,B2C
 GBOXWINDOW WND,X,Y,X+W,Y+H,B1C
 GLINEWINDOW WND,X,Y+H,X+W,Y+H,B2C
 GLINEWINDOW WND,X+W,Y,X+W,Y+H,B2C
 SetWindowDrawPos WND,X+1+PUSHF,Y+1+PUSHF
 GCLIPWindow WND,0,0,W-2-PUSHF,H-2-PUSHF
END
DEF DropDownListBtn WND,F
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 VAR BTNW=8
 VAR BTNH=H
 DrawButton WND,W-BTNW,H-BTNH,BTNW,BTNH,F
 GTRIWindow WND,1,5,BTNW-3,5,(BTNW-2) DIV 2,BTNH-4,RGB(0,0,0)
 GFILLWindow WND,2,2,BTNW-4,4,RGB(0,0,0)
END
COMMON DEF DropDownListPainter WND,CT,T,A1,A2
 IF GBEGINWINDOW(WND)THEN RETURN
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 GCLSWINDOW WND,-1
 VAR LSTBOX=GetWindowVar(WND,0)
 IF LSTBOX THEN
  VAR TXT$=GetListBoxSelectedText$(LSTBOX)
  GPRINTWINDOW WND,2,2,TXT$,RGB(0,0,0)
 ENDIF
 VAR BTNW=8
 VAR BTNH=H
 GBOXWINDOW WND,0,0,W-BTNW-1,H,RGB(0,0,0)
 DropDownListBtn WND,FALSE
 IF GENDWINDOW(WND)THEN RETURN
END
COMMON DEF DropDownListLMD WND,CT,T,X,Y
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 VAR BTNW=8
 VAR BTNH=H
 IF W-BTNW<=X THEN
  IF GBEGINWINDOW(WND)THEN RETURN
  DropDownListBtn WND,TRUE
  IF GENDWINDOW(WND)THEN RETURN
  ShowDropDownListBox WND
 ENDIF
END
COMMON DEF DropDownListLMU WND,CT,T,X,Y
 IF GBEGINWINDOW(WND)THEN RETURN
 DropDownListBtn WND,FALSE
 IF GENDWINDOW(WND)THEN RETURN
END
COMMON DEF GetDropDownListHeight()
 RETURN 11
END
COMMON DEF GetDropDownListBox(WND)
 VAR LSTBOX=GetWindowVar(WND,0)
 IF!LSTBOX THEN
  VAR E
  NewWindowEx CTL_DRPDWNBOXCTL,"",0,0,0,0,GetRootWindow(),0,WindowNeverActiveStyle(),0,0 OUT LSTBOX,E
  VOID SetSysWindowProperty(LSTBOX,"SHADOW",FALSE)
  IF E THEN @ERR
  SetWindowVar WND,0,LSTBOX
  IF JoinWindowGroup(WND,LSTBOX) THEN @ERR
 ENDIF
 RETURN LSTBOX
 @ERR
 RETURN 0
END
DEF ShowDropDownListBox WND
 VAR LSTBOX=GetDropDownListBox(WND)
 VAR PARENT=GetParentWindow(LSTBOX)
 VAR PH=GetWindowHeight(PARENT)
 VAR X=GetWindowAX(WND)
 VAR Y=GetWindowAY(WND)
 VAR W=GetWindowWidth(WND)
 VAR H=64
 INC Y,GetWindowHeight(WND)
 IF Y+H>=PH THEN
  Y=GetWindowAY(WND)-H
 ENDIF
 IF MoveResizeWindow(LSTBOX,X,Y,W,H)||FrontWindow(LSTBOX)||ShowWindow(LSTBOX)||FocusWindow(LSTBOX)THEN @ERR
 RETURN
 @ERR
 RETURN
END
COMMON DEF DropDownListNotif WND,CT,T,A1,A2
 VAR L=GetWindowVar(WND,0)
 IF L&&L==A1 THEN
  VOID HideWindow(L)
  VOID SendNotifWindow(GetOwnerWindow(WND),A1,A2)
 ENDIF
END
COMMON DEF DropDownListDelete WND,CT,T,F,A2
' VOID DeleteWindow(GetWindowVar(WND,0))
END
COMMON DEF DropDownListBoxChFocus WND,CT,T,F,A2
 IF !F&&!IsChildWindow(WND,A2) THEN
  IF HideWindow(WND)THEN RETURN
  VOID RepaintWindow(GetWindowGroupOwner(WND))
 ENDIF
END
COMMON DEF DropDownListBoxCWIN WND,CLT,TYP,ETYP,A
 VAR E=CallBaseControlHandler(WND,CLT,TYP,ETYP,A)
 IF E THEN RETURN
 IF ETYP==WindowLostInputEvent()&&!IsChildWindow(WND,A) THEN
  IF HideWindow(WND)THEN RETURN
  VOID RepaintWindow(GetWindowGroupOwner(WND))
 ENDIF
END
COMMON DEF NewHScrollBar PARENT,SIZ OUT WND,E
 VAR W=GetWindowWidth(PARENT)
 VAR H=GetWindowHeight(PARENT)
 NewWindow GetHScrollBarControl(),"",0,H-GetScrollBarHeight(),W,GetScrollBarHeight(),PARENT,0 OUT WND,E
 SetWindowVar WND,1,SIZ
 SetScrollBarAutoResizeMode WND,1
END
COMMON DEF NewHVScrollBar PARENT,SIZH,SIZV OUT WNDH,WNDV,E
 VAR W=GetWindowWidth(PARENT)
 VAR H=GetWindowHeight(PARENT)
 NewWindow GetHScrollBarControl(),"",0,H-GetScrollBarHeight(),W-GetScrollBarWidth(),GetScrollBarHeight(),PARENT,0 OUT WNDH,E
 IF E THEN RETURN
 SetWindowVar WNDH,1,SIZH
 SetScrollBarAutoResizeMode WNDH,2

 NewWindow GetVScrollBarControl(),"",W-GetScrollBarWidth(),0,GetScrollBarWidth(),H-GetScrollBarHeight(),PARENT,0 OUT WNDV,E
 IF E THEN
  VOID DeleteWindow(WNDH)
  WNDV=0
  RETURN
 ENDIF
 SetScrollBarAutoResizeMode WNDV,2
 SetWindowVar WNDV,1,SIZV
END
COMMON DEF NewVScrollBar PARENT,SIZ OUT WND,E
 VAR W=GetWindowWidth(PARENT)
 VAR H=GetWindowHeight(PARENT)
 NewWindow GetVScrollBarControl(),"",W-GetScrollBarWidth(),0,GetScrollBarWidth(),H,PARENT,0 OUT WND,E
 SetWindowVar WND,1,SIZ
 SetScrollBarAutoResizeMode WND,1
END
COMMON DEF GetScrollBarHeight()
 RETURN 8
END
COMMON DEF GetScrollBarWidth()
 RETURN 8
END
COMMON DEF SetScrollBarSize W,SIZ
 IF GetWindowVar(W,1)==SIZ THEN RETURN
 SetWindowVar W,1,SIZ
 VOID RepaintWindow(W)
 VAR POS=GetWindowVar(W,2)
 IF POS>SIZ THEN
  SetWindowVar W,2,SIZ
  VOID SendNotifWindow(GetParentWindow(W),W,SIZ)
 ENDIF
END
COMMON DEF GetScrollBarSize(W)
 RETURN GetWindowVar(W,1)
END
COMMON DEF IncScrollBarSize W
 SetWindowVar W,1,GetWindowVar(W,1)+1
 VOID RepaintWindow(W)
END
COMMON DEF SetScrollBarPosition W,POS
 IF POS<0||POS>GetScrollBarSize(W)THEN RETURN
 SetWindowVar W,2,POS
 VOID RepaintWindow(W)
END
COMMON DEF GetScrollBarPosition(W)
 RETURN GetWindowVar(W,2)
END
COMMON DEF SetScrollBarAutoResizeMode WND,MODE
 SetWindowVar WND,4,MODE
END
'MESS
DEF HSCRBARCalcPos W,_W,POS OUT BS,S
 VAR AH=_W-18
 VAR SIZ=GetWindowVar(W,1)
 'Barのながさ
 BS=AH-SIZ
 S=8+POS
 '10いか
 IF BS<10THEN
  BS=10
  IF SIZ THEN S=(S-9)*((AH-10)/SIZ)+9
 ENDIF
END
DEF HSCRBARCalcPosInv W,_W,POS OUT BS,S
 VAR AH=_W-18
 VAR SIZ=GetWindowVar(W,1)
 'Barのながさ
 BS=AH-SIZ
 S=POS-8
 '10いか
 IF BS<10THEN
  BS=10
  IF SIZ THEN S=S/((AH-10)/SIZ)
 ENDIF
 S=MIN(MAX(0,S),SIZ)
END
DEF HSCRBARPainter W,_,T,XY,WH
 IF GBEGINWindow(W)THEN RETURN
 GCLSWindow W,WIN_BKGND
 
 VAR _W=GetWindowWidth(W)
 VAR _H=GetWindowHeight(W)
 VAR BTNSIZ=8
 GBOXWindow W,0,0,_W,_H,RGB(0,0,0)
 VAR ID=GetWindowVar(W,3)
 '====
 'BOX
 VAR C=RGB(0,0,0)
 IF ID==2THEN
  VAR P=1
  '
  GFILLWindow W,3+P,5+P,6+P,3+P,C
  GFILLWindow W,4+P,6+P,4+P,2+P,C
  GPSETWindow W,2+P,4+P,C
  
  GLINEWindow W,0,0,0,7,C
  GLINEWindow W,0,0,7,0,C
  GLINEWindow W,8,0,8,8,-1
  GLINEWindow W,0,8,8,8,-1
 ELSE
  GLINEWindow W,0,0,0,7,-1
  GLINEWindow W,0,0,7,0,-1

  GLINEWindow W,8,0,8,8,C
  '
  GFILLWindow W,3,5,6,3,C
  GFILLWindow W,4,6,4,2,C
  GPSETWindow W,2,4,C
 ENDIF
 SetWindowDrawPos W,_W-BTNSIZ,0
 '====
 IF ID==3THEN
  'BOX
  GLINEWindow W,0,_H-1,0,_H-8,C
  GLINEWindow W,0,_H-8,7,_H-8,C
  
  GLINEWindow W,0,_H,8,_H,-1
  GLINEWindow W,8,_H-8,8,_H,-1
  '
  P=1
  GFILLWindow W,2+P,5+P,5+P,3+P,C
  GFILLWindow W,4+P,6+P,4+P,2+P,C
  GPSETWindow W,6+P,4+P,C
 ELSE
  'BOX
  GLINEWindow W,0,_H-1,0,_H-8,-1
  GLINEWindow W,0,_H-8,7,_H-8,-1
  '
  GFILLWindow W,2,5,5,3,C
  GFILLWindow W,4,6,4,2,C
  GPSETWindow W,6,4,C
 ENDIF
 SetWindowDrawPos W,1,1
 
 
 '==BAR==
 VAR BS,S
 HSCRBARCalcPos W,_W,GetWindowVar(W,2) OUT BS,S
 VAR C2=RGB(128,128,128)
 '
 VAR BH=BTNSIZ-2
 GLINEWindow W,S+1,0,S+1,BH,-1
 GLINEWindow W,S+1,0,S+BS,0,-1
 '
 GLINEWindow W,BS+S-1,0,BS+S-1,BH,C2
 GLINEWindow W,S+1,BH,S+BS-1,BH,C2
 '   
 GLINEWindow W,S,0,S,BH,C
 GLINEWindow W,S+BS,0,S+BS,BH,C
 
 IF GENDWindow(W)THEN RETURN
END
DEF HSCRBARLMouseUP W,C,T,X,Y
 IF GetWindowVar(W,3)THEN SetWindowVar W,3,8
 VOID ReleaseCapture(W)
 HSCRBARPainter W,C,0,0,0
END
DEF HSCRBARTimer WND,TIMER,ARG
 HSCRBARLMouseDown WND,0,-1,GetWindowMouseX(WND),GetWindowMouseY(WND)
END
DEF HSCRBARLMouseDown W,C,T,Y,_
 VAR ID=GetWindowVar(W,3)
 VAR BS,S
 VAR _W=GetWindowWidth(W)
 HSCRBARCalcPos W,_W,GetWindowVar(W,2) OUT BS,S
 IF ID<8THEN
  IF!ID THEN
   ID=1
   IF Y<9THEN
    ID=2
   ELSEIF Y>GetWindowWidth(W)-9THEN
    ID=3
   ELSE
    IF Y-S>BS THEN
     ID=5
     VAR YY
     HSCRBARCalcPosInv W,_W,Y-BS OUT ,YY
     SetWindowVar W,5,YY
    ELSEIF Y-S<0THEN
     ID=4
     HSCRBARCalcPosInv W,_W,Y OUT ,YY
     SetWindowVar W,5,YY
    ELSE
     SetWindowVar W,5,S-Y
    ENDIF
   ENDIF
   SetWindowVar W,3,ID
  ENDIF
  VOID SetCapture(W)
  SetTimer W,16,0,"HSCRBARTimer" OUT ,'LMouseDownWindow(W)
 ELSE
  SetWindowVar W,3,0
  RETURN
 ENDIF
 VAR SIZ=GetWindowVar(W,1)
 VAR POS=GetWindowVar(W,2)

 IF (ID==4||ID==2)&&POS>0 THEN
  IF ID==4 THEN
   IF GetWindowVar(W,5)>POS THEN RETURN
  ENDIF
  SetWindowVar W,2,POS-1
  HSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,POS-1)
 ENDIF
 IF (ID==5||ID==3)&&POS<SIZ THEN
  IF ID==5 THEN
   IF GetWindowVar(W,5)<POS THEN RETURN
  ENDIF
  SetWindowVar W,2,POS+1
  HSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,POS+1)
 ENDIF
 IF ID==1THEN
  VAR _Y=POS'Y
  IF!SIZ THEN RETURN
  Y=Y+GetWindowVar(W,5)
  HSCRBARCalcPosInv W,_W,Y OUT BS,Y
  IF Y==_Y THEN RETURN
  SetWindowVar W,2,Y
  HSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,Y)
 ENDIF
END

DEF HSCRBARPARENT W,C,T,TYP,A
 VAR E=CallBaseControlHandler(W,C,T,TYP,A)
 IF TYP==ParentWindowResizeEvent()THEN
  VAR MODE=GetWindowVar(W,4)
  IF!MODE THEN RETURN
  VAR PW=GetParentWindow(W)
  VAR WIDTH=GetWindowWidth(PW)
  VAR HEIGHT=GetWindowHeight(PW)
  IF MODE==2THEN WIDTH=WIDTH-GetScrollBarWidth()
  VOID MoveResizeWindow(W,0,HEIGHT-GetScrollBarHeight(),WIDTH,GetScrollBarHeight())
 ENDIF
END
'WV:1
'WV:2
'WV:3
'WV:4
'WV:
DEF VSCRBARPARENT W,C,T,TYP,A
 VAR E=CallBaseControlHandler(W,C,T,TYP,A)
 IF TYP==ParentWindowResizeEvent()THEN
  VAR MODE=GetWindowVar(W,4)
  IF!MODE THEN RETURN
  VAR PW=GetParentWindow(W)
  VAR WIDTH=GetWindowWidth(PW)
  VAR HEIGHT=GetWindowHeight(PW)
  IF MODE==2THEN HEIGHT=HEIGHT-GetScrollBarHeight()
  VOID MoveResizeWindow(W,WIDTH-GetScrollBarWidth(),0,GetScrollBarWidth(),HEIGHT)
 ENDIF
END

DEF VSCRBARCalcPos W,_H,POS OUT BS,S
 VAR AH=_H-18
 VAR SIZ=GetWindowVar(W,1)
 'Barのながさ
 BS=AH-SIZ
 S=9+POS
 '10いか
 IF BS<10THEN
  BS=10
  IF SIZ THEN S=(S-9)*((AH-10)/SIZ)+9
 ENDIF
END
DEF VSCRBARCalcPosInv W,_H,POS OUT BS,S
 VAR AH=_H-18
 VAR SIZ=GetWindowVar(W,1)
 'Barのながさ
 BS=AH-SIZ
 S=POS-9
 '10いか
 IF BS<10THEN
  BS=10
  IF SIZ THEN S=S/((AH-10)/SIZ)
 ENDIF
 S=MIN(MAX(0,S),SIZ)
END
DEF VSCRBARPainter W,_,T,XY,WH
 IF GBEGINWindow(W)THEN RETURN
 GCLSWindow W,WIN_BKGND
 VAR _W=GetWindowWidth(W)
 VAR _H=GetWindowHeight(W)
 GBOXWindow W,0,0,_W,_H,RGB(0,0,0)
 VAR ID=GetWindowVar(W,3)
 '====
 'BOX
 VAR C=RGB(0,0,0)
 IF ID==2THEN
  VAR P=1
  GLINEWindow W,4+P,2+P,2+P,4+P,C
  GFILLWindow W,3+P,3+P,5+P,6+P,C
  GPSETWindow W,6+P,4+P,C
  GLINEWindow W,P,8+P,8+P,8+P,C
  
  GLINEWindow W,0,0,0,7,C
  GLINEWindow W,0,0,7,0,C
  GLINEWindow W,8,0,8,8,-1
  GLINEWindow W,0,8,8,8,-1
 ELSE
  GLINEWindow W,0,0,0,7,-1
  GLINEWindow W,0,0,7,0,-1
  '
  GLINEWindow W,4,2,2,4,C
  GFILLWindow W,3,3,5,6,C
  GPSETWindow W,6,4,C
  GLINEWindow W,0,8,8,8,C
 ENDIF
 '====
 IF ID==3THEN
  'BOX
  GLINEWindow W,0,_H-1,0,_H-8,C
  GLINEWindow W,0,_H-8,7,_H-8,C
  
  GLINEWindow W,0,_H,8,_H,-1
  GLINEWindow W,8,_H-8,8,_H,-1
  '
  P=1
  GLINEWindow W,2+P,_H-4+P,4+P,_H-2+P,C
  GFILLWindow W,3+P,_H-6+P,5+P,_H-3+P,C
  GPSETWindow W,6+P,_H-4+P,C
 ELSE
  'BOX
  GLINEWindow W,0,_H-1,0,_H-8,-1
  GLINEWindow W,0,_H-8,7,_H-8,-1
  '
  GLINEWindow W,2,_H-4,4,_H-2,C
  GFILLWindow W,3,_H-6,5,_H-3,C
  GPSETWindow W,6,_H-4,C
 ENDIF
 VAR BS,S
 VSCRBARCalcPos W,_H,GetWindowVar(W,2) OUT BS,S
 '==BAR==
 GLINEWindow W,1,S,_W-1,S,C
 GLINEWindow W,1,S+BS,_W-1,S+BS,C
 GLINEWindow W,_W-1,S+1,_W-1,S+BS-2,RGB(128,128,128)
 GLINEWindow W,1,S+BS-1,_W-1,S+BS-1,RGB(128,128,128)
 GLINEWindow W,1,S+1,1,S+BS-2,-1
 GLINEWindow W,1,S+1,_W-2,S+1,-1
 IF GENDWindow(W)THEN RETURN
END
DEF VSCRBARLMouseUP W,C,T,X,Y
 IF GetWindowVar(W,3)THEN SetWindowVar W,3,8
 VOID ReleaseCapture(W)
 VSCRBARPainter W,C,0,0,0
END
DEF VSCRBARTimer WND,TIMER,ARG
 VSCRBARLMouseDown WND,0,-1,GetWindowMouseX(WND),GetWindowMouseY(WND)
END
DEF VSCRBARLMouseDown W,C,T,X,Y
 VAR ID=GetWindowVar(W,3)
 VAR BS,S
 VAR _H=GetWindowHeight(W)
 VSCRBARCalcPos W,_H,GetWindowVar(W,2) OUT BS,S
 IF ID<8THEN
  IF!ID THEN
   ID=1
   IF Y<9THEN
    ID=2
   ELSEIF Y>GetWindowHeight(W)-9THEN
    ID=3
   ELSE
    IF Y-S>BS THEN
     ID=5
     VAR YY
     VSCRBARCalcPosInv W,_H,Y-BS OUT ,YY
     SetWindowVar W,5,YY
    ELSEIF Y-S<0THEN
     ID=4
     VSCRBARCalcPosInv W,_H,Y OUT ,YY
     SetWindowVar W,5,YY
    ELSE
     SetWindowVar W,5,S-Y
    ENDIF
   ENDIF
   SetWindowVar W,3,ID
  ENDIF
  VOID SetCapture(W)
  SetTimer W,16,0,"VSCRBARTimer" OUT ,'LMouseDownWindow(W)
 ELSE
  SetWindowVar W,3,0
  RETURN
 ENDIF
 VAR SIZ=GetWindowVar(W,1)
 VAR POS=GetWindowVar(W,2)
 IF (ID==4||ID==2)&&POS>0 THEN
  IF ID==4 THEN
   IF GetWindowVar(W,5)>POS THEN RETURN
  ENDIF
  SetWindowVar W,2,POS-1
  VSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,POS-1)
 ENDIF
 IF (ID==5||ID==3)&&POS<SIZ THEN
  IF ID==5 THEN
   IF GetWindowVar(W,5)<POS THEN RETURN
  ENDIF
  SetWindowVar W,2,POS+1
  VSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,POS+1)
 ENDIF
 IF ID==1THEN
  VAR _Y=POS'Y
  Y=Y+GetWindowVar(W,5)
  IF!SIZ THEN RETURN
  VSCRBARCalcPosInv W,_H,Y OUT BS,Y
  IF Y==_Y THEN RETURN
  SetWindowVar W,2,Y
  VSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,Y)
 ENDIF
END
COMMON DEF GSPOITWindow(WND,X,Y)
 IF!CheckWindow(WND)THEN RETURN 0
 INC X,WIN_FX[WND AND NUWIDMASK]
 INC Y,WIN_FY[WND AND NUWIDMASK]
 VAR NUWID=RGBToShort(GSPOIT(OTW_MOUSEX,OTW_MOUSEY+240))
 IF NUWID!=(WND AND NUWIDMASK)THEN RETURN 0
 RETURN GSPOIT(X,Y)
END
DEF XORHLINE Y,X1,X2
 IF X1>X2 THEN SWAP X1,X2
 REPEAT
  GPSET X1,Y,GSPOIT(X1,Y)XOR &HFFFFFF
  X1=X1+1
 UNTIL X1>X2
END
DEF XORVLINE X,Y1,Y2
 IF Y1>Y2 THEN SWAP Y1,Y2
 REPEAT
  GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
  Y1=Y1+1
 UNTIL Y1>Y2
END
DEF FASTINVERTGFILL X1,Y1,X2,Y2
 DIM A[0]
 IF X1>X2 THEN SWAP X1,X2
 IF Y1>Y2 THEN SWAP Y1,Y2
 GSAVE X1,Y1,X2-X1+1,Y2-Y1+1,A,1
 ARYOP #AOPSUB,A,65536,A
 GLOAD X1,Y1,X2-X1+1,Y2-Y1+1,A,1,1
END
DEF SLOWINVERTGFILL X1,Y1,X2,Y2
 IF X1>X2 THEN SWAP X1,X2
 IF Y1>Y2 THEN SWAP Y1,Y2
 REPEAT
  VAR X=X1
  REPEAT
   GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
   X=X+1
  UNTIL X>X2
  Y1=Y1+1
 UNTIL Y1>Y2
END
DEF XORGBOX X1,Y1,X2,Y2
 IF X1>X2 THEN SWAP X1,X2
 IF Y1>Y2 THEN SWAP Y1,Y2
 XORGBOX2 X1,Y1,X2,Y2
 XORGBOX2 X1+1,Y1+1,X2-1,Y2-1
END
DEF OTW_MOVWIN_XORGBOX_THICK1 X1,Y1,X2,Y2
 VAR X,Y
 VAR _=Y1 AND 1
 FOR X=X1 TO X2
  IF X+_ AND 1 THEN CONTINUE
  GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
 NEXT
 FOR X=X1 TO X2
  IF !(X+_ AND 1) THEN CONTINUE
  GPSET X,Y1+1,GSPOIT(X,Y1+1) XOR &HFFFFFF
 NEXT
 _=Y2 AND 1
 FOR X=X1 TO X2
  IF X+_ AND 1 THEN CONTINUE
  GPSET X,Y2,GSPOIT(X,Y2) XOR &HFFFFFF
 NEXT
 FOR X=X1 TO X2
  IF !(X+_ AND 1) THEN CONTINUE
  GPSET X,Y2-1,GSPOIT(X,Y2-1) XOR &HFFFFFF
 NEXT

 _=X1 AND 1
 FOR Y=Y1+2 TO Y2-2
  IF Y+_ AND 1 THEN CONTINUE
  GPSET X1,Y,GSPOIT(X1,Y) XOR &HFFFFFF
 NEXT
 FOR Y=Y1+2 TO Y2-2
  IF !(Y+_ AND 1) THEN CONTINUE
  GPSET X1+1,Y,GSPOIT(X1+1,Y) XOR &HFFFFFF
 NEXT
 _=X2 AND 1
 FOR Y=Y1+2 TO Y2-2
  IF Y+_ AND 1 THEN CONTINUE
  GPSET X2,Y,GSPOIT(X2,Y) XOR &HFFFFFF
 NEXT
 FOR Y=Y1+2 TO Y2-2
  IF !(Y+_ AND 1) THEN CONTINUE
  GPSET X2-1,Y,GSPOIT(X2-1,Y) XOR &HFFFFFF
 NEXT
END
'FAST
'
'      
'      
'      
'
DEF OTW_MOVWIN_XORGBOX_THICK X1,Y1,X2,Y2
 VAR X,Y
 VAR Y1_OFF=Y1 AND 1
 VAR Y2_OFF=Y2 AND 1
 VAR X1_OFF=X1 AND 1
 VAR X2_OFF=X2 AND 1
 VAR Y1_1=Y1+1
 VAR Y2_1=Y2-1
 VAR X1_1=X1+1
 VAR X2_1=X2-1
 VAR C1=X1+Y1_OFF AND 1
 VAR C2=X1+Y2_OFF AND 1
 IF C1&&C2 THEN
  X=X1
  VAR XX=X+1
  REPEAT
   GPSET X,Y1_1,GSPOIT(X,Y1_1) XOR &HFFFFFF
   GPSET XX,Y1,GSPOIT(XX,Y1) XOR &HFFFFFF
   GPSET X,Y2_1,GSPOIT(X,Y2_1) XOR &HFFFFFF
   GPSET XX,Y2,GSPOIT(XX,Y2) XOR &HFFFFFF
   X=X+2
   XX=XX+2
  UNTIL X2_1<X
  IF X2>=X THEN
   GPSET X,Y2_1,GSPOIT(X,Y2_1) XOR &HFFFFFF
   GPSET X,Y1_1,GSPOIT(X,Y1_1) XOR &HFFFFFF
  ENDIF
 ELSEIF C1&&!C2 THEN
  X=X1
  XX=X+1
  REPEAT
   GPSET X,Y1_1,GSPOIT(X,Y1_1) XOR &HFFFFFF
   GPSET XX,Y1,GSPOIT(XX,Y1) XOR &HFFFFFF
   GPSET X,Y2,GSPOIT(X,Y2) XOR &HFFFFFF
   GPSET XX,Y2_1,GSPOIT(XX,Y2_1) XOR &HFFFFFF
   X=X+2
   XX=XX+2
  UNTIL X2_1<X
  IF X2>=X THEN
   GPSET X,Y1_1,GSPOIT(X,Y1_1) XOR &HFFFFFF
   GPSET X,Y2,GSPOIT(X,Y2) XOR &HFFFFFF
  ENDIF
 ELSEIF !C1&&C2 THEN
  X=X1
  XX=X+1
  REPEAT
   GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
   GPSET XX,Y1_1,GSPOIT(XX,Y1_1) XOR &HFFFFFF
   GPSET X,Y2_1,GSPOIT(X,Y2_1) XOR &HFFFFFF
   GPSET XX,Y2,GSPOIT(XX,Y2) XOR &HFFFFFF
   X=X+2
   XX=XX+2
  UNTIL X2_1<X
  IF X2>=X THEN
   GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
   GPSET X,Y2_1,GSPOIT(X,Y2_1) XOR &HFFFFFF
  ENDIF
 ELSE'IF !C1&&!C2 THEN
  X=X1
  XX=X+1
  REPEAT
   GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
   GPSET XX,Y1_1,GSPOIT(XX,Y1_1) XOR &HFFFFFF
   GPSET X,Y2,GSPOIT(X,Y2) XOR &HFFFFFF
   GPSET XX,Y2_1,GSPOIT(XX,Y2_1) XOR &HFFFFFF
   X=X+2
   XX=XX+2
  UNTIL X2_1<X
  IF X2>=X THEN
   GPSET X,Y1,GSPOIT(X,Y1) XOR &HFFFFFF
   GPSET X,Y2,GSPOIT(X,Y2) XOR &HFFFFFF
  ENDIF
 ENDIF
 Y2=Y2-2
 Y2_1=Y2_1-2
 C1=Y1+2+X1_OFF AND 1
 C2=Y1+X2_OFF+2 AND 1
 IF !C1&&!C2 THEN
  Y=Y1+2
  VAR YY=Y+1
  REPEAT
   GPSET X1,Y,GSPOIT(X1,Y) XOR &HFFFFFF
   GPSET X1_1,YY,GSPOIT(X1_1,YY) XOR &HFFFFFF
   GPSET X2,Y,GSPOIT(X2,Y) XOR &HFFFFFF'!C2
   GPSET X2_1,YY,GSPOIT(X2_1,YY) XOR &HFFFFFF
   Y=Y+2
   YY=YY+2
  UNTIL Y2_1<Y
  IF Y2>=Y THEN
   GPSET X1,Y,GSPOIT(X1,Y) XOR &HFFFFFF
   GPSET X2,Y,GSPOIT(X2,Y) XOR &HFFFFFF'!C2
  ENDIF
 ELSEIF !C1&&C2 THEN
  Y=Y1+2
  YY=Y+1
  REPEAT
   GPSET X1,Y,GSPOIT(X1,Y) XOR &HFFFFFF'!C1
   GPSET X1_1,YY,GSPOIT(X1_1,YY) XOR &HFFFFFF
   GPSET X2_1,Y,GSPOIT(X2_1,Y) XOR &HFFFFFF'C2
   GPSET X2,YY,GSPOIT(X2,YY) XOR &HFFFFFF
   Y=Y+2
   YY=YY+2
  UNTIL Y2_1<Y
  
  IF Y2>=Y THEN
   GPSET X1,Y,GSPOIT(X1,Y) XOR &HFFFFFF'!C1
   GPSET X2_1,Y,GSPOIT(X2_1,Y) XOR &HFFFFFF'C2
  ENDIF
 ELSEIF C1&&!C2 THEN
  Y=Y1+2
  YY=Y+1
  REPEAT
   GPSET X1_1,Y,GSPOIT(X1_1,Y) XOR &HFFFFFF'C1
   GPSET X1,YY,GSPOIT(X1,YY) XOR &HFFFFFF
   GPSET X2,Y,GSPOIT(X2,Y) XOR &HFFFFFF'!C2
   GPSET X2_1,YY,GSPOIT(X2_1,YY) XOR &HFFFFFF
   Y=Y+2
   YY=YY+2
  UNTIL Y2_1<Y
  IF Y2>=Y THEN
   GPSET X1_1,Y,GSPOIT(X1_1,Y) XOR &HFFFFFF'C1
   GPSET X2,Y,GSPOIT(X2,Y) XOR &HFFFFFF'!C2
  ENDIF
 ELSE'IF C1&&C2 THEN
  Y=Y1+2
  YY=Y+1
  REPEAT
   GPSET X1_1,Y,GSPOIT(X1_1,Y) XOR &HFFFFFF'C1
   GPSET X1,YY,GSPOIT(X1,YY) XOR &HFFFFFF
   GPSET X2_1,Y,GSPOIT(X2_1,Y) XOR &HFFFFFF'C2
   GPSET X2,YY,GSPOIT(X2,YY) XOR &HFFFFFF
   Y=Y+2
   YY=YY+2
  UNTIL Y2_1<Y
  IF Y2>=Y THEN
   GPSET X1_1,Y,GSPOIT(X1_1,Y) XOR &HFFFFFF'C1
   GPSET X2_1,Y,GSPOIT(X2_1,Y) XOR &HFFFFFF'C2
  ENDIF
 ENDIF
END
'=================
DEF OTW_MOVWIN_XORGBOX X1,Y1,X2,Y2
 VAR Y=Y1
 VAR YY=Y1
 VAR OX1=X1
 Y=Y+(X1 AND 1)+(Y1 AND 1)
 IF Y-Y1==2 THEN
  Y=Y1
 ENDIF
 IF Y==Y1 THEN
  Y=Y+2
 ENDIF
 YY=YY+(X2 AND 1)+(Y1 AND 1)
 IF YY-Y1==2 THEN
  YY=Y1
 ENDIF
 IF YY==Y1 THEN
  YY=YY+2
 ENDIF
 VAR _=Y2-1
 REPEAT
  GPSET X1,Y,GSPOIT(X1,Y) XOR &HFFFFFF
  GPSET X2,YY,GSPOIT(X2,YY) XOR &HFFFFFF
  Y=Y+2
  YY=YY+2
 UNTIL Y>_
 VAR XX=X1
 XX=XX+(X1 AND 1)+(Y2 AND 1)
 IF XX-X1==2 THEN
  XX=X1
 ENDIF
 _=X1
 X1=X1+(X1 AND 1)+(Y1 AND 1)
 IF X1-_==2 THEN
  X1=_
 ENDIF
 X2=X2-1
 REPEAT
  GPSET X1,Y1,GSPOIT(X1,Y1) XOR &HFFFFFF
  GPSET XX,Y2,GSPOIT(XX,Y2) XOR &HFFFFFF
  X1=X1+2
  XX=XX+2
 UNTIL X1>X2
 IF XX<=X2+1 THEN
  GPSET XX,Y2,GSPOIT(XX,Y2) XOR &HFFFFFF
 ENDIF
 IF X1<=X2+1 THEN
  GPSET X1,Y1,GSPOIT(X1,Y1) XOR &HFFFFFF
 ENDIF
END
DEF XORGBOX2 X1,Y1,X2,Y2
 XORHLINE Y1,X1,X2
 IF Y1==Y2 THEN RETURN
 XORHLINE Y2,X1,X2
 IF Y1>Y2 THEN SWAP Y1,Y2
 IF Y1+1>=Y2 THEN RETURN
 XORVLINE X1,Y1+1,Y2-1
 XORVLINE X2,Y1+1,Y2-1
END
DEF OTW_XORWindow NUWID
 XORGBOX WIN_AX[NUWID],WIN_AY[NUWID],WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID]
END
VAR OTW_CURSOR_ARROW'
VAR OTW_CURSOR_SIZENS'|
VAR OTW_CURSOR_SIZEWE'-
VAR OTW_CURSOR_SIZENWSE'
VAR OTW_CURSOR_SIZENESW'/
VAR OTW_CURSOR_WAIT
VAR OTW_CURSOR_BEAM
COMMON DEF GetArrowCursor()
 RETURN OTW_CURSOR_ARROW
END
COMMON DEF GetSizeNSCursor()
 RETURN OTW_CURSOR_SIZENS
END
COMMON DEF GetSizeWECursor()
 RETURN OTW_CURSOR_SIZEWE
END
COMMON DEF GetSizeNWSECursor()
 RETURN OTW_CURSOR_SIZENWSE
END
COMMON DEF GetSizeNESWCursor()
 RETURN OTW_CURSOR_SIZENESW
END
COMMON DEF GetWaitCursor()
 RETURN OTW_CURSOR_WAIT
END
COMMON DEF GetBeamCursor()
 RETURN OTW_CURSOR_BEAM
END
DEF OTW_LOAD_CUR
 VAR ERR
 RESTORE @ARROW
 NewImageFromDATA OUT OTW_CURSOR_ARROW,ERR
 RESTORE @SIZENS
 NewImageFromDATA OUT OTW_CURSOR_SIZENS,ERR
 SetImageHotspot OTW_CURSOR_SIZENS,4,10 OUT ERR
 RESTORE @SIZENWSE
 NewImageFromDATA OUT OTW_CURSOR_SIZENWSE,ERR
 SetImageHotspot OTW_CURSOR_SIZENWSE,7,7 OUT ERR
 RESTORE @WAIT
 NewImageFromDATA OUT OTW_CURSOR_WAIT,ERR
 RotateImage OTW_CURSOR_SIZENS,#SPROT90 OUT OTW_CURSOR_SIZEWE,ERR
 RotateImage OTW_CURSOR_SIZENWSE,#SPREVH OUT OTW_CURSOR_SIZENESW,ERR
 RESTORE @BEAM
 NewImageFromDATA OUT OTW_CURSOR_BEAM,ERR
 SetImageHotspot OTW_CURSOR_BEAM,2,5 OUT ERR
 VAR ATR
 GetImageAttr OTW_CURSOR_BEAM OUT ATR,ERR
 IF !ERR THEN
  SetImageAttr OTW_CURSOR_BEAM,ImageAttrHideShadow() OR ATR OUT ERR
 ENDIF
 @ARROW
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 10,16
 DATA "1         
 DATA "11        
 DATA "1F1       
 DATA "1FF1      
 DATA "1FFF1     
 DATA "1FFFF1    
 DATA "1FFFFF1   
 DATA "1FFFFFF1  
 DATA "1FFFFFFF1 
 DATA "1FFFFF1111
 DATA "1FF1FF1   
 DATA "1F1 1FF1  
 DATA "11  1FF1  
 DATA "1    1FF1 
 DATA "     1FF1 
 DATA "      11  
 @SIZENS
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 9,21
 DATA "    F    
 DATA "   F1F   
 DATA "  F111F  
 DATA " F11111F 
 DATA "F1111111F
 DATA "FFFF1FFFF
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "FFFF1FFFF
 DATA "F1111111F
 DATA " F11111F 
 DATA "  F111F  
 DATA "   F1F   
 DATA "    F    
 @SIZENWSE
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 15,15
 DATA "FFFFFFF        
 DATA "F11111F        
 DATA "F1111F         
 DATA "F111F          
 DATA "F11F1F         
 DATA "F1F F1F        
 DATA "FF   F1F       
 DATA "      F1F      
 DATA "       F1F   FF
 DATA "        F1F F1F
 DATA "         F1F11F
 DATA "          F111F
 DATA "         F1111F
 DATA "        F11111F
 DATA "        FFFFFFF
 DATA "
 @WAIT
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 11,20
 DATA "11111111111
 DATA "11FFFFFFF11
 DATA "11111111111
 DATA "1FFFFFFFFF1
 DATA "1FFFFFFFFF1
 DATA "1FFFFFFFFF1
 DATA "1FFFF1FFFF1
 DATA "11FF1F1FF11
 DATA " 11FF1FF11 
 DATA "  11FFF11  
 DATA "   11F11   
 DATA "  11FFF11  
 DATA " 11FFFFF11 
 DATA "11FFF1FFF11
 DATA "1FFF1F1FFF1
 DATA "1FF1F1F1FF1
 DATA "1F1F1F1F1F1
 DATA "11111111111
 DATA "11FFFFFFF11
 DATA "11111111111
 @BEAM
 DATA "1",&HFF000000
 DATA "F",&HFFFFFFFF
 DATA ""
 DATA 5,11
 DATA "FFFFF
 DATA "F1F1F
 DATA " F1F 
 DATA " F1F 
 DATA " F1F 
 DATA " F1F 
 DATA " F1F 
 DATA " F1F 
 DATA " F1F 
 DATA "F1F1F
 DATA "FFFFF
END
'CURRENT CURSOR
VAR OTW_CURCUR
COMMON DEF SetCursor(IMG)
 IF OTW_CURCUR==IMG THEN RETURN 0
 RETURN ResetCursor(IMG)
END
COMMON DEF ResetCursor(IMG)
 IF IMG==0 THEN IMG=GetArrowCursor()
 VAR ATR,ERR
 GetImageAttr IMG OUT ATR,ERR
 OTW_CURCUR=IMG
 VAR VP,WP
 GPAGE OUT VP,WP
 IF WP!=OTW_DP THEN
  BACKTRACE
  ?"FIXME:CURSOR"
  RETURN WIN_EVENTERR
 ENDIF
 GPAGE OTW_SP,OTW_DP
 GCLIP 1
 GPSET 408,0,-1
 SPDEF 0,408,0,1,1,1
 VAR OTW_MOUSESP_GX=416
 VAR OTW_MOUSESP_GY=0
 GLOADImage OTW_MOUSESP_GX,OTW_MOUSESP_GY,IMG,TRUE
 VAR HX,HY,E,W,H
 GetImageSize IMG OUT W,H,E
 GetImageHotspot IMG OUT HX,HY,E
 SPCHR OTW_MOUSESP,OTW_MOUSESP_GX,OTW_MOUSESP_GY,W,H
 SPHOME OTW_MOUSESP,HX,HY
 GCLIP 1,0,0,400,239
 SPCHR OTW_SHADOWSP,OTW_MOUSESP_GX,OTW_MOUSESP_GY,W,H
 SPHOME OTW_SHADOWSP,HX,HY

 SPVAR 0,0,1
 SPOFS OTW_MOUSESP,OTW_MOUSEX,OTW_MOUSEY,-256
 SPCOL 0,0,0,1,1

 SPLINK OTW_SHADOWSP,OTW_MOUSESP
 SPOFS OTW_SHADOWSP,-2,2,1
 SPCOLOR OTW_SHADOWSP,RGB(128,0,0,0)
 SPVAR OTW_SHADOWSP,0,1
 IF ATR AND ImageAttrHideShadow()THEN
  SPHIDE OTW_SHADOWSP
 ELSE
  SPSHOW OTW_SHADOWSP
 ENDIF
 RETURN 0
END

COMMON DEF ValidateMML MML$ OUT CHR,ERR
 VAR C=CHKMML(MML$)
 IF C==-1 THEN
  CHR=0
  ERR=0
 ELSE
  CHR=C
  ERR=1
 ENDIF
END
VAR WIN_ROOTCTL
VAR TSTWND,TSTCTL
VAR TSTWND2
VAR TSTWND3

VAR OTW_MOUSELBTN
VAR OTW_MOUSERBTN
VAR OTW_LMOUSEDWN
VAR OTW_LMOUSEUP
VAR OTW_RMOUSEDWN
VAR OTW_RMOUSEUP
VAR OTW_CNT,OTW_FPS,OTW_FPSCNT
VAR OTW_FCNT,OTW_FPF#,OTW_FPFCNT
VAR OTW_KX
VAR OTW_KY
VAR OTW_KX2
VAR OTW_KY2
VAR OTW_USEBTN
VAR OTW_USEMEM
VAR OTW_EXITFLG
VAR OTW_EXITTIME
COMMON DEF ExitWin()
 VAR ERR=DeleteWindow(WIN_ROOTWND2)
 IF ERR THEN RETURN ERR
 ERR=DeleteAllIM()
 IF ERR THEN RETURN ERR
 OTW_EXITFLG=TRUE
 OTW_EXITTIME=MAINCNT+60
 OTW_INIT=FALSE
 RETURN ERR
END
COMMON DEF S_OTW S
 BGMPLAY"L1C>B<C:1L1EDE:2L1GFG:3L1>CGC
END
COMMON DEF GetWinVer$()
 RETURN "5.0 rev58"
END
COMMON DEF GetWinMemorySize()
 RETURN OTW_USEMEM
END
COMMON DEF I_OTW
 IF!OTW_INIT THEN
' KEY 1,"KEY OFF"
  OTW_EXITFLG=FALSE
  OTW_ENABLE_SHADOW=TRUE
  WIN_BKGND=RGB(208,208,208)
  WIN_BTNBACK=RGB(192,192,192)
  WIN_SELCOL=RGB(0,0,136)
  WIN_SELTXTCOL=RGB(255,255,255)
  WIN_WORKSPACECOL=RGB(96,96,96)
  WIN_ACTVCAPCOL=RGB(0,0,136)
  WIN_INACTVCAPCOL=RGB(64,64,64)
  WIN_ACTVCAPTXTCOL=RGB(255,255,255)
  WIN_INACTVCAPTXTCOL=RGB(200,200,200)
  'sound unit
  OTW_CLIPMODE=0
  VAR FM=FREEMEM
  PrintConsole "=================="+LF$()
  PrintConsole "OTYA WINDOW SYSTEM"+LF$()
  PrintConsole "=================="+LF$()
  PrintConsole "Ver "+GetWinVer$()+LF$()
' BEEP 94,-1000
  VAR M1$,M2$,M3$,M4$,M5$,M6$,G$=@77+"V10"'34
  M1$=":1"+G$+"T140<<C8 C8&C2."
  M2$=":2"+G$+"T140<G8 G8&G2."
  M3$=":3"+G$+"T140<E8 E8&E2."
  M4$=":4"+G$+"T140>>>><<G8 G8&G2."
  M5$=":5"+G$+"T140>>>><<E8 E8&E2."
  M6$=":6"+G$+"T140>>>><<C8 C8&C2."
  BGMPLAY M1$+M2$+M3$+M4$+M5$+M6$
'  BEEP 96
  PrintConsole "Loading font..."+LF$()
  OTW_LOADFONT
'  BEEP 97
  PrintConsole "Init..........."+LF$()
  OTWRunning=TRUE
  OTW_WIN_INITARRAY
  OTW_CTL_INITARRAY
  OTW_INIT_ERR
  OTW_IM_INITARRAY
  CLIPBOARD_INIT
  PrintConsoleln "Init setting..."
  OTW_USEBTN=&B11001111
  OTW_FPS=1
  OTW_FPSCNT=1
  OTW_FPF#=1
  OTW_FPFCNT=1
  'ACLS
  OTW_DP=4
  OTW_SP=0
  OTW_BP=1
  OTW_GP=2
  OTW_DDRAWPAGE=2
  PrintConsoleln "Init screen..."
  MouseClipDef
  BACKCOLOR RGB(0,128,128)
  VISIBLE 1,0,0,1
  GPAGE OTW_SP,OTW_DP
  GPRIO 1023
  OTW_INIT=TRUE
  VAR E
  NewControl "ROOT" OUT WIN_ROOTCTL,E
' E=SetControlPainter(WIN_ROOTCTL,"DesktopPainter")
  NewTopLevelWindow WIN_ROOTCTL,"ROOT",400-1,240-1 OUT WIN_ROOTWND,E
  ExtendControl "HELLO",GetWindowControl() OUT TSTCTL,E
' NewTopLevelWindow TSTCTL,"HELLO",164,164 OUT TSTWND,E
' NewTopLevelWindow TSTCTL,"HELLO",64,64 OUT TSTWND2,E
' NewTopLevelWindow TSTCTL,"HELLO",64,64 OUT TSTWND3,E
  E=SetControlPainter(TSTCTL,"HELLOPainter")
  GCLIP 1,0,0,400,239
  VISIBLE 1,1,1,1
  OTW_MOUSEX=(400-16)/2
  OTW_MOUSEY=(240-16)/2
  OTW_MOUSEX#=(400-16)/2
  OTW_MOUSEY#=(240-16)/2
  
  OTW_MOUSELBTN=32OR 256
  OTW_MOUSERBTN=16OR 512
  OTW_LMOUSEDWN=1
  OTW_LMOUSEUP =2
  OTW_RMOUSEDWN=4
  OTW_RMOUSEUP =8
  DEC FM,FREEMEM
  OTW_USEMEM=FM
  PrintConsoleln FORMAT$("UsingMemory8192KB/%DKB",FM/1024)+LF$()
  
  '290
  SPSET OTW_MOUSESP,0
  OTW_SHADOWSP=1
  SPSET OTW_SHADOWSP,0
  OTW_LOAD_CUR
  VOID SetCursor(GetArrowCursor())
  OTW_MOVWINSP=2
  OTW_MOVWIN_HNDLR$="OTW_MOVWIN_HNDLR_XOR"
  SPSET OTW_MOVWINSP,0
  SPHIDE OTW_MOVWINSP
  SPVAR OTW_MOVWINSP,0,1
  OTW_MOVWINCOL=RGB(128,128,128,128)
  OTW_MOVWINCOL=RGB(128,255,255,255)
  SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
  CLS
  LOCATE 0,29
  WIN_IM$="RIM"
  WIN_SHELL$="ODE"
  VOID OTW_LOADCONF("/TXT/OTW.CONF")
  IF!LEN(WIN_IM$)THEN
   WIN_IM$="DEFIM"
  ENDIF
  NewProcess WIN_IM$,"" OUT E,E
'  WIN_SHELL$="DLGED"
  IF LEN(WIN_SHELL$)THEN
   NewProcess WIN_SHELL$,"" OUT E,E
  ENDIF
  OTW_ASSOC_INIT
  BREPEAT 0,15,4
  BREPEAT 1,15,4
  BREPEAT 2,15,4
  BREPEAT 3,15,4
 ENDIF
RETURN
END
DEF OTW_LOADCONF FILE$ OUT ERR
 VAR RES$
 LoadFile FILE$ OUT RES$,ERR
 IF ERR THEN RETURN
 IF 0THEN DIM KEYS$[0],VALUES$[0]
 LoadConfigFile RES$ OUT KEYS$,VALUES$
 OTW_CONF_KEY$=KEYS$
 OTW_CONF_VALUE$=VALUES$
 VAR SHELL=FindArray(KEYS$,"SHELL")
 IF SHELL!=-1THEN
  WIN_SHELL$=VALUES$[SHELL]
 ENDIF
 VAR IM=FindArray(KEYS$,"IM")
 IF IM!=-1THEN
  WIN_IM$=VALUES$[IM]
 ENDIF
END
COMMON DEF HELLOPainter WND,CTL,TYPE,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYPE,A1,A2)
 E=GBEGINWindow(WND)
 IF E THEN RETURN
 GFILLWindow WND,0,0,64,64,RGB(224-224,224,224)'RGB(0,0,0)
 VAR S$="HELLOWORLD",I
 FOR I=0TO LEN(S$)-1
  GPRINTWindowCC WND,6+I*8,1,S$[I],I
 NEXT
 E=GENDWindow(WND)
END
VAR OTW_OLDMOUSEX
VAR OTW_OLDMOUSEY
DEF OTWGetOvMouseNUWID()
 RETURN RGBToShort(GSPOIT(OTW_MOUSEX,OTW_MOUSEY+240))
END
VAR OTW_OLDLMOUSE
VAR OTW_OLDRMOUSE
VAR OTW_FDIFF
VAR OTW_OLDBTN
VAR OTW_OLDBTNF
VAR OLDMOVEMOUSEWINDOW
VAR OTW_ENKEY_STATE
VAR OTW_ENABLEKEY
VAR OTW_PRC_CHK
COMMON DEF L_OTW
' VAR X,Y,MMM
' TOUCH OUT MMM,X,Y
' IF MMM&&!OTW_ENKEY_STATE&&X>=5&&X<=63&&Y>=5&&Y<=16THEN
'  OTW_ENKEY_STATE=1
'  OTW_ENABLEKEY=!OTW_ENABLEKEY
'  IF OTW_ENABLEKEY THEN
'   KEY 1,"KEY ON"
'  ELSE
'   KEY 1,"KEY OFF"
'  ENDIF
'  BEEP 9
' ENDIF
' IF!MMM THEN OTW_ENKEY_STATE=0
 VAR MOVEMOUSE
 UpdateMouse
 IF OTW_MOUSEX!=OTW_OLDMOUSEX THEN MOVEMOUSE=1
 IF OTW_MOUSEY!=OTW_OLDMOUSEY THEN MOVEMOUSE=1
 VAR NUWID,E
 VAR BTN=UpdateButton()
 IF MOVEMOUSE||BTN THEN
  NUWID=OTWGetOvMouseNUWID()
 ENDIF
 IF BTN THEN
  'LEFT MOUSE DOWN
  IF BTN AND OTW_LMOUSEDWN THEN
   CAPTURE_WND=0
   E=FocusWindow(NUWIDToWND(NUWID AND 32767))
   VAR F=MAINCNT
   IF NUWID==OTW_LCLKWND&&F-OTW_LCLKF<=OTW_DBLCLKF&&ABS(OTW_MOUSEY-OTW_DBLCLKY)<OTW_DBLCLKXY&&ABS(OTW_MOUSEX-OTW_DBLCLKX)<OTW_DBLCLKXY THEN
    OTW_LCLKWND=0
    IF NUWID AND WIN_FRAMEFLG THEN
     E=LMouseDblClickWindowOnFrame(NUWIDToWND(NUWID AND 32767))
    ELSE
     IF LEN(CTL_HANDLER$[WIN_CTL[NUWID]AND 4095,CTL_LDBLCLKHANDLER])THEN
      E=LDoubleClickWindow(NUWIDToWND(NUWID))
     ELSE
      E=LMouseDownWindow(NUWIDToWND(NUWID))
     ENDIF
    ENDIF
   ELSE
    OTW_LCLKWND=NUWID
    OTW_LCLKF=F
    OTW_DBLCLKX=OTW_MOUSEX
    OTW_DBLCLKY=OTW_MOUSEY
    IF NUWID AND WIN_FRAMEFLG THEN
     E=LMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
    ELSE
     E=LMouseDownWindow(NUWIDToWND(NUWID))
    ENDIF
   ENDIF
  ENDIF
  IF BTN AND OTW_LMOUSEUP THEN
   IF WIN_DRAGHANDLER_USE THEN
    MoveWindowSP TRUE
   ELSE
    VAR NUWIDRAW=NUWID AND 32767
    IF NUWIDRAW!=(WIN_INPUTNUWID AND 32767)&&CAPTURE_WND==NUWIDToWND(WIN_INPUTNUWID)THEN
     IF NUWID AND WIN_FRAMEFLG THEN
      E=LMouseUpWindowOnFrame(NUWIDToWND(WIN_INPUTNUWID))
      E=LMouseUpWindow(NUWIDToWND(WIN_INPUTNUWID))
     ELSE
      E=LMouseUpWindow(NUWIDToWND(WIN_INPUTNUWID))
     ENDIF
    ELSE
     IF NUWID AND WIN_FRAMEFLG THEN
      E=LMouseUpWindowOnFrame(NUWIDToWND(NUWIDRAW))
      E=LMouseUpWindow(NUWIDToWND(NUWIDRAW))
     ELSE
      E=LMouseUpWindow(NUWIDToWND(NUWID))
     ENDIF
    ENDIF
   ENDIF
   CAPTURE_WND=0
  ENDIF


  '=====R=====
  IF BTN AND OTW_RMOUSEDWN THEN
   E=FocusWindow(NUWIDToWND(NUWID AND 32767))
   F=MAINCNT
   IF NUWID==OTW_RCLKWND&&F-OTW_RCLKF<=OTW_DBLCLKF&&ABS(OTW_MOUSEY-OTW_DBLCLKY)<OTW_DBLCLKXY&&ABS(OTW_MOUSEX-OTW_DBLCLKX)<OTW_DBLCLKXY THEN
    OTW_RCLKWND=0
    IF NUWID AND WIN_FRAMEFLG THEN
     E=RMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
    ELSE
     IF LEN(CTL_HANDLER$[WIN_CTL[NUWID]AND 4095,CTL_LDBLCLKHANDLER])THEN
      E=RDoubleClickWindow(NUWIDToWND(NUWID))
     ELSE
      E=RMouseDownWindow(NUWIDToWND(NUWID))
     ENDIF
    ENDIF
   ELSE
    OTW_RCLKWND=NUWID
    OTW_RCLKF=F
    OTW_DBLCLKX=OTW_MOUSEX
    OTW_DBLCLKY=OTW_MOUSEY
    IF NUWID AND WIN_FRAMEFLG THEN
     E=RMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
    ELSE
     E=RMouseDownWindow(NUWIDToWND(NUWID))
    ENDIF
   ENDIF
  ENDIF

  IF BTN AND OTW_RMOUSEUP THEN
    IF NUWID AND WIN_FRAMEFLG THEN
     E=RMouseUpWindowOnFrame(NUWIDToWND(WIN_INPUTNUWID))
     E=RMouseUpWindow(NUWIDToWND(WIN_INPUTNUWID))
    ELSE
     E=RMouseUpWindow(NUWIDToWND(WIN_INPUTNUWID))
    ENDIF
    E=SendContextMenuEvent(NUWIDToWND(WIN_INPUTNUWID))
  ENDIF
  '===========
 ENDIF
 IF MOVEMOUSE THEN
  MoveWindowSP FALSE
  IF CAPTURE_WND THEN
   IF CAPTURE_WND_FRAME THEN
    E=MouseMoveWindowOnFrame(CAPTURE_WND AND NUWIDMASK)
   ELSE
    E=MouseMoveWindow(CAPTURE_WND AND NUWIDMASK)
   ENDIF
  ELSE
  IF OLDMOVEMOUSEWINDOW!=NUWID THEN
   IF OTW_INSPECTWIN&&(OLDMOVEMOUSEWINDOW AND 32767)!=(NUWID AND 32767) THEN
    OTW_XORWindow NUWID AND 32767
    OTW_XORWindow OLDMOVEMOUSEWINDOW AND 32767
   ENDIF
   IF!(OLDMOVEMOUSEWINDOW AND WIN_FRAMEFLG)THEN
    E=MouseLeaveWindow(NUWIDToWND(OLDMOVEMOUSEWINDOW))
   ELSE
    E=MouseLeaveWindowOnFrame(NUWIDToWND(OLDMOVEMOUSEWINDOW AND 32767))
   ENDIF
   IF IsWindowEnabled(NUWIDToWND(NUWID AND 32767))THEN
    E=SetCursor(GetWindowCursor(NUWIDToWND(NUWID AND 32767)))
   ENDIF
  ENDIF
   IF!(NUWID AND WIN_FRAMEFLG)THEN
    E=MouseMoveWindow(NUWID)
   ELSE
    E=MouseMoveWindowOnFrame(NUWID AND 32767)
   ENDIF
   OLDMOVEMOUSEWINDOW=NUWID
  ENDIF
 ENDIF
 OTW_OLDMOUSEX=OTW_MOUSEX
 OTW_OLDMOUSEY=OTW_MOUSEY
' VAR K$=INKEY$()
' IF OTW_ENABLEKEY&&LEN(K$)THEN
'  E=SendKeyWindow(NUWIDToWND(WIN_INPUTNUWID),ASC(K$))
' ENDIF
 VOID UpdateWindowOnly(WIN_ROOTWND)
 OTW_FDIFF=MAINCNT-OTW_FCNT
 IF OTW_FDIFF>1 THEN
  OTW_FPF#=OTW_FPFCNT
  IF!OTW_FPFCNT THEN
   OTW_FPF#=1.0/OTW_FDIFF
   IF OTW_FPF#<0.3THEN OTW_FPF#=0.333
  ENDIF
  OTW_FPFCNT=0
  OTW_FCNT=MAINCNT
 ELSE
  INC OTW_FPFCNT
 ENDIF
 OTW_FDIFF=MAINCNT-OTW_CNT
 IF OTW_FDIFF>60 THEN
  OTW_FPS=OTW_FPSCNT
  OTW_FPSCNT=0
  '?OTW_FPS
  OTW_CNT=MAINCNT
 ELSE
  INC OTW_FPSCNT
 ENDIF
 BTN=BUTTON()AND OTW_USEBTN
 IF BTN||OTW_OLDBTN THEN
  IF MAINCNT-OTW_OLDBTNF>=8||!OTW_OLDBTN THEN
   E=SendButtonWindow(NUWIDToWND(WIN_INPUTNUWID),BTN)
   OTW_OLDBTNF=MAINCNT
   OTW_OLDBTN=BTN
  ENDIF
 ENDIF

 IF OTW_PRC_CHK==0THEN OTW_PRC_CHK=1
 IF OTW_PRC_CHK>=LEN(WIN_PRC)THEN
  OTW_PRC_CHK=1
 ENDIF
 IF WIN_WID[OTW_PRC_CHK]&&WIN_PRC[OTW_PRC_CHK]&&!CheckProcess(WIN_PRC[OTW_PRC_CHK])THEN
STOP
  VOID DeleteWindowNUWID(OTW_PRC_CHK)
 ENDIF
 OTW_PRC_CHK=OTW_PRC_CHK+1


 IF OTW_EXITFLG&&OTW_EXITTIME>=MAINCNT THEN
  OTW_EXIT
 ENDIF
 RETURN
END
DEF OTW_EXIT
 ACLS
 ExitProcess 0
 RETURN
END
'STATE:-1 INIT
'STATE:0 MOVING
'STATE:1 END
DEF OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX G,X,Y,X2,Y2
 GCOPY G,X,Y,X2,Y,X,Y,TRUE
 GCOPY G,X2,Y,X2,Y2,X2,Y,TRUE
 GCOPY G,X,Y2,X2,Y2,X,Y2,TRUE
 GCOPY G,X,Y,X,Y2,X,Y,TRUE
END
DEF OTW_MOVWIN_HNDLR_XOR SX,SY,SW,SH,OX,OY,OW,OH,X,Y,W,H,STATE
 VAR T=HARDWARE!=0
 VAR BUF=FALSE
 IF BUF THEN
  GPAGE OTW_SP,OTW_DDRAWPAGE
  OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DP,OX,OY,OX+OW-1,OY+OH-1

  OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DP,X,Y,X+W-1,Y+H-1
  IF T THEN
   OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DP,OX+1,OY+1,OX+OW-2,OY+OH-2
   OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DP,X+1,Y+1,X+W-2,Y+H-2
  ENDIF
 ENDIF
 IF STATE==0 THEN
  IF !T THEN
   OTW_MOVWIN_XORGBOX OX,OY,OX+OW-1,OY+OH-1
  ELSE
   OTW_MOVWIN_XORGBOX_THICK OX,OY,OX+OW-1,OY+OH-1
  ENDIF
 ENDIF
 IF !T THEN
  OTW_MOVWIN_XORGBOX X,Y,X+W-1,Y+H-1
 ELSE
  OTW_MOVWIN_XORGBOX_THICK X,Y,X+W-1,Y+H-1
 ENDIF
 IF BUF THEN
  GPAGE OTW_SP,OTW_DP
  OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DDRAWPAGE,X,Y,X+W-1,Y+H-1
  OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DDRAWPAGE,OX,OY,OX+OW-1,OY+OH-1
  IF T THEN
   OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DDRAWPAGE,X+1,Y+1,X+W-2,Y+H-2
   OTW_MOVWIN_HNDLR_XOR_GCOPY_BOX OTW_DDRAWPAGE,OX+1,OY+1,OX+OW-2,OY+OH-2
  ENDIF
 ENDIF
END
DEF OTW_MOVWIN_HNDLR_SP2 SX,SY,SW,SH,OX,OY,OW,OH,X,Y,W,H,STATE
 IF STATE==-1THEN
  SPSHOW OTW_MOVWINSP
  SPCHR OTW_MOVWINSP,MAX(X,0),MAX(Y,0),W,H
  SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
 ENDIF
 IF STATE==-1||STATE==0 THEN
  SPOFS OTW_MOVWINSP,X,Y
  SPSCALE OTW_MOVWINSP,W/SW,H/SH
 ENDIF
 IF STATE==1 THEN
  SPHIDE OTW_MOVWINSP
 ENDIF
END
DEF OTW_MOVWIN_HNDLR_SP SX,SY,SW,SH,OX,OY,OW,OH,X,Y,W,H,STATE
 IF STATE==-1THEN
  SPSHOW OTW_MOVWINSP
  SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
 ENDIF
 IF STATE==-1||STATE==0 THEN
  SPOFS OTW_MOVWINSP,X,Y
  SPSCALE OTW_MOVWINSP,W,H
 ENDIF
 IF STATE==1 THEN
  SPHIDE OTW_MOVWINSP
 ENDIF
END
  '2     3     4
  ' 
  ' 
  '           
  '5          6
  '           
  '           
  '           
  '789
DEF MoveWindowSP F
 IF!OTW_MOVWINFLG THEN RETURN
 VAR CALLHNDLR
 IF !F&&OTW_SMOOTH_MOVE_WINDOW THEN
  CALLHNDLR=1
  F=1
 ENDIF
 VAR OX=OTW_MOVWIN_X
 VAR OY=OTW_MOVWIN_Y
 VAR OW=OTW_MOVWIN_W
 VAR OH=OTW_MOVWIN_H
 VAR DX=OTW_MOVWIN_DX
 VAR DY=OTW_MOVWIN_DY
 IF OTW_MOVWINFLG>=2THEN
  VAR NW=OTW_MOVWIN_NUWID
  VAR W=OTW_MOVWIN_SW-1,H=OTW_MOVWIN_SH-1
  VAR X=OTW_MOVWIN_SX,Y=OTW_MOVWIN_SY
  VAR DW=DX+W
  VAR DH=DY+H
  VAR LTOPH,LTOPW
  VAR RTOPH,RTOPW
  IF OTW_MOVWINFLG==2THEN
   LTOPH=1LTOPW=1
  ENDIF
  IF OTW_MOVWINFLG==3THEN
   LTOPH=1
  ENDIF
  IF OTW_MOVWINFLG==5THEN
   LTOPW=1
  ENDIF
   IF LTOPW THEN
    INC W,X-OTW_MOUSEX
    X=OTW_MOUSEX
    IF W<WIN_MINW[NW]THEN
     W=WIN_MINW[NW]-1
     X=WIN_AX[NW]+WIN_WIDTH[NW]-W
    ENDIF
    X=X+DX
    W=W-DX
   ENDIF
   IF LTOPH THEN
    INC H,Y-OTW_MOUSEY
    Y=OTW_MOUSEY
    IF H<WIN_MINH[NW]THEN
     H=WIN_MINH[NW]-1
     Y=WIN_AY[NW]+WIN_HEIGHT[NW]-H
    ENDIF
    Y=Y+DY
    H=H-DY
   ENDIF
  IF OTW_MOVWINFLG==4THEN
   RTOPH=1RTOPW=1
  ENDIF
  IF OTW_MOVWINFLG==6THEN
   RTOPW=1
  ENDIF
   IF RTOPW THEN
    DEC W,X-OTW_MOUSEX+W
    W=W+DW
    IF W<WIN_MINW[NW]THEN W=WIN_MINW[NW]-1
   ENDIF
   IF RTOPH THEN
    INC H,Y-OTW_MOUSEY
    Y=OTW_MOUSEY
    IF H<WIN_MINH[NW]THEN
     H=WIN_MINH[NW]-1
     Y=WIN_AY[NW]+WIN_HEIGHT[NW]-H
    ENDIF
    Y=Y+DY
    H=H-DY
   ENDIF
  VAR LBOTH,LBOTW
  VAR RBOTH,RBOTW
  IF OTW_MOVWINFLG==7THEN
   LBOTH=1LBOTW=1
  ENDIF
  IF OTW_MOVWINFLG==8THEN
   LBOTH=1
  ENDIF
   IF LBOTW THEN
    INC W,X-OTW_MOUSEX
    X=OTW_MOUSEX
    IF W<WIN_MINW[NW]THEN
     W=WIN_MINW[NW]-1
     X=WIN_AX[NW]+WIN_WIDTH[NW]-W
    ENDIF
    X=X+DX
    W=W-DX
   ENDIF
   IF LBOTH THEN
    DEC H,Y-OTW_MOUSEY+H
    H=H+DH
    IF H<WIN_MINH[NW]THEN H=WIN_MINH[NW]-1
   ENDIF
  IF OTW_MOVWINFLG==9THEN
   RBOTH=1RBOTW=1
  ENDIF
   IF RBOTW THEN
    DEC W,X-OTW_MOUSEX+W
    W=W+DW
    IF W<WIN_MINW[NW]THEN W=WIN_MINW[NW]-1
   ENDIF
   IF RBOTH THEN
    DEC H,Y-OTW_MOUSEY+H
    H=H+DH
    IF H<WIN_MINH[NW]THEN H=WIN_MINH[NW]-1
   ENDIF
  OTW_MOVWIN_X=X
  OTW_MOVWIN_Y=Y
  OTW_MOVWIN_W=W+1
  OTW_MOVWIN_H=H+1
  IF F THEN
   IF !CALLHNDLR THEN
    VOID ClearWindowMoveFrame(WIN_DRAGHANDLER_WND)
   ENDIF
   CALL WIN_DRAGHANDLER$,WIN_DRAGHANDLER_WND,X-WIN_FX[WIN_PARENT[NW]],Y-WIN_FY[WIN_PARENT[NW]],W,H
   IF !CALLHNDLR THEN
    VOID ClearWindowDragHandler()
    RETURN
   ENDIF
  ENDIF
 ELSE
  IF F THEN
   VAR PWND=GetParentWindow(WIN_DRAGHANDLER_WND)
   VAR WIDTH
   VAR HEIGHT
   VAR AX=GetTrueWindowAX(PWND)
   VAR AY=GetTrueWindowAY(PWND)
   VAR E
   GetWindowSize WIN_DRAGHANDLER_WND,TRUE OUT WIDTH,HEIGHT,E
   IF !CALLHNDLR THEN
    VOID ClearWindowMoveFrame(WIN_DRAGHANDLER_WND)
   ENDIF
   IF !E THEN
    CALL WIN_DRAGHANDLER$,WIN_DRAGHANDLER_WND,OTW_MOUSEX-AX+DX,OTW_MOUSEY-AY+DY,WIDTH,HEIGHT
   ENDIF
   IF !CALLHNDLR THEN
    VOID ClearWindowDragHandler()
    RETURN
   ENDIF
  ENDIF
  OTW_MOVWIN_X=OTW_MOUSEX+DX
  OTW_MOVWIN_Y=OTW_MOUSEY+DY
 ENDIF
 IF CALLHNDLR THEN RETURN
 IF OTW_MOVWIN_INIT THEN
  CALL OTW_MOVWIN_HNDLR$,OTW_MOVWIN_SX,OTW_MOVWIN_SY,OTW_MOVWIN_SW,OTW_MOVWIN_SH,OX,OY,OW,OH,OTW_MOVWIN_X,OTW_MOVWIN_Y,OTW_MOVWIN_W,OTW_MOVWIN_H,0
 ELSE
  CALL OTW_MOVWIN_HNDLR$,OTW_MOVWIN_SX,OTW_MOVWIN_SY,OTW_MOVWIN_SW,OTW_MOVWIN_SH,OX,OY,OW,OH,OTW_MOVWIN_X,OTW_MOVWIN_Y,OTW_MOVWIN_W,OTW_MOVWIN_H,-1
  OTW_MOVWIN_INIT=TRUE
 ENDIF
END
VAR RUNCTL
COMMON DEF I_RUN
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 ExtendControl "RUN",GetWindowControl() OUT RUNCTL,E
 VAR WND
 NewTopLevelStyleWindow RUNCTL,"RUN",64,32,WindowMinMaxStyle()OR WindowDisableMaxStyle() OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 E=SetControlNotificationHandler(RUNCTL,"RunNotificationHandler")
 SetProcessVar WND
 VAR TW
 NewWindow GetButtonControl(),"RUN",0,12,32,10,WND,0OUT TW,E
 NewWindow GetTextBoxControl(),"",0,0,64,10,WND,0OUT TW,E
END
COMMON DEF L_RUN
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END
VAR ABOUTCTL
DIM OTWLOGO[0]
COMMON DEF I_ABOUT
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!ABOUTCTL THEN
  ExtendControl "ABOUT",GetWindowControl() OUT ABOUTCTL,E
  OTWLOGO=NewArray(0)
  LOAD"DAT:OTWLOGORC",OTWLOGO,0
 ENDIF
 VAR WND
 NewTopLevelWindow ABOUTCTL,"OTW",144+15,64 OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 SetProcessVar WND
 E=SetControlPainter(ABOUTCTL,"AboutPainter")
 E=SetControlNotificationHandler(ABOUTCTL,"ABOUTNotif")
 VAR W=GetWindowWidth(WND)
 NewWindow GetButtonControl(),"OK",(W-20)/2,16,20,12,WND,0 OUT E,E
END
COMMON DEF AboutNotif WND,CTL,TYPE,A1,A2
 VOID Deletewindow(WND)
END
COMMON DEF AboutPainter WND,CTL,TYPE,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYPE,A1,A2)
' E=GBeginWindow(WND)
 IF E THEN RETURN
 VAR S$="otya window"
 VAR W=GetWindowWidth(WND)
 GPRINTWindow WND,(W-LEN(S$)*8)/2,0,S$,RGB(0,0,0)
 S$="system "+GetWinVer$()
 GPRINTWindow WND,(W-LEN(S$)*8)/2,8,S$,RGB(0,0,0)
 GLOADWindow WND,1,1,16,16,OTWLOGO,1,0
 S$="Logo designed by"
 GPRINTWindow WND,(W-LEN(S$)*8)/2,30,S$,RGB(0,0,0)
 S$="mintyan"
 GPRINTWindow WND,(W-LEN(S$)*8)/2,38,S$,RGB(0,0,0)
 S$="© 2011-2018 otya"
 GPRINTWindow WND,(W-LEN(S$)*8)/2,46+4,S$,RGB(0,0,0)
 E=GEndWindow(WND)
END
COMMON DEF L_ABOUT
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 1
END
VAR LAUNCHERCTL
DIM LAUNCHERITEM$[0]
DIM LAUNCHERLEN
COMMON DEF LauncherPainter WND,CTL,T,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,T,A1,A2)
 IF GBeginWindow(WND)THEN RETURN
 VAR I
 FOR I=0TO LAUNCHERLEN-1
  GPRINTWindow WND,0,I*8+1,LAUNCHERITEM$[I],RGB(0,0,0)
 NEXT
 E=GEndWindow(WND)
END
COMMON DEF LauncherLMouseUP WND,CTL,T,X,Y
 VAR E=CallBaseControlHandler(WND,CTL,T,X,Y)
 VAR ITEM=Y/8
 IF ITEM>=LAUNCHERLEN||ITEM<0THEN
  RETURN
 ENDIF
 NewProcess LAUNCHERITEM$[ITEM],"" OUT E,E
END
COMMON DEF LauncherResize WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 VOID ResizeWindow(CW,W,H)
END
COMMON DEF LauncherNotif WND,CTL,T,A1,A2
 IF A2==0THEN
  VAR PROC$=GetListBoxSelectedText$(A1)
  VAR E
  NewProcess PROC$,"" OUT E,E
 ENDIF
END
COMMON DEF I_LAUNCHER
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 IF LAUNCHERCTL THEN
  VAR WND,E
  NewTopLevelStyleWindow LAUNCHERCTL,"LAUNCHER",80,99,WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle() OUT WND,E
  SetProcessVar WND
  NewWindow GetListBoxControl(),"",0,0,80,98,WND,0 OUT WND,E
  AddArrayListBoxItem WND,LAUNCHERITEM$
 ELSE
  LAUNCHERLEN=13
  LAUNCHERITEM$=NewArray$(LAUNCHERLEN)
  LAUNCHERITEM$[0]="WCLOCK"
  LAUNCHERITEM$[1]="RUN"
  LAUNCHERITEM$[2]="ABOUT"
  LAUNCHERITEM$[3]="LAUNCHER"
  LAUNCHERITEM$[4]="PAINT"
  LAUNCHERITEM$[5]="TXTED"
  LAUNCHERITEM$[6]="PRGED"
  LAUNCHERITEM$[7]="OTYFIL"
  LAUNCHERITEM$[8]="OTYDOC"
  LAUNCHERITEM$[9]="MPLAY"
  LAUNCHERITEM$[10]="CLIPBRD"
  LAUNCHERITEM$[11]="OTYMINE"
  LAUNCHERITEM$[12]="OTWTERM"
  ExtendControl "LAUNCHER",GetWindowControl() OUT LAUNCHERCTL,E
'  E=SetControlPainter(LAUNCHERCTL,"LauncherPainter")
'  E=SetControlLMouseUpHandler(LAUNCHERCTL,"LauncherLMouseUP")
  E=SetControlNotifHandler(LAUNCHERCTL,"LauncherNotif")
  E=SetControlResizeHandler(LAUNCHERCTL,"LauncherResize")
  I_LAUNCHER
 ENDIF
END
COMMON DEF L_LAUNCHER
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 1
END

VAR WCLOCKWND
VAR WCLOCKCTL
VAR WCLOCKBC
VAR WCLOCKBC2
VAR WCLOCKTIM
COMMON DEF RunNotificationHandler W,C,T,V,A2
 VAR PRC,E
 NewProcess GetWindowName$(GetChildWindow(GetParentWindow(V))),"" OUT PRC,E
 IF E THEN BEEP
END
COMMON DEF I_WCLOCK
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 ExtendControl "WCLOCK",GetWindowControl() OUT WCLOCKCTL,E
 E=SetControlPainter(WCLOCKCTL,"WCLOCKPainter")
 NewTopLevelWindow WCLOCKCTL,"CLOCK",64,64 OUT WCLOCKWND,E
 WCLOCKTIM=MAINCNT/60
 WCLOCKTIM=WCLOCKTIM*60
 'NewWindow GetButtonControl()
 NewWindow TSTCTL,"TEST",8,8,32,32,WCLOCKWND,0 OUT WCLOCKBC,E
 NewWindow GetTextBoxControl(),"TEST",0,16,48,8,WCLOCKWND,0OUT WCLOCKBC2,E
'NewWindow GetButtonControl(),"TEST",16,16,32,32,WCLOCKWND,0 OUT WCLOCKBC2,E
 E=SetControlNotificationHandler(WCLOCKCTL,"WCLOCKNotif")
 SetProcessVar WCLOCKWND
END
COMMON DEF WCLOCKNotif W,C,T,WND,V
 BEEP 
END
COMMON DEF WCLOCKPainter W,C,T,A,B
 VAR E=CallBaseControlHandler(W,C,T,A,B)
 WCLOCK_RP
END
COMMON DEF L_WCLOCK
 VAR E
 WCLOCKWND=GetProcessVar()
 VAR H,M,S
' E=UpdateWindow(WCLOCKBC)
 E=PeekWindowEvent(WCLOCKWND)
' IF E==RepaintControlEvent()THEN
'  E=UpdateWindow(WCLOCKWND)
'  WCLOCK_RP
'  RETURN
' ENDIF
 E=UpdateWindow(WCLOCKWND)
 IF E THEN ExitProcess 1
 TMREAD OUT H,M,S
 IF S!=GetWindowVar(WCLOCKWND,0)THEN
  WCLOCK_RP
  SetWindowVar WCLOCKWND,0,S
 ENDIF
' IF MAINCNT-WCLOCKTIM>=60 THEN
'  WCLOCKTIM=MAINCNT/60
'  WCLOCKTIM=WCLOCKTIM*60
'  WCLOCK_RP
' ENDIF
' E=UpdateWindow(WCLOCKBC2)
 
END
 DEF WCLOCK_RP
  VAR E
  E=GBeginWindow(WCLOCKWND)
  IF E THEN RETURN
  GCLSWindow WCLOCKWND,WIN_BKGND'255,160,16)
  GPRINTWindowCC WCLOCKWND,0,0,TIME$,1
  GPRINTWindowCC WCLOCKWND,0,8,TIME$,1
  GPRINTWindowCC WCLOCKWND,0,56,TIME$,1
  E=GEndWindow(WCLOCKWND)
 END
'DEBUG
COMMON DEF DUMP_WND
 COLOR #TGRAY,#TBLACK
 LOCATE ,,-256
 WINLIST_Add2 GetRootWindow(),"",CHR$(0)
 COLOR #TGRAY,0
 LOCATE ,,0
'DUMP_WND2 WIN_ROOTWND AND NUWIDMASK,""
END
DEF WINLIST_Add2 WND,P$,CNT$
 WHILE WND
  VAR C=GetChildWindow(WND)
  VAR N=GetNextWindow(WND)
  VAR CNT=ASC(CNT$)
  IF CNT>=29THEN'SCREEN HEIGHT
   ?"=== Press ENTER ===";
   WHILE INKEY$()!=CHR$(13)VSYNC WEND
   LOCATE 0,
   ?CHR$(0)*LEN("=== Press ENTER ===");
   LOCATE 0,
   CNT=0
  ENDIF
  VAR BUF$
  IF N THEN
   BUF$=P$+""
  ELSE
   BUF$=P$+""
  ENDIF
  COLOR #TGRAY
  IF N&&WND!=GetPrevWindow(N)THEN
   COLOR #TMAROON
   PUSH BUF$,"!broken"
  ENDIF
  PUSH BUF$,STR$(WND AND NUWIDMASK)
  PUSH BUF$,","
  VAR S$=""
  IF WIN_HIDE[WND AND NUWIDMASK]THEN
   S$=" HIDE"
  ENDIF
  PUSH BUF$,GetControlName$(GetControl(WND))+":"+GetWindowName$(WND)+S$
  ?BUF$
  CNT$[0]=CHR$(CNT+LEN(BUF$) DIV 50+1)
  IF N THEN
   IF C THEN WINLIST_Add2 C,P$+"",CNT$
  ELSE
   IF C THEN WINLIST_Add2 C,P$+" ",CNT$
  ENDIF
  WND=N
 WEND
END

DEF UpdateButton()
 VAR B=BUTTON()
 IF!IM_KBDMODE THEN
  B=B AND NOT(#L OR #R)
 ENDIF
 VAR RET=0
 IF B AND OTW_MOUSELBTN THEN
  IF!OTW_OLDLMOUSE THEN RET=OTW_LMOUSEDWN
  OTW_OLDLMOUSE=1
 ELSE
  IF OTW_OLDLMOUSE THEN RET=OTW_LMOUSEUP
  OTW_OLDLMOUSE=0
 ENDIF
 IF B AND OTW_MOUSERBTN THEN
  IF!OTW_OLDRMOUSE THEN RET=RET OR OTW_RMOUSEDWN
  OTW_OLDRMOUSE=1
 ELSE
  IF OTW_OLDRMOUSE THEN RET=RET OR OTW_RMOUSEUP
  OTW_OLDRMOUSE=0
 ENDIF
 RETURN RET
END
VAR OTW_MOUSEOLDX,OTW_MOUSEOLDY
VAR OTW_MOUSEOLDST
VAR OTW_OLDSTICKMCNT
COMMON DEF MoveMouse X,Y
 OTW_MOUSEX=X
 OTW_MOUSEY=Y
 IF OTW_MOUSEX<OTW_MOUSECLIPX THEN OTW_MOUSEX=OTW_MOUSECLIPX
 IF OTW_MOUSEY<OTW_MOUSECLIPY THEN OTW_MOUSEY=OTW_MOUSECLIPY
 IF OTW_MOUSEX>=OTW_MOUSECLIPX2 THEN OTW_MOUSEX=OTW_MOUSECLIPX2
 IF OTW_MOUSEY>=OTW_MOUSECLIPY2 THEN OTW_MOUSEY=OTW_MOUSECLIPY2
 SPOFS OTW_MOUSESP,OTW_MOUSEX,OTW_MOUSEY
 OTW_MOUSEX#=OTW_MOUSEX
 OTW_MOUSEY#=OTW_MOUSEY
END
VAR OTW_MOUSE_MODE

COMMON DEF SetMouseMode MODE
 OTW_MOUSE_MODE=MODE
END
COMMON DEF UpdateMouse
 VAR S,X,Y
 TOUCH OUT S,X,Y
 IF OTW_MOUSEOLDST&&S THEN
  IF OTW_MOUSE_MODE THEN
   OTW_MOUSEX=X/(320/400)
   OTW_MOUSEY=Y
  ELSE
   OTW_MOUSEX=OTW_MOUSEX+X-OTW_MOUSEOLDX
   OTW_MOUSEY=OTW_MOUSEY+Y-OTW_MOUSEOLDY
  ENDIF
  IF OTW_MOUSEX<OTW_MOUSECLIPX THEN OTW_MOUSEX=OTW_MOUSECLIPX
  IF OTW_MOUSEY<OTW_MOUSECLIPY THEN OTW_MOUSEY=OTW_MOUSECLIPY
  IF OTW_MOUSEX>=OTW_MOUSECLIPX2 THEN OTW_MOUSEX=OTW_MOUSECLIPX2
  IF OTW_MOUSEY>=OTW_MOUSECLIPY2 THEN OTW_MOUSEY=OTW_MOUSECLIPY2
  SPOFS OTW_MOUSESP,OTW_MOUSEX,OTW_MOUSEY
  OTW_MOUSEX#=OTW_MOUSEX
  OTW_MOUSEY#=OTW_MOUSEY
 ELSE
  IF S&&X>=OTW_KX&&X<OTW_KX2&&Y>=OTW_KY&&Y<OTW_KY2 THEN
   BEEP 
   VAR K$
   XSCREEN 0,512,2
   VISIBLE 1,1,1,1
   
   OTW_SP=OTW_DP
   GPAGE OTW_DP,OTW_DP
   PRUN_RESTORE
   KEY 1,"
  ENDIF
 ENDIF
 OTW_MOUSEOLDX=X
 OTW_MOUSEOLDY=Y
 OTW_MOUSEOLDST=S
 VAR MCNT=MAINCNT
 IF OTW_OLDSTICKMCNT-MCNT THEN
  VAR X#,Y#
  STICK OUT X#,Y#
  VAR D=(MAINCNT-OTW_OLDSTICKMCNT)*2.5
  IF X#!=0 OR Y#!=0 THEN
   OTW_MOUSEX#=OTW_MOUSEX#+X#*D
   OTW_MOUSEY#=OTW_MOUSEY#-Y#*D
   IF OTW_MOUSEX#<OTW_MOUSECLIPX THEN OTW_MOUSEX#=OTW_MOUSECLIPX
   IF OTW_MOUSEY#<OTW_MOUSECLIPY THEN OTW_MOUSEY#=OTW_MOUSECLIPY
   IF OTW_MOUSEX#>=OTW_MOUSECLIPX2 THEN OTW_MOUSEX#=OTW_MOUSECLIPX2-1
   IF OTW_MOUSEY#>=OTW_MOUSECLIPY2 THEN OTW_MOUSEY#=OTW_MOUSECLIPY2
   'SPANIM OTW_MOUSESP,"XY",OTW_OLDSTICKMCNT-MCNT,OTW_MOUSEX#,OTW_MOUSEY#
   SPOFS OTW_MOUSESP,OTW_MOUSEX#,OTW_MOUSEY#
   OTW_MOUSEX=OTW_MOUSEX#
   OTW_MOUSEY=OTW_MOUSEY#
  ENDIF
  OTW_OLDSTICKMCNT=MCNT
 ENDIF
 IF 0&&!S THEN
'  VAR X#,Y#
  STICK OUT X#,Y#
  IF X#!=0 OR Y#!=0 THEN
   OTW_MOUSEX#=OTW_MOUSEX#+X#*(4/OTW_FPF#)'0.2'/2
   OTW_MOUSEY#=OTW_MOUSEY#-Y#*(4/OTW_FPF#)'0.2'/2
   IF OTW_MOUSEX#<OTW_MOUSECLIPX THEN OTW_MOUSEX#=OTW_MOUSECLIPX
   IF OTW_MOUSEY#<OTW_MOUSECLIPY THEN OTW_MOUSEY#=OTW_MOUSECLIPY
   IF OTW_MOUSEX#>=OTW_MOUSECLIPX2 THEN OTW_MOUSEX#=OTW_MOUSECLIPX2-1
   IF OTW_MOUSEY#>=OTW_MOUSECLIPY2 THEN OTW_MOUSEY#=OTW_MOUSECLIPY2
   SPANIM OTW_MOUSESP,"XY",-1,OTW_MOUSEX#,OTW_MOUSEY#
'   SPOFS OTW_MOUSESP,OTW_MOUSEX#,OTW_MOUSEY#
   OTW_MOUSEX=OTW_MOUSEX#
   OTW_MOUSEY=OTW_MOUSEY#
  ENDIF
 ENDIF
 OTW_LASTUPD=MAINCNT
END
COMMON DEF OTWSAVE VER$
 SAVE"PRG1:OTW"+VER$
END
'DEF OTW_LOADMOUSE
' 
'END
COMMON DEF CREATEOTW
 ?"OTW Develop Tool"
 VAR K$
 INC K$,"VAR \1CTL"+LF$()
 INC K$,"COMMON DEF I_\1"+LF$()
 INC K$," IF!CHKCALL(\QIsWinRunning\Q)||!IsWinRunning()THEN"+LF$()
 INC K$,"  PrintConsole \QThis program requires window system\Q+LF$()"+LF$()
 INC K$,"  ExitProcess 1"+LF$()
 INC K$,"  RETURN"+LF$()
 INC K$," ENDIF"+LF$()
 INC K$," VAR WND,E"+LF$()
 INC K$," IF!\1CTL THEN"+LF$()
 INC K$,"  ExtendControl \Q\2\Q,GetWindowControl() OUT \1CTL,E"+LF$()
 INC K$," ENDIF"+LF$()
 INC K$," NewTopLevelWindow \1CTL,\Q\2\Q,\W,\H OUT WND,E"+LF$()
 INC K$," SetProcessVar WND"+LF$()
 INC K$,"END"+LF$()
 INC K$,"COMMON DEF L_\1"+LF$()
 INC K$," IF UpdateWindow(GetProcessVar())THEN ExitProcess 1"+LF$()
 INC K$,"END
 VAR _1$
 VAR _2$,_W,_H
 VAR _Q$=CHR$(34)
 LINPUT "ProcessName?";_1$
 LINPUT "WindowName?";_2$
 INPUT "Width";_W
 INPUT "Height";_H
 K$=ReplaceStr$(K$,"\1",_1$)
 K$=ReplaceStr$(K$,"\2",_2$)
 K$=ReplaceStr$(K$,"\W",STR$(_W))
 K$=ReplaceStr$(K$,"\H",STR$(_H))
 K$=ReplaceStr$(K$,"\Q",_Q$)
 VAR SLOT=3
 CLIPBOARD K$
END

VAR PAINT1CTL
COMMON DEF Paint1Repaint WND,CTL,T,A1,A2
 IF CallBaseControlHandler(WND,CTL,T,A1,A2)THEN RETURN
 DIM A[64*64]
 ReadArray GetWindowVar(WND,2),A,0,LEN(A)
 GLOADWindow WND,0,0,64,64,A,1,0
 VAR E=GEndWindow(WND)
END
COMMON DEF Paint1LDWN WND,CTL,T,X,Y
 VAR E=CallBaseControlHandler(WND,CTL,T,X,Y)
 SetWindowVar WND,3,1
 SetWindowVar WND,0,X
 SetWindowVar WND,1,Y
 VOID SetCapture(WND)
END
COMMON DEF Paint1LUP WND,CTL,T,X,Y
 SetWindowVar WND,3,0
END
COMMON DEF Paint1CF WND,CTL,T,F,A2
'IF CallBaseControlHandler(WND,CTL,T,F,A2)THEN 
 IF!F THEN SetWindowVar WND,3,0
END

COMMON DEF Paint1MouseMove WND,CTL,T,X,Y
 IF!GetWindowVar(WND,3)THEN RETURN
 VAR OX=GetWindowVar(WND,0)
 VAR OY=GetWindowVar(WND,1)
 VAR E=GBeginWindow(WND)
 GLINEWindow WND,X,Y,OX,OY,RGB(0,0,0)
 GLINEArrayMemory GetWindowVar(WND,2),64,64,X,Y,OX,OY,RGB(0,0,0)
 E=GEndWindow(WND)
 SetWindowVar WND,0,X
 SetWindowVar WND,1,Y
END
COMMON DEF I_PAINT1
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR PTR=malloc(64*64)
 IF!PTR THEN BEEP:ExitProcess 1RETURN
 VAR WND,E
 IF!PAINT1CTL THEN
  ExtendControl "PAINT1",GetWindowControl() OUT PAINT1CTL,E
  E=SetControlMouseMoveHandler(PAINT1CTL,"Paint1MouseMove")
  E=SetControlPainter(PAINT1CTL,"Paint1Repaint")
  E=SetControlLMouseDownHandler(PAINT1CTL,"Paint1LDWN")
  E=SetControlLMouseUpHandler(PAINT1CTL,"Paint1LUP")
  E=SetControlChFocusHandler(PAINT1CTL,"Paint1CF")
 ENDIF
 NewTopLevelWindow PAINT1CTL,"PAINT1",64,64 OUT WND,E  SetProcessVar WND
 SetWindowVar WND,2,PTR
END
COMMON DEF L_PAINT1
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
'===Text editor===
VAR TXTEDCTL
VAR TXTBOXEXCTL
VAR TXTBOXEX_LINESIZ
VAR TXTBOXEX_FREE
DIM TXTBOXEX_VAL$[0]
DIM TXTBOXEX_LINE[0]
DIM TXTBOXEX_NEXT[0]
DIM TXTBOXEX_PREV[0]

VAR TXTBOXEX_MAXCTL
VAR TXTBOXEX_CFREE
DIM TXTBOXEX_CLINE[0]
DIM TXTBOXEX_CMODE[0]
DIM TXTBOXEX_CNEXT[0]
DIM TXTBOXEX_CFIRST[0]
DIM TXTBOXEX_CSELLINE1[0]
DIM TXTBOXEX_CSELPOS1[0]
DIM TXTBOXEX_CSELLINE2[0]
DIM TXTBOXEX_CSELPOS2[0]
DIM TXTBOXEX_CISSEL[0]
DIM TXTBOXEX_CISSELING[0]
DIM TXTBOXEX_CLINECNT[0]
COMMON DEF GetTextBoxExControl()
 RETURN TXTBOXEXCTL
END
COMMON DEF SetTextBoxExPRGMode WND,FLG
 VAR CTL=GetWindowVar(WND,7)
 SetTextBoxExMode CTL,FLG
END
VAR TextBoxEx_MENU
COMMON DEF INIT_TXTBOXEX
 VAR E
 IF!TXTEDCTL THEN
  NewControl "TextBoxEx" OUT TXTBOXEXCTL,E
  E=SetControlPainter(TXTBOXEXCTL,"TextBoxExPainter")
  E=SetControlKeyHandler(TXTBOXEXCTL,"TextBoxExKey")
  E=SetControlButtonHandler(TXTBOXEXCTL,"TextBoxExButton")
  E=SetControlChFocusHandler(TXTBOXEXCTL,"TextBoxExChFocus")
  E=SetControlCreateHandler(TXTBOXEXCTL,"TextBoxExCreate")
  E=SetControlNotifHandler(TXTBOXEXCTL,"TextBoxExNotif")
  E=SetControlLMouseDownHandler(TXTBOXEXCTL,"TextBoxExLMD")
  E=SetControlLMouseUpHandler(TXTBOXEXCTL,"TextBoxExLMU")
  E=SetControlContextMenuHandler(TXTBOXEXCTL,"TextBoxExCTXMENU")
  E=SetControlResizeHandler(TXTBOXEXCTL,"TextBoxResize")
  E=SetControlMouseMoveHandler(TXTBOXEXCTL,"TextBoxExMMOVE")
  E=SetControlDeleteHandler(TXTBOXEXCTL,"TextBoxExDelete")
  TXTBOXEX_LINESIZ=10000'1024
  TXTBOXEX_VAL$=NewArray$(TXTBOXEX_LINESIZ)
  TXTBOXEX_LINE=NewArray(TXTBOXEX_LINESIZ)
  TXTBOXEX_NEXT=NewArray(TXTBOXEX_LINESIZ)
  TXTBOXEX_PREV=NewArray(TXTBOXEX_LINESIZ)
  TXTBOXEX_FREE=1
  TXTBOXEX_MAXCTL=100'1024
  TXTBOXEX_CNEXT=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CLINE=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CMODE=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CFIRST=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELLINE1=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELPOS1=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELLINE2=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELPOS2=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CISSEL=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CISSELING=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CLINECNT=NewArray(TXTBOXEX_MAXCTL)
  VAR I
  FOR I=1TO TXTBOXEX_LINESIZ-2
   TXTBOXEX_NEXT[I]=I+1
  NEXT
  FOR I=1TO TXTBOXEX_MAXCTL-2
   TXTBOXEX_CNEXT[I]=I+1
  NEXT
  TXTBOXEX_CFREE=1
  NewMenu OUT TextBoxEx_MENU,E
  AddMenuItem TextBoxEx_MENU,"Copy",1
  AddMenuItem TextBoxEx_MENU,"Cut",2
  AddMenuItem TextBoxEx_MENU,"Paste",3
  AddMenuItemSeparator TextBoxEx_MENU
  AddMenuItem TextBoxEx_MENU,"Select all",4
 ENDIF
END
DEF TXTED_NewCTL(WND)
 VAR R=TXTBOXEX_CFREE
 IF!R THEN RETURN 0
 TXTBOXEX_CFREE=TXTBOXEX_CNEXT[TXTBOXEX_CFREE]
 TXTBOXEX_CLINE[TXTBOXEX_CFREE]=0
 RETURN TXTBOXEX_CFREE
END
DEF TXTED_NewLINE(V$,P)
 VAR R=TXTBOXEX_FREE
 IF!R THEN RETURN 0
 TXTBOXEX_FREE=TXTBOXEX_NEXT[TXTBOXEX_FREE]
 IF P THEN
  TXTBOXEX_LINE[R]=TXTBOXEX_LINE[P]+1
 ELSE
  TXTBOXEX_LINE[R]=1
 ENDIF
 VAR N
 IF P THEN
  N=TXTBOXEX_NEXT[P]
  TXTBOXEX_NEXT[P]=R
 ENDIF
 TXTBOXEX_VAL$[R]=V$
 TXTBOXEX_NEXT[R]=N
 TXTBOXEX_PREV[R]=P
 IF N THEN
  TXTBOXEX_PREV[N]=R
 ENDIF
 RETURN R
END
DEF TXTED_DeleteLine(L)
 IF!L THEN RETURN 0
 VAR N=TXTBOXEX_NEXT[L]
 VAR P=TXTBOXEX_PREV[L]
 IF N THEN
  TXTBOXEX_PREV[N]=P
 ENDIF
 IF P THEN
  TXTBOXEX_NEXT[P]=N
 ENDIF
 VAR NULL$
 TXTBOXEX_VAL$[L]=NULL$
 TXTBOXEX_NEXT[L]=TXTBOXEX_FREE
 TXTBOXEX_FREE=L
 IF P THEN RETURN P
 IF N THEN RETURN N
 RETURN 0
END

COMMON DEF TextBoxExMMOVE WND,CTL,T,X,Y
 IF GetCapture()!=WND THEN
  RETURN
 ENDIF
 VAR MF
 IF Y<0&&TXTED_UpCursor(WND)THEN
  MF=TRUE
 ENDIF
 
 VAR H=GetWindowHeight(WND)
 IF Y>H&&TXTED_DownCursor(WND)THEN
  MF=TRUE
 ENDIF
 IF MF THEN
  TextBoxExRepaint WND
  RETURN
 ENDIF
 VAR LINE,POS,OL,OP
 GetWindowVar WND,2 OUT OL
 GetWindowVar WND,3 OUT OP
 VAR LINEOBJ
 TEXTBOXEX_GETLINEPOS WND,X,Y OUT LINE,POS,LINEOBJ
 VAR BOX=GetWindowVar(WND,7)
 SetWindowVar WND,2,LINEOBJ
 SetWindowVar WND,3,POS
 TXTBOXEX_CSELLINE2[BOX]=LINE
 TXTBOXEX_CSELPOS2[BOX]=POS
 TXTBOXEX_CISSEL[BOX]=TRUE
 TXTBOXEX_CISSELING[BOX]=TRUE
 IF LINE==OL&&POS==OP THEN RETURN
 VOID RepaintWindow(WND)
END
COMMON DEF TextBoxExLMU WND,CTL,T,X,Y
 VOID ReleaseCapture(WND)
 VAR BOX=GetWindowVar(WND,7)
 TXTBOXEX_CISSELING[BOX]=FALSE
END
DEF TEXTBOXEX_GETLINEPOS WND,X,Y OUT LINE,POS,V
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
' IF!X||!Y||X>=W||Y>=H THEN RETURN
 V=GetWindowVar(WND,1)
 VAR Y1=1,Y2
 LINE=TXTBOXEX_CLINE[GETWINDOWVar(WND,7)]
 VAR OV
' IF X<33THEN RETURN
 VAR TW,TH
 VAR LW=TXTED_GETLINEW(W)
 WHILE V
  OV=V
  LINE=LINE+1
'  TW=LEN(TXTBOXEX_VAL$[V]) MOD LW
  TH=(LEN(TXTBOXEX_VAL$[V]) DIV LW)*8+8
  Y2=Y1+TH
  IF Y>=Y1&&Y<Y2 THEN
   BREAK
  ENDIF
  Y1=Y2
  V=TXTBOXEX_NEXT[V]
 WEND
 POS=MAX(0,((X-1-32) DIV 8)+(ABS(Y1-Y)DIV 8)*LW)
 IF!V THEN V=OV
END
COMMON DEF TextBoxExLMD WND,CTL,T,X,Y
 VAR LINE,POS
 VAR OL,OP
 GetWindowVar WND,2 OUT OL
 GetWindowVar WND,3 OUT OP
 VAR LINEOBJ
 TEXTBOXEX_GETLINEPOS WND,X,Y OUT LINE,POS,LINEOBJ
 VAR BOX=GetWindowVar(WND,7)
 TXTBOXEX_CISSEL[BOX]=FALSE
 TXTBOXEX_CISSELING[BOX]=FALSE
 IF OL==LINE&&OP==POS THEN
 ELSE
  SetWindowVar WND,2,LINEOBJ
  SetWindowVar WND,3,POS
  VOID RepaintWindow(WND)
 ENDIF
 TXTBOXEX_CSELLINE1[BOX]=LINE
 TXTBOXEX_CSELPOS1[BOX]=POS
 TXTBOXEX_CSELLINE2[BOX]=LINE
 TXTBOXEX_CSELPOS2[BOX]=POS
 VOID SetCapture(WND)
END
COMMON DEF TextBoxExCTXMENU WND,CTL,T,X,Y
 ShowMenu TextBoxEx_MENU,WND,X,Y
END
DEF TEXTBOXEX_MENU WND,ID
 ON ID GOTO @UNK,@COPY,@CUT,@PASTE,@ALL
 @UNK
 ?"UNK
 RETURN
 @CUT
 TextBoxExCut WND
 RETURN
 @COPY
'?TEXTBOXEXGETSELECTEDTEXT(WND)
 TextBoxExCopy WND
 RETURN
 @PASTE
 TextBoxExPaste WND
 RETURN
 @ALL
 TextBoxExSelectAll WND
END
COMMON DEF TextBoxExNotif WND,CTL,T,_,POS
 'MENU
 IF _==MenuNotifID() THEN
  TEXTBOXEX_MENU WND,POS
  RETURN
 ENDIF
 VAR BOX=GetWindowVar(WND,7)
 VAR F=GetTextBoxExLine(BOX)
 VAR SA=POS-F
 VAR I
 IF!SA THEN RETURN
 VAR V=GetWindowVar(WND,1)
 IF SA>0THEN
  FOR I=1TO SA
   IF!TXTBOXEX_NEXT[V]THEN BREAK
   V=TXTBOXEX_NEXT[V]
  NEXT
 ELSE
  SA=ABS(SA)
  FOR I=1TO SA
   IF!TXTBOXEX_PREV[V]THEN BREAK
   V=TXTBOXEX_PREV[V]
  NEXT
 ENDIF
 SetTextBoxExLine BOX,POS
 SetWindowVar WND,1,V
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExCreate WND,CTL,T,_,__
 VAR SCR,E
 VAR W=GetWindowWidth(WND),
 NewVScrollBar WND,0 OUT SCR,E
 VAR C=TXTED_NewCTL(WND)
 SetWindowVar WND,7,C
 SetTextBoxExLine C,0
 TXTBOXEX_CFIRST[C]=0
 TXTBOXEX_CISSEL[C]=0
 TXTBOXEX_CISSELING[C]=0
 TXTBOXEX_CSELLINE1[C]=0
 TXTBOXEX_CSELPOS1[C]=0
 TXTBOXEX_CSELLINE2[C]=0
 TXTBOXEX_CSELPOS2[C]=0
 VOID SetWindowCursor(WND,GetBeamCursor())
END
COMMON DEF TextBoxExDelete WND,CTL,T,_,__
 VAR BOX=GetWindowVar(WND,7)
 VAR F=TXTBOXEX_CFIRST[BOX]
 WHILE F
  F=TXTED_DeleteLine(F)
 WEND
END
DEF GetTextBoxExMode(CTL)
 RETURN TXTBOXEX_CMODE[CTL]
END
DEF SetTextBoxExMode CTL,L
 TXTBOXEX_CMODE[CTL]=L
END
DEF GetTextBoxExLine(CTL)
 RETURN TXTBOXEX_CLINE[CTL]
END
DEF SetTextBoxExLine CTL,L
 TXTBOXEX_CLINE[CTL]=L
END
DEF TextBoxResize WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 'VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF TextBoxExPainter WND,CTL,T,_,__
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExChFocus WND,CTL,T,_,__
 TextBoxExRepaint WND
END
DEF TXTED_GETLINEW(W)
 RETURN MAX(1,(W-32-8)DIV 8)
END
DEF TextBoxExDrawSelBox SELPOS1,SELPOS2,LINEC,LEN,X,Y,W
 SELPOS1=MIN(LEN,SELPOS1)
 SELPOS2=MIN(LEN,SELPOS2)
 IF SELPOS1==SELPOS2 THEN RETURN
 VAR SY1=SELPOS1 DIV LINEC
 VAR SY2=SELPOS2 DIV LINEC
 IF SY1>SY2 THEN
  SWAP SY1,SY2
  SWAP SELPOS1,SELPOS2
 ENDIF
 VAR SLC=GetSelectionColor()

 IF SY1==SY2 THEN
  GFILL X+SELPOS1 MOD LINEC*8,Y+SY1*8,X+SELPOS2 MOD LINEC*8-1,Y+SY2*8+7,SLC
 ELSE
  VAR K
  IF SY2-SY1>1THEN
   GFILL X,Y+SY1*8+8,W,Y+SY2*8-1,SLC
  ENDIF
  GFILL X+SELPOS1 MOD LINEC*8,Y+SY1*8,W,Y+SY1*8+7,SLC
  GFILL X,Y+SY2*8,X+SELPOS2 MOD LINEC*8-1,Y+SY2*8+7,SLC
 ENDIF
END
COMMON DEF TextBoxExRepaint WND
 VAR E=GBeginDirect(WND)
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 GCLIP 1,0,0,W,H
 VAR BOX=GetWindowVar(WND,7)
 VAR SH=GetTextBoxExMode(BOX)
 IF SH THEN
  GCLS RGB(0,0,0)
 ELSE
  GCLS RGB(255,255,255)
 ENDIF
 VAR L=GetWindowVar(WND,1)
 VAR C=GetWindowVar(WND,2)
 VAR V$=TXTBOXEX_VAL$[C]
 VAR CX=GetWindowVar(WND,3)
 VAR L$=LF$()
 IF LEN(V$)<=CX THEN
  CX=LEN(V$)
  IF LEN(V$)&&V$[LEN(V$)-1]==L$THEN DEC CX
  SetWindowVar WND,3,CX
 ENDIF
 VAR TC=RGB(0,0,0)
 IF SH THEN TC=-1
 VAR Y=1,X=32,PL,LC
 VAR LINE=GetTextBoxExLine(BOX),_
 VAR M0=MAINCNT
 VAR LINEC=TXTED_GETLINEW(W)'((W-X)DIV 8)-1
 VAR ISSEL=TXTBOXEX_CISSEL[BOX]
 IF ISSEL THEN
  VAR SELLINE1=TXTBOXEX_CSELLINE1[BOX]
  VAR SELLINE2=TXTBOXEX_CSELLINE2[BOX]
  VAR SELPOS1=TXTBOXEX_CSELPOS1[BOX]
  VAR SELPOS2=TXTBOXEX_CSELPOS2[BOX]
  IF SELLINE1>SELLINE2 THEN
   SWAP SELLINE1,SELLINE2
   SWAP SELPOS1,SELPOS2
  ENDIF
 ENDIF
 VAR SLC=GetSelectionColor()
 VAR SLTC=GetSelectionTextColor()
 WHILE 1
  INC LINE
  V$=TXTBOXEX_VAL$[L]
  _=(LINE-(LINE DIV 1000000)*1000000) DIV 10000
  IF LINE>=1000000THEN INC _,&H64
  IF !_ THEN _=&H6E
  VAR LS$=CHR$(&HE100+_)
  _=(LINE-((LINE DIV 10000)*10000))DIV 100
  IF LINE>=10000&&_<=&H9THEN INC _,&H64
  IF !_ THEN _=&H6E
  INC LS$,CHR$(&HE100+_)
  _=LINE-((LINE DIV 100)*100)
  IF LINE>=100&&_<=&H9THEN INC _,&H64
  IF !_ THEN _=&H6E
  INC LS$,CHR$(&HE100+_)
  GPUTCHR 1,Y,LS$+CHR$(&HE16F),RGB(198,198,198)
  IF LINE>SELLINE1&&LINE<SELLINE2 THEN
   VAR LH=LEN(V$) DIV LINEC
   IF LH THEN
    GFILL X,Y,W,Y+LH*8-1,SLC
   ENDIF
   GFILL X,Y+LH*8,X+LEN(V$) MOD LINEC*8-1,Y+LH*8+7,SLC
  ENDIF
  IF LINE==SELLINE1&&LINE==SELLINE2 THEN
   TextBoxExDrawSelBox SELPOS1,SELPOS2,LINEC,LEN(V$),X,Y,W
  ELSEIF LINE==SELLINE1 THEN
   TextBoxExDrawSelBox SELPOS1,LEN(V$),LINEC,LEN(V$),X,Y,W
  ELSEIF LINE==SELLINE2 THEN
   TextBoxExDrawSelBox 0,SELPOS2,LINEC,LEN(V$),X,Y,W
  ENDIF
  VAR OY=Y
  IF SH THEN
   TXTED_PRGPRINT X,Y,V$,LINEC
  ELSE
   IF LINE==SELLINE1&&LINE==SELLINE2 THEN
    TXTED_PRINT X,Y,V$,TC,LINEC,SELPOS1,SELPOS2,SLTC
   ELSEIF LINE==SELLINE1 THEN
    TXTED_PRINT X,Y,V$,TC,LINEC,SELPOS1,LEN(V$),SLTC
   ELSEIF LINE==SELLINE2 THEN
    TXTED_PRINT X,Y,V$,TC,LINEC,0,SELPOS2,SLTC
   ELSEIF LINE>SELLINE1&&LINE<SELLINE2 THEN
    TXTED_PRINT X,Y,V$,TC,LINEC,0,LEN(V$),SLTC
   ELSE
    TXTED_PRINT X,Y,V$,TC,LINEC,-1,-1,SLTC
   ENDIF
  ENDIF
  Y=Y+LEN(V$) DIV LINEC*8
  PL=L
  IF !ISSEL&&L==C&&IsActiveWindow(WND)THEN
   VAR _CX=X+(CX MOD LINEC)*8,_CY=OY+CX DIV LINEC*8
   GFILL _CX,_CY+6,_CX+7,_CY+7,TC
   VOID SetWindowIMCursor(WND,_CX,_CY)
  ENDIF
  L=TXTBOXEX_NEXT[L]
  INC Y,8
  IF Y+8>=H THEN BREAK
  IF!L THEN
   IF!LEN(V$)||V$[LEN(V$)-1]!=L$THEN
'    GPUTCHR LEN(V$)*8,Y-8,"[EOF]",RGB(80,208,255)
    IF PL==C&&IsActiveWindow(WND)THEN
     GFILL X+CX*8,Y-1,X+7+CX*8,Y-2,TC
     VOID SetWindowIMCursor(WND,X+CX*8,Y)
    ENDIF
   ELSE
'    GPUTCHR X,Y,"[EOF]",RGB(80,208,255)
    IF PL==C&&IsFocusWindow(WND)THEN
'     GFILLWindow WND,CX*8,Y+7,8+CX*8,Y+6,TC
    ENDIF
   ENDIF
   PL=0
   BREAK
  ENDIF
  IF MAINCNT-M0>1THEN UpdateMouse
 WEND
 GBOX 0,0,W,H,RGB(0,0,0)
 E=GCopyDirect(WND,0,0,W,H,0,0,0)
 SetWindowVar WND,6,PL
END
DEF TXTED_PRINT X,Y,V$,TC,W,SEL1,SEL2,SLTC
 IF SEL1==-1&&SEL2==-1THEN
  IF LEN(V$)<=W THEN
   GPUTCHR X,Y,V$,TC
  ELSE
   VAR I,L=(LEN(V$) DIV W)
   FOR I=0TO L
    GPUTCHR X,Y+I*8,MID$(V$,I*W,W),TC
   NEXT
  ENDIF
 ELSE
  IF SEL2<SEL1 THEN SWAP SEL1,SEL2
  IF LEN(V$)<=W THEN
   GPUTCHR X,Y,MID$(V$,0,SEL1),TC
   GPUTCHR X+SEL1*8,Y,MID$(V$,SEL1,SEL2-SEL1),SLTC
   GPUTCHR X+SEL2*8,Y,MID$(V$,SEL2,&H7FFFFFFF),TC
  ELSE
   L=(LEN(V$) DIV W)
   FOR I=0TO L
    VAR I1=I*W
    VAR I2=I1+W-1
    IF I1<=SEL1&&I2>=SEL2 THEN
     GPUTCHR X,Y+I*8,MID$(V$,I1,SEL1-I1),TC
     GPUTCHR X+(SEL1-I1)*8,Y+I*8,MID$(V$,SEL1,SEL2-SEL1),SLTC
     GPUTCHR X+(SEL2-I1)*8,Y+I*8,MID$(V$,SEL2,W-SEL2+I1),TC
     CONTINUE
    ENDIF

    IF I1<=SEL1&&I2>=SEL1 THEN
     GPUTCHR X,Y+I*8,MID$(V$,I1,SEL1-I1),TC
     GPUTCHR X+(SEL1-I1)*8,Y+I*8,MID$(V$,SEL1,I1+W-SEL1),SLTC
     CONTINUE
    ENDIF
    IF SEL1<=I1&&SEL2>=I2 THEN
     GPUTCHR X,Y+I*8,MID$(V$,I1,W),SLTC
     CONTINUE
    ENDIF
    IF SEL2>=I1&&I2>=SEL2 THEN
     GPUTCHR X,Y+I*8,MID$(V$,I1,SEL2-I1),SLTC
     GPUTCHR X+(SEL2-I1)*8,Y+I*8,MID$(V$,SEL2,W-(SEL2-I1)),TC
     CONTINUE
    ENDIF
    GPUTCHR X,Y+I*8,MID$(V$,I1,W),TC
   NEXT
  ENDIF
 ENDIF
END
DEF TXTED_UpCursor(WND)
  VAR C=GetWindowVar(WND,2)
  IF TXTBOXEX_PREV[C]THEN
   VAR L=TXTBOXEX_PREV[GetWindowVar(WND,1)]
   C=TXTBOXEX_PREV[C]
   IF L==C THEN
     SetWindowVar WND,1,L
    VAR BOX=GetWindowVar(WND,7)
    VAR LINE=GetTextBoxExLine(BOX)-1
    SetTextBoxExLine BOX,LINE
    SetScrollBarPosition GetChildWindow(WND),LINE

   ENDIF
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
DEF TXTED_GETLASTVLINE(WND)
 VAR LINEC=TXTED_GETLINEW(GetWindowWidth(WND))
 VAR H=GetWindowHeight(WND)
 VAR Y=1
 VAR C=GetWindowVar(WND,1)
 VAR PL=C
 WHILE C
  PL=C
  INC Y,(LEN(TXTBOXEX_VAL$[C])DIV LINEC)*8+8
  IF Y+8>=H THEN
   BREAK
  ENDIF
  C=TXTBOXEX_NEXT[C]
 WEND
 RETURN PL
END
DEF TXTED_DownCursor(WND)
  VAR C=GetWindowVar(WND,2)
  VAR ISSCROLL=0
  IF TXTBOXEX_NEXT[C]THEN
   IF GetWindowVar(WND,6)==C THEN
 @TAIL
    VAR L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
    IF L THEN
     SetWindowVar WND,1,L
     VAR BOX=GetWindowVar(WND,7)
     VAR LINE=GetTextBoxExLine(BOX)+1
     SetTextBoxExLine BOX,LINE
     SetScrollBarPosition GetChildWindow(WND),LINE
     ISSCROLL=TRUE
    ENDIF
   ENDIF
   C=TXTBOXEX_NEXT[C]
   SetWindowVar WND,2,C
   IF ISSCROLL THEN
    VAR P=TXTED_GETLASTVLINE(WND)
    ISSCROLL=0
    IF P!=C THEN @TAIL
   ENDIF
   RETURN 1
  ENDIF
  RETURN 0
END
COMMON DEF TextBoxExButton WND,CTL,T,BTN,_
 VAR BOX=GetWindowVar(WND,7)
 IF TXTBOXEX_CISSELING[BOX]THEN RETURN
 VAR F=GetWindowVar(WND,4),U,R=GetWindowVar(WND,5)
 TXTBOXEX_CISSEL[BOX]=0
 IF!BTN THEN SetWindowVar WND,5,0RETURN
' IF MAINCNT-F<R THEN RETURN

 IF BTN AND 1 THEN
  IF TXTED_UpCursor(WND)THEN
   TextBoxExRepaint WND
  ENDIF
  U=1
 ENDIF
 IF BTN AND 2 THEN
  IF TXTED_DownCursor(WND)THEN
   TextBoxExRepaint WND
  ENDIF
  U=1
 ENDIF
 IF BTN AND 4THEN
  VAR CX=GetWindowVar(WND,3)
  IF CX THEN
   SetWindowVar WND,3,CX-1
   TextBoxExRepaint WND
  ELSE
   IF TXTED_UpCursor(WND)THEN
    VAR C=GetWindowVar(WND,2)
    SetWindowVar WND,3,LEN(TXTBOXEX_VAL$[C])
    TextBoxExRepaint WND
   ENDIF
  ENDIF
  U=1
 ENDIF
 IF BTN AND 8THEN
  CX=GetWindowVar(WND,3)
  C=GetWindowVar(WND,2)
  SetWindowVar WND,3,CX+1
  VAR V$=TXTBOXEX_VAL$[C]
  IF LEN(V$)<=CX||LEN(V$)-1==CX&&V$[CX]==LF$()THEN
   IF TXTED_DownCursor(WND)THEN
    SetWindowVar WND,3,0
    TextBoxExRepaint WND
   ENDIF
  ENDIF
  TextBoxExRepaint WND
  U=1
 ENDIF
 IF U THEN
  IF R==0 THEN
   SetWindowVar WND,5,20
  ELSE
   SetWindowVar WND,5,3
  ENDIF
  SetWindowVar WND,4,MAINCNT
 ENDIF
END
DEF TextBoxEx_UpdateScrollBar WND
 VAR SCRBAR=GetChildWindow(WND)
 VAR BOX=GetWindowVar(WND,7)
 SetScrollBarSize SCRBAR,TXTBOXEX_CLINECNT[BOX]-1
END

COMMON DEF TextBoxExKey WND,CTL,T,KEY,_
 VAR C=GetWindowVar(WND,2)
 VAR BOX=GetWindowVar(WND,7)
 IF TXTBOXEX_CISSELING[BOX]THEN RETURN
 IF!C THEN
  C=TXTED_NewLINE("",0)
  SetWindowVar WND,1,C
  SetWindowVar WND,2,C
  TXTBOXEX_CFIRST[BOX]=C
  IF!C THEN RETURN
 ENDIF
 VAR X=GetWindowVar(WND,3)
 VAR K$=CHR$(KEY)
 IF TXTBOXEX_CISSEL[BOX]THEN
  TEXTBOXEX_REMOVESELECTEDTEXT WND OUT C,X
  IF K$==BS$()THEN @END
 ENDIF
 TXTBOXEX_CISSEL[BOX]=0
 IF K$==CR$()THEN K$=LF$()
 IF K$==BS$()THEN
  IF X>0THEN
   TXTBOXEX_VAL$[C]=RemoveStr$(TXTBOXEX_VAL$[C],X-1,1)
   SetWindowVar WND,3,X-1
  ELSE
   VAR P=TXTBOXEX_PREV[C]
   IF P THEN
    VAR L=GetWindowVar(WND,1)
    VAR V$=TXTBOXEX_VAL$[C]
    DEC TXTBOXEX_CLINECNT[BOX]
    L=TXTED_DeleteLine(C)
    IF C==TXTBOXEX_CFIRST[BOX]THEN
     TXTBOXEX_CFIRST[BOX]=L
    ENDIF
    SetWindowVar WND,2,L
    TXTBOXEX_VAL$[L]=LEFT$(TXTBOXEX_VAL$[L],LEN(TXTBOXEX_VAL$[L])-1)
    SetWindowVar WND,3,LEN(TXTBOXEX_VAL$[L])
    INC TXTBOXEX_VAL$[L],MID$(V$,X,LEN(V$)-X)
    L=GetWindowVar(WND,1)
    TextBoxEx_UpdateScrollBar WND
     VAR SCRBAR=GetChildWindow(WND)
    TextBoxEx_UpdateScrollBar WND

    IF L==C THEN
     VAR LINE=GetTextBoxExLine(BOX)-1
     SetTextBoxExLine BOX,LINE
     SetScrollBarPosition SCRBAR,LINE
     SetWindowVar WND,1,GetWindowVar(WND,2)
    ENDIF
   ENDIF
  ENDIF
 ELSE
  IF K$==LF$()THEN
   VAR C2=TXTED_NewLine(MID$(TXTBOXEX_VAL$[C],X,LEN(TXTBOXEX_VAL$[C])-X),C)
   INC TXTBOXEX_CLINECNT[BOX]
   IF!C2 THEN RETURN
   SetWindowVar WND,2,C2
   SetWindowVar WND,3,0
   TXTBOXEX_VAL$[C]=MID$(TXTBOXEX_VAL$[C],0,X)+K$
   IF 1||GetWindowVar(WND,6)==C THEN
    L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
    IF L THEN
         LINE=GetTextBoxExLine(BOX)
     IF GetWindowVar(WND,6)==C THEN
      SetWindowVar WND,1,L
      INC LINE
     ENDIF
     SetTextBoxExLine BOX,LINE
         SCRBAR=GetChildWindow(WND)
     TextBoxEx_UpdateScrollBar WND
     SetScrollBarPosition SCRBAR,LINE
    ENDIF
   ENDIF
  ELSE
'   X=MIN(MAX(LEN(TXTBOXEX_VAL$[C]),-80),X)
'   SetWindowVar WND,3,X
   TXTBOXEX_VAL$[C]=InsertStr$(TXTBOXEX_VAL$[C],X,K$)
   SetWindowVar WND,3,X+1
  ENDIF
 ENDIF
 @END
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExSetText WND,TXT$
 VAR BOX=GetWindowVar(WND,7)
 VAR C=GetWindowVar(WND,1),I,J
 TXTBOXEX_CISSEL[BOX]=FALSE
 IF C THEN
  I=C
  WHILE 1
   TXTBOXEX_VAL$[C]=""
   TXTBOXEX_PREV[C]=0
   IF!TXTBOXEX_NEXT[C]THEN BREAK
   C=TXTBOXEX_NEXT[C]
  WEND
  TXTBOXEX_NEXT[C]=TXTBOXEX_FREE
  TXTBOXEX_FREE=I
  I=0
 ENDIF
 C=0
 VAR OC=0,L=-8-8
 IF!LEN(TXT$)THEN
  TXT$=LF$()'FIXME
 ENDIF
 WHILE 1
  INC L
  J=INSTR(I,TXT$,LF$())
  IF LEN(TXT$)==I THEN BREAK
  IF J==-1THEN
   J=LEN(TXT$)-1
   C=TXTED_NewLINE(MID$(TXT$,I,J-I+1)+LF$(),C)'FIXME
  ELSE
   C=TXTED_NewLINE(MID$(TXT$,I,J-I+1),C)
  ENDIF
  IF!OC THEN
   SetWindowVar WND,1,C
   SetWindowVar WND,2,C
   TXTBOXEX_CFIRST[BOX]=C
   OC=1
  ENDIF
  IF!C THEN BREAK
  IF I==LEN(TXT$)-1THEN INC L:BREAK
  I=J+1
 WEND
 TXTBOXEX_CLINECNT[BOX]=L+15
 VAR S=L+CEIL((GetWindowHeight(WND)-2)/8)
 IF S<0THEN S=0
 TextBoxEx_UpdateScrollBar WND
' SetScrollBarSize GetChildWindow(WND),S
 SetScrollBarPosition GetChildWindow(WND),0
 SetTextBoxExLine BOX,0
 VOID RepaintWindow(WND)
END
COMMON DEF TextBoxExGetText WND OUT TXT$
 TXT$=""+""
 VAR BOX=GetWindowVar(WND,7)
 VAR C=TXTBOXEX_CFIRST[BOX]
 WHILE C
  PUSH TXT$,TXTBOXEX_VAL$[C]
  C=TXTBOXEX_NEXT[C]
 WEND
END
COMMON DEF TextBoxExCopy WND
 VAR TXT$
 TextBoxExGetSelectedText WND OUT TXT$
 ClearClipboard
 ClipboardSetText TXT$
END
COMMON DEF TextBoxExPaste WND
 IF!ClipboardContainsText()THEN RETURN
 VAR TXT$=ClipboardGetText$()
 TextBoxExSetSelectedText WND,TXT$
END
COMMON DEF TextBoxExCut WND
 TextBoxExCopy WND
 VAR _
 TEXTBOXEX_REMOVESELECTEDTEXT WND OUT _,_
END
COMMON DEF TextBoxExSelectAll WND
 VAR BOX=GetWindowVar(WND,7)
 VAR C=TXTBOXEX_CFIRST[BOX]
 TXTBOXEX_CSELLINE1[BOX]=1
 TXTBOXEX_CSELPOS1[BOX]=0
 VAR LINE
 WHILE C
  VAR OC=C
  INC LINE
  C=TXTBOXEX_NEXT[C]
 WEND
 TXTBOXEX_CSELLINE2[BOX]=LINE
 TXTBOXEX_CSELPOS2[BOX]=LEN(TXTBOXEX_VAL$[OC])
 TXTBOXEX_CISSEL[BOX]=TRUE
 VOID RepaintWindow(WND)
END
'TXT$->LINEOBJ
DEF TEXTBOXEX_PARSETXT TXT$ OUT LINEFIRST,LINELAST,LINECOUNT
 VAR I,J
 VAR C=0
 VAR OC=0,L
 VAR LF$=LF$()
 WHILE 1
  INC L
  J=INSTR(I,TXT$,LF$)
  IF LEN(TXT$)==I THEN BREAK
  IF J==-1THEN J=LEN(TXT$)-1
  C=TXTED_NewLINE(MID$(TXT$,I,J-I+1),C)
  IF!OC THEN
   LINEFIRST=C
   OC=TRUE
  ENDIF
  IF!C THEN BREAK
  IF I==LEN(TXT$)-1THEN BREAK
  I=J+1
 WEND
 IF!LEN(TXT$)THEN
  C=TXTED_NewLINE("",C)
  LINEFIRST=C
 ENDIF
 LINELAST=C
 TXTBOXEX_NEXT[C]=0
 LINECOUNT=L
END
'RET:LINE
DEF TEXTBOXEX_REMOVESELECTEDTEXT WND OUT L,CX
 VAR BOX=GetWindowVar(WND,7)
 L=GetWindowVar(WND,2)
 IF!TXTBOXEX_CISSEL[BOX]THEN
  CX=GetWindowVar(WND,3)
  RETURN
 ENDIF
 TXTBOXEX_CISSEL[BOX]=FALSE
 VAR C=TXTBOXEX_CFIRST[BOX]
 VAR SELLINE1=TXTBOXEX_CSELLINE1[BOX]
 VAR SELLINE2=TXTBOXEX_CSELLINE2[BOX]
 VAR SELPOS1=TXTBOXEX_CSELPOS1[BOX]
 VAR SELPOS2=TXTBOXEX_CSELPOS2[BOX]
 IF SELLINE1>SELLINE2 THEN
  SWAP SELLINE1,SELLINE2
  SWAP SELPOS1,SELPOS2
 ENDIF
 VAR SEL1LINEDAT
 VAR LINE
 VAR DELLINE=SELLINE2-SELLINE1
 VAR SCRBAR=GetChildWindow(WND)
 VAR CS=TXTBOXEX_CLINECNT[BOX]
 DEC TXTBOXEX_CLINECNT[BOX],DELLINE
 TextBoxEx_UpdateScrollBar WND
 'SetScrollBarSize SCRBAR,MAX(0,CS-DELLINE-16)
 IF GetTextBoxExLine(BOX)>CS-DELLINE THEN
  SetTextBoxExLine BOX,CS-DELLINE
  TXTBOXEX_CLINECNT[BOX]=CS-DELLINE
  SetScrollBarPosition SCRBAR,MAX(0,CS-DELLINE-16)

 ENDIF
 CX=SELPOS1
 WHILE C
  INC LINE
  IF SELLINE1==LINE THEN
   L=C
  ENDIF
  IF SELLINE1==LINE&&SELLINE2==LINE THEN
   IF SELPOS2<SELPOS1 THEN
    SWAP SELPOS2,SELPOS1
   ENDIF
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   TXTBOXEX_VAL$[C]=RemoveStr$(TXTBOXEX_VAL$[C],SELPOS1,SELPOS2-SELPOS1)
   CX=MIN(CX,LEN(TXTBOXEX_VAL$[C])-1)
   BREAK
  ELSEIF SELLINE1==LINE THEN
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   IF SELPOS1 THEN
    TXTBOXEX_VAL$[C]=LEFT$(TXTBOXEX_VAL$[C],SELPOS1)
   ELSE
    TXTBOXEX_VAL$[C]=""
   ENDIF
'   CX=MIN(CX,MAX(LEN(TXTBOXEX_VAL$[C])-1,0))
   SEL1LINEDAT=C
  ELSEIF SELLINE2==LINE THEN
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
'AAA<
'BBB
'C>CC
   CX=LEN(TXTBOXEX_VAL$[SEL1LINEDAT])
   INC TXTBOXEX_VAL$[SEL1LINEDAT],RIGHT$(TXTBOXEX_VAL$[C],LEN(TXTBOXEX_VAL$[C])-SELPOS2)
   TXTBOXEX_VAL$[C]=RIGHT$(TXTBOXEX_VAL$[C],LEN(TXTBOXEX_VAL$[C])-SELPOS2-1)
   VAR OC=C
   C=TXTBOXEX_NEXT[C]
   VAR _=TXTED_DeleteLine(OC)
   
   C=SEL1LINEDAT
   BREAK
  ELSEIF SELLINE1<LINE THEN
   OC=C
   C=TXTBOXEX_NEXT[C]
   _=TXTED_DeleteLine(OC)
   CONTINUE
  ENDIF
  C=TXTBOXEX_NEXT[C]
 WEND
END
COMMON DEF TextBoxExSetSelectedText WND,TXT$
 VAR _1,_3,_2,LF$=LF$()
 TEXTBOXEX_PARSETXT TXT$ OUT _1,_2,_3
 IF _1==0THEN RETURN
 VAR T1$=TXTBOXEX_VAL$[_1]
 VAR LASTLF
 IF LEN(T1$)&&T1$[LEN(T1$)-1]==LF$THEN
  LASTLF=TRUE
 ENDIF
 VAR T2$=TXTBOXEX_VAL$[_2]
 VAR LASTLF2
 IF LEN(T2$)&&T2$[LEN(T2$)-1]==LF$THEN
  LASTLF2=TRUE
 ENDIF
 VAR C
 VAR CX
 TEXTBOXEX_REMOVESELECTEDTEXT WND OUT C,CX
 VAR BOX=GetWindowVar(WND,7)

 IF LASTLF THEN
  VAR MATSUO$=MID$(TXTBOXEX_VAL$[C],CX,LEN(TXTBOXEX_VAL$[C])-CX)
  TXTBOXEX_VAL$[C]=LEFT$(TXTBOXEX_VAL$[C],CX)+T1$
  IF!LASTLF2 THEN
   TXTBOXEX_VAL$[_2]=TXTBOXEX_VAL$[_2]+MATSUO$
  ELSE
   VOID TXTED_NewLine(MATSUO$,C)
  ENDIF
  DEC _3
 ELSE
  TXTBOXEX_VAL$[C]=InsertStr$(TXTBOXEX_VAL$[C],CX,T1$)
  DEC _3
 ENDIF
 INC TXTBOXEX_CLINECNT[BOX],_3
 TextBoxEx_UpdateScrollBar WND
 IF _1==_2 THEN
  VOID TXTED_DeleteLine(_1)
  RETURN
 ENDIF
 _1=TXTBOXEX_NEXT[_1]
 VAR CN=TXTBOXEX_NEXT[C]
 TXTBOXEX_NEXT[C]=_1
 TXTBOXEX_PREV[_1]=C
 TXTBOXEX_NEXT[_2]=CN
 TXTBOXEX_PREV[CN]=_2
 VOID RepaintWindow(WND)
RETURN

END
COMMON DEF TextBoxExGetSelectedText WND OUT TXT$
 TXT$=""+""
 VAR BOX=GetWindowVar(WND,7)
 VAR C=TXTBOXEX_CFIRST[BOX]
 VAR SELLINE1=TXTBOXEX_CSELLINE1[BOX]
 VAR SELLINE2=TXTBOXEX_CSELLINE2[BOX]
 VAR SELPOS1=TXTBOXEX_CSELPOS1[BOX]
 VAR SELPOS2=TXTBOXEX_CSELPOS2[BOX]
 IF SELLINE1>SELLINE2 THEN
  SWAP SELLINE1,SELLINE2
  SWAP SELPOS1,SELPOS2
 ENDIF
 VAR LINE
 WHILE C
  INC LINE
  IF SELLINE1==LINE&&SELLINE2==LINE THEN
   IF SELPOS2<SELPOS1 THEN
    SWAP SELPOS2,SELPOS1
   ENDIF
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   TXT$=MID$(TXTBOXEX_VAL$[C],SELPOS1,SELPOS2-SELPOS1)
   BREAK
  ELSEIF SELLINE1==LINE THEN
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   PUSH TXT$,MID$(TXTBOXEX_VAL$[C],SELPOS1,LEN(TXTBOXEX_VAL$[C])-SELPOS1)
  ELSEIF SELLINE2==LINE THEN
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   PUSH TXT$,MID$(TXTBOXEX_VAL$[C],0,SELPOS2)
   BREAK
  ELSEIF SELLINE1<LINE THEN
   PUSH TXT$,TXTBOXEX_VAL$[C]
  ENDIF
  C=TXTBOXEX_NEXT[C]
 WEND
END
'===syntax highlighting===
'HashSet
VAR RTXTEDTRUE
VAR RTXTEDFALSE
VAR RTXTEDVAR
VAR RTXTEDDIM
VAR RTXTEDFOR
VAR RTXTEDNEXT
VAR RTXTEDBREAK
VAR RTXTEDCONTINUE
VAR RTXTEDREPEAT
VAR RTXTEDUNTIL
VAR RTXTEDWHILE
VAR RTXTEDWEND
VAR RTXTEDDATA
VAR RTXTEDREAD
VAR RTXTEDCOMMON
VAR RTXTEDDEF
VAR RTXTEDOUT
VAR RTXTEDEND
VAR RTXTEDRETURN
VAR RTXTEDIF
VAR RTXTEDTHEN
VAR RTXTEDELSE
VAR RTXTEDENDIF
VAR RTXTEDPRINT
VAR RTXTEDREM
VAR RTXTEDINC
VAR RTXTEDDEC
VAR RTXTEDGOTO
VAR RTXTEDGOSUB
VAR RTXTEDRESTORE
VAR RTXTEDAND
VAR RTXTEDOR
VAR RTXTEDXOR
VAR RTXTEDNOT
VAR RTXTEDMOD
VAR RTXTEDDIV
VAR RTXTEDCALL
COMMON DEF TXTED_PRGPRINT X,Y,P$,W
 W=W*8+X
 VAR OFSX=X
 VAR L=LEN(P$)-1,I,A
 VAR _0=ASC("0"),_9=ASC("9"),_Q=34
 VAR _S=ASC("'"),_A=ASC("A"),_Z=ASC("Z")
 VAR _LA=ASC("a"),_LZ=ASC("z"),__=ASC("_")
 VAR _AT=ASC("@"),_AND=ASC("&"),_B=ASC("B")
 VAR _H=ASC("H"),_1=ASC("1"),_F=ASC("F")
 VAR _LF=10
 VAR S
 FOR I=0TO L
  A=ASC(P$[I])
  IF A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__ THEN 
   S=I
   FOR I=I+1 TO L
    A=ASC(P$[I])
    IF A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__ THEN CONTINUE
    IF A>=_0&&A<=_9 THEN CONTINUE
    BREAK
   NEXT
   VAR I$=MID$(P$,S,I-S)
   VAR C=RGB(0,198,247)
   IF CHKVAR("RTXTED"+I$)THEN
    C=RGB(0,198,247)
   ELSE
    C=-1
   ENDIF
   VAR S2=0
   VAR CL=(W-X)DIV 8
   WHILE 1
    IF CL>=LEN(I$)-S2 THEN
     I$=MID$(I$,S2,CL)
     GPUTCHR X,Y,I$,C
     INC X,LEN(I$)*8
     IF X>=W THEN X=OFSX:Y=Y+8
     BREAK
    ELSE
     GPUTCHR X,Y,MID$(I$,S2,CL),C
     X=OFSX
     INC Y,8
     INC S2,CL
     CL=(W-OFSX) DIV 8
    ENDIF
   WEND
   DEC I
   CONTINUE
  ENDIF
  IF A==_Q THEN
   GPUTCHR X,Y,A,RGB(99,132,247)
   INC X,8
   IF X>=W THEN X=OFSX:Y=Y+8
   FOR I=I+1 TO L
    A=ASC(P$[I])
    IF A==_LF THEN GPUTCHR X,Y,A,-1BREAK
    GPUTCHR X,Y,A,RGB(99,132,247)
    INC X,8
    IF X>=W THEN X=OFSX:Y=Y+8
    IF A==_Q THEN BREAK
   NEXT
   IF A!=_Q THEN BREAK
   IF I==L THEN BREAK
   CONTINUE
  ENDIF
  IF A==_S THEN
   FOR I=I TO L
    A=ASC(P$[I])
    IF A==_LF THEN GPUTCHR X,Y,A,-1BREAK
    GPUTCHR X,Y,A,RGB(33,247,16)
    INC X,8
    IF X>=W THEN X=OFSX:Y=Y+8
   NEXT
   BREAK
  ENDIF
  IF A==_AT THEN
   FOR I=I TO L
    A=ASC(P$[I])
    IF!(A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__||A>=_0&&A<=_9||A==_AT)THEN DEC I:BREAK
    GPUTCHR X,Y,A,RGB(247,167,0)
    INC X,8
    IF X>=W THEN X=OFSX:Y=Y+8
   NEXT
   CONTINUE
  ENDIF
  IF A==_AND THEN
   S=ASC(P$[I])
   FOR I=I+1 TO L
    A=ASC(P$[I])
    INC X,8
    IF A==_B THEN
     GPUTCHR X-8,Y,S,RGB(247,69,149)
     IF X>=W THEN X=OFSX:Y=Y+8
     GPUTCHR X,Y,A,RGB(247,69,149)
     INC X,8
     IF X>=W THEN X=OFSX:Y=Y+8
     S=0
     FOR I=I+1 TO L
      A=ASC(P$[I])
      IF A>_1&&A<=_9 THEN
       GPUTCHR X,Y,A,-1'RGB(0,0,0)
       INC X,8
       IF X>=W THEN X=OFSX:Y=Y+8
       S=1
       CONTINUE
      ENDIF
      IF A!=_0&&A!=_1||S THEN DEC I:BREAK
      GPUTCHR X,Y,A,RGB(247,69,149)
      INC X,8
      IF X>=W THEN X=OFSX:Y=Y+8
     NEXT
     DEC I
     BREAK
    ENDIF
    IF A==_H THEN
     GPUTCHR X-8,Y,S,RGB(247,69,149)
     IF X>=W THEN X=OFSX:Y=Y+8
     GPUTCHR X,Y,A,RGB(247,69,149)
     INC X,8
     IF X>=W THEN X=OFSX:Y=Y+8
     FOR I=I+1 TO L
      A=ASC(P$[I])
      IF!(A>=_0&&A<=_9||A>=_A&&A<=_F)THEN DEC I:BREAK
      GPUTCHR X,Y,A,RGB(247,69,149)
      INC X,8
      IF X>=W THEN X=OFSX:Y=Y+8
     NEXT
     BREAK
    ENDIF
    GPUTCHR X-8,Y,S,RGB(255,255,255)
    IF X>=W THEN X=OFSX:Y=Y+8
    DEC I
    BREAK
   NEXT
   CONTINUE
  ENDIF
  IF A>=_0&&A<=_9 THEN
   GPUTCHR X,Y,A,RGB(247,69,149)
  ELSE
   IF A==_LF THEN GPUTCHR X,Y,A,RGB(0,0,0)',RGB(0,184,255)BREAK
   GPUTCHR X,Y,A,-1'RGV(0,0,0)
  ENDIF
  INC X,8
  IF X>=W THEN X=OFSX:Y=Y+8
 NEXT
END
'===End text editor===
COMMON DEF TXTEDNOTIF W,C,T,A1,A2
  IF A2==4THEN
  VOID SaveFileDialog(W,"TXT",1)
 ENDIF
 IF A2==3THEN
  VAR FILE=GetWindowVar(W,1)
  IF!FILE THEN
   VOID SaveFileDialog(W,"TXT",1)
   RETURN
  ENDIF
  IF TXTED_SAVE(W,GetString$(FILE))THEN RETURN
 ENDIF
 IF A2==2THEN
  VOID OpenFileDialog(W,"TXT",0)
 ENDIF
 IF A2==1THEN
  TextBoxExSetText GetWindowVar(W,0),LF$()
  TXTED_NEWFILE W
 ENDIF
END
DEF TXTED_NEWFILE WND
 VAR FILE=GetWindowVar(WND,1)
 IF FILE THEN
  SetWindowVar WND,1,0
  FreeString FILE
 ENDIF
 SetWindowName WND,GetControlName$(GetControl(WND))
END
DEF TXTED_SETFILE WND,FILE$
 FILE$=GetAbsolutePath$(FILE$)
 VAR FILE=GetWindowVar(WND,1)
 IF !FILE THEN
  SetWindowVar WND,1,AllocString(FILE$)
 ELSE
  SetString FILE,FILE$
 ENDIF
 SetWindowName WND,GetFileNameWithoutDir$(FILE$)+" "+GetControlName$(GetControl(WND))
END
DEF TXTED_ERROR WND,ERR
 VOID MessageBox(WND,GetControlName$(GetControl(WND)),"error:"+GetErrorName$(ERR),MessageBoxOK()OR MessageBoxError())
END
DEF TXTED_SAVE WND,FILE$ OUT ERR
 VAR T$
 TextBoxExGetText GetWindowVar(WND,0) OUT T$
 SaveFile FILE$,T$ OUT ERR
 IF ERR THEN
  TXTED_ERROR WND,ERR
  RETURN
 ENDIF
 TXTED_SETFILE WND,FILE$
END
COMMON DEF TXTEDSTRNOTIF W,C,T,ID,A2$
 ON ID GOTO @OPEN,@SAVE
 RETURN
 @OPEN
 VAR ERR,T$
 LoadFile A2$ OUT T$,ERR
 IF ERR THEN
  TXTED_ERROR W,ERR
  RETURN
 ENDIF

 TXTED_SETFILE W,A2$
 TextBoxExSetText GetWindowVar(W,0),T$
 RETURN
 @SAVE
 IF TXTED_SAVE(W,A2$)THEN RETURN
 RETURN
END
COMMON DEF TXTEDRESIZE WND,C,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W>=0THEN
  VOID ResizeWindow(GetChildWindow(WND),W,H)
 ENDIF
END
COMMON DEF TXTEDDELETE WND,C,T,A1,A2
 VAR FILE=GetWindowVar(WND,1)
 IF FILE THEN FreeString FILE
END
COMMON DEF I_TXTED
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!TXTEDCTL THEN
  ExtendControl "TXTED",GetWindowControl() OUT TXTEDCTL,E
  E=SetControlNotifHandler(TXTEDCTL,"TXTEDNOTIF")
  E=SetControlStrNotifHandler(TXTEDCTL,"TXTEDSTRNOTIF")
  E=SetControlResizeHandler(TXTEDCTL,"TXTEDRESIZE")
  E=SetControlDeleteHandler(TXTEDCTL,"TXTEDDELETE")
 ENDIF
 NewTopLevelStyleWindow TXTEDCTL,"TXTED",128,64,WindowMenuStyle()OR WindowResizableStyle()OR WindowMinMaxStyle() OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"New",1
 AddMenuItem MENU,"Open",2
 AddMenuItem MENU,"Save",3
 AddMenuItem MENU,"Save as",4
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 SetProcessVar WND
 VAR TED
 NewWindow GetTextBoxExControl(),"",0,0,128,64,WND,0 OUT TED,E
 TextBoxExSetText TED,LF$()
 SetWindowVar WND,0,TED
 VAR CMD$
 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

 IF LEN(CMD$)THEN
  VAR T$
  LoadFile(CMD$)OUT T$,E
  IF E THEN
   VOID MessageBox(WND,"TXTED","error:"+GetErrorName$(E),MessageBoxOK()OR MessageBoxError())
   RETURN
  ENDIF
  TextBoxExSetText GetWindowVar(WND,0),T$
  TXTED_SETFILE WND,CMD$
 ENDIF
'SetTextBoxExPRGMode WND,TRUE
END
COMMON DEF L_TXTED
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR PRGEDCTL
COMMON DEF I_PRGED
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!PRGEDCTL THEN
  ExtendControl "PRGED",GetWindowControl() OUT PRGEDCTL,E
  E=SetControlNotifHandler(PRGEDCTL,"TXTEDNOTIF")
  E=SetControlStrNotifHandler(PRGEDCTL,"TXTEDSTRNOTIF")
  E=SetControlResizeHandler(PRGEDCTL,"TXTEDRESIZE")
  E=SetControlDeleteHandler(PRGEDCTL,"TXTEDDELETE")
 ENDIF
 NewTopLevelStyleWindow PRGEDCTL,"PRGED",128,64,WindowMenuStyle()OR WindowResizableStyle()OR WindowMinMaxStyle() OUT WND,E
'NewTopLevelMenuWindow PRGEDCTL,"PRGED",128,64 OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"New",1
 AddMenuItem MENU,"Open",2
 AddMenuItem MENU,"Save",3
 AddMenuItem MENU,"Save as",4
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 SetProcessVar WND
 VAR TED
 NewWindow GetTextBoxExControl(),"",0,0,128,64,WND,0 OUT TED,E
 TextBoxExSetText TED,LF$()
 SetWindowVar WND,0,TED
 SetTextBoxExPRGMode TED,TRUE
 VAR CMD$

 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

 IF LEN(CMD$)THEN
  VAR T$
  LoadFile(CMD$)OUT T$,E
  IF E THEN
   VOID MessageBox(WND,"PRGED","error:"+GetErrorName$(E),MessageBoxOK()OR MessageBoxError())
   RETURN
  ENDIF
  TextBoxExSetText GetWindowVar(WND,0),T$
  TXTED_SETFILE WND,CMD$
 ENDIF
END
COMMON DEF L_PRGED
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
'===OTYA DOCUMENT EDITOR===
COMMON DEF RichTextBold()
 RETURN 1
END
COMMON DEF RichTextItalic()
 RETURN 2
END
COMMON DEF RichTextStrike()
 RETURN 4
END
COMMON DEF RichTextUnderline()
 RETURN 8
END
COMMON DEF RICHTEXT X,Y,C,STYLE,SIZE,COL
 VAR S2=SIZE DIV 8
 VAR I,X2
' INC Y,SIZE MOD 8
  @LOOP1
  IF STYLE AND 2THEN
   VAR IX=512-SIZE,IY=512-SIZE
   GFILL IX,IY,511,511,0
   GPUTCHR IX,IY,C,S2,S2,COL
   IF STYLE AND 1 THEN
    GPUTCHR X+S2,Y,C,S2,S2,COL
    GCOPY IX,IY,511,512-S2*4-1,X+1,Y,0
    GCOPY IX,IY+S2*4,511,511,X,Y+S2*4,0
   ELSE
    GCOPY IX,IY,511,512-S2*4-1,X+1,Y,0
    GCOPY IX,IY+S2*4,511,511,X,Y+S2*4,0
   ENDIF
  ELSE
   GPUTCHR X,Y,C,S2,S2,COL
   IF STYLE AND 1 THEN
    GPUTCHR X+S2,Y,C,S2,S2,COL
   ENDIF
  ENDIF
 IF STYLE AND 4THEN
  GLINE X,Y+SIZE/2-1,X+SIZE,Y+SIZE/2-1,COL
 ENDIF
 IF STYLE AND 8THEN
  GLINE X,Y+SIZE-1,X+SIZE-1,Y+SIZE-1,COL
 ENDIF
END
VAR OTYDOCCTL
VAR OTYDOC_WNDCTL
VAR OTYDOC_FREE
'===LINE===
DIM OTYDOC_LINE[0]
DIM OTYDOC_NEXT[0]
DIM OTYDOC_PREV[0]
DIM OTYDOC_VAL$[0]
'===LINE===
VAR OTYDOC_LEFT
VAR OTYDOC_CENTER
VAR OTYDOC_RIGHT
'===LINE===
'left/right/center
DIM OTYDOC_LINESTYLE[0]
'heading/list
DIM OTYDOC_LINEDATA[0]
'LINE SIZE
DIM OTYDOC_SIZE[0]
DIM OTYDOC_INDENT[0]
'===LINE===
VAR OTYDOC_LINESIZ

VAR OTYDOC_WFREE
VAR OTYDOC_WSIZ
DIM OTYDOC_WNEXT[0]
DIM OTYDOC_WPREV[0]
DIM OTYDOC_ShowLine[0]
DIM OTYDOC_CurLine[0]
DIM OTYDOC_LastShowLine[0]
DIM OTYDOC_WSIZE[0]
DIM OTYDOC_STYLE[0]
DIM OTYDOC_WSIZE2[0]
DIM OTYDOC_STYLE2[0]
DIM OTYDOC_COL[0]
DIM OTYDOC_COL2[0]
DIM OTYDOC_DEFSIZE[0]
DIM OTYDOC_DEFSTYLE[0]
DIM OTYDOC_DEFCOL[0]
DIM OTYDOC_CX[0]
DIM OTYDOC_SCRBAR[0]
DIM OTYDOC_SCRBARPOS[0]
DIM OTYDOC_HASSTARTSEL[0]
DIM OTYDOC_HASENDSEL[0]
DIM OTYDOC_SEL1[0]
DIM OTYDOC_SEL1X[0]
DIM OTYDOC_SEL2[0]
DIM OTYDOC_SEL2X[0]
DIM OTYDOC_SELS[0]
DIM OTYDOC_SELSX[0]
DIM OTYDOC_ISSEL[0]
DIM OTYDOC_SELREVERSE[0]
DIM OTYDOC_SEL1TABLE[0]
DIM OTYDOC_SEL1ROW[0]
DIM OTYDOC_SEL1COL[0]
DIM OTYDOC_SEL2TABLE[0]
DIM OTYDOC_SEL2ROW[0]
DIM OTYDOC_SEL2COL[0]
DIM OTYDOC_SELSTABLE[0]
DIM OTYDOC_SELSROW[0]
DIM OTYDOC_SELSCOL[0]
VAR OTYDOC_HEAD1
VAR OTYDOC_HEAD2
VAR OTYDOC_HEAD3
VAR OTYDOC_HEAD4
VAR OTYDOC_HEAD5
VAR OTYDOC_HEAD6
VAR OTYDOC_HEADLAST
VAR OTYDOC_ORDLIST
VAR OTYDOC_UORDLIST
VAR OTYDOC_TABLE
'===LINE===
'TABLE IS SBARRAY DATA
DIM OTYDOC_TABLEDATA[0]
DIM OTYDOC_TABLEPARENT[0]
'===LINE===
VAR OTYDOC_TABLEARY_COL
VAR OTYDOC_TABLEARY_ROW
VAR OTYDOC_TABLEARY_LINE
VAR OTYDOC_TABLEARY_HEAD
VAR OTYDOC_TBLELM
VAR OTYDOC_BEG$
VAR OTYDOC_END$
VAR OTYDOC_MENU
VAR OTYDOC_FILE_LINESTYLE
VAR OTYDOC_FILE_CONTENT
VAR OTYDOC_FILE_LINEDATA
VAR OTYDOC_FILE_INDENT
VAR OTYDOC_FILE_TABLE
VAR OTYDOC_FILE_NEWROW
VAR OTYDOC_FILE_NEWCOL
VAR OTYDOC_FILE_TABLEEND
'line size
DIM OTYDOC_WIDTH[0]
DIM OTYDOC_HEIGHT[0]
'scroll
DIM OTYDOC_YOFFSET[0]

DIM OTYDOC_WND[0]

COMMON DEF INIT_OTYDOC
 VAR E
 IF!OTYDOCCTL THEN
  OTYDOC_BEG$=CHR$(&HB10B)
  OTYDOC_END$=CHR$(&HE0F0)
  NewControl "OTYDoc" OUT OTYDOCCTL,E
  E=SetControlPainter(OTYDOCCTL,"OTYDocPainter")
  E=SetControlKeyHandler(OTYDOCCTL,"OTYDocKey")
  E=SetControlButtonHandler(OTYDOCCTL,"OTYDocButton")
  E=SetControlChFocusHandler(OTYDOCCTL,"OTYDocChFocus")
  E=SetControlCreateHandler(OTYDOCCTL,"OTYDocCreate")
  E=SetControlResizeHandler(OTYDOCCTL,"OTYDocResize")
  E=SetControlLMouseDownHandler(OTYDOCCTL,"OTYDocLMouseUp")
  E=SetControlMouseMoveHandler(OTYDOCCTL,"OTYDocMouseMove")
  E=SetControlNotifHandler(OTYDOCCTL,"OTYDocNotif")
  E=SetControlContextMenuHandler(OTYDOCCTL,"OTYDocContextMenu")
  OTYDOC_LINESIZ=1024
  OTYDOC_VAL$=NewArray$(OTYDOC_LINESIZ)
  OTYDOC_LINE=NewArray(OTYDOC_LINESIZ)
  OTYDOC_NEXT=NewArray(OTYDOC_LINESIZ)
  OTYDOC_PREV=NewArray(OTYDOC_LINESIZ)
  OTYDOC_SIZE=NewArray(OTYDOC_LINESIZ)
  OTYDOC_LINESTYLE=NewArray(OTYDOC_LINESIZ)
  OTYDOC_LINEDATA=NewArray(OTYDOC_LINESIZ)
  OTYDOC_INDENT=NewArray(OTYDOC_LINESIZ)
  OTYDOC_TABLEDATA=NewArray(OTYDOC_LINESIZ)
  OTYDOC_TABLEPARENT=NewArray(OTYDOC_LINESIZ)
  OTYDOC_WIDTH=NewArray(OTYDOC_LINESIZ)
  OTYDOC_HEIGHT=NewArray(OTYDOC_LINESIZ)
  OTYDOC_TABLEARY_COL=0
  OTYDOC_TABLEARY_ROW=1
  OTYDOC_TABLEARY_LINE=2
  OTYDOC_TABLEARY_HEAD=3
  OTYDOC_TBLELM=1
  OTYDOC_LEFT=0
  OTYDOC_CENTER=1
  OTYDOC_RIGHT=2
  OTYDOC_HEAD1=1
  OTYDOC_HEAD2=2
  OTYDOC_HEAD3=3
  OTYDOC_HEAD4=4
  OTYDOC_HEAD5=5
  OTYDOC_HEAD6=6
  OTYDOC_HEADLAST=6
  OTYDOC_ORDLIST=7
  OTYDOC_UORDLIST=8
  OTYDOC_TABLE=9
  OTYDOC_FREE=1
  VAR I
  FOR I=1TO OTYDOC_LINESIZ-2
   OTYDOC_NEXT[I]=I+1
  NEXT
  OTYDOC_WSIZ=16
  OTYDOC_WNEXT=NewArray(OTYDOC_WSIZ)
  OTYDOC_WPREV=NewArray(OTYDOC_WSIZ)
  OTYDOC_ShowLine=NewArray(OTYDOC_WSIZ)
  OTYDOC_CurLine=NewArray(OTYDOC_WSIZ)
  OTYDOC_LastShowLine=NewArray(OTYDOC_WSIZ)
  OTYDOC_WSIZE=NewArray(OTYDOC_WSIZ)
  OTYDOC_STYLE=NewArray(OTYDOC_WSIZ)
  OTYDOC_WSIZE2=NewArray(OTYDOC_WSIZ)
  OTYDOC_STYLE2=NewArray(OTYDOC_WSIZ)
  OTYDOC_COL=NewArray(OTYDOC_WSIZ)
  OTYDOC_COL2=NewArray(OTYDOC_WSIZ)
  OTYDOC_DEFSIZE=NewArray(OTYDOC_WSIZ)
  OTYDOC_DEFSTYLE=NewArray(OTYDOC_WSIZ)
  OTYDOC_DEFCOL=NewArray(OTYDOC_WSIZ)
  OTYDOC_CX=NewArray(OTYDOC_WSIZ)
  OTYDOC_SCRBAR=NewArray(OTYDOC_WSIZ)
  OTYDOC_SCRBARPOS=NewArray(OTYDOC_WSIZ)
  OTYDOC_HASSTARTSEL=NewArray(OTYDOC_WSIZ)
  OTYDOC_HASENDSEL=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL1=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL1X=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL2=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL2X=NewArray(OTYDOC_WSIZ)
  OTYDOC_SELS=NewArray(OTYDOC_WSIZ)
  OTYDOC_SELSX=NewArray(OTYDOC_WSIZ)
  OTYDOC_SELSTABLE=NewArray(OTYDOC_WSIZ)
  OTYDOC_SELSROW=NewArray(OTYDOC_WSIZ)
  OTYDOC_SELSCOL=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL1TABLE=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL1ROW=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL1COL=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL2TABLE=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL2ROW=NewArray(OTYDOC_WSIZ)
  OTYDOC_SEL2COL=NewArray(OTYDOC_WSIZ)
  OTYDOC_ISSEL=NewArray(OTYDOC_WSIZ)
  OTYDOC_SELREVERSE=NewArray(OTYDOC_WSIZ)
  OTYDOC_YOFFSET=NewArray(OTYDOC_WSIZ)
  OTYDOC_WND=NewArray(OTYDOC_WSIZ)
  OTYDOC_WFREE=1
  FOR I=1TO OTYDOC_WSIZ-2
   OTYDOC_WNEXT[I]=I+1
  NEXT
  OTYDOC_FILE_LINESTYLE=1
  OTYDOC_FILE_CONTENT=2
  OTYDOC_FILE_LINEDATA=3
  OTYDOC_FILE_INDENT=4
  OTYDOC_FILE_TABLE=5
  OTYDOC_FILE_NEWROW=6
  OTYDOC_FILE_NEWCOL=7
  OTYDOC_FILE_TABLEEND=8
  NewMenu OUT OTYDOC_MENU,E
  AddMenuItem OTYDOC_MENU,"Copy",1
  AddMenuItem OTYDOC_MENU,"Cut",2
  AddMenuItem OTYDOC_MENU,"Paste",3
  AddMenuItemSeparator OTYDOC_MENU
  AddMenuItem OTYDOC_MENU,"Select all",4
 ENDIF
END
DEF OTYDOC_NewLINE(V$,P)
 VAR R=OTYDOC_FREE
 OTYDOC_FREE=OTYDOC_NEXT[OTYDOC_FREE]
 IF P THEN
  OTYDOC_LINE[R]=OTYDOC_LINE[P]+1
  OTYDOC_TABLEPARENT[R]=OTYDOC_TABLEPARENT[P]
 ELSE
  OTYDOC_LINE[R]=1
  OTYDOC_INDENT[R]=0
  OTYDOC_TABLEPARENT[R]=0
 ENDIF
 OTYDOC_LINEDATA[R]=0
 VAR N
 IF P THEN
  N=OTYDOC_NEXT[P]
  OTYDOC_NEXT[P]=R
 ENDIF
 OTYDOC_VAL$[R]=V$
 OTYDOC_NEXT[R]=N
 OTYDOC_PREV[R]=P
 IF P THEN
  VAR LD=OTYDOC_LINEDATA[P]
  IF LD==OTYDOC_UORDLIST||LD==OTYDOC_ORDLIST THEN
   OTYDOC_LINEDATA[R]=LD
  ENDIF
  OTYDOC_INDENT[R]=OTYDOC_INDENT[P]
 ENDIF
 IF N THEN
  OTYDOC_PREV[N]=R
 ENDIF
 OTYDOC_SIZE[R]=8
 RETURN R
END
DEF OTYDOC_DeleteTable(L)
 IF!OTYDOC_TABLEDATA[L]THEN RETURN
 IF 0THEN DIM A[0]
 A=GetSBArray(OTYDOC_TABLEDATA[L])
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR R,C,_
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 FOR C=0TO COL-1
  FOR R=0TO ROW-1
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   VAR ERR=OTYDOC_DeleteLine(LINE)
  NEXT
 NEXT
 FreeSBArray OTYDOC_TABLEDATA[L]
 OTYDOC_TABLEDATA[L]=0
END
DEF OTYDOC_DeleteLine(L)
 IF!L THEN RETURN 0
 IF OTYDOC_TABLEDATA[L]THEN
  'TODO:delete table
 ENDIF
 VAR NULL$
 OTYDOC_VAL$[L]=NULL$
 VAR N=OTYDOC_NEXT[L]
 VAR P=OTYDOC_PREV[L]
 IF N THEN
  OTYDOC_PREV[N]=P
 ENDIF
 IF P THEN
  OTYDOC_NEXT[P]=N
 ENDIF
 OTYDOC_NEXT[L]=OTYDOC_FREE
 OTYDOC_FREE=L
 IF P THEN RETURN P
 IF N THEN RETURN N
 RETURN 0
END
DEF OTYDOC_NewCTL WND
 VAR R=OTYDOC_WFREE
 OTYDOC_WFREE=OTYDOC_WNEXT[OTYDOC_WFREE]
 OTYDOC_SetData WND,R
 OTYDOC_WND[R]=WND
END
DEF OTYDOC_DeleteCTL WND
 VAR L=OTYDOC_GetData(WND)
 IF!L THEN RETURN
 OTYDOC_SetData WND,0
 OTYDOC_WNEXT[L]=OTYDOC_WFREE
 OTYDOC_WFREE=L
 RETURN
END
'FONT SIZE と LINE SIZE あわせる(かいぎょうよう)
DEF OTYDOC_AdjustLine L
 VAR V$=OTYDOC_VAL$[L]
 '?"OTYDOC_AdjustLine",L,V$
 VAR I
 VAR HASTEXT
 IF LEN(V$)THEN VAR C=-1'ASC(V$[I])
 VAR YSZ=8
 FOR I=0TO LEN(V$)-1
  IF C==-1 THEN C=ASC(V$[I])CONTINUE
  IF C==&HB10BTHEN
   C=ASC(V$[I])
   IF C==0THEN
    INC I
    VAR YSZ2=ASC(V$[I])
    '?"L,YSZ2,YSZ",L,YSZ2,YSZ
    'ひどいいれこ
    'FONTSIZEしていのあと もじがないか うわがきされてたら むこう
    IF YSZ<YSZ2 THEN
     FOR I=I+1 TO LEN(V$)
      IF I<LEN(V$)THEN C=ASC(V$[I])ELSE
       IF HASTEXT THEN
        '?"EEEEEEEEEE"
        BREAK
       ENDIF
       C=0
      ENDIF
      IF C==&HB10C THEN CONTINUE
      IF C==&HB10BTHEN
       IF ASC(V$[I+1])==0THEN YSZ2=0BREAK
       FOR I=I TO LEN(V$)-1
        IF ASC(V$[I])==&HB10C THEN BREAK
       NEXT
       CONTINUE
      ENDIF
      '?CHR$(C),HEX$(C),YSZ2
      YSZ=MAX(YSZ,YSZ2)
      BREAK
     NEXT
    ENDIF
'    YSZ=MAX(YSZ,ASC(V$[I]))
    CONTINUE
   ELSE
    FOR I=I TO LEN(V$)-1
     IF ASC(V$[I])==&HB10C THEN BREAK
    NEXT
    INC I
    IF I<LEN(V$)THEN C=ASC(V$[I])
    CONTINUE
   ENDIF
  ENDIF
  HASTEXT=MAX(C,1)'TRUE
  C=ASC(V$[I])
 NEXT
 OTYDOC_SIZE[L]=YSZ
 IF!HASTEXT THEN YSZ=MAX(YSZ,YSZ2)
'DIALOG V$
'DIALOG STR$(YSZ)
END
'
DEF OTYDOC_GetData(WND)
 RETURN GetWindowVar(WND,0)
END
DEF OTYDOC_SetData WND,L
 SetWindowVar WND,0,L
END
'====EVENT HANDLER====
COMMON DEF OTYDocCreate WND,CTL,TYPE,A1,A2
 VAR SCR,E
 VAR W=GetWindowWidth(WND),
 NewVScrollBar WND,0 OUT SCR,E
 OTYDOC_NewCTL WND
 VAR D=OTYDOC_GetData(WND)
 IF!D THEN RETURN
 OTYDOC_SCRBAR[D]=SCR
 OTYDOC_COL2[D]=RGBToShort(RGB(0,0,0))
 OTYDOC_COL[D]=RGBToShort(RGB(0,0,0))
 OTYDOC_DEFCOL[D]=RGBToShort(RGB(0,0,0))
 OTYDOC_WSIZE[D]=8
 OTYDOC_WSIZE2[D]=8
 OTYDOC_DEFSIZE[D]=8
 OTYDOC_STYLE[D]=0
 OTYDOC_STYLE2[D]=0
 OTYDOC_DEFSTYLE[D]=0
 VAR S=OTYDOC_NewLine(OTYDOC_NewLineInitStyle$(D),0)
 OTYDOC_ShowLine[D]=S
 OTYDOC_CurLine[D]=S
 VOID SetWindowCursor(WND,GetBeamCursor())
END
DEF OTYDOC_CalcDocumentSize WND
 VAR D=OTYDOC_GetData(WND)
 VAR LINE=OTYDOC_ShowLine[D]
 VAR W=OTYDOC_GetWidth(WND)

 VAR HEIGHT
 WHILE LINE
  VAR N=OTYDOC_NEXT[LINE]
  VAR MINW,MAXW,LINEH
  OTYDOC_CalcSize LINE,W,N OUT MINW,MAXW,LINEH
  OTYDOC_HEIGHT[LINE]=LINEH
  HEIGHT=HEIGHT+LINEH
  LINE=N
 WEND
 VAR SCRBAR=OTYDOC_SCRBAR[D]
 SetScrollBarSize SCRBAR,HEIGHT
END
COMMON DEF OTYDocResize WND,C,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 'VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
'RESIZE TABLE
 VAR D=OTYDOC_GetData(WND)
 VAR LINE=OTYDOC_ShowLine[D]
 W=OTYDOC_GetWidth(WND)
 VAR HEIGHT
 IF 0THEN DIM A[0]
 WHILE LINE
  IF OTYDOC_TABLEDATA[LINE]THEN
   A=GetSBArray(OTYDOC_TABLEDATA[LINE])
   OTYDOC_UpdateTable2 A,W
   OTYDOC_UpdateChildrenTable A
  ENDIF
  VAR MINW,MAXW,LINEH
  VAR N=OTYDOC_NEXT[LINE]
  OTYDOC_CalcSize LINE,W,N OUT MINW,MAXW,LINEH
  OTYDOC_HEIGHT[LINE]=LINEH
  HEIGHT=HEIGHT+LINEH
  LINE=N
 WEND
 VAR SCRBAR=OTYDOC_SCRBAR[D]
 SetScrollBarSize SCRBAR,HEIGHT
 RETURN
 LINE=OTYDOC_PREV[LINE]
 WHILE LINE
  IF OTYDOC_TABLEDATA[LINE]THEN
   A=GetSBArray(OTYDOC_TABLEDATA[LINE])
   OTYDOC_UpdateTable2 A,W
   OTYDOC_UpdateChildrenTable A
  ENDIF
  LINE=OTYDOC_PREV[LINE]
 WEND
END
COMMON DEF OTYDocPainter WND,CTL,TYPE,A1,A2
 OTYDOCRepaint WND
END
DEF OTYDOCRepaint WND
 OTYDOCRepaintSEL WND',FALSE,0,0
END
DEF OTYDOC_CalcSize I,MAX,EI OUT MINW,MAXW,H
 MINW=0
 MAXW=0
 H=0
 VAR ST=0
 VAR SZ=8
 VAR COL=RGB(0,0,0)
 VAR A
 VAR OL
 VAR SL=I
 WHILE I!=EI
  VAR J
  VAR V$=OTYDOC_VAL$[I]
  VAR YSZ=OTYDOC_SIZE[I],L=LEN(V$)-1
  VAR SX=OTYDOC_INDENT[I]
  VAR X=SX
  VAR LINED=OTYDOC_LINEDATA[I]
  IF LINED==OTYDOC_UORDLIST THEN
   VAR Y8=(YSZ DIV 8)
   X=X+5*Y8
  ELSEIF LINED==OTYDOC_ORDLIST THEN
   Y8=(YSZ DIV 8)
   IF OL THEN
    OL=OL+1
   ELSEIF I==SL THEN
    VAR OLS=OTYDOC_PREV[I]
    OL=1
    WHILE OLS
     IF OTYDOC_LINEDATA[OLS]==OTYDOC_ORDLIST THEN
      OL=OL+1
      OLS=OTYDOC_PREV[OLS]
     ELSE
      BREAK
     ENDIF
    WEND
   ELSE
    OL=1
   ENDIF
   X=X+(LOG(OL,10)+1)*5*Y8+2*Y8
  ELSE
   OL=0
  ENDIF
  IF LINED==OTYDOC_TABLE THEN
   IF 0THEN DIM TBLARY[0]
   VAR TD=OTYDOC_TABLEDATA[I]
   TBLARY=GetSBArray(TD)
   VAR TH
   VAR MTBLW
   OTYDOC_CalcTableMinMax TBLARY,MAX OUT MTBLW,X,TH
   MINW=MAX(MINW,MTBLW)
   MAXW=MAX(MAXW,X)
   H=H+TH
   GOTO @C
  ENDIF
  FOR J=0TO L
   VAR C=ASC(V$[J])
   IF C==&Hb10cTHEN CONTINUE
   IF C==&Hb10bTHEN
    INC J
    C=ASC(V$[J])
    ON C GOTO@FNT,@COL,@STY
    CONTINUE
    @FNT'0
    INC J
    A=ASC(V$[J])
    SZ=A
    CONTINUE
    @COL'1
    INC J
    A=ASC(V$[J])
    COL=ShortToRGB(A)
    CONTINUE
    @STY'2
    INC J
    A=ASC(V$[J])
    ST=A
    CONTINUE
   ENDIF
   IF C<128THEN
    VAR TW=SZ*6/8+(ST AND 1)
   ELSE
    TW=SZ+(ST AND 1)
   ENDIF
   MINW=MAX(MINW,SX+TW)
   X=X+TW
   IF X+TW>=MAX THEN
    MAXW=MAX(MAXW,X)
    X=0
    H=H+YSZ
   ENDIF
  NEXT
  H=H+YSZ
  @C
  MAXW=MAX(MAXW,X)
  I=OTYDOC_NEXT[I]
 WEND
END
DEF OTYDOC_UpdateTable A
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR R,C
 VAR MINW,MW
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 
 FILL A,0,OTYDOC_TABLEARY_HEAD,ROW
 FOR C=0TO COL-1
  VAR MAXW=0
  FOR R=0TO ROW-1
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   VAR H2
   OTYDOC_CalcSize LINE,&H7FFFFFFF,0 OUT MINW,MW,H2
   MAXW=MAX(MAXW,MW+4)
   A[OTYDOC_TABLEARY_HEAD+R]=MAX(A[OTYDOC_TABLEARY_HEAD+R],H2+2)
  NEXT
  A[OTYDOC_TABLEARY_HEAD+ROW+C]=MAXW
 NEXT
END
DEF OTYDOC_CalcTableMinMax A,MAX OUT WIDTH,MAXWIDTH,HEIGHT
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR R,C
 VAR MINW,MW
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 DIM H3[ROW]
 WIDTH=2
 MAXWIDTH=2
 FOR C=0TO COL-1
  VAR MAXW=0,MAXW2=0
  FOR R=0TO ROW-1
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   VAR H2
   OTYDOC_CalcSize LINE,MAX,0 OUT MINW,MW,H2
   MAXW=MAX(MAXW,MINW+4)
   MAXW2=MAX(MAXW2,MW+4)
   H3[R]=MAX(H3[R],H2+4)
  NEXT
  WIDTH=WIDTH+MAXW
  MAXWIDTH=MAXWIDTH+MAXW2
 NEXT
 HEIGHT=4
 FOR R=0TO ROW-1
  HEIGHT=HEIGHT+H3[R]
 NEXT
END
DEF OTYDOC_UpdateTable2 A,SCRW
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR R,C
 VAR MINW,MW
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 
 DIM MINWS[COL]
 DIM MAXWS[COL]
 FILL A,0,OTYDOC_TABLEARY_HEAD,ROW
 FOR C=0TO COL-1
  VAR MAXW=0
  FOR R=0TO ROW-1
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   VAR H2
   OTYDOC_CalcSize LINE,&H7FFFFFFF,0 OUT MINW,MW,H2
   MAXWS[C]=MAX(MAXWS[C],MW+6)
   MINWS[C]=MAX(MINWS[C],MINW+6)
   A[OTYDOC_TABLEARY_HEAD+R]=MAX(A[OTYDOC_TABLEARY_HEAD+R],H2+4)
  NEXT
 NEXT
 MAXW=2
 FOR C=0TO COL-1
  MAXW=MAXW+MAXWS[C]
 NEXT
 IF MAXW<=SCRW THEN
  FOR C=0TO COL-1
   A[OTYDOC_TABLEARY_HEAD+ROW+C]=MAXWS[C]
  NEXT
  RETURN
 ENDIF
 MINW=2
 FOR C=0TO COL-1
  MINW=MINW+MINWS[C]
 NEXT
 VAR W=SCRW-MINW
 IF W>=0THEN
  VAR D=MAXW-MINW
  FOR C=0TO COL-1
   VAR D2=MAXWS[C]-MINWS[C]
   INC MINWS[C],(D2*W)DIV D
  NEXT
 ENDIF
 FOR C=0TO COL-1
  A[OTYDOC_TABLEARY_HEAD+ROW+C]=MINWS[C]
  FOR R=0TO ROW-1
   LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   OTYDOC_CalcSize LINE,MINWS[C]-2,0 OUT MINW,MW,H2
   A[OTYDOC_TABLEARY_HEAD+R]=MAX(A[OTYDOC_TABLEARY_HEAD+R],H2+4)
  NEXT
 NEXT
END
DEF OTYDOC_UpdateParentTable LINE,WIDTH
 IF 0THEN DIM A[0]
 WHILE 1
  VAR TD=OTYDOC_TABLEPARENT[LINE]
  IF!TD THEN
   BREAK
  ENDIF
  A=GetSBArray(TD)
  LINE=A[OTYDOC_TABLEARY_LINE]
 WEND
 A=GetSBArray(OTYDOC_TABLEDATA[LINE])
 OTYDOC_UpdateTable2 A,WIDTH
 OTYDOC_UpdateChildrenTable A
END
DEF OTYDOC_GetParentTable LINE OUT TBL,HIE
 IF 0THEN DIM A[0]
 HIE=0
 WHILE 1
  VAR TD=OTYDOC_TABLEPARENT[LINE]
  IF!TD THEN
   BREAK
  ENDIF
  A=GetSBArray(TD)
  LINE=A[OTYDOC_TABLEARY_LINE]
  INC HIE
 WEND
 TBL=OTYDOC_TABLEDATA[LINE]
END
DEF OTYDOC_UpdateChildrenTable A
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 VAR R,C
 IF 0THEN DIM B[0]
 FOR C=0TO COL-1
  FOR R=0TO ROW-1
   VAR CELLW=A[OTYDOC_TABLEARY_HEAD+ROW+C]
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   WHILE LINE
    VAR TD=OTYDOC_TABLEDATA[LINE]
    IF TD THEN
     B=GetSBArray(TD)
     OTYDOC_UpdateTable2 B,CELLW-2
     OTYDOC_UpdateChildrenTable B
    ENDIF
    LINE=OTYDOC_NEXT[LINE]
   WEND
  NEXT
 NEXT
END
DEF OTYDOC_GetTableLocation T1,T2 OUT R,C
 IF 0THEN DIM A[0]
 A=GetSBArray(T1)
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 FOR C=0TO COL-1
  FOR R=0TO ROW-1
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   WHILE LINE
    IF OTYDOC_TABLEDATA[LINE]THEN
     IF OTYDOC_TABLEDATA[LINE]==T2 THEN
      RETURN
     ENDIF
     VAR _
     OTYDOC_GetTableLocation OTYDOC_TABLEDATA[LINE],T2 OUT _,_
     IF _!=-1THEN RETURN
    ENDIF
    LINE=OTYDOC_NEXT[LINE]
   WEND
  NEXT
 NEXT
 R=-1
 C=-1
END
DEF OTYDOCRenderTable D,I,X,Y,WIDTH,HEIGHT,SELFLG OUT Y2
 VAR TD=OTYDOC_TABLEDATA[I]
 Y2=Y
 IF!TD THEN RETURN
 IF 0THEN DIM A[0]
 A=GetSBArray(TD)
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR R,C,_
 VAR SY=Y2
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 IF COL&&ROW&&!A[OTYDOC_TABLEARY_HEAD]THEN OTYDOC_UpdateTable2 A,WIDTH-X
' FILL A,0,OTYDOC_TABLEARY_HEAD+ROW,COL
 VAR SELR=&H7FFFFFFF,SELR2=&H7FFFFFFF
 VAR SELC=&H7FFFFFFF,SELC2=&H7FFFFFFF
 IF OTYDOC_ISSEL[D]THEN
  IF OTYDOC_SEL1TABLE[D]==TD THEN
   SELR=OTYDOC_SEL1ROW[D]
   SELC=OTYDOC_SEL1COL[D]
  ELSEIF SELFLG THEN
   SELR=0
   SELC=0
  ENDIF
  IF OTYDOC_SEL2TABLE[D]==TD THEN
   SELR2=OTYDOC_SEL2ROW[D]
   SELC2=OTYDOC_SEL2COL[D]
  ENDIF
'  IF SELC2<SELC||SELR2<SELR THEN
'   SWAP SELR2,SELR
'   SWAP SELC2,SELC
'  ENDIF
  IF SELC2<SELC THEN
   SWAP SELC2,SELC
  ENDIF
  IF SELR2<SELR THEN
   SWAP SELR2,SELR
  ENDIF
  IF SELR2==SELR&&SELC2==SELC THEN
   SELR=&H7FFFFFFF
   SELR2=&H7FFFFFFF
   SELC=&H7FFFFFFF
   SELC2=&H7FFFFFFF
  ENDIF
  VAR SC=GetSelectionColor()
 ENDIF
 FOR C=0TO COL-1
  Y2=SY
  VAR CELLW=A[OTYDOC_TABLEARY_HEAD+ROW+C]
  FOR R=0TO ROW-1
   VAR LINE=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   VAR W2,H2
   IF SELR<=R&&SELC<=C&&SELR2>=R&&SELC2>=C THEN
    GFILL X,Y2,CELLW+X,Y2+A[OTYDOC_TABLEARY_HEAD+R],SC
   ENDIF
   OTYDOCRender X+2,Y2+2,D,LINE,CELLW+X,HEIGHT OUT _,W2,H2
   H2=A[OTYDOC_TABLEARY_HEAD+R]
'   H2=MAX(A[OTYDOC_TABLEARY_HEAD+ROW+C],H2)
'   A[OTYDOC_TABLEARY_HEAD+ROW+C]=H2
   GBOX X,Y2,X+CELLW,Y2+H2,#BLACK

   Y2=Y2+H2
  NEXT
  X=X+CELLW
 NEXT
 Y2=Y2+2
END
DEF OTYDOC_GetWidth(WND)
 VAR D=OTYDOC_GetData(WND)
 RETURN GetWindowWidth(WND)-GetWindowWidth(OTYDOC_SCRBAR[D])-1
END
DEF OTYDOC_GetHeight(WND)
 VAR D=OTYDOC_GetData(WND)
 RETURN GetWindowHeight(WND)-2'border
END'CONTAINS STARTSELECTION
'CONTAINS ENDSELECTION
DEF OTYDOCRepaintSEL WND',SEL_FLG',SX,SY
 IF GBeginDirect(WND)THEN RETURN
 VAR D=OTYDOC_GetData(WND)
 VAR W=GetWindowWidth(WND)-GetWindowWidth(OTYDOC_SCRBAR[D])-1
 VAR H=GetWindowHeight(WND)
 IF!D THEN
  RETURN
 ENDIF
 VAR SL=OTYDOC_ShowLine[D]
 GCLS RGB(255,255,255)
 VAR _
 
 OTYDOCRender 2,2-OTYDOC_YOFFSET[D],D,SL,W,4+H+OTYDOC_YOFFSET[D] OUT OTYDOC_LastShowLine[D],_,_
 GBOX 0,0,W,H,RGB(0,0,0)
 VAR E=GCopyDirect(WND,0,0,W,H,0,0,1)
 E=GEndWindow(WND)
END
DEF OTYDOCRender X,Y,D,SL,W,H OUT LAST,W2,H2
 W2=0
 'DBG
 'GFILL X,Y,W,H,RGB(RND(256),RND(256),RND(256))
 VAR SY=Y
 VAR I=SL
 VAR CL=OTYDOC_CurLine[D]
 VAR CX=OTYDOC_CX[D]
 VAR ST=0
 VAR SZ=8
 VAR COL=RGB(0,0,0)
 VAR OJ
 VAR ACX=-100,ACY=-100
 VAR CURSORX=&H7FFFFFFF,CURSORY
 VAR ISTBL=!OTYDOC_SEL1TABLE[D]||(OTYDOC_SEL1COL[D]==OTYDOC_SEL2COL[D]&&OTYDOC_SEL1ROW[D]==OTYDOC_SEL2ROW[D])
 VAR CURSHOW=!OTYDOC_ISSEL[D]||ISTBL
 VAR ISSEL=OTYDOC_ISSEL[D]&&ISTBL
 IF ISSEL THEN
  VAR HASSEL1=OTYDOC_HASSTARTSEL[D]
  VAR HASSEL2=OTYDOC_HASENDSEL[D]
  IF!HASSEL2&&!HASSEL1 THEN
   ISSEL=FALSE
  ELSE
   IF HASSEL1 THEN
    VAR SEL1=OTYDOC_SEL1[D]
    VAR SEL1X=OTYDOC_SEL1X[D]
   ELSE
    SEL1=I
    SEL1X=0
   ENDIF
   VAR SEL2=OTYDOC_SEL2[D]
   VAR SEL2X=OTYDOC_SEL2X[D]
  ENDIF
 ENDIF
 VAR SELBKGND=GetSelectionColor()
 VAR SELFRGND=GetSelectionTextColor()
 VAR OL=0
 VAR SX=X
 VAR OH=GetScrollBarSize(OTYDOC_SCRBAR[D])
 VAR ISROOT=!OTYDOC_TABLEPARENT[SL]
 WHILE I
  VAR YSZ=OTYDOC_SIZE[I]
'?"YSZ",YSZ
'?YSZ,SZ,Y
  VAR V$=OTYDOC_VAL$[I]
  VAR LINESTYLE=OTYDOC_LINESTYLE[I]
  VAR A
  VAR L=LEN(V$)-1,J,C
  SZ=8
  X=SX+OTYDOC_INDENT[I]
  
  VAR HEIGHT_OY=Y
  VAR LINED=OTYDOC_LINEDATA[I]
  IF ISSEL THEN
   IF I==SEL1 THEN
    VAR SELSX=SEL1X
    IF SEL1==SEL2 THEN
     VAR SELEX=SEL2X
    ELSE
     SELEX=&H7FFDDDDF
    ENDIF
   ELSEIF I==SEL2 THEN
    SELSX=0
    SELEX=SEL2X
   ENDIF
  ENDIF
  IF LINED==OTYDOC_UORDLIST THEN
   VAR Y8=(YSZ DIV 8)
   GFILL X+Y8,Y+2*Y8,X+3*Y8,Y+4*Y8,#BLACK
   X=X+5*Y8
   OL=0
  ELSEIF LINED==OTYDOC_ORDLIST THEN
   Y8=(YSZ DIV 8)
   IF OL THEN
    OL=OL+1
   ELSEIF I==SL THEN
    VAR OLS=OTYDOC_PREV[I]
    OL=1
    WHILE OLS
     IF OTYDOC_LINEDATA[OLS]==OTYDOC_ORDLIST THEN
      OL=OL+1
      OLS=OTYDOC_PREV[OLS]
     ELSE
      BREAK
     ENDIF
    WEND
   ELSE
    OL=1
   ENDIF
   VAR OOL=OL
   VAR DG=LOG(OL,10)
   X=X+DG*5*Y8
   VAR K
   FOR K=0 TO DG
    GPUTCHR X,Y,OOL MOD 10+48,Y8,Y8
    OOL=OOL DIV 10
    X=X-5*Y8
   NEXT
   X=X+DG*5*Y8+14*Y8
   GFILL X-2*Y8,Y+YSZ-2*Y8,X-Y8-1,Y+YSZ-Y8-1,#BLACK
  ELSEIF LINED==OTYDOC_TABLE THEN
   OL=0
   OTYDOCRenderTable D,I,X,Y,W,H,ISSEL&&SELSX<=0&&SELEX>0 OUT Y
   IF!ISSEL&&OTYDOC_SEL1TABLE[D]==OTYDOC_TABLEDATA[I]THEN ISSEL=TRUE
   IF ISSEL&&OTYDOC_SEL2TABLE[D]==OTYDOC_TABLEDATA[I]THEN ISSEL=FALSE
   GOTO @C
  ELSE
   OL=0
  ENDIF
  FOR J=0TO L
   C=ASC(V$[J])
   IF C==&Hb10cTHEN CONTINUE
   IF C==&Hb10bTHEN
   IF I==CL THEN
    IF CURSHOW&&CX==J THEN
     GFILL X,Y+YSZ-SZ,X+1,Y+YSZ-1,RGB(0,0,0)
     OTYDOC_STYLE[D]=ST
     OTYDOC_COL[D]=RGBToShort(COL)
     OTYDOC_WSIZE[D]=SZ
    ENDIF
   ENDIF
    INC J
    C=ASC(V$[J])
    ON C GOTO@FNT,@COL,@STY
    CONTINUE
    @FNT'0
    INC J
    A=ASC(V$[J])
    SZ=A
'    ?"SZ",SZ
    CONTINUE
    @COL'1
    INC J
    A=ASC(V$[J])
    COL=ShortToRGB(A)
    CONTINUE
    @STY'2
    INC J
    A=ASC(V$[J])
    ST=A
    CONTINUE
   ENDIF
   IF C<128THEN
    VAR TW=SZ*6/8+(ST AND 1)
   ELSE
    TW=SZ+(ST AND 1)
   ENDIF
   IF X+TW>=W THEN
    W2=MAX(W2,X-SX)
    X=SX
    INC Y,YSZ
    IF Y+YSZ>=H THEN BREAK
   ENDIF
   IF ISSEL&&SELSX<=J&&SELEX>J THEN
     GFILL X,Y,X+TW-1,Y+YSZ-1,SELBKGND
     IF C<128THEN
      RICHTEXT X-SZ DIV 8,Y+YSZ-SZ,C,ST,SZ,SELFRGND
     ELSE
      RICHTEXT X,Y+YSZ-SZ,C,ST,SZ,SELFRGND
     ENDIF
   ELSEIF  C<128THEN
    RICHTEXT X-SZ DIV 8,Y+YSZ-SZ,C,ST,SZ,COL
   ELSE
    RICHTEXT X,Y+YSZ-SZ,C,ST,SZ,COL
   ENDIF
   IF I==CL THEN
    IF CURSHOW&&CX==J THEN
     GFILL X,Y+YSZ-SZ,X+1,Y+YSZ-1,RGB(0,0,0)
     CURSORX=X
     CURSORY=Y+YSZ-SZ
     OTYDOC_STYLE[D]=ST
     OTYDOC_COL[D]=RGBToShort(COL)
     OTYDOC_WSIZE[D]=SZ
    ENDIF
   ENDIF
'   ?HEX$(COL)
   INC X,TW
  NEXT
  IF ISSEL&&SX==X&&SELEX>0 THEN
   GFILL X,Y,X,Y+YSZ-1,SELBKGND
  ENDIF
  W2=MAX(W2,X-SX)
  IF I==CL&&CX>L&&CURSHOW THEN
   GFILL X,Y+YSZ-SZ,X+1,Y+YSZ-1,RGB(0,0,0)
   CURSORX=X
   CURSORY=Y+YSZ-SZ
   OTYDOC_STYLE[D]=ST
   OTYDOC_COL[D]=RGBToShort(COL)
   OTYDOC_WSIZE[D]=SZ
'   VOID SetWindowIMCursor(WND,
  ENDIF
  IF LINESTYLE==OTYDOC_CENTER THEN
   'CENTER
   VAR CENT=SX+(W-2-X-SX)DIV 2
   IF CURSORY>=Y&&CURSORY<=Y+YSZ THEN
    CURSORX=CURSORX+CENT-1
   ENDIF
   GCOPY SX,Y,X+1,Y+YSZ,CENT,Y,0
   IF CENT>1 THEN
    GFILL SX,Y,CENT-1,Y+YSZ,-1
   ENDIF
  ENDIF
  IF LINESTYLE==OTYDOC_RIGHT THEN
   'RIGHT
   VAR MOVE=SX+(W-2-X-SX)
   IF CURSORY>=Y&&CURSORY<=Y+YSZ THEN
    CURSORX=CURSORX+MOVE-1
   ENDIF
   GCOPY SX,Y,X+1,Y+YSZ,MOVE,Y,0
   IF MOVE>1 THEN
    GFILL SX,Y,MOVE-1,Y+YSZ,-1
   ENDIF
  ENDIF
  INC Y,YSZ
  @C
  OH=OH-OTYDOC_HEIGHT[I]
  OTYDOC_HEIGHT[I]=Y-HEIGHT_OY+1
  OH=OH+OTYDOC_HEIGHT[I]
  IF ISSEL THEN
   IF I==SEL1 THEN
    SELSX=0
    IF SEL1==SEL2 THEN
     ISSEL=FALSE
    ELSE
     SELEX=&H7FFDDDDF
    ENDIF
   ELSEIF I==SEL2 THEN
    ISSEL=FALSE
   ENDIF
  ENDIF
  IF Y+YSZ>=H THEN BREAK
  I=OTYDOC_NEXT[I]
 WEND
 IF GetScrollBarSize(OTYDOC_SCRBAR[D])!=OH THEN
  SetScrollBarSize OTYDOC_SCRBAR[D],OH
 ENDIF
 H2=Y-SY
 LAST=I
 IF CURSORX!=&H7FFFFFFF THEN
  VOID SetWindowIMCursor(OTYDOC_WND[D],CURSORX,CURSORY)
 ENDIF
END
COMMON DEF OTYDocChFocus WND,CTL,TYPE,A1,A2
END
DEF OTYDOC_CLK WND,MX,MY OUT LINE,POS
 VAR W=GetWindowWidth(WND)-8
 VAR D=OTYDOC_GetData(WND)
 IF!D THEN
  RETURN
 ENDIF
 VAR H=GetWindowHeight(WND)+OTYDOC_YOFFSET[D]
 MY=MY+OTYDOC_YOFFSET[D]
 VAR I=OTYDOC_ShowLine[D]
 OTYDOC_CLKWH I,W-2,H-2,MX-2,MY-2 OUT LINE,POS
END
DEF OTYDOC_GetTableSize A[] OUT WI,HE
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 VAR I
 WI=0
 HE=0
 FOR I=0TO ROW-1
  INC HE,A[OTYDOC_TABLEARY_HEAD+I]+2
 NEXT
 FOR I=0TO COL-1
  INC WI,A[OTYDOC_TABLEARY_HEAD+I+ROW]+2
 NEXT
END
DEF OTYDOC_CLKTBL L,MX,MY OUT LINE,POS,HEIGHT
 LINE=-1
 POS=-1
 VAR TD=OTYDOC_TABLEDATA[L]
 IF!TD THEN HEIGHT=0:RETURN
 IF 0THEN DIM A[0]
 A=GetSBArray(TD)
 VAR WI,HE
 OTYDOC_GetTableSize A OUT WI,HE
 HEIGHT=HE+1
 IF MX>WI&&MY>HE THEN RETURN
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 VAR I,J,Y,X,R,C
 FOR C=0TO COL-1
  Y=0
  VAR CELLW=A[OTYDOC_TABLEARY_HEAD+ROW+C]
  FOR R=0TO ROW-1
   L=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   VAR H2=A[OTYDOC_TABLEARY_HEAD+R]
   IF MY>=Y&&MY<Y+H2+2&&MX>=X-1&&MX<=X+CELLW THEN
    OTYDOC_CLKWH L,CELLW,H2,MX-X,MY-Y OUT LINE,POS
    IF LINE==-1THEN
     LINE=L
     POS=0
    ENDIF
    RETURN
   ENDIF
   Y=Y+H2
  NEXT
  X=X+CELLW
 NEXT
END
DEF OTYDOC_CLKWH I,W,H,MX,MY OUT LINE,POS
 VAR SL=I
 VAR Y=0,X=0
 MX=MIN(MAX(X,MX),W)
 MY=MIN(MAX(Y,MY),H)
 VAR ST=0
 VAR SZ=8
 VAR COL=RGB(0,0,0)
 VAR OJ
 VAR ACX=-100,ACY=-100
 VAR CURSORX,CURSORY
 VAR MOVECHRPOS
 VAR OL=0
 WHILE I
  LINE=-1
  POS=-1
  VAR YSZ=OTYDOC_SIZE[I]
  VAR V$=OTYDOC_VAL$[I]
  VAR LINESTYLE=OTYDOC_LINESTYLE[I]
  VAR A
  VAR L=LEN(V$)-1,J,C
  VAR ISNCR=LINESTYLE!=OTYDOC_CENTER&&LINESTYLE!=OTYDOC_RIGHT
  SZ=8
  X=1+OTYDOC_INDENT[I]
  MOVECHRPOS=0
  VAR SY=Y
  J=0
  VAR LINED=OTYDOC_LINEDATA[I]
  IF LINED==OTYDOC_UORDLIST THEN
   VAR Y8=(YSZ DIV 8)
   X=X+5*Y8
  ELSEIF LINED==OTYDOC_ORDLIST THEN
   Y8=(YSZ DIV 8)
   IF OL THEN
    OL=OL+1
   ELSEIF I==SL THEN
    VAR OLS=OTYDOC_PREV[I]
    OL=1
    WHILE OLS
     IF OTYDOC_LINEDATA[OLS]==OTYDOC_ORDLIST THEN
      OL=OL+1
      OLS=OTYDOC_PREV[OLS]
     ELSE
      BREAK
     ENDIF
    WEND
   ELSE
    OL=1
   ENDIF
   X=X+(LOG(OL,10)+1)*5*Y8+2*Y8
  ELSEIF LINED==OTYDOC_TABLE THEN
   VAR TH
   OTYDOC_CLKTBL I,MX-X,MY-Y OUT LINE,POS,TH'I,W,H,MX,MY OUT LINE,POS
   Y=Y+TH
   IF POS!=-1&&LINE!=-1THEN RETURN
   OL=0
   GOTO @C
  ELSE
   OL=0
  ENDIF
  @RETRY
  VAR SX=X
  FOR J=J TO L
   C=ASC(V$[J])
   IF C==&Hb10cTHEN CONTINUE
   IF C==&Hb10bTHEN
    INC J
    C=ASC(V$[J])
    ON C GOTO@FNT,@COL,@STY
    CONTINUE
    @FNT'0
    INC J
    A=ASC(V$[J])
    SZ=A
    CONTINUE
    @COL'1
    INC J
    A=ASC(V$[J])
    COL=ShortToRGB(A)
    CONTINUE
    @STY'2
    INC J
    A=ASC(V$[J])
    ST=A
    CONTINUE
   ENDIF
   IF C<128THEN
    VAR TW=SZ*6/8+(ST AND 1)
   ELSE
    TW=SZ+(ST AND 1)
   ENDIF
   IF X+SZ>=W THEN
    X=1
    INC Y,YSZ
    IF ISNCR&&LINE!=-1THEN RETURN
    IF Y+YSZ>=H THEN BREAK
    MOVECHRPOS=J
   ENDIF
   IF MY>=Y&&MY<=Y+YSZ THEN
    IF MX>=X&&MX<=X+TW-1THEN
     LINE=I
     POS=J
     IF ISNCR THEN RETURN
    ENDIF
   ENDIF
   INC X,TW
  NEXT
  IF POS!=-1&&MOVECHRPOS>POS THEN
   RETURN
  ENDIF
  IF !ISNCR&&LINESTYLE==OTYDOC_CENTER THEN
   'CENTER
   VAR CENT=(W-2-X)DIV 2
   IF CURSORY>=Y&&CURSORY<=Y+YSZ THEN
    CURSORX=CURSORX+CENT-1
   ENDIF
   IF MY>=Y&&MY<=Y+YSZ THEN
    X=CENT
    ISNCR=TRUE
    J=MOVECHRPOS
    GOTO @RETRY
   ENDIF
   'GCOPY 1,Y,X+1,Y+YSZ,CENT,Y,0
  ENDIF
  IF !ISNCR&&LINESTYLE==OTYDOC_RIGHT THEN
   'RIGHT
   VAR MOVE=(W-2-X)
   IF CURSORY>=Y&&CURSORY<=Y+YSZ THEN
    CURSORX=CURSORX+MOVE-1
   ENDIF
   IF MY>=Y&&MY<=Y+YSZ THEN
    X=MOVE
    ISNCR=TRUE
    J=MOVECHRPOS
    GOTO @RETRY
   ENDIF
   'GCOPY 1,Y,X+1,Y+YSZ,MOVE,Y,0
  ENDIF
  IF ISNCR&&LINE!=-1THEN RETURN
  INC Y,YSZ
  IF MY>=SY&&MY<=Y THEN
   LINE=I
   IF SX<=MX THEN
    POS=LEN(V$)
   ELSE
    POS=MOVECHRPOS
   ENDIF
   RETURN
  ENDIF
  IF!OTYDOC_NEXT[I]THEN
   MY=Y
   X=SX
   IF SX>MX THEN
    POS=0
    LINE=I
    RETURN
   ENDIF
   J=MOVECHRPOS
   GOTO @RETRY
  ENDIF
  @C
  IF Y+YSZ>=H THEN BREAK
  I=OTYDOC_NEXT[I]
 WEND
END
COMMON DEF OTYDocLMouseUp WND,CTL,TYPE,X,Y
 VAR LINE,POS
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_ISSEL[D]=FALSE
 OTYDOC_CLK WND,X,Y OUT LINE,POS
 IF LINE==-1THEN RETURN
 OTYDOC_CurLine[D]=LINE
 OTYDOC_CX[D]=POS
 VOID RepaintWindow(WND)
 VOID SetCapture(WND)
END
COMMON DEF OTYDocContextMenu WND,CTL,TYPE,X,Y
 ShowMenu OTYDOC_MENU,WND,X,Y
END
DEF OTYDOC_IsForward(S,LINE)
 VAR S2=S
 WHILE S&&S2
  S=OTYDOC_NEXT[S]
  S2=OTYDOC_PREV[S2]
  IF S==LINE THEN RETURN TRUE
  IF S2==LINE THEN RETURN FALSE
 WEND
 RETURN S!=0
END
COMMON DEF OTYDocMouseMove WND,CTL,TYPE,X,Y
 IF GetCapture()!=WND THEN
  RETURN
 ENDIF
 VAR D=OTYDOC_GetData(WND)
 VAR LINE,POS
 VAR PAINTF
 IF Y>GetWindowHeight(WND)THEN
  OTYDOC_UpdateScrollBarAndScrollContentDot D,OTYDOC_HEIGHT[OTYDOC_NEXT[OTYDOC_CurLine[D]]]
' OTYDOC_Scroll D,1
' OTYDOC_ScrollContent D,1
  PAINTF=TRUE
  VOID RepaintWindow(WND)
 ELSEIF Y<0THEN
    IF OTYDOC_YOFFSET[D]THEN
     OTYDOC_UpdateScrollBarAndScrollContentDot D,-OTYDOC_YOFFSET[D]
    ELSE
     OTYDOC_UpdateScrollBarAndScrollContentDot D,-OTYDOC_HEIGHT[OTYDOC_PREV[OTYDOC_CurLine[D]]]
    ENDIF
'  OTYDOC_Scroll D,-1
'  OTYDOC_ScrollContent D,-1
  PAINTF=TRUE
  VOID RepaintWindow(WND)
 ENDIF
 OTYDOC_CLK WND,X,Y OUT LINE,POS
 IF LINE==-1THEN RETURN
 'FWD,BKWD
 IF OTYDOC_ISSEL[D]THEN
  VAR ISF
  IF OTYDOC_SELREVERSE[D]THEN
   IF OTYDOC_SEL2[D]==LINE THEN
    ISF=OTYDOC_SEL2X[D]<POS
   ELSE
    ISF=OTYDOC_IsForward(OTYDOC_SEL2[D],LINE)
   ENDIF
  ELSE
   IF OTYDOC_SEL1[D]==LINE THEN
    ISF=OTYDOC_SEL1X[D]<POS
   ELSE
    ISF=OTYDOC_IsForward(OTYDOC_SEL1[D],LINE)
   ENDIF
  ENDIF
  IF ISF==OTYDOC_SELREVERSE[D]THEN
   VAR RF=TRUE
   OTYDOC_SEL2X[D]=OTYDOC_SELSX[D]
   OTYDOC_SEL2[D]=OTYDOC_SELS[D]
   OTYDOC_SEL1X[D]=OTYDOC_SELSX[D]
   OTYDOC_SEL1[D]=OTYDOC_SELS[D]
   OTYDOC_SELREVERSE[D]=!ISF
  ENDIF
 ENDIF
 IF OTYDOC_SELREVERSE[D]THEN
  IF OTYDOC_ISSEL[D]&&!RF&&OTYDOC_SEL1X[D]==POS&&OTYDOC_SEL1[D]==LINE THEN RETURN
  OTYDOC_SEL1X[D]=POS
  OTYDOC_SEL1[D]=LINE
 ELSE
  IF OTYDOC_ISSEL[D]&&!RF&&OTYDOC_SEL2X[D]==POS&&OTYDOC_SEL2[D]==LINE THEN RETURN
  OTYDOC_SEL2X[D]=POS
  OTYDOC_SEL2[D]=LINE
 ENDIF
 OTYDOC_CurLine[D]=LINE
 OTYDOC_CX[D]=POS
 IF!OTYDOC_ISSEL[D]THEN
  OTYDOC_SELREVERSE[D]=FALSE
  OTYDOC_ISSEL[D]=TRUE
  OTYDOC_SEL1[D]=LINE
  OTYDOC_SEL2[D]=LINE
  OTYDOC_SELS[D]=LINE
  OTYDOC_SELSTABLE[D]=OTYDOC_TABLEPARENT[LINE]
  IF OTYDOC_SELSTABLE[D]THEN 
   OTYDOC_TableGetPos GetSBArray(OTYDOC_SELSTABLE[D]),LINE OUT OTYDOC_SELSROW[D],OTYDOC_SELSCOL[D]
  ENDIF
  
  OTYDOC_SEL1X[D]=POS
  OTYDOC_SEL2X[D]=POS
  OTYDOC_SELSX[D]=POS
  OTYDOC_HASSTARTSEL[D]=TRUE
  OTYDOC_HASENDSEL[D]=TRUE
 ENDIF
 OTYDOC_SEL1TABLE[D]=OTYDOC_TABLEPARENT[OTYDOC_SEL1[D]]
 OTYDOC_SEL2TABLE[D]=OTYDOC_TABLEPARENT[OTYDOC_SEL2[D]]
 IF OTYDOC_SEL1TABLE[D]THEN 
  OTYDOC_TableGetPos GetSBArray(OTYDOC_SEL1TABLE[D]),OTYDOC_SEL1[D] OUT OTYDOC_SEL1ROW[D],OTYDOC_SEL1COL[D]
 ENDIF
 IF OTYDOC_SEL2TABLE[D]THEN 
  OTYDOC_TableGetPos GetSBArray(OTYDOC_SEL2TABLE[D]),OTYDOC_SEL2[D] OUT OTYDOC_SEL2ROW[D],OTYDOC_SEL2COL[D]
 ENDIF
 IF OTYDOC_SEL1TABLE[D]&&OTYDOC_SEL2TABLE[D]THEN
  IF OTYDOC_SEL1TABLE[D]!=OTYDOC_SEL2TABLE[D]THEN
   VAR T1,T2,HIE1,HIE2
   OTYDOC_GetParentTable OTYDOC_SEL1[D] OUT T1,HIE1
   OTYDOC_GetParentTable OTYDOC_SEL2[D] OUT T2,HIE2
   IF T1==T2 THEN
    IF HIE1>HIE2 THEN
     OTYDOC_GetTableLocation OTYDOC_SEL2TABLE[D],OTYDOC_SEL1TABLE[D] OUT OTYDOC_SEL1ROW[D],OTYDOC_SEL1COL[D]
     OTYDOC_SEL1TABLE[D]=OTYDOC_SEL2TABLE[D]
    ELSEIF HIE1<HIE2 THEN
     OTYDOC_GetTableLocation OTYDOC_SEL1TABLE[D],OTYDOC_SEL2TABLE[D] OUT OTYDOC_SEL2ROW[D],OTYDOC_SEL2COL[D]
     OTYDOC_SEL2TABLE[D]=OTYDOC_SEL1TABLE[D]
    ENDIF
   ENDIF
  ENDIF
 ENDIF
 IF!PAINTF THEN VOID RepaintWindow(WND)
END
'なんかアレ
DEF OTYDOC_UpdateScrollBarAndScrollContentDo2 D,DIFF
END
DEF OTYDOC_UpdateScrollBarAndScrollContentDot D,DIFF
 VAR SCRBAR=OTYDOC_SCRBAR[D]
 OTYDOC_SCRBARPOS[D]=GetScrollBarPosition(SCRBAR)+DIFF
 IF OTYDOC_SCRBARPOS[D]<0||GetScrollBarSize(SCRBAR)<OTYDOC_SCRBARPOS[D] THEN
  OTYDOC_SCRBARPOS[D]=GetScrollBarPosition(SCRBAR)
  RETURN
 ENDIF
 SetScrollBarPosition SCRBAR,OTYDOC_SCRBARPOS[D]
 OTYDOC_ScrollContentDot D,DIFF
END
DEF OTYDOC_ScrollContentDot D,DIFF
 VAR S=OTYDOC_ShowLine[D]
 VAR H=OTYDOC_HEIGHT[S]
 VAR OFF=OTYDOC_YOFFSET[D]
 VAR OFF2=OFF+DIFF
 IF OFF2<0THEN
  DIFF=DIFF+OTYDOC_YOFFSET[D]
  H=0
  WHILE 1
   DIFF=H+DIFF
   OTYDOC_YOFFSET[D]=DIFF
   IF DIFF>=0 THEN BREAK
   S=OTYDOC_ShowLine[D]
   VAR P=OTYDOC_PREV[S]
   IF!P THEN BREAK
   IF OTYDOC_ISSEL[D]THEN
    IF OTYDOC_SEL1[D]==P THEN
     OTYDOC_HASSTARTSEL[D]=TRUE
    ENDIF
    IF OTYDOC_SEL2[D]==P THEN
     OTYDOC_HASENDSEL[D]=TRUE
    ENDIF
   ENDIF
   H=OTYDOC_HEIGHT[P]
   OTYDOC_ShowLine[D]=P
  WEND
 ELSEIF OFF2<H THEN
  OTYDOC_YOFFSET[D]=OFF2
 ELSEIF OFF2>=H THEN
  DIFF=DIFF+OTYDOC_YOFFSET[D]
  H=0
  WHILE 1
   S=OTYDOC_ShowLine[D]
   DIFF=DIFF-H
   OTYDOC_YOFFSET[D]=DIFF
   IF OTYDOC_YOFFSET[D]<OTYDOC_HEIGHT[S]THEN BREAK
   IF!OTYDOC_NEXT[S]THEN BREAK
   IF OTYDOC_ISSEL[D]THEN
    IF OTYDOC_SEL1[D]==S THEN
     OTYDOC_HASSTARTSEL[D]=FALSE
    ENDIF
    IF OTYDOC_SEL2[D]==S THEN
     OTYDOC_HASENDSEL[D]=FALSE
    ENDIF
   ENDIF
   H=OTYDOC_HEIGHT[S]
   OTYDOC_ShowLine[D]=OTYDOC_NEXT[S]
  WEND
 ENDIF
END
DEF OTYDOC_ScrollContent D,DIFF
 VAR I
 'DOWN
 IF DIFF>0THEN
  FOR I=1TO DIFF
   VAR S=OTYDOC_ShowLine[D]
   IF!OTYDOC_NEXT[S]THEN BREAK
   IF OTYDOC_ISSEL[D]THEN
    IF OTYDOC_SEL1[D]==S THEN
     OTYDOC_HASSTARTSEL[D]=FALSE
    ENDIF
    IF OTYDOC_SEL2[D]==S THEN
     OTYDOC_HASENDSEL[D]=FALSE
    ENDIF
   ENDIF
   OTYDOC_ShowLine[D]=OTYDOC_NEXT[S]
  NEXT
 'UP
 ELSEIF DIFF<0THEN
  FOR I=DIFF TO -1
   S=OTYDOC_ShowLine[D]
   VAR P=OTYDOC_PREV[S]
   IF!P THEN BREAK
   IF OTYDOC_ISSEL[D]THEN
    IF OTYDOC_SEL1[D]==P THEN
     OTYDOC_HASSTARTSEL[D]=TRUE
    ENDIF
    IF OTYDOC_SEL2[D]==P THEN
     OTYDOC_HASENDSEL[D]=TRUE
    ENDIF
   ENDIF
   OTYDOC_ShowLine[D]=P
  NEXT
 ENDIF
END
COMMON DEF OTYDocNotif WND,CTL,TYPE,A1,A2
 VAR D=OTYDOC_GetData(WND)
 IF!D THEN RETURN
 IF A1==MenuNotifID()THEN
  ON A2 GOTO @I,@COP,@CUT,@PAS,@SEL
  @I
  RETURN
  @COP
  RTECopy WND
  RETURN
  @CUT
  RTECut WND
  RETURN
  @PAS
  RTEPaste WND
  RETURN
  @SEL
  RTESelectAll WND
  RETURN
 ENDIF
 IF A1==OTYDOC_SCRBAR[D]THEN
  VAR OLD=OTYDOC_SCRBARPOS[D]
  VAR DIFF=A2-OLD
  OTYDOC_SCRBARPOS[D]=A2
  OTYDOC_ScrollContentDot D,DIFF
  VOID RepaintWindow(WND)
 ENDIF
END
DEF OTYDOC_UpCursor(WND)
  VAR D=GetWindowVar(WND,0)
  VAR C=OTYDOC_CurLine[D]
  VAR P=OTYDOC_PREV[C]
  IF P THEN
   OTYDOC_ISSEL[D]=0
   IF C==OTYDOC_ShowLine[D]THEN
    IF OTYDOC_YOFFSET[D]THEN
     OTYDOC_UpdateScrollBarAndScrollContentDot D,-OTYDOC_YOFFSET[D]
    ELSE
     OTYDOC_UpdateScrollBarAndScrollContentDot D,-OTYDOC_HEIGHT[OTYDOC_PREV[OTYDOC_CurLine[D]]]
    ENDIF
'    OTYDOC_ShowLine[D]=OTYDOC_PREV[C]
'    OTYDOC_Scroll D,-1
   ENDIF
   IF OTYDOC_PREV[C]==OTYDOC_ShowLine[D]THEN
    IF OTYDOC_YOFFSET[D]THEN
     OTYDOC_UpdateScrollBarAndScrollContentDot D,-OTYDOC_YOFFSET[D]
    ENDIF
   ENDIF
   VAR CV$=OTYDOC_VAL$[OTYDOC_CurLine[D]]
   OTYDOC_CurLine[D]=P
   OTYDOC_CX[D]=OTYDOC_TOPOS(OTYDOC_VAL$[OTYDOC_CurLine[D]],OTYDOC_GETPOS(CV$,OTYDOC_CX[D]))
   RETURN 1
'SCROLL
   VAR L=OTYDOC_PREV[GetWindowVar(WND,1)]
   C=OTYDOC_PREV[C]
   IF L==C THEN
     SetWindowVar WND,1,L
   ENDIF
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
DEF OTYDOC_SetLine D,S
 VAR SCRBAR=OTYDOC_SCRBAR[D]
 SetScrollBarSize SCRBAR,S
 SetScrollBarPosition SCRBAR,0
 OTYDOC_SCRBARPOS[D]=0
END
DEF OTYDOC_AddLine D,MY
 VAR SCRBAR=OTYDOC_SCRBAR[D]
 SetScrollBarSize SCRBAR,GetScrollBarSize(SCRBAR)+MY
END
DEF OTYDOC_Scroll D,MY
 VAR SCRBAR=OTYDOC_SCRBAR[D]
 OTYDOC_SCRBARPOS[D]=GetScrollBarPosition(SCRBAR)+MY
 IF OTYDOC_SCRBARPOS[D]<0||GetScrollBarSize(SCRBAR)<OTYDOC_SCRBARPOS[D] THEN
  OTYDOC_SCRBARPOS[D]=GetScrollBarPosition(SCRBAR)
  RETURN
 ENDIF
 SetScrollBarPosition SCRBAR,OTYDOC_SCRBARPOS[D]
END
DEF OTYDOC_GETPOS(V$,CX)
 VAR I,L=LEN(V$)-1
 VAR CC
 IF CX>L THEN
  CC=CC+1
  CX=L
 ENDIF
 FOR I=0 TO CX
  VAR A=ASC(V$[I])
  IF A==&HB10B THEN
   FOR I=I TO L
    IF ASC(V$[I])==&HB10CTHEN
     BREAK
    ENDIF
   NEXT
   CONTINUE
  ENDIF
  CC=CC+1
 NEXT
 RETURN MAX(0,CC-1)
END
DEF OTYDOC_TOPOS(V$,CC)
 VAR I,L=LEN(V$)-1
 FOR I=0 TO L
  VAR A=ASC(V$[I])
  IF A==&HB10B THEN
   FOR I=I TO L
    IF ASC(V$[I])==&HB10CTHEN
     BREAK
    ENDIF
   NEXT
   CONTINUE
  ENDIF
  IF CC<=0 THEN RETURN I
  CC=CC-1
 NEXT
 RETURN L+1
END
DEF OTYDOC_DownCursor(WND)
  VAR D=GetWindowVar(WND,0)
  VAR C=OTYDOC_CurLine[D]
'SCROLL
  IF OTYDOC_NEXT[C]THEN
   OTYDOC_ISSEL[D]=0
   IF OTYDOC_CurLine[D]==OTYDOC_LastShowLine[D]THEN
    OTYDOC_UpdateScrollBarAndScrollContentDot D,OTYDOC_HEIGHT[OTYDOC_NEXT[OTYDOC_CurLine[D]]]
    'OTYDOC_ShowLine[D]=OTYDOC_NEXT[OTYDOC_ShowLine[D]]
    'OTYDOC_Scroll D,1
   ENDIF
   VAR CV$=OTYDOC_VAL$[OTYDOC_CurLine[D]]
   OTYDOC_CurLine[D]=OTYDOC_NEXT[C]
   OTYDOC_CX[D]=OTYDOC_TOPOS(OTYDOC_VAL$[OTYDOC_CurLine[D]],OTYDOC_GETPOS(CV$,OTYDOC_CX[D]))
   RETURN 1
   IF GetWindowVar(WND,6)==C THEN
    VAR L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
    IF L THEN
     SetWindowVar WND,1,L
    ENDIF
   ENDIF
   C=TXTBOXEX_NEXT[C]
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
DEF OTYDOC_DeleteDup2 C
 VAR V$=OTYDOC_VAL$[C]
 VAR CX
 FOR CX=0TO LEN(V$)-1
 VAR S0=0,S1=0,S2=0,OC=CX
 IF ASC(V$[CX])==&HB10BTHEN
  @LOOP21
  VAR A=ASC(V$[CX])
  FOR CX=CX+1 TO LEN(V$)-1
   IF A==&HB10B THEN
    A=ASC(V$[CX])
    IF A==0THEN INC S0:CONTINUE
    IF A==1THEN INC S1:CONTINUE
    IF A==2THEN INC S2:CONTINUE
   ENDIF
   A=ASC(V$[CX])
   IF A==&HB10CTHEN BREAK
  NEXT
  IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN @LOOP21
  '?S0,S1,S2
  IF S2||S1||S0 THEN
   OTYDOC_DeleteDup V$,OC,CX,S0,S1,S2 OUT CX
  ENDIF
 ENDIF
 NEXT
END
DEF OTYDOC_DeleteDup V$,OC,CX,S0,S1,S2 OUT CX2
 VAR I
 VAR A=ASC(V$[OC])
 FOR I=OC+1 TO CX
  IF LEN(V$)<=I THEN BREAK
  IF A==&HB10B THEN
   A=ASC(V$[I])
   IF A==0THEN
    IF S0>1 THEN DEC S0 ELSE CONTINUE
   ENDIF
   IF A==1THEN
    IF S1>1 THEN DEC S1 ELSE CONTINUE
   ENDIF
   IF A==2THEN
    IF S2>1 THEN DEC S2 ELSE CONTINUE
   ENDIF
   DEC I
   WHILE 1
    A=ASC(V$[I])
    V$[I]=""
    DEC CX
    IF A==&HB10C THEN BREAK
   WEND
  ENDIF
  IF LEN(V$)<=I THEN BREAK
  A=ASC(V$[I])
  'IF A==&HB10C THEN BREAK
 NEXT
 CX2=CX
END
COMMON DEF OTYDOCButton WND,CTL,T,BTN,_
 IF GetCapture()==WND THEN RETURN
 VAR F=GetWindowVar(WND,4),U,R=GetWindowVar(WND,5)
 IF BTN AND 1 THEN
  IF OTYDOC_UpCursor(WND)THEN
   OTYDOCRepaint WND
  ENDIF
  U=1
 ENDIF
 IF BTN AND 2 THEN
  IF OTYDOC_DownCursor(WND)THEN
   OTYDOCRepaint WND
  ENDIF
  U=1
 ENDIF
 VAR D=GetWindowVar(WND,0)
 IF BTN AND 4THEN
  VAR CX=OTYDOC_CX[D]
  VAR C=OTYDOC_CurLine[D]
  OTYDOC_ISSEL[D]=FALSE
  VAR S$=OTYDOC_VAL$[C]
  IF CX<LEN(S$)&&ASC(S$[CX])==&HB10CTHEN
   @LOOP11
   FOR CX=CX TO 0 STEP -1
    IF ASC(S$[CX])==&HB10BTHEN DEC CX:BREAK
   NEXT
   IF CX<0THEN CX=0
   IF ASC(S$[CX])==&HB10CTHEN @LOOP11
   OTYDOC_CX[D]=CX
  ENDIF
  IF CX THEN
   DEC OTYDOC_CX[D]
   DEC CX
   IF CX<LEN(S$)&&ASC(S$[CX])==&HB10CTHEN
   BEEP 
    @LOOP1
    FOR CX=CX TO 0 STEP -1
     IF ASC(S$[CX])==&HB10BTHEN DEC CX:BREAK
    NEXT
    VAR CXMF
    IF CX<0THEN CX=0:CXMF=TRUE
    IF ASC(S$[CX])==&HB10CTHEN @LOOP1
    OTYDOC_CX[D]=CX
    IF CXMF THEN @___
   ENDIF
   OTYDOCRepaint WND
  ELSE
   @___
   IF OTYDOC_UpCursor(WND)THEN
    C=OTYDOC_CurLine[D]
    OTYDOC_CX[D]=LEN(OTYDOC_VAL$[C])
    OTYDOCRepaint WND
   ELSE
    OTYDOCRepaint WND
   ENDIF
  ENDIF
  U=1
 ENDIF
 IF BTN AND 8THEN
  CX=OTYDOC_CX[D]
  C=OTYDOC_CurLine[D]
  OTYDOC_ISSEL[D]=FALSE
  VAR V$=OTYDOC_VAL$[C]
  VAR S0,S1,S2,OC=CX
  IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN
   @LOOP21
   VAR A=ASC(V$[CX])
   FOR CX=CX+1 TO LEN(V$)-1
    IF A==&HB10B THEN
     A=ASC(V$[CX])
     IF A==0THEN INC S0:CONTINUE
     IF A==1THEN INC S1:CONTINUE
     IF A==2THEN INC S2:CONTINUE
    ENDIF
    A=ASC(V$[CX])
    IF A==&HB10CTHEN INC CX:BREAK
   NEXT
   IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN @LOOP21
   IF S2||S1||S0 THEN
    '?S0,S1,S2,OC;"-";CX
    OTYDOC_DeleteDup V$,OC,CX,S0,S1,S2 OUT CX
   ENDIF
   OTYDOC_CX[D]=CX
  ENDIF
  INC OTYDOC_CX[D]
  INC CX'TODO:BUG?  IF LEN(V$)<=CX||LEN(V$)-1==CX&&V$[CX]==LF$()THEN

  IF LEN(V$)<=CX THEN'IF LEN(V$)<=CX||LEN(V$)==CX&&V$[CX]==LF$()THEN
   IF LEN(V$)<CX THEN 
   IF OTYDOC_DownCursor(WND)THEN
    OTYDOC_CX[D]=0
   ELSE
    DEC OTYDOC_CX[D]
   ENDIF
   ENDIF
  ELSE
   IF ASC(V$[CX])==&HB10B0THEN
    @LOOP2
    FOR CX=CX TO LEN(V$)-1
     IF ASC(V$[CX])==&HB10CTHEN INC CX:BREAK
    NEXT
    IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN @LOOP2
    OTYDOC_CX[D]=CX
   ENDIF
  ENDIF
  OTYDOCRepaint WND
  U=1
 ENDIF
 CX=LEN(OTYDOC_VAL$[OTYDOC_CurLine[D]])-1
 IF 0THEN 
 VAR I,LLL
 FOR I=0TO CX
  IF I==OTYDOC_CX[D]THEN LLL=CSRX
  S$=OTYDOC_VAL$[OTYDOC_CurLine[D]]
  IF ASC(S$[I])==&HB10BTHEN
   COLOR 2
   ?OTYDOC_VAL$[OTYDOC_CurLine[D]][I];'C]
   INC I
   IF I==OTYDOC_CX[D]THEN LLL=CSRX
   IF ASC(S$[I])==0THEN ?"<SIZE>";
   IF ASC(S$[I])==1THEN ?"<COLOR>";
   IF ASC(S$[I])==2THEN ?"<STYLE>";
   INC I
   IF I==OTYDOC_CX[D]THEN LLL=CSRX
   ?ASC(S$[I]);
   CONTINUE
  ELSEIF ASC(S$[I])==&HB10CTHEN
   COLOR 3
  ELSE COLOR 15 ENDIF
  ?OTYDOC_VAL$[OTYDOC_CurLine[D]][I];'C]
 NEXT
  IF I==OTYDOC_CX[D]THEN LLL=CSRX
 ?
 COLOR 15
 ?" "*(LLL);""
 ENDIF
 IF U THEN
  IF R==0 THEN
   SetWindowVar WND,5,20
  ELSE
   SetWindowVar WND,5,3
  ENDIF
  SetWindowVar WND,4,MAINCNT
 ENDIF
END

COMMON DEF OTYDOC_TextCheck(V$,I)
 FOR I=I TO LEN(V$)-1
  VAR A=ASC(V$[I])
  IF A==&HB10B THEN
   FOR I=I TO LEN(V$)-1
    IF ASC(V$[I])==&HB10CTHEN
     BREAK
    ENDIF
   NEXT
   CONTINUE
  ENDIF
  RETURN TRUE
 NEXT
 RETURN FALSE
END
DEF OTYDOC_RemoveSelected D,WND OUT X,C
 IF!OTYDOC_ISSEL[D] THEN
  RETURN
 ENDIF
 C=OTYDOC_CurLine[D]
 X=OTYDOC_CX[D]
 VAR SL=OTYDOC_ShowLine[D]
 VAR S=OTYDOC_SEL1[D]
 VAR E=OTYDOC_SEL2[D]
 VAR SX=OTYDOC_SEL1X[D]
 VAR EX=OTYDOC_SEL2X[D]
 IF S==E THEN
  RemoveStrB OTYDOC_VAL$[S],SX,EX-SX
  IF C==S&&X>SX THEN
   X=SX
  ENDIF
  IF OTYDOC_TABLEPARENT[S]THEN
   OTYDOC_UpdateParentTable S,OTYDOC_GetWidth(WND)
  ENDIF
  RETURN
 ENDIF
 OTYDOC_VAL$[S]=MID$(OTYDOC_VAL$[S],0,SX)
 S=OTYDOC_NEXT[S]
 VAR DL
 WHILE S
  IF S==C THEN
   C=OTYDOC_PREV[S]
   X=LEN(OTYDOC_VAL$[C])
  ENDIF
  VAR NXT=OTYDOC_NEXT[S]
  IF S==E THEN
   VAR S2=OTYDOC_SEL1[D]
   OTYDOC_VAL$[S2]=OTYDOC_VAL$[S2]+MID$(OTYDOC_VAL$[S],EX,LEN(OTYDOC_VAL$[S]))
  ENDIF
  VAR _=OTYDOC_DeleteLine(S)
  INC DL
  IF S==E THEN
   BREAK
  ENDIF
  S=NXT
 WEND
 IF OTYDOC_TABLEPARENT[C]THEN
  OTYDOC_UpdateParentTable C,OTYDOC_GetWidth(WND)
 ENDIF
 OTYDOC_AddLine D,-DL
END

DEF OTYDOC_GetNextTextPos(V$,I)
 FOR I=I TO LEN(V$)-1
  VAR C=ASC(V$[I])
  IF C==&HB10BTHEN
   I=INSTR(I,V$,CHR$(&HB10C))
   CONTINUE
  ENDIF
  BREAK
 NEXT
 RETURN I
END
DEF OTYDOC_GetStyle V$,I,E,TYPE OUT S$
 VAR L=LEN(V$)-1
 S$=""
 WHILE 1
  I=INSTR(I,V$,CHR$(&HB10B))
  IF I==-1THEN RETURN
  IF I>=E THEN RETURN
  IF ASC(V$[I+1])==TYPE THEN
   VAR O=I
   I=INSTR(I,V$,CHR$(&HB10C))
   S$=MID$(V$,O,I-O+1)
  ELSE
   I=INSTR(I,V$,CHR$(&HB10C))
  ENDIF
 WEND
END
DEF OTYDOC_RemoveStyle V$,I,E,TYPE
 VAR S$
 OTYDOC_GetStyle V$,0,E,TYPE OUT S$
 VAR L=LEN(V$)-1
 IF LEN(S$)THEN V$[E-1]=V$[E-1]+S$
 WHILE 1
  I=INSTR(I,V$,CHR$(&HB10B))
  IF I==-1THEN BREAK
  IF I>=E THEN BREAK
  IF ASC(V$[I+1])==TYPE THEN
   REPEAT
    VAR VI=ASC(V$[I])
    V$[I]=""
    DEC E
   UNTIL VI==&HB10C
  ELSE
   I=INSTR(I,V$,CHR$(&HB10C))
  ENDIF
 WEND
END
DEF OTYDOC_RemoveAllStyle V$,I,E
 VAR S$
 VAR L=LEN(V$)-1
 WHILE 1
  I=INSTR(I,V$,CHR$(&HB10B))
  IF I==-1THEN BREAK
  IF I>=E THEN BREAK
  REPEAT
   VAR VI=ASC(V$[I])
   V$[I]=""
   DEC E
  UNTIL VI==&HB10C
 WEND
END
'D:DATA
'S:LINE
'S$:STYLE(B10B...B10C)
DEF OTYDOC_SetLineStyle D,S,SX,EX,S$ OUT SX2,EX2
 VAR CX=OTYDOC_CX[D]
 VAR CL=OTYDOC_CurLine[D]
 VAR TYPE=ASC(S$[1])
 VAR UF
 IF TYPE==0THEN 'FONT SIZE
  IF OTYDOC_SIZE[S]<ASC(S$[2]) THEN
   OTYDOC_SIZE[S]=ASC(S$[2])
   UF=TRUE
  ENDIF
 ENDIF
 IF CL==S THEN
  VAR X2=OTYDOC_GETPOS(OTYDOC_VAL$[S],CX)
 ENDIF
 SX2=OTYDOC_GETPOS(OTYDOC_VAL$[S],SX)
 EX2=OTYDOC_GETPOS(OTYDOC_VAL$[S],EX)
 IF OTYDOC_LINEDATA[S]==OTYDOC_TABLE THEN
  'TABLE
  
  RETURN
 ENDIF
 OTYDOC_RemoveStyle OTYDOC_VAL$[S],SX,EX,TYPE
 IF!LEN(OTYDOC_VAL$[S])||LEN(OTYDOC_VAL$[S])<=SX THEN
  PUSH OTYDOC_VAL$[S],S$
 ELSE
  OTYDOC_VAL$[S][SX]=S$+OTYDOC_VAL$[S][SX]
 ENDIF
 SX2=OTYDOC_TOPOS(OTYDOC_VAL$[S],SX2)
 EX2=OTYDOC_TOPOS(OTYDOC_VAL$[S],EX2)
 IF CL==S THEN
  OTYDOC_CX[D]=OTYDOC_TOPOS(OTYDOC_VAL$[S],X2)
 ENDIF
 IF TYPE==0&&!UF THEN
  OTYDOC_AdjustLine S
 ENDIF
END
'&HB10B TYPE ARGS &HB10C
'=>TYPE ARGSをしてい
DEF OTYDOC_SetSelectedStyle WND,STYLE$
 VAR D=OTYDOC_GetData(WND)
 IF!OTYDOC_ISSEL[D] THEN
  RETURN
 ENDIF
 VAR TYPE=ASC(STYLE$[0])
 VAR CX=OTYDOC_CX[D]
 VAR CL=OTYDOC_CurLine[D]
 VAR SL=OTYDOC_ShowLine[D]
 VAR S=OTYDOC_SEL1[D]
 VAR E=OTYDOC_SEL2[D]
 VAR SX=OTYDOC_SEL1X[D]
 VAR EX=OTYDOC_SEL2X[D]
 IF SX==EX&&S==E THEN RETURN
 VAR S$=CHR$(&HB10B)+STYLE$+CHR$(&HB10C)
 IF S==E THEN
  OTYDOC_SetLineStyle D,S,SX,EX,S$ OUT OTYDOC_SEL1X[D],OTYDOC_SEL2X[D]
  VOID RepaintWindow(WND)
  RETURN
 ENDIF
 VAR _
 OTYDOC_SetLineStyle D,S,SX,LEN(OTYDOC_VAL$[S]),S$ OUT OTYDOC_SEL1X[D],_
 S=OTYDOC_NEXT[S]
 WHILE 1
  VAR NXT=OTYDOC_NEXT[S]
  IF S==E THEN
   VAR S2=OTYDOC_SEL1[D]
   OTYDOC_SetLineStyle D,S,0,EX,S$ OUT _,OTYDOC_SEL2X[D]
   BREAK
  ENDIF
  OTYDOC_SetLineStyle D,S,0,LEN(OTYDOC_VAL$[S]),S$ OUT _,_
  S=NXT
 WEND
 VOID RepaintWindow(WND)
END
COMMON DEF OTYDocKey WND,CTL,TYPE,KEY,A2
 IF GetCapture()==WND THEN RETURN
 VAR D=OTYDOC_GetData(WND)
 VAR S=OTYDOC_ShowLine[D]
 IF OTYDOC_ISSEL[D]THEN
  'REMOVE
  OTYDOC_RemoveSelected D,WND OUT OTYDOC_CX[D],OTYDOC_CurLine[D]
  OTYDOC_ISSEL[D]=0
  IF KEY==8THEN @END
 ENDIF
 VAR C=OTYDOC_CurLine[D]
 VAR X=OTYDOC_CX[D]
 IF!S THEN
  RETURN
 ENDIF
 VAR I$=CHR$(KEY)
 IF I$==BS$()THEN
  IF X THEN
   DEC OTYDOC_CX[D]
   DEC X
   VAR S$=OTYDOC_VAL$[C]
   WHILE 1
    IF ASC(S$[X])==&Hb10cTHEN
     FOR X=X TO 0 STEP -1
      IF ASC(S$[X])==&Hb10bTHEN DEC X:BREAK
     NEXT
     IF X<0THEN X=0OTYDOC_CX[D]=X:OTYDOCRepaint WND:RETURN
     OTYDOC_CX[D]=X
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF ASC(S$[X])==&Hb10bTHEN
    DEC X
    DEC OTYDOC_CX[D]
    IF X<0THEN X=0OTYDOC_CX[D]=X:OTYDOCRepaint WND:RETURN

   ENDIF
   RemoveStrB OTYDOC_VAL$[C],X,1
   
   OTYDOC_AdjustLine C
  ELSE
   IF OTYDOC_PREV[C]THEN
    OTYDOC_AddLine D,-1
    S$=OTYDOC_VAL$[C]
    C=OTYDOC_DeleteLine(C)
    OTYDOC_CurLine[D]=C
    'SCROLL
    OTYDOC_CX[D]=LEN(OTYDOC_VAL$[C])
    OTYDOC_VAL$[C]=OTYDOC_VAL$[C]+S$
    OTYDOC_AdjustLine C
   ENDIF
  ENDIF
 ELSE
  IF I$==CR$()THEN
   IF OTYDOC_LINEDATA[C]>=OTYDOC_HEAD1&&OTYDOC_LINEDATA[C]<=OTYDOC_HEADLAST THEN
    OTYDOC_STYLE2[D]=OTYDOC_DEFSTYLE[D]
    OTYDOC_WSIZE2[D]=OTYDOC_DEFSIZE[D]
    OTYDOC_COL2[D]=OTYDOC_DEFCOL[D]
    OTYDOC_STYLE[D]=OTYDOC_DEFSTYLE[D]
    OTYDOC_WSIZE[D]=OTYDOC_DEFSIZE[D]
    OTYDOC_COL[D]=OTYDOC_DEFCOL[D]
   ENDIF
   VAR HEAD$=OTYDOC_NewLineInitStyle$(D)
   VAR C2=OTYDOC_NewLine(HEAD$+MID$(OTYDOC_VAL$[C],X,LEN(OTYDOC_VAL$[C])-X),C)
   IF!C2 THEN RETURN
   IF OTYDOC_LastShowLine[D]==OTYDOC_CurLine[D]THEN
    OTYDOC_ShowLine[D]=OTYDOC_NEXT[OTYDOC_ShowLine[D]]
    OTYDOC_Scroll D,1
   ENDIF
   OTYDOC_AddLine D,1
   OTYDOC_VAL$[C]=MID$(OTYDOC_VAL$[C],0,X)
'  OTYDOC_DeleteDup2 C
'  OTYDOC_DeleteDup2 C2
   OTYDOC_AdjustLine C
   OTYDOC_SIZE[C2]=OTYDOC_WSIZE[D]
   OTYDOC_AdjustLine C2
   OTYDOC_CurLine[D]=C2
   OTYDOC_CX[D]=LEN(HEAD$)
   IF FALSE THEN 
   SetWindowVar WND,2,C2
   SetWindowVar WND,3,0
'  OTYDOC_VAL$[C]=MID$(TXTBOXEX_VAL$[C],0,X)+K$
   IF GetWindowVar(WND,6)==C THEN
'   L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
'   IF L THEN
'    SetWindowVar WND,1,L
'   ENDIF
   ENDIF
   ENDIF
  ELSE
  IF OTYDOC_STYLE[D]!=OTYDOC_STYLE2[D]THEN
   VAR TF=OTYDOC_TextCheck(OTYDOC_VAL$[C],X)
   I$=CHR$(&HB10B)+CHR$(2)+CHR$(OTYDOC_STYLE2[D])+CHR$(&HB10C)+I$
   IF TF THEN PUSH I$,CHR$(&HB10B)+CHR$(2)+CHR$(OTYDOC_STYLE[D])+CHR$(&HB10C)
   OTYDOC_STYLE[D]=OTYDOC_STYLE2[D]
   INC OTYDOC_CX[D],4
  ENDIF
  IF OTYDOC_COL[D]!=OTYDOC_COL2[D]THEN
   TF=OTYDOC_TextCheck(OTYDOC_VAL$[C],X)
   I$=CHR$(&HB10B)+CHR$(1)+CHR$(OTYDOC_COL2[D])+CHR$(&HB10C)+I$
   IF TF THEN PUSH I$,CHR$(&HB10B)+CHR$(1)+CHR$(OTYDOC_COL[D])+CHR$(&HB10C)
   OTYDOC_COL[D]=OTYDOC_COL2[D]
   INC OTYDOC_CX[D],4
  ENDIF
  
  IF OTYDOC_WSIZE[D]!=OTYDOC_WSIZE2[D]THEN
   TF=OTYDOC_TextCheck(OTYDOC_VAL$[C],X)
   I$=CHR$(&HB10B)+CHR$(0)+CHR$(OTYDOC_WSIZE2[D])+CHR$(&HB10C)+I$
   IF TF THEN PUSH I$,CHR$(&HB10B)+CHR$(0)+CHR$(OTYDOC_WSIZE[D])+CHR$(&HB10C)
   '?STR$(OTYDOC_WSIZE2[D])
   OTYDOC_WSIZE[D]=OTYDOC_WSIZE2[D]
   INC OTYDOC_CX[D],4
   IF OTYDOC_SIZE[C]<OTYDOC_WSIZE[D]THEN OTYDOC_SIZE[C]=OTYDOC_WSIZE[D]
  ENDIF
  INC OTYDOC_CX[D]
  IF!LEN(OTYDOC_VAL$[C])THEN
   OTYDOC_VAL$[C]=I$
  ELSE
   InsertStrB OTYDOC_VAL$[C],X,I$
  ENDIF
   OTYDOC_AdjustLine C
  ENDIF
 ENDIF
 @END
 IF OTYDOC_TABLEPARENT[C]THEN
  OTYDOC_UpdateParentTable C,OTYDOC_GetWidth(WND)
 ENDIF
 OTYDOCRepaint WND
 '?OTYDOC_VAL$[C]
 '?" "*MAX(OTYDOC_CX[D],0);""
END
DEF OTYDOC_NewLineInitStyle$(D)
 RETURN CHR$(&HB10B)+CHR$(2)+CHR$(OTYDOC_STYLE[D])+CHR$(&HB10C)+CHR$(&HB10B)+CHR$(1)+CHR$(OTYDOC_COL[D])+CHR$(&HB10C)+CHR$(&HB10B)+CHR$(0)+CHR$(OTYDOC_WSIZE[D])+CHR$(&HB10C)
END
'====EVENT HANDLER====

'RichTextEditor API
COMMON DEF RTESetBold WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR 1
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT 1
 ENDIF
 IF OTYDOC_ISSEL[D]THEN
  OTYDOC_SetSelectedStyle WND,CHR$(2)+CHR$(OTYDOC_STYLE2[D])
 ENDIF
END
COMMON DEF RTESetItalic WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR RichTextItalic()
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT RichTextItalic()
 ENDIF
 IF OTYDOC_ISSEL[D]THEN
  OTYDOC_SetSelectedStyle WND,CHR$(2)+CHR$(OTYDOC_STYLE2[D])
 ENDIF
END
COMMON DEF RTESetStrike WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR RichTextStrike()
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT RichTextStrike()
 ENDIF
 IF OTYDOC_ISSEL[D]THEN
  OTYDOC_SetSelectedStyle WND,CHR$(2)+CHR$(OTYDOC_STYLE2[D])
 ENDIF
END
COMMON DEF RTESetUnderline WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR RichTextUnderline()
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT RichTextUnderline()
 ENDIF
 IF OTYDOC_ISSEL[D]THEN
  OTYDOC_SetSelectedStyle WND,CHR$(2)+CHR$(OTYDOC_STYLE2[D])
 ENDIF
END
COMMON DEF RTESetTextColor WND,COL
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_COL2[D]=RGBToShort(COL)
 IF OTYDOC_ISSEL[D]THEN
 ?"S
  OTYDOC_SetSelectedStyle WND,CHR$(1)+CHR$(OTYDOC_COL2[D])
 ENDIF
END
COMMON DEF RTESetAlignLeft WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_LINESTYLE[OTYDOC_CURLINE[D]]=OTYDOC_LEFT
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetAlignCenter WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_LINESTYLE[OTYDOC_CURLINE[D]]=OTYDOC_CENTER
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetAlignRight WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_LINESTYLE[OTYDOC_CURLINE[D]]=OTYDOC_RIGHT
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetHeading WND,LEVEL
 IF LEVEL<1||LEVEL>6THEN RETURN
 VAR D=OTYDOC_GetData(WND)
 VAR CD=OTYDOC_CURLINE[D]
 OTYDOC_LINEDATA[CD]=OTYDOC_HEAD1+LEVEL-1
 VAR CX=OTYDOC_GETPOS(OTYDOC_VAL$[CD],OTYDOC_CX[D])
 VAR TYPE
 VAR ST$=""
 FOR TYPE=0TO 2
  VAR S$
  OTYDOC_GetStyle OTYDOC_VAL$[CD],0,LEN(OTYDOC_VAL$[CD]),TYPE OUT S$
  PUSH ST$,S$
  OTYDOC_RemoveStyle OTYDOC_VAL$[CD],0,LEN(OTYDOC_VAL$[CD]),TYPE
 NEXT
 PUSH OTYDOC_VAL$[CD],ST$
 VAR FS=8
 OTYDOC_LINESTYLE[CD]=0
 IF LEVEL==1THEN
  OTYDOC_LINESTYLE[CD]=OTYDOC_CENTER
 ENDIF
 IF LEVEL<=2THEN FS=16
 
 OTYDOC_WSIZE[D]=FS
 OTYDOC_WSIZE2[D]=FS
 VAR FSIZ$=CHR$(&HB10B)+CHR$(0)+CHR$(FS)+CHR$(&HB10C)
 OTYDOC_COL[D]=RGBToShort(#BLACK)
 OTYDOC_COL2[D]=RGBToShort(#BLACK)
 VAR COL$=CHR$(&HB10B)+CHR$(1)+CHR$(RGBToShort(#BLACK))+CHR$(&HB10C)
 OTYDOC_STYLE[D]=1
 OTYDOC_STYLE2[D]=1
 VAR STY$=CHR$(&HB10B)+CHR$(2)+CHR$(1)+CHR$(&HB10C)'BOLD
 OTYDOC_VAL$[CD]=COL$+FSIZ$+STY$+OTYDOC_VAL$[CD]
 OTYDOC_CX[D]=OTYDOC_TOPOS(OTYDOC_VAL$[CD],CX)
 OTYDOC_AdjustLine CD
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetUnorderedList WND
 VAR D=OTYDOC_GetData(WND)
 VAR CD=OTYDOC_CURLINE[D]
 OTYDOC_LINEDATA[CD]=OTYDOC_UORDLIST
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetOrderedList WND
 VAR D=OTYDOC_GetData(WND)
 VAR CD=OTYDOC_CURLINE[D]
 OTYDOC_LINEDATA[CD]=OTYDOC_ORDLIST
 VOID RepaintWindow(WND)
END
COMMON DEF RTEIndent WND,SZ
 VAR D=OTYDOC_GetData(WND)
 VAR CD=OTYDOC_CURLINE[D]
 INC OTYDOC_INDENT[CD],SZ
 VOID RepaintWindow(WND)
END
COMMON DEF RTEClear WND
 VAR D=OTYDOC_GetData(WND)
 VAR CD=OTYDOC_CURLINE[D]
 OTYDOC_INDENT[CD]=0
 OTYDOC_LINEDATA[CD]=0
 OTYDOC_LINESTYLE[CD]=0
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetFontSize WND,SIZE
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_WSIZE2[D]=SIZE
 IF OTYDOC_ISSEL[D]THEN
  OTYDOC_SetSelectedStyle WND,CHR$(0)+CHR$(OTYDOC_WSIZE2[D])
 ENDIF
END
DEF OTYDOC_GetFirstLine(F)
 VAR L
 WHILE F
  L=F
  F=OTYDOC_PREV[F]
 WEND
 RETURN L
END
'OTYDOC FILE FORMAT
'LINE1:OTYDOC
'LINE:LINESTYLE(LEFT,RIGHT,CENTER)...
COMMON DEF RTESave WND,FILE$ OUT ERR
 VAR D=OTYDOC_GetData(WND)
 VAR FILE
 FileOpen FILE$,FileWriteFlag()OR FileCreateFlag() OUT FILE,ERR
 IF ERR THEN RETURN
 FileWrite FILE,"OTYDOC"+LF$() OUT ERR
 VAR F=OTYDOC_GetFirstLine(OTYDOC_ShowLine[D])
 VAR BUF$=""
 OTYDOC_SerializeBlock F,BUF$
 FileWrite FILE,BUF$ OUT ERR
 FileClose FILE OUT ERR
END
COMMON DEF RTENew WND
 VAR D=OTYDOC_GetData(WND)
 VAR F=OTYDOC_ShowLine[D]
 WHILE F
  VAR N=OTYDOC_NEXT[F]
  VAR P=OTYDOC_DeleteLine(F)
  IF P THEN F=P ELSE F=N
 WEND
 VAR L=OTYDOC_NewLine(OTYDOC_NewLineInitStyle$(D),0)
 OTYDOC_ShowLine[D]=L
 OTYDOC_CurLine[D]=L
 VOID RepaintWindow(WND)
 OTYDOC_SetLine D,0
END
DEF OTYDOC_DeserializeBlock D$,IN_I OUT I,LC,OUTLINE
 VAR L=LEN(D$)-1
 VAR LINE=0
 OUTLINE=0
 LC=0
 FOR I=IN_I TO L
  VAR C=ASC(D$[I])
  IF I+1>L THEN BREAK
  VAR CL=ASC(D$[I+1])
  IF I+1+CL>L THEN BREAK
  IF C==OTYDOC_FILE_NEWCOL THEN
   BREAK
  ENDIF
  IF C==OTYDOC_FILE_TABLE THEN
   LINE=OTYDOC_NewLine("",LINE)
   OTYDOC_DeserializeTable D$,I,LINE OUT I,OTYDOC_TABLEDATA[LINE]
   IF!OUTLINE THEN OUTLINE=LINE
   INC LC
   I=I-1
   CONTINUE
  ENDIF
  IF C==OTYDOC_FILE_LINESTYLE THEN
   VAR V=ASC(D$[I+2])
   OTYDOC_LINESTYLE[LINE]=V
  ELSEIF C==OTYDOC_FILE_LINEDATA THEN
   V=ASC(D$[I+2])
   OTYDOC_LINEDATA[LINE]=V
  ELSEIF C==OTYDOC_FILE_INDENT THEN
   V=ASC(D$[I+2])
   OTYDOC_INDENT[LINE]=V
  ELSEIF C==OTYDOC_FILE_CONTENT THEN
   LINE=OTYDOC_NewLine(MID$(D$,I+2,CL),LINE)
   IF!OUTLINE THEN OUTLINE=LINE
   INC LC
   OTYDOC_AdjustLine LINE
  ENDIF
  I=I+CL+1
 NEXT
 
END
COMMON DEF RTEOpen WND,FILE$ OUT ERR
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_ISSEL[D]=FALSE
 VAR F$
 LoadFile FILE$ OUT F$,ERR
 IF MID$(F$,0,LEN("OTYDOC")+1)!="OTYDOC"+LF$()THEN
  ERR=TRUE
  RETURN
 ENDIF
 VAR I=LEN("OTYDOC")+1
 RTENew WND
 VAR LINE=OTYDOC_ShowLine[D]
 VAR L=LEN(F$)-1
 VAR LC
 VAR OUTLINE
 OTYDOC_DeserializeBlock F$,I OUT I,LC,LINE
 IF LINE THEN
  VOID OTYDOC_DeleteLine(OTYDOC_ShowLine[D])
  OTYDOC_ShowLine[D]=LINE
  OTYDOC_CurLine[D]=OTYDOC_ShowLine[D]
  OTYDOC_SetLine D,LC-1
 ENDIF
 OTYDOC_CalcDocumentSize WND
END
DEF OTYDOC_PlainText F,S,E,O$
 VAR L$=MID$(OTYDOC_VAL$[F],S,E-S)
 VAR TYPE:FOR TYPE=0TO 2
  OTYDOC_RemoveAllStyle L$,0,LEN(L$)
 NEXT
 PUSH O$,L$'+LF$()
END
'if ER=-1, ER=Row size
'if EC=-1, EC=Col size
DEF OTYDOC_SerializeTable TBL,O$,SR,SC,ER,EC
 IF 0THEN DIM A[0]
 A=GetSBArray(TBL)
 VAR ROW=A[OTYDOC_TABLEARY_ROW]
 VAR COL=A[OTYDOC_TABLEARY_COL]
 IF ER==-1THEN ER=ROW-1
 IF EC==-1THEN EC=COL-1
 IF SR>ER THEN SWAP SR,ER
 IF SC>EC THEN SWAP SC,EC
 PUSH O$,CHR$(OTYDOC_FILE_TABLE)+CHR$(2)
 PUSH O$,CHR$(ER-SR+1)
 PUSH O$,CHR$(EC-SC+1)
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 
 VAR I,J,Y,X,R,C
 FOR R=SR TO ER
  FOR C=SC TO EC
   VAR L=A[H+R*COL*OTYDOC_TBLELM+C*OTYDOC_TBLELM]
   OTYDOC_SerializeBlock L,O$
   PUSH O$,CHR$(OTYDOC_FILE_NEWCOL)+CHR$(0)
  NEXT
  PUSH O$,CHR$(OTYDOC_FILE_NEWROW)+CHR$(0)
 NEXT
  PUSH O$,CHR$(OTYDOC_FILE_TABLEEND)+CHR$(0)
 
END
DEF OTYDOC_SerializeBlock F,O$
 WHILE F
  IF OTYDOC_TABLEDATA[F]THEN
   OTYDOC_SerializeTable OTYDOC_TABLEDATA[F],O$,0,0,-1,-1
  ELSE
   VAR LS$=CHR$(OTYDOC_FILE_LINESTYLE)+CHR$(1)+CHR$(OTYDOC_LINESTYLE[F])
   VAR LD$=CHR$(OTYDOC_FILE_LINEDATA)+CHR$(1)+CHR$(OTYDOC_LINEDATA[F])
   VAR LI$=CHR$(OTYDOC_FILE_INDENT)+CHR$(1)+CHR$(OTYDOC_INDENT[F])
   VAR LC$=CHR$(OTYDOC_FILE_CONTENT)+CHR$(LEN(OTYDOC_VAL$[F]))+OTYDOC_VAL$[F]

   PUSH O$,LC$
   PUSH O$,LS$
   PUSH O$,LD$
   PUSH O$,LI$
  ENDIF
  F=OTYDOC_NEXT[F]
 WEND
END
DEF OTYDOC_Serialize F,S,E,O$
 VAR L$=""
 
 IF OTYDOC_TABLEDATA[F]THEN
  OTYDOC_SerializeTable OTYDOC_TABLEDATA[F],O$,0,0,-1,-1
  RETURN
 ENDIF
 VAR S$,TYPE
 FOR TYPE=0TO 2
  OTYDOC_GetStyle OTYDOC_VAL$[F],0,S,TYPE OUT S$
  PUSH L$,S$
 NEXT
 PUSH L$,MID$(OTYDOC_VAL$[F],S,E-S)
 VAR LS$=CHR$(OTYDOC_FILE_LINESTYLE)+CHR$(1)+CHR$(OTYDOC_LINESTYLE[F])
 VAR LD$=CHR$(OTYDOC_FILE_LINEDATA)+CHR$(1)+CHR$(OTYDOC_LINEDATA[F])
 VAR LI$=CHR$(OTYDOC_FILE_INDENT)+CHR$(1)+CHR$(OTYDOC_INDENT[F])
 VAR LC$=CHR$(OTYDOC_FILE_CONTENT)+CHR$(LEN(L$))+L$
 PUSH O$,LC$
 PUSH O$,LS$
 PUSH O$,LD$
 PUSH O$,LI$
 
END
DEF OTYDOC_PastePlainText WND,TXT$
 VAR D=OTYDOC_GetData(WND)
 VAR C=OTYDOC_CurLine[D]
 VAR I,J,LF$=LF$()
 OTYDOC_GetNextTextPos OTYDOC_VAL$[C],OTYDOC_CX[D] OUT OTYDOC_CX[D]
 VAR LST$=MID$(OTYDOC_VAL$[C],OTYDOC_CX[D],LEN(OTYDOC_VAL$[C]))
 VAR F$=LEFT$(OTYDOC_VAL$[C],OTYDOC_CX[D])
 VAR S$,TYPE,ST$
 
 FOR TYPE=0TO 2
  OTYDOC_GetStyle F$,0,LEN(F$),TYPE OUT S$
  PUSH ST$,S$
 NEXT
 PUSH LST$,ST$
 TXT$=TXT$+LST$
 OTYDOC_VAL$[C]=F$
 WHILE 1
  I=INSTR(I,TXT$,LF$)
  IF I==-1THEN
   VAR T$=MID$(TXT$,J,LEN(TXT$))
  ELSE
   T$=MID$(TXT$,J,I-J)
  ENDIF
  IF J==0THEN
   PUSH OTYDOC_VAL$[C],T$
  ELSE
   C=OTYDOC_NewLine(ST$+T$,C)
  ENDIF
  IF I==-1THEN BREAK
  I=I+1
  J=I
 WEND
 IF OTYDOC_TABLEPARENT[C]THEN
  OTYDOC_UpdateParentTable C,OTYDOC_GetWidth(WND)
 ENDIF
 VOID RepaintWindow(WND)
END
DEF OTYDOC_DeserializeTable D$,IN_I,TBLLINE OUT I,TBL
 VAR L=LEN(D$)-1
 VAR ROW,COL
 VAR _
 VAR COLC,ROWC
 FOR I=IN_I TO L
  VAR C=ASC(D$[I])
  IF I+1>L THEN BREAK
  VAR CL=ASC(D$[I+1])
  IF I+1+CL>L THEN BREAK
  IF C==OTYDOC_FILE_TABLE THEN
   ROW=ASC(D$[I+2])
   COL=ASC(D$[I+3])
   TBL=AllocSBArray()
   VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
   DIM A[ROW*COL*OTYDOC_TBLELM+H]
   A[OTYDOC_TABLEARY_ROW]=ROW
   A[OTYDOC_TABLEARY_COL]=COL
   SetSBArray TBL,A
   A[OTYDOC_TABLEARY_LINE]=TBLLINE
   OTYDOC_LINEDATA[TBLLINE]=OTYDOC_TABLE
  ELSEIF C==OTYDOC_FILE_NEWROW THEN
   COL=0
   INC ROWC
  ELSEIF C==OTYDOC_FILE_NEWCOL THEN
   INC COLC
  ELSEIF C==OTYDOC_FILE_TABLEEND THEN
   I=I+CL+2
   BREAK
  ELSE
   VAR LINE
   OTYDOC_DeserializeBlock D$,I OUT I,_,LINE
   
   A[H+ROWC*COL*OTYDOC_TBLELM+COLC*OTYDOC_TBLELM]=LINE
   WHILE LINE
    OTYDOC_TABLEPARENT[LINE]=TBL
    LINE=OTYDOC_NEXT[LINE]
   WEND
   I=I-1
   CONTINUE
  ENDIF
  
  I=I+CL+1
 NEXT
END
COMMON DEF RTEPaste WND
 VAR D=OTYDOC_GetData(WND)
 IF OTYDOC_ISSEL[D]THEN
  OTYDOC_RemoveSelected D,WND OUT OTYDOC_CX[D],OTYDOC_CurLine[D]
  OTYDOC_ISSEL[D]=0
 ENDIF
 VAR D$,CNTNS
 ClipboardGetData$ "RichText" OUT D$,CNTNS
 IF!CNTNS THEN
  IF!ClipboardContainsText()THEN RETURN
  OTYDOC_PastePlainText WND,ClipboardGetText$()
  RETURN
 ENDIF
 VAR C=OTYDOC_CurLine[D]
 VAR I,J
 VAR LST$=MID$(OTYDOC_VAL$[C],OTYDOC_CX[D],LEN(OTYDOC_VAL$[C]))
 VAR F$=LEFT$(OTYDOC_VAL$[C],OTYDOC_CX[D])
 VAR S$,TYPE,ST$
 FOR TYPE=0TO 2
  OTYDOC_GetStyle F$,0,LEN(F$),TYPE OUT S$
  PUSH ST$,S$
 NEXT
 LST$=ST$+LST$
 OTYDOC_VAL$[C]=F$

 VAR L=LEN(D$)-1
 VAR LC
 VAR LINE=C
 VAR FL=C
 VAR FIRSTLINE=TRUE
 FOR I=I TO L
      C=ASC(D$[I])
  IF C==OTYDOC_FILE_NEWCOL THEN
   BREAK
  ENDIF
  IF I+1>L THEN BREAK
  VAR CL=ASC(D$[I+1])
  IF I+1+CL>L THEN BREAK
  IF C==OTYDOC_FILE_TABLE THEN
   LINE=OTYDOC_NewLine("",LINE)
   OTYDOC_DeserializeTable D$,I,LINE OUT I,OTYDOC_TABLEDATA[LINE]
   INC LC
   I=I-1
   CONTINUE
  ENDIF
  IF LINE!=FL THEN
   IF C==OTYDOC_FILE_LINESTYLE THEN
    VAR V=ASC(D$[I+2])
    OTYDOC_LINESTYLE[LINE]=V
   ELSEIF C==OTYDOC_FILE_LINEDATA THEN
    V=ASC(D$[I+2])
    OTYDOC_LINEDATA[LINE]=V
   ELSEIF C==OTYDOC_FILE_INDENT THEN
    V=ASC(D$[I+2])
    OTYDOC_INDENT[LINE]=V
   ENDIF
  ENDIF
  IF!FIRSTLINE&&C==OTYDOC_FILE_CONTENT THEN
    LINE=OTYDOC_NewLine(MID$(D$,I+2,CL),LINE)
    INC LC
    OTYDOC_AdjustLine LINE
  ELSEIF C==OTYDOC_FILE_CONTENT THEN
   PUSH OTYDOC_VAL$[LINE],MID$(D$,I+2,CL)
   OTYDOC_AdjustLine LINE
   FIRSTLINE=FALSE
  ENDIF
  I=I+CL+1
 NEXT
 PUSH OTYDOC_VAL$[LINE],LST$
 OTYDOC_AddLine D,LC
 IF OTYDOC_TABLEPARENT[C]THEN
  OTYDOC_UpdateParentTable C,OTYDOC_GetWidth(WND)
 ENDIF
 VOID RepaintWindow(WND)
END
COMMON DEF RTESelectAll WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_ISSEL[D]=TRUE
 OTYDOC_SEL1X[D]=0
 OTYDOC_SEL1[D]=OTYDOC_GetFirstLine(OTYDOC_ShowLine[D])
 VAR L=OTYDOC_ShowLine[D]
 WHILE L
  VAR OL=L
  L=OTYDOC_NEXT[L]
 WEND
 OTYDOC_SEL2X[D]=LEN(OTYDOC_VAL$[OL])
 OTYDOC_SEL2[D]=OL
 OTYDOC_HASSTARTSEL[D]=FALSE
 OTYDOC_HASENDSEL[D]=TRUE
 VOID RepaintWindow(WND)
END
COMMON DEF RTECut WND
 VAR D=OTYDOC_GetData(WND)
 IF OTYDOC_ISSEL[D]THEN
  RTECopy WND
  OTYDOC_RemoveSelected D,WND OUT OTYDOC_CX[D],OTYDOC_CurLine[D]
  OTYDOC_ISSEL[D]=0
 ENDIF
END
COMMON DEF RTECopy WND
 VAR D=OTYDOC_GetData(WND)
 IF!OTYDOC_ISSEL[D] THEN
  RETURN
 ENDIF
 VAR CX=OTYDOC_CX[D]
 VAR CL=OTYDOC_CurLine[D]
 VAR SL=OTYDOC_ShowLine[D]
 VAR S=OTYDOC_SEL1[D]
 VAR E=OTYDOC_SEL2[D]
 VAR SX=OTYDOC_SEL1X[D]
 VAR EX=OTYDOC_SEL2X[D]
 VAR STBL=OTYDOC_SEL1TABLE[D]
 VAR SROW=OTYDOC_SEL1ROW[D]
 VAR SCOL=OTYDOC_SEL1COL[D]
 VAR ETBL=OTYDOC_SEL2TABLE[D]
 VAR EROW=OTYDOC_SEL2ROW[D]
 VAR ECOL=OTYDOC_SEL2COL[D]
 
 VAR O$=""
 VAR P$=""
 ClearClipboard
 IF S==E THEN
  OTYDOC_PlainText S,SX,EX,P$
  OTYDOC_SERIALIZE S,SX,EX,O$
  ClipboardSetData$ "RichText",O$
  ClipboardSetText P$
  RETURN
 ENDIF
 VAR _
 IF STBL&&STBL==ETBL THEN
  OTYDOC_SERIALIZETABLE STBL,O$,SROW,SCOL,EROW,ECOL
 ELSE
 OTYDOC_SERIALIZE S,SX,LEN(OTYDOC_VAL$[S]),O$
 OTYDOC_PlainText S,SX,LEN(OTYDOC_VAL$[S]),P$
 PUSH P$,LF$()
 S=OTYDOC_NEXT[S]
 WHILE 1
  VAR NXT=OTYDOC_NEXT[S]
  IF S==E THEN
   VAR S2=OTYDOC_SEL1[D]
   OTYDOC_SERIALIZE S,0,EX,O$
   OTYDOC_PlainText S,0,EX,P$
   BREAK
  ENDIF
  OTYDOC_SERIALIZE S,0,LEN(OTYDOC_VAL$[S]),O$
  OTYDOC_PlainText S,0,LEN(OTYDOC_VAL$[S]),P$
  PUSH P$,LF$()
  S=NXT
 WEND
 ENDIF
 ClipboardSetData$ "RichText",O$
 ClipboardSetText P$
END
DEF OTYDOC_NewTableData(D,R,C,L)
 VAR SB=AllocSBArray()
 VAR H=OTYDOC_TABLEARY_HEAD+R+C
 DIM A[R*C*OTYDOC_TBLELM+H]
 A[OTYDOC_TABLEARY_ROW]=R
 A[OTYDOC_TABLEARY_COL]=C
 VAR I,J
 FOR I=0TO R-1
  FOR J=0TO C-1
   VAR TL=OTYDOC_NewLine(OTYDOC_NewLineInitStyle$(D)+"",0)
   OTYDOC_TABLEPARENT[TL]=SB
   A[H+J*R*OTYDOC_TBLELM+I*OTYDOC_TBLELM]=TL
  NEXT
 NEXT
 IF LEN(A)>H THEN
  OTYDOC_CurLine[D]=A[H]
  OTYDOC_CX[D]=LEN(OTYDOC_VAL$[A[H]])
 ENDIF
 A[OTYDOC_TABLEARY_LINE]=L
 SetSBArray SB,A
 RETURN SB
END
DEF OTYDOC_SearchLine(LINE,T)
 WHILE LINE
  IF LINE==T THEN BREAK
  LINE=OTYDOC_NEXT[LINE]
 WEND
 RETURN LINE
END
DEF OTYDOC_TableGetPos TBL,LINE OUT R,C
 VAR ROW=TBL[OTYDOC_TABLEARY_ROW]
 VAR COL=TBL[OTYDOC_TABLEARY_COL]
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 VAR I,J
 FOR I=0TO ROW-1
  FOR J=0TO COL-1
   VAR L=TBL[H+I*COL*OTYDOC_TBLELM+J*OTYDOC_TBLELM]
   IF OTYDOC_SearchLine(L,LINE)THEN
    R=I
    C=J
    RETURN
   ENDIF
  NEXT
 NEXT
 R=-1
 C=-1
END
COMMON DEF RTEAddTableRow WND,F
 VAR D=OTYDOC_GetData(WND)
 VAR CL=OTYDOC_CurLine[D]
 VAR T=OTYDOC_TABLEPARENT[CL]
 IF!T THEN RETURN
 IF 0THEN DIM OLD[0]
 OLD=GetSBArray(T)
 VAR R,C
 OTYDOC_TableGetPos OLD,CL OUT R,C
 IF R==-1||C==-1THEN RETURN
 VAR OLDROW=OLD[OTYDOC_TABLEARY_ROW]
 VAR COL=OLD[OTYDOC_TABLEARY_COL]
 VAR ROW=OLDROW+1
 VAR INSROW=R
 VAR I,J
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 VAR OH=OTYDOC_TABLEARY_HEAD+OLDROW+COL
 VAR K=0
 DIM A[ROW*COL*OTYDOC_TBLELM+H]
 A[OTYDOC_TABLEARY_ROW]=ROW
 A[OTYDOC_TABLEARY_COL]=COL
 A[OTYDOC_TABLEARY_LINE]=OLD[OTYDOC_TABLEARY_LINE]
 SetSBArray T,A
 FOR I=0TO ROW-1
  IF (!F&&I==R)||(F&&I==R+1) THEN
   FOR J=0TO COL-1
    VAR TL=OTYDOC_NewLine(OTYDOC_NewLineInitStyle$(D)+"",0)
    OTYDOC_TABLEPARENT[TL]=T
    A[H+I*COL*OTYDOC_TBLELM+J*OTYDOC_TBLELM]=TL
   NEXT
   K=-1
  ELSEIF 0&&F THEN
   FOR J=0TO COL-1
    A[H+I*COL*OTYDOC_TBLELM+J*OTYDOC_TBLELM]=OLD[OH+(I-K)*COL*OTYDOC_TBLELM+J*OTYDOC_TBLELM]
   NEXT
  ELSE
   FOR J=0TO COL-1
    A[H+I*COL*OTYDOC_TBLELM+J*OTYDOC_TBLELM]=OLD[OH+(I+K)*COL*OTYDOC_TBLELM+J*OTYDOC_TBLELM]
   NEXT
  ENDIF
 NEXT
 OTYDOC_UpdateParentTable TL,OTYDOC_GetWidth(WND)
END
COMMON DEF RTEAddTableColumn WND,F
 VAR D=OTYDOC_GetData(WND)
 VAR CL=OTYDOC_CurLine[D]
 VAR T=OTYDOC_TABLEPARENT[CL]
 IF!T THEN RETURN
 IF 0THEN DIM OLD[0]
 OLD=GetSBArray(T)
 VAR R,C
 OTYDOC_TableGetPos OLD,CL OUT R,C
 IF R==-1||C==-1THEN RETURN
 VAR ROW=OLD[OTYDOC_TABLEARY_ROW]
 VAR OLDCOL=OLD[OTYDOC_TABLEARY_COL]
 VAR COL=OLDCOL+1
 VAR INSCOL=C
 VAR I,J
 VAR H=OTYDOC_TABLEARY_HEAD+ROW+COL
 VAR OH=OTYDOC_TABLEARY_HEAD+ROW+OLDCOL
 VAR K=0
 DIM A[ROW*COL*OTYDOC_TBLELM+H]
 A[OTYDOC_TABLEARY_ROW]=ROW
 A[OTYDOC_TABLEARY_COL]=COL
 A[OTYDOC_TABLEARY_LINE]=OLD[OTYDOC_TABLEARY_LINE]

 SetSBArray T,A
 FOR I=0TO COL-1
  IF (!F&&I==C)||(F&&I==C+1) THEN
   FOR J=0TO ROW-1
    VAR TL=OTYDOC_NewLine(OTYDOC_NewLineInitStyle$(D)+"",0)
    OTYDOC_TABLEPARENT[TL]=T
    A[H+J*COL*OTYDOC_TBLELM+I*OTYDOC_TBLELM]=TL
   NEXT
   K=-1
  ELSE
   FOR J=0TO ROW-1
    A[H+J*COL*OTYDOC_TBLELM+I*OTYDOC_TBLELM]=OLD[OH+J*OLDCOL*OTYDOC_TBLELM+(I+K)*OTYDOC_TBLELM]
   NEXT
  ENDIF
 NEXT
 OTYDOC_UpdateParentTable TL,OTYDOC_GetWidth(WND)

END
COMMON DEF RTEAddTable WND,R,C
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_ISSEL[D]=FALSE
 VAR L=OTYDOC_NewLine("",OTYDOC_CurLine[D])
 OTYDOC_CurLine[D]=OTYDOC_NewLine(OTYDOC_NewLineInitStyle$(D),L)
 OTYDOC_LINEDATA[L]=OTYDOC_TABLE
 OTYDOC_TABLEDATA[L]=OTYDOC_NewTableData(D,R,C,L)
 OTYDOC_UpdateParentTable L,OTYDOC_GetWidth(WND)
 VOID RepaintWindow(WND)
END
'==================
VAR OTYDOCCOLOR_CTL
VAR OTYDOC_MENU_NEW=1
VAR OTYDOC_MENU_OPEN=2
VAR OTYDOC_MENU_SAVE=3
VAR OTYDOC_MENU_SAVEAS=4
VAR OTYDOC_MENU_ADDTABLE
VAR OTYDOC_MENU_ADDTABLECOL
VAR OTYDOC_MENU_ADDTABLECOL2
VAR OTYDOC_MENU_ADDTABLEROW
VAR OTYDOC_MENU_ADDTABLEROW2
COMMON DEF OTYDOC_WNDSTRNOTIF WND,CTL,TYPE,A1,A2$
 IF A1==OTYDOC_MENU_SAVEAS THEN
  VOID RTESave(GetWindowVar(WND,0),A2$)
 ENDIF
 IF A1==OTYDOC_MENU_OPEN THEN
  VOID RTEOpen(GetWindowVar(WND,0),A2$)
 ENDIF
END
COMMON DEF OTYDOC_WNDNOTIF WND,CTL,TYPE,CW,F
 IF CW==MenuNotifID()THEN
  IF F==OTYDOC_MENU_NEW THEN
   RTENew GetWindowVar(WND,0)
  ELSEIF F==OTYDOC_MENU_SAVEAS THEN
   VOID SaveFileDialog(WND,"TXT:.DOC",F)
  ELSEIF F==OTYDOC_MENU_OPEN THEN
   VOID OpenFileDialog(WND,"TXT:.DOC",F)
  ELSEIF F==OTYDOC_MENU_ADDTABLE THEN
   RTEAddTable GetWindowVar(WND,0),2,2
  ELSEIF F==OTYDOC_MENU_ADDTABLEROW THEN
   RTEAddTableRow GetWindowVar(WND,0),FALSE
  ELSEIF F==OTYDOC_MENU_ADDTABLEROW2 THEN
   RTEAddTableRow GetWindowVar(WND,0),TRUE
  ELSEIF F==OTYDOC_MENU_ADDTABLECOL THEN
   RTEAddTableColumn GetWindowVar(WND,0),FALSE
  ELSEIF F==OTYDOC_MENU_ADDTABLECOL2 THEN
   RTEAddTableColumn GetWindowVar(WND,0),TRUE
  ENDIF
  RETURN
 ENDIF
 VAR N$=GetWindowName$(CW)
 IF N$=="B"THEN
  RTESetBold GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$=="I"THEN
  RTESetItalic GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$=="S"THEN
  RTESetStrike GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$=="U"THEN
  RTESetUnderline GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$==""THEN
  VAR X=GetWindowX(WND)+GetWindowX(CW),Y=GetWindowY(WND)+GetWindowY(CW)
  OTYDOC_ShowMenu OTYDOCCOLOR_CTL,WND,X,Y,X+GetWindowWidth(CW),Y+GetWindowHeight(CW)
 ENDIF
 IF N$==""THEN
  RTEIndent GetWindowVar(WND,0),8
  RETURN
 ENDIF
 IF N$==""THEN
  RTEIndent GetWindowVar(WND,0),-8
  RETURN
 ENDIF
 IF N$=="OTYDOCCOLOR"THEN
  RTESetTextColor GetWindowVar(WND,0),F
 ENDIF
 IF N$==""THEN
  VAR BTNL,BTNC,BTNR
  BTNL=GetWindowVar(WND,1)
  BTNC=GetWindowVar(WND,2)
  BTNR=GetWindowVar(WND,3)
  IF CW==BTNL THEN
   CheckButton BTNL
   UnCheckButton BTNR
   UnCheckButton BTNC
   RTESetAlignLeft GetWindowVar(WND,0)
  ENDIF
  IF CW==BTNC THEN
   CheckButton BTNC
   UnCheckButton BTNR
   UnCheckButton BTNL
   RTESetAlignCenter GetWindowVar(WND,0)
  ENDIF
  IF CW==BTNR THEN
   CheckButton BTNR
   UnCheckButton BTNL
   UnCheckButton BTNC
   RTESetAlignRight GetWindowVar(WND,0)
  ENDIF
'  UnCheckButtonsGroup CW
 ENDIF
 IF IsControlExtend(GetControl(CW),GetNumUpDownControl())THEN
  RTESetFontSize GetWindowVar(WND,0),GetNumUpDownValue(CW)*8
 ENDIF
 IF IsControlExtend(GetControl(CW),GetListBoxControl())THEN
  VAR C$=GetListBoxSelectedText$(CW)
  IF LEN(C$)>1&&C$[0]=="H"THEN
   VAR LEVEL=ASC(C$[1])-ASC("0")
   RTESetHeading GetWindowVar(WND,0),LEVEL
  ENDIF
  IF C$=="  xxx"THEN
   RTESetUnorderedList GetWindowVar(WND,0)
  ENDIF
  IF C$=="1. xxx"THEN
   RTESetOrderedList GetWindowVar(WND,0)
  ENDIF
  IF C$=="clear"THEN
   RTEClear GetWindowVar(WND,0)
  ENDIF
 ENDIF
END
COMMON DEF OTYDOC_WNDRESIZE WND,CTL,TYPE,A1,A2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VOID ResizeWindow(GetWindowVar(WND,0),W,H-12-12)
END
'2PX
'
'
'
'
COMMON DEF OTYDOC_COLORCREATE WND,CTL,TYP,A1,A2
 VAR E
 NewWindow GetButtonControl(),">>>",1,GetWindowHeight(WND)-10,27,10,WND,0 OUT E,E
 SetWindowVar WND,0,-1
END
COMMON DEF OTYDOC_COLORPAINT WND,CTL,TYP,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,RGB(200,200,200)
 GBOXWindow WND,0,0,GetWindowWidth(WND),GetWindowHeight(WND),RGB(0,0,0)
 VAR X,Y,C
 VAR SEL=GetWindowVar(WND,0)
 FOR Y=0TO 3
  FOR X=0TO 3
   VAR RGB
   IF!C THEN
    RGB=RGB(0,0,0)
    GBOXWindow WND,X*8+2*X+2,Y*8+2*Y+2,X*8+7+2*X+2,Y*8+7+2*Y+2,RGB
   ELSE
    RGB=GetConsolePalette(C)
    GFILLWindow WND,X*8+2*X+2,Y*8+2*Y+2,X*8+7+2*X+2,Y*8+7+2*Y+2,RGB
   ENDIF
   IF SEL==C THEN
    GBOXWindow WND,X*8+2*X+1,Y*8+2*Y+1,X*8+7+2*X+3,Y*8+7+2*Y+3,RGB(255,160,16)
   ENDIF
   INC C
  NEXT
 NEXT
 E=GEndWindow(WND)
END
COMMON DEF OTYDOC_ColorNotif WND,CTL,TYP,FLG,FW
 'そのうち まともに
 VOID ActiveWindow(WND)
END
COMMON DEF OTYDOC_ColorChFocus WND,CTL,TYP,FLG,FW
 IF!FLG THEN
  IF GetParentWindow(FW)==WND THEN RETURN
  VOID DeleteWindow(WND)
 ENDIF
END
COMMON DEF OTYDOC_ColorMouseUp WND,CTL,TYP,X,Y
 VAR E=CallBaseControlHandler(WND,CTL,TYP,X,Y)
' IF X MOD 10<2THEN RETURN
' IF Y MOD 10<2THEN RETURN
 VAR COL=(X DIV 10)+(Y DIV 10)*4
 IF COL>15THEN RETURN
 SetWindowVar WND,0,COL
 OTYDOC_COLORPAINT WND,CTL,TYP,0,0
 VAR OWN=GetWindowGroupOwner(WND)
 IF GetWindowVar(WND,0)!=-1THEN
  VOID SendNotifWindow(OWN,WND,GetConsolePalette(GetWindowVar(WND,0)))
  RETURN
 ENDIF
END
COMMON DEF OTYDOC_ShowMenu CTL,WND,X,Y,X2,Y2
 VAR E,MENUWND
 IF CTL==OTYDOCCOLOR_CTL THEN
  NewWindow OTYDOCCOLOR_CTL,"OTYDOCCOLOR",X,Y2,4*8+2*4+1,4*8+2*4+2+8+1,GetRootWindow(),WindowFrontFlag()OUT MENUWND,E
  IF E THEN RETURN
 ENDIF
 E=JoinWindowGroup(WND,MENUWND)
 
END
COMMON DEF OTYDOC_LCRPAINT WND,CTL,TYP,_,__
 IF CallBaseControlHandler(WND,CTL,TYP,_,__)THEN RETURN
 VAR T=GetWindowVar(WND,7)
 REPEAT
  ON T GOTO @LEFT,@CENTER,@RIGHT
  @LEFT
   GLINEWindow WND,1,1,8,1,RGB(0,0,0)
   GLINEWindow WND,1,3,6,3,RGB(0,0,0)
   GLINEWindow WND,1,5,8,5,RGB(0,0,0)
   GLINEWindow WND,1,7,6,7,RGB(0,0,0)
  BREAK
  @CENTER
   GLINEWindow WND,1,1,8,1,RGB(0,0,0)
   GLINEWindow WND,2,3,7,3,RGB(0,0,0)
   GLINEWindow WND,1,5,8,5,RGB(0,0,0)
   GLINEWindow WND,2,7,7,7,RGB(0,0,0)
  BREAK
  @RIGHT
   GLINEWindow WND,1,1,8,1,RGB(0,0,0)
   GLINEWindow WND,3,3,8,3,RGB(0,0,0)
   GLINEWindow WND,1,5,8,5,RGB(0,0,0)
   GLINEWindow WND,3,7,8,7,RGB(0,0,0)
  BREAK
 UNTIL FALSE
 VAR E=GEndWindow(WND)
END
COMMON DEF OTYDOC_LCRMouseDown WND,CTL,TYP,_,__
 IF IsCheckedButton(WND)THEN RETURN
 IF CallBaseControlHandler(WND,CTL,TYP,_,__)THEN RETURN
END
VAR OTYDOCLCRBTN_CTL
COMMON DEF I_OTYDOC
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTYDOC_WNDCTL THEN
  INIT_OTYDOC
  ExtendControl "OTYDOC",GetWindowControl() OUT OTYDOC_WNDCTL,E
'  ExtendControl "OTYDOCCOLOR",GetWindowControl() OUT OTYDOCCOLOR_CTL,E
  NewControl "OTYDOCCOLOR" OUT OTYDOCCOLOR_CTL,E
  E=SetControlNotifHandler(OTYDOC_WNDCTL,"OTYDOC_WNDNOTIF")
  E=SetControlStrNotifHandler(OTYDOC_WNDCTL,"OTYDOC_WNDSTRNOTIF")
  E=SetControlPainter(OTYDOCCOLOR_CTL,"OTYDOC_COLORPAINT")
  E=SetControlCreateHandler(OTYDOCCOLOR_CTL,"OTYDOC_COLORCREATE")
  E=SetControlChFocusHandler(OTYDOCCOLOR_CTL,"OTYDOC_ColorChFocus")
  E=SetControlNotifHandler(OTYDOCCOLOR_CTL,"OTYDOC_ColorNotif")
  E=SetControlLMouseDownHandler(OTYDOCCOLOR_CTL,"OTYDOC_ColorMouseUp")
  E=SetControlResizeHandler(OTYDOC_WNDCTL,"OTYDOC_WNDRESIZE")
  ExtendControl "OTYDOCLCRBUTTON",GetToggleButtonControl() OUT OTYDOCLCRBTN_CTL,E
  E=SetControlPainter(OTYDOCLCRBTN_CTL,"OTYDOC_LCRPAINT")
  E=SetControlLMouseDownHandler(OTYDOCLCRBTN_CTL,"OTYDOC_LCRMouseDown")
 ENDIF
 NewTopLevelStyleWindow OTYDOC_WNDCTL,"Document",256+8,128,WindowMenuStyle() OR WindowResizableStyle()OR WindowMinMaxStyle() OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 OTYDOC_MENU_NEW=1
 OTYDOC_MENU_OPEN=2
 OTYDOC_MENU_SAVE=3
 OTYDOC_MENU_SAVEAS=4
 OTYDOC_MENU_AddTable=5
 OTYDOC_MENU_AddTableRow=6
 OTYDOC_MENU_AddTableRow2=7
 OTYDOC_MENU_AddTableCol=8
 OTYDOC_MENU_AddTableCol2=9
 AddMenuItem MENU,"New",1
 AddMenuItem MENU,"Open",2
 AddMenuItem MENU,"Save",3
 AddMenuItem MENU,"Save as",4
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"Insert",OTYDOC_MENU_AddTable
 AddMenuItem MENU,"Insert Left",OTYDOC_MENU_AddTableCol
 AddMenuItem MENU,"Insert Right",OTYDOC_MENU_AddTableCol2
 AddMenuItem MENU,"Insert Above",OTYDOC_MENU_AddTableRow
 AddMenuItem MENU,"Insert Below",OTYDOC_MENU_AddTableRow2
 AddSubMenuItem GetWindowMenu(WND),"Table",MENU
 SetProcessVar WND
 VAR DOC,COL
 NewWindow OTYDOCCTL,"OTYDOC",0,12+12,256+8,116-12,WND,0 OUT DOC,E
 SetWindowVar WND,0,DOC
 VAR W
 NewWindow GetToggleButtonControl(),"B",0,0,11,11,WND,0 OUT W,E
 NewWindow GetToggleButtonControl(),"I",12*1,0,11,11,WND,0 OUT W,E
 NewWindow GetToggleButtonControl(),"S",12*2,0,11,11,WND,0 OUT W,E
 NewWindow GetToggleButtonControl(),"U",12*3,0,11,11,WND,0 OUT W,E
 NewWindow GetButtonControl(),"color",12*4,0,11+32,11,WND,0 OUT W,E
 NewWindow GetButtonControl(),"",12*5+32,0,11,11,WND,0 OUT W,E

 VAR NUM
 VAR X=12*6+32
 NewWindow GetLabelControl(),"size",X,2,31,7,WND,0 OUT W,E
 INC X,32
 NewWindow GetNumUpDownControl(),"0",X,0,11+8*3,11,WND,0 OUT NUM,E
 SetNumUpDownRange NUM,1,96/8
 INC X,11+8*3+1
 VAR BTNL,BTNC,BTNR
 NewWindow OTYDOCLCRBTN_CTL,"",X,0,11,11,WND,WindowOwnerDrawFlag() OUT BTNL,E
 INC X,12
 NewWindow OTYDOCLCRBTN_CTL,"",X,0,11,11,WND,WindowOwnerDrawFlag() OUT BTNC,E
 INC X,12
 NewWindow OTYDOCLCRBTN_CTL,"",X,0,11,11,WND,WindowOwnerDrawFlag() OUT BTNR,E
 INC X,12
 VAR DRP
 NewWindow GetDropDownListControl(),"",X,0,56,GetDropDownListHeight(),WND,0 OUT DRP,E
 VAR LST=GetDropDownListBox(DRP)
 AddListBoxItem LST,"H1"
 AddListBoxItem LST,"H2"
 AddListBoxItem LST,"H3"
 AddListBoxItem LST,"  xxx"
 AddListBoxItem LST,"1. xxx"
 AddListBoxItem LST,"clear"
 AddListBoxItem LST,"H4"
 AddListBoxItem LST,"H5"
 AddListBoxItem LST,"H6"
 INC X,56
 SetWindowVar WND,1,BTNL
 SetWindowVar WND,2,BTNC
 SetWindowVar WND,3,BTNR
 SetWindowVar BTNL,7,0
 SetWindowVar BTNC,7,1
 SetWindowVar BTNR,7,2
 NewWindow GetButtonControl(),"",0,12,11,11,WND,0 OUT E,E
 NewWindow GetButtonControl(),"",12,12,11,11,WND,0 OUT E,E
 'TODO:GROUPのかくちょう
'E=JoinWindowGroup(BTNL,BTNC)
'E=JoinWindowGroup(BTNL,BTNR)
'E=JoinWindowGroup(BTNC,BTNL)
'E=JoinWindowGroup(BTNC,BTNR)
'E=JoinWindowGroup(BTNR,BTNL)
'E=JoinWindowGroup(BTNR,BTNC)
 VOID ActiveWindow(WND)
 VAR CMD$
 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

 IF LEN(CMD$)THEN
  RTEOpen DOC,CMD$ OUT E
 ENDIF
 
 'DISABLE CLIP
 W=GetChildWindow(WND)
 WHILE W
  E=DisableWindowClipping(W)
  W=GetNextWindow(W)
 WEND
END
COMMON DEF L_OTYDOC
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
'===OTYA DOCUMENT EDITOR===
VAR OTYFIL_MOPEN
VAR OTYFIL_MCOPY
VAR OTYFIL_MCUT
VAR OTYFIL_MDEL
VAR OTYFIL_MREN
VAR OTYFIL_MABOUT
VAR OTYFIL_MPASTE
VAR OTYFIL_MFIL
VAR OTYFIL_MUPD
VAR OTYFIL_MNEWFOL
VAR OTYFIL_MNEWTXT
DIM OTYFILICOTXT[0]
DIM OTYFILICODAT[0]
DIM OTYFILICODIR[0]
DIM OTYFILICON[0]
VAR RC_OTYFIL_LOADED
COMMON DEF RC_OTYFIL
 IF RC_OTYFIL_LOADED THEN RETURN
 RC_OTYFIL_LOADED=TRUE
 DIM ICONS[512]
 LOAD"DAT:OTYFILRC",ICONS,0
 OTYFILICODIR=NewArray(16*16)
' LOAD"DAT:OTYFILRC3",OTYFILICODIR,0
 OTYFILICOTXT=NewArray(16*16)
 OTYFILICODAT=NewArray(16*16)
 OTYFILICON=NewArray(16*16)
 COPY OTYFILICOTXT,ICONS,0,16*16
 COPY OTYFILICODAT,ICONS,16*16,16*16
' COPY OTYFILICON,ICONS,16*16*2,16*16
 DIM A[16,16]
 LOAD"DAT:FOLDER.IMG",A,0
 COPY OTYFILICODIR,A,0,16*16
 LOAD"DAT:FILEMAN.IMG",A,0
 COPY OTYFILICON,A,0,16*16
 
END
VAR OTYFILCTL
VAR OTYFILICONCTL
VAR OTYFILABOUTCTL
VAR OTYFILRENCTL
VAR OTYFILNEWFOLCTL
COMMON DEF OTYFILICONCTLPainter W,C,T,_,__
 IF GBeginWindow(W)THEN RETURN
 VAR SEL=GetWindowVar(W,3)
 IF SEL THEN
  GCLSWindow W,RGB(0,0,255)
 ELSE
  GCLSWindow W,WIN_BKGND
 ENDIF
 VAR TYP=GetWindowVar(W,1)
 IF TYP THEN
  IF TYP==2THEN
   GLOADWindow W,0,0,16,16,OTYFILICON,1,0
   RETURN
  ENDIF
  GLOADWindow W,0,0,16,16,OTYFILICODAT,1,0
 ELSE
  GLOADWindow W,0,0,16,16,OTYFILICOTXT,1,0
 ENDIF
 IF GEndWindow(W)THEN RETURN
END
COMMON DEF OTYFILABOUTNOTIF WND,CTL,T,_,__
 VOID DeleteWindow(WND)
END
COMMON DEF OTYFILABOUTCREATE WND,CTL,T,_,__
 VAR W,E
 NewWindow OTYFILICONCTL,"",0,0,15,15,WND,0 OUT W,E
 SetWindowVar W,1,2
 VAR WI=GetWindowWidth(WND)
 VAR S$="OTW Filer"
 NewWindow GetLabelControl(),S$,(WI-LEN(S$)*8)/2,0,LEN(S$)*8,7,WND,0 OUT W,E
 S$="Ver "+GetWinVer$()
 NewWindow GetLabelControl(),S$,(WI-LEN(S$)*8)/2,8,LEN(S$)*8,7,WND,0 OUT W,E
 S$="© 2011-2018 otya"
 NewWindow GetLabelControl(),S$,(WI-LEN(S$)*8)/2,16,LEN(S$)*8,7,WND,0 OUT W,E
 S$="OK"
 NewWindow GetButtonControl(),S$,(WI-LEN(S$)*8)/2+2,24,LEN(S$)*8+2,12,WND,0 OUT W,E
END
DEF OTYFIL_GETSELECTEDFILE$ WND OUT F$
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR SELECT=GetWindowVar(WND,4)
 F$=""
 IF SELECT<0||KL<=SELECT THEN RETURN
 F$=GetString$(ASC(ARY$[SELECT])OR ASC(ARY$[SELECT+1])<<16)
END
DEF OTYFIL_OPEN WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 IF F$[0]=="/"THEN
  VAR CWD$=GetCurrentDir$()
  IF SetCurrentDir(MID$(F$,1,LEN(F$)))THEN RETURN
  VAR ERR=OTYFIL_UPD(WND)
  IF ERR THEN
   VOID SetCurrentDir(CWD$)
   RETURN
  ENDIF
  SetScrollBarPosition GetChildWindow(WND),0
  RETURN
 ENDIF
 VAR TYP$
 TYP$=F$[0]
 F$=MID$(F$,1,LEN(F$))
 VAR E=ExecFile(F$)
END
DEF OTYFIL_COPY WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 ClearClipboard
 ClipboardSetFile FALSE,MID$(F$,1,&H7FFFFFFF)
END
DEF OTYFIL_CUT WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 ClearClipboard
 ClipboardSetFile TRUE,F$
END
DEF OTYFIL_FIL WND
 
END
DEF OTYFIL_UPD(WND)
 VAR PTR=GetWindowVar(WND,3)
 VAR ERR=StrArrayGetFiles(PTR,"")
 IF ERR THEN
  OTYFIL_SHOWERROR ERR,WND
  RETURN ERR
 ENDIF
 VAR CW=GetChildWindow(WND)
 SetScrollBarSize CW,OTYFILGETSCRBARLEN(WND)
 void(repaintWindow(WND))
 SetWindowName WND,GetCurrentDir$()
 RETURN 0
END
'
'Old [HOGEHOGE.TXT]
'New [FUGAFUGA.TXT]
'       [OK]
COMMON DEF OTYFILRENCREATE WND,CTL,T,A1,A2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR OLD=LEN("Old")*8+8
 VAR E,W2,OLDW,NEWW
 VAR OLD$=GetWindowName$(WND)
 NewWindow GetLabelControl(),"Old",1,1,OLD-2,7,WND,0 OUT W2,E
 NewWindow GetLabelControl(),"New",1,11,OLD-2,7,WND,0 OUT W2,E
 NewWindow GetTextBoxControl(),OLD$,OLD,0,W-OLD,8,WND,0 OUT OLDW,E
 NewWindow GetTextBoxControl(),"",OLD,11,W-OLD,8,WND,0 OUT NEWW,E
 VAR BW=24
 NewWindow GetButtonControl(),"OK",(W-BW) DIV 2,22,BW,10,WND,0 OUT W2,E
 SetWindowName WND,"Rename"
 SetWindowVar WND,0,OLDW
 SetWindowVar WND,1,NEWW
 IF OLD$[0]==" "THEN
  SetWindowVar WND,2,1
 ENDIF
END
COMMON DEF OTYFILRENNOTIF WND,CTL,T,A1,A2
 IF!IsControlExtend(GetControl(A1),GetButtonControl())THEN
  RETURN
 ENDIF
 VAR OLDW,NEWW
 GetWindowVar WND,0OUT OLDW
 GetWindowVar WND,1OUT NEWW
 VAR OLD$=GetWindowName$(OLDW)
 VAR NEW$=GetWindowName$(NEWW)
 IF MID$(OLD$,0,1)=="/"||MID$(OLD$,0,1)==" "||MID$(OLD$,0,1)=="*"THEN
  OLD$=MID$(OLD$,1,LEN(OLD$))
 ENDIF
 VAR ERR=RenameFile(OLD$,NEW$)
 IF ERR THEN
  OTYFIL_SHOWERROR ERR,WND
 ELSE
  VOID DeleteWindow(WND)
 ENDIF
END
DEF OTYFIL_SHOWERROR ERR,WND
 VOID MessageBox(WND,"Files","error:"+GetErrorName$(ERR),MessageBoxOK()OR MessageBoxError())
END
COMMON DEF OTYFILNEWFOLCREATE WND,CTL,T,A1,A2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR W2,NAMEW,E
 VAR NAME=LEN("NAME")*8+8
 NewWindow GetLabelControl(),"Name",1,11,NAME-2,7,WND,0 OUT W2,E
 NewWindow GetTextBoxControl(),"",NAME,11,W-NAME,8,WND,0 OUT NAMEW,E
 VAR BW=24
 NewWindow GetButtonControl(),"OK",(W-BW) DIV 2,22,BW,10,WND,0 OUT W2,E
 IF A1 THEN
  SetWindowVar WND,1,A1
  SetWindowName WND,"New File"
 ELSE
  SetWindowName WND,"New Folder"
 ENDIF
 SetWindowVar WND,0,NAMEW
END
COMMON DEF OTYFILNEWFOLNOTIF WND,CTL,T,A1,A2
 IF CheckWindow(A1)&&IsControlExtend(GetControl(A1),GetButtonControl())THEN
  VAR FLG=GetWindowVar(WND,1)
  VAR FOLNAME$=GetWindowName$(GetWindowVar(WND,0))
  VAR ERR
  IF FLG THEN
   SaveFile FOLNAME$,"" OUT ERR
  ELSE
   ERR=NewDir(FOLNAME$)
  ENDIF
  IF ERR THEN
   OTYFIL_SHOWERROR ERR,WND
   RETURN
  ENDIF
  VOID(DeleteWindow(WND))
 ENDIF
END
DEF OTYFIL_DEL WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 VAR ERR=DeleteFile(MID$(F$,1,LEN(F$)))
END
DEF OTYFIL_COPYFILE TYP$,F$,PATH$ OUT ERR
 PATH$=CombinePath$(PATH$,GetFileNameWithoutDir$(F$))
 IF TYP$==" "THEN 'DAT
  ERR=0
  'GRP
  VAR EXT$=GetFileExtension$(F$)
  ToUpper EXT$
  IF EXT$=="GRP"THEN
   DIM A[0,0]
   LoadDATA F$,A OUT ERR
   IF ERR THEN RETURN
   SaveDATA PATH$,A OUT ERR
   IF ERR THEN RETURN
  ENDIF
  RETURN
 ENDIF
 VAR T$
 LoadFile F$ OUT T$,ERR
 IF ERR THEN RETURN
 SaveFile PATH$,T$ OUT ERR
 IF ERR THEN RETURN
END
DEF OTYFIL_COPY2 F$,PATH$ OUT ERR
 VAR TYPE$
 GetFileType F$ OUT TYPE$,ERR
 IF ERR THEN RETURN
 IF TYPE$=="/"THEN
  VAR DIR$=F$
  IF RIGHT$(DIR$,1)=="/"THEN
   DIR$=LEFT$(DIR$,LEN(DIR$)-1)
  ENDIF
  DIR$=GetFileNameWithoutDir$(DIR$)
  OTYFIL_COPYDIR F$,CombinePath$(PATH$,DIR$) OUT ERR
 ELSE
  OTYFIL_COPYFILE TYPE$,F$,PATH$ OUT ERR
 ENDIF
END
DEF OTYFIL_COPYDIR F$,PATH$ OUT ERR
 NewDir PATH$ OUT ERR
 IF ERR THEN
  IF GetErrorName$(ERR)!="ERROR_ALREADYFILE"THEN
   RETURN
  ENDIF
 ENDIF
 IF 0THEN DIM ARY$[0]
 GetFiles F$ OUT ARY$,ERR
 IF ERR THEN RETURN
 VAR I
 FOR I=0TO LEN(ARY$)-1
  VAR A$=ARY$[I]
  IF A$=="/.."||A$=="/."THEN CONTINUE
  VAR FN$=MID$(A$,1,&H7FFFFFFF)
  IF A$[0]=="/"THEN
   OTYFIL_COPYDIR CombinePath$(F$,FN$),CombinePath$(PATH$,FN$) OUT ERR
  ELSE
   OTYFIL_COPYFILE A$[0],CombinePath$(F$,FN$),PATH$ OUT ERR
  ENDIF
  IF ERR THEN RETURN
 NEXT
END
DEF OTYFIL_PASTE WND
 IF!ClipboardContainsFile()THEN
  RETURN
 ENDIF
 VAR CUT,F$
 ClipboardGetFile OUT CUT,F$
 VAR ERR
 OTYFIL_COPY2 F$,GetCurrentDir$() OUT ERR
 IF ERR THEN
  OTYFIL_SHOWERROR ERR,WND
 ENDIF
 '?"PASTE:",F$
END
DEF OTYFIL_REN WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 VAR E=NewModalDialogBox(OTYFILRENCTL,F$,40+15*8+4,32,WND)
END
COMMON DEF OTYFILLDBL WND,CTL,T,X,Y
 OTYFILLMouse WND,CTL,T,X,Y
 OTYFIL_OPEN WND
END
VAR OTYFIL_CONTEXTMENU
COMMON DEF OTYFILCTXMenu WND,CTL,T,X,Y
 ShowMenu OTYFIL_CONTEXTMENU,WND,X,Y
END
COMMON DEF OTYFILLMouse WND,CTL,T,X,Y
 VAR S=GetChildWindow(WND)
 VAR POS=GetScrollBarPosition(S)*2
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 VAR R=WIDTH DIV 42
 VAR BY1=(POS MOD 40)+7
 VAR BY2=(POS MOD 40)-9
 VAR K=(POS DIV 40)*R
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR W=42
 VAR H=40
 K=K+((Y+(POS MOD 40)) DIV H)*R
 K=K+X DIV W
 K=K*2
 IF GetWindowVar(WND,4)!=K THEN
  SetWindowVar WND,4,K
  OTYFILPAINT WND,CTL,T,0,0
 ENDIF
END
COMMON DEF OTYFILDEL WND,CTL,T,A1,A2
 FreeString GetWindowVar(WND,2)
 StrArrayFree GetWindowVar(WND,3)
END
DEF OTYFILGETSCRBARLEN(WND)
 VAR CW=GetChildWindow(WND)
 VAR W=GetWindowWidth(WND)
 VAR OL=W DIV 42
 VAR LEN=LEN(GetString$(GetWindowVar(WND,3)))
 IF OL==0THEN OL=1
 VAR AW=(LEN DIV OL)*10
 RETURN AW
END
COMMON DEF OTYFILRESIZ WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 SetScrollBarSize CW,OTYFILGETSCRBARLEN(WND)
 'VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF OTYFILPAINT WND,CTL,T,A1,A2
 IF CallBaseControlHandler(WND,CTL,T,A1,A2)THEN RETURN
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,GetBackColor()
 VAR S=GetChildWindow(WND)
 VAR POS=GetScrollBarPosition(S)*2
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 VAR R=WIDTH DIV 42
 VAR BY1=(POS MOD 40)+7
 VAR BY2=(POS MOD 40)-9
 VAR X=0,Y=7
 VAR K=((POS DIV 40)*R)*2
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR W=42
 VAR H=40
 VAR SELECT=GetWindowVar(WND,4)
 VAR IX=(40-16) DIV 2
 VAR C=RGB(0,0,0)
 WHILE K<KL
  VAR F$=GetString$(ASC(ARY$[K])OR ASC(ARY$[K+1])<<16)
  IF F$[0]==" "THEN
   GLOADWindow WND,X+IX,Y-BY1,16,16,OTYFILICODAT,1,0
  ELSE
   IF F$[0]=="*"THEN
    GLOADWindow WND,X+IX,Y-BY1,16,16,OTYFILICOTXT,1,0
   ELSE
    IF F$[0]=="/"THEN
     GLOADWindow WND,X+IX,Y-BY1,16,16,OTYFILICODIR,1,0
    ENDIF
   ENDIF
  ENDIF
  IF SELECT==K THEN
   GFILLWindow WND,X,Y-BY2,X+39,Y-BY2+23,GetSelectionColor()
   C=-1
  ENDIF
  VAR L=LEN(F$)-1
  IF L<=5 THEN
   GPRINTWindow WND,X+(5-L)*4,Y-BY2,MID$(F$,1,5),C
  ELSEIF L>10THEN
   GPRINTWindow WND,X,Y-BY2+8,MID$(F$,6,5),C
   GPRINTWindow WND,X+((5-MIN(L-10,5))*4),Y-BY2+16,MID$(F$,11,5),C
   GPRINTWindow WND,X,Y-BY2,MID$(F$,1,5),C
  ELSEIF L>5THEN
   GPRINTWindow WND,X+((5-(L-5))*4),Y-BY2+8,MID$(F$,6,5),C
   GPRINTWindow WND,X,Y-BY2,MID$(F$,1,5),C
  ENDIF
  X=X+W
  IF X+W>WIDTH THEN
   X=0
   IF Y>=HEIGHT THEN BREAK
   Y=Y+H
  ENDIF
  IF SELECT==K THEN
   C=RGB(0,0,0)
  ENDIF
  K=K+2
 WEND
 IF GENDWindow(WND)THEN RETURN
END
DEF OTYFILSCR WND,SEL
 VAR S=GetChildWindow(WND)
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 VAR R=WIDTH DIV 42
 SetScrollBarPosition S,((SEL DIV 2)DIV R)*20
END
COMMON DEF OTYFILKEY WND,CTL,T,KEY,A2
 VAR IND=0
 VAR K$=CHR$(KEY)
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR K=GetWindowVar(WND,4),SEL=-1,ISSEL=TRUE
 IF K==-1THEN
  K=0
  ISSEL=FALSE
 ELSE
  K=K+2
 ENDIF
 WHILE TRUE
  IF K>=KL THEN
   IF ISSEL THEN
    ISSEL=0
    KL=MIN(LEN(ARY$),GetWindowVar(WND,4))
    K=0
   ELSE
    BREAK
   ENDIF
  ENDIF
  VAR F$=GetString$(ASC(ARY$[K])OR ASC(ARY$[K+1])<<16)
  IF LEN(F$)>IND+1&&F$[IND+1]==K$ THEN
   SEL=K
   BREAK
  ENDIF
  K=K+2
 WEND
 IF SEL!=-1THEN
  SetWindowVar WND,4,SEL
  OTYFILSCR WND,SEL
 ENDIF
 void(repaintWindow(WND))
END
DEF OTYFIL_NEWFOL WND,FLG
 VAR E
 NewDialogBoxWithArg OTYFILNEWFOLCTL,"",40+15*8+4,40,WND,TRUE,FLG,0OUT ,E
END
COMMON DEF OTYFILNOTIF WND,CTL,T,ID,POS
 IF ID==MenuNotifID() THEN
  IF POS==OTYFIL_MOPEN THEN
   OTYFIL_OPEN WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MCOPY THEN
   OTYFIL_COPY WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MCUT THEN
   OTYFIL_CUT WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MDEL THEN
   OTYFIL_DEL WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MREN THEN
   OTYFIL_REN WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MPASTE THEN
   OTYFIL_PASTE WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MFIL THEN
   OTYFIL_FIL WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MUPD THEN
   VOID OTYFIL_UPD(WND)
   RETURN
  ENDIF
  IF POS==OTYFIL_MNEWFOL THEN
   OTYFIL_NEWFOL WND,0
   RETURN
  ENDIF
  IF POS==OTYFIL_MNEWTXT THEN
   OTYFIL_NEWFOL WND,1
   RETURN
  ENDIF
  IF POS==OTYFIL_MABOUT THEN
   VAR E=NewModalDialogBox(OTYFILABOUTCTL,"ABOUT",128+15,40,WND)
  ENDIF
  RETURN
 ENDIF
 OTYFILPAINT WND,CTL,T,0,0
 RETURN
END
DEF StrArrayGetFiles(PTR,DIR$)
 DIM FILES$[0]
 VAR ERR
 VAR ISROOT
 DIR$=GetAbsolutePath$(DIR$)
 IF DIR$=="/"THEN ISROOT=TRUE
 GetFiles DIR$ OUT FILES$,ERR
 IF ERR THEN
  RETURN ERR
 ENDIF
 VAR S$=CHR$(0)*(2*LEN(FILES$))
 VAR I,L=LEN(FILES$)-1
 VAR J
 VAR A
 IF !ISROOT THEN
  A=AllocString("/..")
  PUSH S$,CHR$(0)*2
  S$[J]=CHR$(A)
  S$[J+1]=CHR$(A>>16)
  J=J+2
 ENDIF
 FOR I=0TO L
  'hidden file
  IF(ISROOT&&FILES$[I]=="/dev")||                  FILES$[I][1]=="@"||                           FILES$[I]=="/.."THEN
   VAR _$=POP(S$)
   _$=POP(S$)
   CONTINUE
  ENDIF
  A=AllocString(FILES$[I])
  S$[J]=CHR$(A)
  S$[J+1]=CHR$(A>>16)
  J=J+2
 NEXT

 SetString PTR,S$
 RETURN 0
END
DEF StrArrayFree PTR
 VAR OLD$=GetString$(PTR)
 VAR I,L=LEN(OLD$)-1
 FOR I=0 TO L STEP 2
  VAR J=ASC(OLD$[I])OR ASC(OLD$[I+1])<<16
  FreeString J
 NEXT
END
COMMON DEF I_OTYFIL
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTYFILCTL THEN
  ExtendControl "Files",GetWindowControl() OUT OTYFILCTL,E
  E=SetControlNotifHandler(OTYFILCTL,"OTYFILNOTIF")
  E=SetControlPainter(OTYFILCTL,"OTYFILPAINT")
  E=SetControlResizeHandler(OTYFILCTL,"OTYFILRESIZ")
  E=SetControlDeleteHandler(OTYFILCTL,"OTYFILDEL")
  E=SetControlLMouseDownHandler(OTYFILCTL,"OTYFILLMouse")
  E=SetControlContextMenuHandler(OTYFILCTL,"OTYFILCTXMenu")
  E=SetControlLDoubleClickHandler(OTYFILCTL,"OTYFILLDBL")
  E=SetControlKeyHandler(OTYFILCTL,"OTYFILKEY")
  NewControl "OTYFILICON" OUT OTYFILICONCTL,E
  E=SetControlPainter(OTYFILICONCTL,"OTYFILICONCTLPainter")
  RC_OTYFIL
  ExtendControl "FilesAbout",GetWindowControl() OUT OTYFILABOUTCTL,E
  E=SetControlNotifHandler(OTYFILABOUTCTL,"OTYFILABOUTNOTIF")
  E=SetControlCreateHandler(OTYFILABOUTCTL,"OTYFILABOUTCREATE")
  ExtendControl "Files_Rename",GetWindowControl() OUT OTYFILRENCTL,E
  E=SetControlCreateHandler(OTYFILRENCTL,"OTYFILRENCREATE")
  E=SetControlNotifHandler(OTYFILRENCTL,"OTYFILRENNOTIF")
  ExtendControl "Files_NewFolder",GetWindowControl() OUT OTYFILNEWFOLCTL,E
  E=SetControlCreateHandler(OTYFILNEWFOLCTL,"OTYFILNEWFOLCREATE")
  E=SetControlNotifHandler(OTYFILNEWFOLCTL,"OTYFILNEWFOLNOTIF")
 ENDIF
 VAR CMD$,DIR$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT DIR$,I
 E=SetCurrentDir(DIR$)
 VAR W=42*4+8,H=64,LBL
 NewTopLevelStyleWindow OTYFILCTL,"Files",W,H,WINDOWMENUSTYLE()OR WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle() OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 OTYFIL_MOPEN=1
 OTYFIL_MCOPY=2
 OTYFIL_MCUT=3
 OTYFIL_MDEL=4
 OTYFIL_MREN=5
 OTYFIL_MABOUT=6
 OTYFIL_MPASTE=7
 OTYFIL_MFIL=8
 OTYFIL_MUPD=9
 OTYFIL_MNEWFOL=10
 OTYFIL_MNEWTXT=11
 VAR NEWMENU
 NewMenu OUT NEWMENU,E
 AddMenuItem NEWMENU,"Folder",OTYFIL_MNEWFOL
 AddMenuItem NEWMENU,"Text",OTYFIL_MNEWTXT
 AddMenuItem MENU,"Open",OTYFIL_MOPEN
 AddMenuItem MENU,"Copy",OTYFIL_MCOPY
 AddMenuItem MENU,"Cut",OTYFIL_MCUT
 AddMenuItem MENU,"Paste",OTYFIL_MPASTE
 AddMenuItem MENU,"Delete",OTYFIL_MDEL
 AddMenuItem MENU,"Rename",OTYFIL_MREN
 AddSubMenuItem MENU,"New",NEWMENU
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 OTYFIL_CONTEXTMENU=MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"Filter",OTYFIL_MFIL
 AddMenuItem MENU,"Update",OTYFIL_MUPD
 AddSubMenuItem GetWindowMenu(WND),"View",MENU NewMenu OUT MENU,E
 AddMenuItem MENU,"About",OTYFIL_MABOUT
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 VAR SCR
 SetProcessVar WND
 SetWindowVar WND,2,AllocString("")
 VAR PTR=AllocString("")
 SetWindowVar WND,3,PTR
 NewVScrollBAR WND,OTYFILGETSCRBARLEN(WND) OUT SCR,E
 SetWindowVar WND,4,-1'SELECTED
 OTYFILNOTIF WND,0,0,WND,0
 SetWindowMinSize WND,52,64
 VOID OTYFIL_UPD(WND)
END
COMMON DEF L_OTYFIL
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR MPLAYCTL
VAR MPLAYABOUTCTL
VAR MPLAYPRESETCTL

VAR MPLAY_WV_LABEL
VAR MPLAY_WV_BGM
VAR MPLAY_WV_PRESET
VAR MPLAY_WV_TRACK
VAR MPLAY_WV_FILE
DEF MPLAY_GET_TRACK()
 VAR I
 FOR I=0TO 7
  IF!BGMCHK(I)THEN RETURN I
 NEXT
 RETURN 0
END
COMMON DEF MPLAYDEL WND,CTL,TYP,_,__
 VAR S=GetWindowVar(WND,MPLAY_WV_FILE)
 IF S THEN
  FreeString S
 ENDIF
 BGMSTOP GetWindowVar(WND,MPLAY_WV_TRACK)
END
COMMON DEF MPLAYNOTIF WND,CTL,TYP,CW,ID
 IF GetControl(CW)==MPLAYPRESETCTL THEN
  VOID DeleteWindow(CW)
  SetWindowVar WND,MPLAY_WV_PRESET,TRUE
  SetWindowVar WND,MPLAY_WV_BGM,ID
  SetWindowName GetWindowVar(WND,MPLAY_WV_LABEL),MPLAY_LOADPRESET()[ID]
  RETURN
 ENDIF
 VAR N$=GetWindowName$(CW)
 IF N$==""THEN
  BGMPAUSE GetWindowVar(WND,MPLAY_WV_TRACK)
  SetWindowName CW,""
  VOID RepaintWindow(CW)
 ENDIF
 IF N$==""THEN
  VAR TRACK=MPLAY_GET_TRACK()
' IF BGMCHK(TRACK)THEN 
'  BGMCONT TRACK
'  RETURN
' ENDIF
  SetWindowVar WND,MPLAY_WV_TRACK,TRACK
  IF GetWindowVar(WND,MPLAY_WV_PRESET)THEN
   
   SetWindowName CW,""
   VOID RepaintWindow(CW)
   BGMPLAY TRACK,GetWindowVar(WND,MPLAY_WV_BGM)
   RETURN
  ENDIF
  VAR FILE=GetWindowVar(WND,MPLAY_WV_FILE)
  IF!FILE THEN RETURN
  
  VAR ERR,T$
  LoadFile GetString$(FILE) OUT T$,ERR
  IF ERR THEN RETURN
  'FIXME:IMPL SOUND API
  VAR BGM=255-TRACK
  BGMSET BGM,T$
  BGMPLAY TRACK,BGM
  VOID RepaintWindow(CW)
  SetWindowName CW,""
  RETURN
 ENDIF
 IF ID==1THEN
  VOID OpenFileDialog(WND,"TXT",0)
  RETURN
 ENDIF
 IF ID==2THEN
  VAR E=NewModalDialogBox(MPLAYPRESETCTL,"Preset",210,128,WND)
 ENDIF
 IF ID==3THEN
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
 IF ID==4THEN
  E=NewModalDialogBox(MPLAYABOUTCTL,"ABOUT",128,40,WND)
 ENDIF
END
DEF MPLAY_SETFILE W,A2$
 SetWindowVar W,MPLAY_WV_PRESET,FALSE
 A2$=GetAbsolutePath$(A2$)
 VAR FILE=GetWindowVar(W,MPLAY_WV_FILE)
 IF!FILE THEN
  SetWindowVar W,MPLAY_WV_FILE,AllocString(A2$)
 ELSE
  SetString FILE,A2$
 ENDIF
 SetWindowName GetWindowVar(W,MPLAY_WV_LABEL),GetFileNameWithoutDir$(A2$)
 VOID RepaintWindow(GetWindowVar(W,MPLAY_WV_LABEL))
END
COMMON DEF MPLAYSNOTIF W,C,T,A1,A2$
 MPLAY_SETFILE W,A2$
END
COMMON DEF MPLAYPRESETNOTIF WND,CTL,TYP,CW,A2
 
 IF IsControlExtend(GetControl(CW),GetListBoxControl())THEN
  IF A2==0THEN
   VAR C$=GetListBoxSelectedText$(CW)
   VAR BGM=FindArray(MPLAY_LOADPRESET(),C$)
   VOID SendNotificationWindow(GetOwnerWindow(WND),WND,BGM)
  ENDIF
 ENDIF
END
COMMON DEF MPLAYPRESETCREATE WND,CTL,TYP,A1,A2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR LST,E
 NewWindow GetListBoxControl(),"",0,0,W,H,WND,0 OUT LST,E
 IF E THEN
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
 AddArrayListBoxItem LST,MPLAY_LOADPRESET()
END
DEF MPLAY_LOADPRESET()
 DIM A$[43]
 COPY A$,@BGMNAME
 RETURN A$
@BGMNAME
DATA "Kung-Fu POP"
DATA "With stealthy steps"
DATA "Flat out run"
DATA "Nostalgia TECHNO"
DATA "Feel easy"
DATA "Have a good time"
DATA "Relief"
DATA "Exciting days"
DATA "Skipping march"
DATA "Valiant departure"
DATA "Important thing"
DATA "Chasing at 'Ooedo'"
DATA "Funny land"
DATA "Step on the accelerator"
DATA "Experiment"
DATA "New discovery"
DATA "Thinking time"
DATA "Mischievous boy"
DATA "Float"
DATA "Sound of the surf"
DATA "Sound of the surf2"
DATA "Spy movie"
DATA "Calculating"
DATA "Take Off!"
DATA "The evening moon."
DATA "Sensibility"
DATA "Pure water"
DATA "Strategy"
DATA "cure"
DATA "Intense battle"
DATA "Keen competition"
DATA "Heat uuuup!!"
DATA "Rise with force"
DATA "Bright blue"
DATA "Storyteller"
DATA "Return trip"
DATA "High spirits"
DATA "Welcome to the party"
DATA "Funky claps"
DATA "Night surfer"
DATA "Ready to FLY"
DATA "We are heroes"
DATA "Pure water2"
END
COMMON DEF I_MPLAY
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!MPLAYCTL THEN
  ExtendControl "MPLAY",GetWindowControl() OUT MPLAYCTL,E
  E=SetControlNotifHandler(MPLAYCTL,"MPLAYNOTIF")
  E=SetControlStrNotifHandler(MPLAYCTL,"MPLAYSNOTIF")
  E=SetControlDeleteHandler(MPLAYCTL,"MPLAYDEL")
  ExtendControl "MPLAYABOUT",GetWindowControl() OUT MPLAYABOUTCTL,E
  ExtendControl "MPLAYPRESET",GetWindowControl() OUT MPLAYPRESETCTL,E
  E=SetControlCreateHandler(MPLAYPRESETCTL,"MPLAYPRESETCREATE")
  E=SetControlNotifHandler(MPLAYPRESETCTL,"MPLAYPRESETNOTIF")
 ENDIF
 VAR MENU
 NewTopLevelStyleWindow MPLAYCTL,"MPLAY",128,10,WindowMinMaxStyle()OR WindowDisableMaxStyle()OR WindowMenuStyle() OUT WND,E
 NewMenu OUT MENU,E
 AddMenuItem MENU,"Open",1
 AddMenuItem MENU,"Preset",2
 AddMenuItem MENU,"Exit",3
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"About",4
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 SetProcessVar WND
 VAR W2
 NewWindow GetButtonControl(),"",0,0,10,10,WND,0 OUT W2,E
 VAR CMD$
 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,
 NewWindow GetLabelControl(),"",12,2,128-12,8,WND,1 OUT W2,E
 MPLAY_WV_LABEL=0
 SetWindowVar WND,MPLAY_WV_LABEL,W2
 MPLAY_WV_BGM=1
 MPLAY_WV_PRESET=2
 MPLAY_WV_TRACK=3
 MPLAY_WV_FILE=4
 IF LEN(CMD$)THEN MPLAY_SETFILE WND,CMD$
END
COMMON DEF L_MPLAY
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
DEF GETBGMLIST()
 DIM BGM$[43]
 COPY BGM$,@BGMNAME
 RETURN BGM$
@BGMNAME
DATA "Kung-Fu POP"
DATA "With stealthy steps"
DATA "Flat out run"
DATA "Nostalgia TECHNO"
DATA "Feel easy"
DATA "Have a good time"
DATA "Relief"
DATA "Exciting days"
DATA "Skipping march"
DATA "Valiant departure"
DATA "Important thing"
DATA "Chasing at 'Ooedo'"
DATA "Funny land"
DATA "Step on the accelerator"
DATA "Experiment"
DATA "New discovery"
DATA "Thinking time"
DATA "Mischievous boy"
DATA "Float"
DATA "Sound of the surf"
DATA "Sound of the surf2"
DATA "Spy movie"
DATA "Calculating"
DATA "Take Off!"
DATA "The evening moon."
DATA "Sensibility"
DATA "Pure water"
DATA "Strategy"
DATA "cure"
DATA "Intense battle"
DATA "Keen competition"
DATA "Heat uuuup!!"
DATA "Rise with force"
DATA "Bright blue"
DATA "Storyteller"
DATA "Return trip"
DATA "High spirits"
DATA "Welcome to the party"
DATA "Funky claps"
DATA "Night surfer"
DATA "Ready to FLY"
DATA "We are heroes"
DATA "Pure water2"
END
'Init common dialogs
VAR CTL_FILDIA
VAR FILDIA_WV_LSTBOX
VAR FILDIA_WV_ISSAVE
VAR FILDIA_WV_TXTBOX
VAR FILDIA_WV_ID
VAR FILDIA_WV_DRPDWN


DEF OTW_FileDialog
 VAR E
 ExtendControl "FileDialog",GetWindowControl()OUT CTL_FILDIA,E
 IF E THEN RETURN
 E=SetControlCreateHandler(CTL_FILDIA,"FileDialogCreate")
 E=SetControlNotifHandler(CTL_FILDIA,"FileDialogNotif")
 FILDIA_WV_LSTBOX=0
 FILDIA_WV_ISSAVE=1
 FILDIA_WV_TXTBOX=2
 FILDIA_WV_ID=3
 FILDIA_WV_DRPDWN=4
END
COMMON DEF DeleteFileDialogInfo(FDINFO)
 RETURN DeleteWindow(FDINFO)
END
COMMON DEF GetFileDialogInfoFile$(FDINFO)
 VAR WND=FDINFO
 VAR ISSAVE=GetWindowVar(WND,FILDIA_WV_ISSAVE)
 VAR SEL$
 IF ISSAVE THEN
  SEL$=GetWindowName$(GetWindowVar(WND,FILDIA_WV_TXTBOX))
  IF!LEN(SEL$)THEN RETURN""
  IF SEL$[0]!=" "&&SEL$[0]!="*"THEN
   SEL$="*"+SEL$
  ENDIF
 ELSE
  SEL$=GetListBoxSelectedText$(GetWindowVar(WND,0))
  IF!LEN(SEL$)THEN RETURN""
 ENDIF
 VAR FILE$=MID$(SEL$,1,LEN(SEL$))
 RETURN FILE$
END
COMMON DEF GetFileDialogInfoType$(FDINFO)
 RETURN GetListBoxSelectedText$(GetDropDownListBox(GetWindowVar(FDINFO,FILDIA_WV_DRPDWN)))
END
COMMON DEF FileDialogNotif WND,C,T,W,__
 VAR ISSAVE=GetWindowVar(WND,FILDIA_WV_ISSAVE)
 VAR DRPDWN=GetWindowVar(WND,FILDIA_WV_DRPDWN)
 IF W==GetWindowVar(WND,FILDIA_WV_LSTBOX)&&ISSAVE&&__==ListBoxChItem()THEN
  VAR L$=GetListBoxSelectedText$(W)
  IF !LEN(L$)||L$[0]!="/"THEN
   SetWindowName GetWindowVar(WND,FILDIA_WV_TXTBOX),L$
   VOID RepaintWindow(GetWindowVar(WND,FILDIA_WV_TXTBOX))
   RETURN
  ENDIF
 ENDIF
 IF GetWindowVar(WND,FILDIA_WV_LSTBOX)==W&&__==ListBoxChItem()THEN RETURN
 IF GetWindowName$(W)=="OK"||GetWindowName$(W)=="L"THEN
  VAR SEL$
  IF ISSAVE&&GetWindowName$(W)=="OK"&&__!=ListBoxChItem() THEN
   SEL$=GetWindowName$(GetWindowVar(WND,FILDIA_WV_TXTBOX))
   IF!LEN(SEL$)THEN RETURN
   IF SEL$[0]!=" "&&SEL$[0]!="*"THEN
    SEL$="*"+SEL$
   ENDIF
  ELSE
   SEL$=GetListBoxSelectedText$(GetWindowVar(WND,0))
   IF!LEN(SEL$)THEN RETURN
  ENDIF
  IF SEL$[0]=="/"THEN
   VOID SetCurrentDir(MID$(SEL$,1,LEN(SEL$)))
   INITFILEDIALOGLISTBOX WND
   RETURN
  ENDIF
  VAR FILE$=MID$(SEL$,1,LEN(SEL$))
  VAR ID=GetWindowVar(WND,FILDIA_WV_ID)
  IF DRPDWN THEN
   VOID SendNotifWindow(GetWindowGroupOwner(WND),ID,WND)
  ELSE
   VOID SendStrNotifWindow(GetWindowGroupOwner(WND),ID,FILE$)
   VOID DeleteWindow(WND)
  ENDIF
 ELSE
  IF GetWindowName$(W)=="Cancel"THEN
   VOID DeleteWindow(WND)
  ENDIF
 ENDIF
END
DEF INITFILEDIALOGLISTBOX WND
 VAR L=GetWindowVar(WND,FILDIA_WV_LSTBOX)'LISTBOX WND
 DIM F$[0]
 VAR E
 GetFiles "" OUT F$,E
 VAR I
 VAR T$=GetWindowName$(WND)
 T$=RIGHT$(T$,LEN(T$)-5)
 VAR T=0
 IF T$=="TXT"THEN T=1
 IF T$=="DAT"THEN T=2
 ClearListBox L
 FOR I=0TO LEN(F$)-1
  IF F$[I][0]==" "&&T==1THEN CONTINUE
  IF F$[I][0]=="*"&&T==2THEN CONTINUE
  AddListBoxItem L,F$[I]
 NEXT
END
COMMON DEF FileDialogCreate WND,C,T,ID,LIST
 VAR E,L
 NewWindow GetListBoxControl(),"L",0,0,116,64,WND,0 OUT L,E

 VAR HEIGHT=GetWindowHeight(WND)
 SetWindowVar WND,FILDIA_WV_LSTBOX,L
 IF LIST THEN
  IF 0THEN DIM LIST$[0]
  NewWindow GetDropDownListControl(),"L",0,65,116,GetDropDownListHeight(),WND,0 OUT L,E
  VAR LB=GetDropDownListBox(L)
  LIST$=GetSBArray(LIST)
  AddArrayListBoxItem LB,LIST$
  SelectListBoxItem LB,0
  SetWindowVar WND,FILDIA_WV_DRPDWN,L
 ENDIF
 INITFILEDIALOGLISTBOX WND
 VAR F=LEFT$(GetWindowName$(WND),4)=="Save"
 SetWindowVar WND,1,F
 NewWindow GetButtonControl(),"OK",119,2,20,12,WND,0 OUT L,E
 NewWindow GetButtonControl(),"Cancel",119,16,50,12,WND,0 OUT L,E
 'SAVE DIALOG
 IF F THEN
  NewWindow GetTextBoxControl(),"",0,HEIGHT-9,170,9,WND,0 OUT L,E
  SetWindowVar WND,FILDIA_WV_TXTBOX,L
 ENDIF
 SetWindowVar WND,FILDIA_WV_ID,ID
END
COMMON DEF SaveFileDialog(OWNER,TYPE$,ID)
 IF!CTL_FILDIA THEN
  OTW_FileDialog
 ENDIF
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN TYPE$=""
 VAR TITLE$=TYPE$
 VAR E
 NewDialogBoxWithArg CTL_FILDIA,"Save "+TYPE$,170,74,OWNER,TRUE,ID,0OUT ,E
 RETURN E
END
COMMON DEF OpenFileDialog(OWNER,TYPE$,ID)
 IF!CTL_FILDIA THEN
  OTW_FileDialog
 ENDIF
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN TYPE$=""
 VAR TITLE$=TYPE$
 VAR E
 NewDialogBoxWithArg CTL_FILDIA,"Open "+TYPE$,170,64+10,OWNER,TRUE,ID,0OUT ,E
 RETURN E
END
COMMON DEF OpenFileDialogEx OWNER,TYPE$,ID,LIST$[] OUT E
 IF!CTL_FILDIA THEN
  OTW_FileDialog
 ENDIF
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN TYPE$=""
 VAR TITLE$=TYPE$
 VAR WND
 VAR ARY=AllocSBArray()
 SetSBArray ARY,LIST$
 NewDialogBoxWithArg CTL_FILDIA,"Open "+TYPE$,170,64+GetDropDownListHeight()+1,OWNER,TRUE,ID,ARY OUT WND,E
 FreeSBArray ARY
 'GetWindowVar 
END
COMMON DEF SaveFileDialogEx(OWNER,TYPE$,ID,LIST$)
 IF!CTL_FILDIA THEN
  OTW_FileDialog
 ENDIF
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN TYPE$=""
 VAR TITLE$=TYPE$
 VAR E
 VAR ARY=AllocSBArray()
 SetSBArray ARY,LIST$
 NewDialogBoxWithArg CTL_FILDIA,"Save "+TYPE$,170,74+GetDropDownListHeight()+1,OWNER,TRUE,ID,ARY OUT ,E
 FreeSBArray ARY
 RETURN E
END
COMMON DEF FindWindowByControl(WND,CTL,EXTEND)
 WND=GetChildWindow(WND)
 WHILE WND
  IF EXTEND THEN
   IF IsControlExtend(GetControl(WND),CTL) THEN
    RETURN WND
   ENDIF
  ELSE
   IF GetControl(WND)==CTL THEN
    RETURN WND
   ENDIF
  ENDIF
  WND=GetNextWindow(WND)
 WEND
 RETURN 0
END

'=========
DEF OTW_LOADFONT
 'LOAD FONT-1
 VAR C$
 VAR X,Y,I,J
 RESTORE @FONT
 VAR C,_$,K
 DIM PAL[16]
 OTW_CONSOLEPAL=PAL
 FOR I=0TO 15
  READ PAL[I]
 NEXT
 RETURN
 '3.0.X
 OTW_FNT=NewArray2(1024,64)
 OTW_FNTTMP=NewArray(64)
 OTW_FNTPAL=NewArray(2)
 OTW_FNTTBL=NewArray(65536)
 PrintConsoleln "Init font table..."
 FOR I=0TO 127
  OTW_FNTTBL[I]=703
 NEXT
 FOR I=1TO 511
  COPY OTW_FNTTBL,I*128,OTW_FNTTBL,0,128
 NEXT
 OTW_FNTTBL[10]=13
 OTW_LOADFNTTBL
 IF!CHKFILE("DAT:OTW_FONT")THEN
  OTW_GENFONT
 ELSE
  PrintConsoleln "Load DAT:OTW_FONT"
  LOAD"DAT:OTW_FONT",OTW_FNT,0
 ENDIF
 @FONT
 '      AARRGGBB
DATA &H00000000
DATA &HFF000000
DATA &HFF7F0000
DATA &HFFFF0000
DATA &HFF007F00
DATA &HFF00FF00
DATA &HFF7F7F00
DATA &HFFFFFF00
DATA &HFF00007F
DATA &HFF0000FF
DATA &HFF7F007F
DATA &HFFFF00FF
DATA &HFF007F7F
DATA &HFF00FFFF
DATA &HFF7F7F7F
DATA &HFFFFFFFF
END
DEF OTW_GENFONT
 VAR I
 IF!CHKFILE("DAT:FONT")THEN
  SAVE "GRPF:FONT"
  IF RESULT==-1 THEN SAVE "GRPF:FONT"
  '2かいもやめたならしかたない
  IF RESULT!=1 THEN
   FOR I=0TO 63
    READ OTW_FNT[703,I]
   NEXT
   FOR I=1TO 65535
    OTW_FNTTBL[I]=703
   NEXT
   RETURN
  ENDIF
 ENDIF
 LOAD"GRP1:FONT",0
 VAR L
 VAR X,Y,J,K
 GPAGE 0,1
 FOR I=0TO 1023
  X=I*8
  Y=X/512
  Y=Y*8
  X=X MOD 512
  VAR X2=X+7,Y2=Y+7,M=0
  FOR K=Y TO Y2
   FOR J=X TO X2
    IF(GSPOIT(J,K)AND&HFF000000)THEN
     OTW_FNT[I,M]=1
    ENDIF
    INC M
   NEXT
  NEXT
 NEXT
 SAVE"DAT:OTW_FONT",OTW_FNT
 GCLS 
 GPAGE 0,0
@FONT
RETURN
COLOR
DATA 1,1,1,1,1,1,1,0'"FFFFFFF0"
DATA 1,0,1,1,1,0,1,0'"F0FFF0F0"
DATA 1,1,0,1,0,1,1,0'"FF0F0FF0"
DATA 1,1,1,0,1,1,1,0'"FFF0FFF0"
DATA 1,1,0,1,0,1,1,0'"FF0F0FF0"
DATA 1,0,1,1,1,0,1,0'"F0FFF0F0"
DATA 1,1,1,1,1,1,1,0'"FFFFFFF0"
DATA 0,0,0,0,0,0,0,0'"00000000"
DATA "0"
DATA &B00111000'"00FFF000"
DATA &B01000100
DATA &B01001100
DATA &B01010100
DATA &B01100100
DATA &B01000100
DATA &B00111000
DATA &B00000000
DATA "END"
END
DEF OTW_LOADFNTTBL
 RESTORE@RANGE
 VAR I
 WHILE 1
  VAR R1,R2,C1,C2
  READ R1
  IF R1==-1THEN BREAK
  READ C1,R2,C2
  FOR I=R1 TO R2
   OTW_FNTTBL[I]=C1
   INC C1
  NEXT
 WEND
 RESTORE @GRPFTABLE
 WHILE 1
  READ R1
  IF R1==-1THEN BREAK
  READ C1
  OTW_FNTTBL[R1]=C1
 WEND
@RANGE
DATA -1,"A"
@GRPFTABLE
DATA -1
END
VAR TRIANCTL
COMMON DEF DrawSquare WND,X1,Y1,X2,Y2,X3,Y3,X4,Y4,COL
 GTRIWindow WND,X2,Y2,X1,Y1,X4,Y4,COL'RGB(0,255,0)'COL
 GTRIWindow WND,X1,Y1,X4,Y4,X3,Y3,COL
END
COMMON DEF TRIANPAINT WND,CTL,TYP,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 E=GBeginWindow(WND)
' DrawSquare WND,32,0,                                         0,63,                                         63,0,                                         32,63,-1
' DrawSquare WND,8,8,                                         0,63,                                         32,16,                                         32,63,-1
 DrawSquare WND,8,8,0,63,32,16,32,63,-1
 E=GEndWindow(WND)
END
COMMON DEF I_TRIAN
IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!TRIANCTL THEN
  ExtendControl "TRIAN",GetWindowControl() OUT TRIANCTL,E
  E=SetControlPainter(TRIANCTL,"TRIANPAINT")
 ENDIF
 NewTopLevelWindow TRIANCTL,"TRIAN",64,64 OUT WND,E
 SetProcessVar WND
END
COMMON DEF L_TRIAN
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR ODSKCTL
COMMON DEF I_ODSK
IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!ODSKCTL THEN
  ExtendControl "ODSK",GetWindowControl() OUT ODSKCTL,E
 ENDIF
 NewTopLevelStyleWindow ODSKCTL,"Desktop",256,128,WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle() OUT WIN_ROOTWND2,E
 SetProcessVar WIN_ROOTWND2
END
COMMON DEF L_ODSK
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
DEF PRUN_RMFIRSTSP P$
 VAR I,L=LEN(P$)-1,_$
 FOR I=0TO L
  IF P$[0]!=" "THEN RETURN
  _$=SHIFT(P$)
 NEXT
END
DEF PRUN_ISTHEN(P$)
 VAR I,L=LEN(P$)-1,I$,THEN$="THEN",J=LEN(THEN$)-1
 FOR I=L TO 0STEP -1
  I$=P$[I]
  IF I$==" "THEN CONTINUE
  IF J==-1THEN
   'IF ASC(I$)>= THEN 'ISALPHA
   'TODO AATHENなどのばあいや COMMENT
   RETURN TRUE
  ENDIF
  IF P$[I]==THEN$[J] THEN
   DEC J
   CONTINUE
  ENDIF
  BREAK
 NEXT
 RETURN FALSE
END

VAR PRUN_CONT
COMMON DEF __PRUN_CONT
 PRUN_CONT=1
 VAR P
 DIM GPRESULT[6]
 DIM CON[50,30]
 VAR CX,CY
 VAR CCSRX=CSRX,CCSRY=CSRY,CCSRZ=CSRZ
 FOR CY=0 TO 29
  FOR CX=0 TO 49
   CON[CX,CY]=CHKCHR(CX,CY)
  NEXT
 NEXT
 FOR P=0TO 5
  SAVE FORMAT$("GRP%D:@GRPPAGE%D",P,P)
  GPRESULT[P]=RESULT
 NEXT
 DIM SPUSED[512],I
 DIM SPU[512],SPV[512],SPW[512],SPH[512],SPA[512]
 DIM SPSX[512],SPSY[512]
 DIM SPC32[512]
 DIM SPLINK[512]
 DIM SPVAR[512,8]
 DIM SPX[512],SPY[512],SPZ[512]
 DIM SPHX[512],SPHY[512]
 DIM SPDR[512]
 FOR I=0TO 511
  VAR J
  FOR J=0TO 7
   SPVAR I,J OUT SPVAR[I,J]
  NEXT
  SPUSED I OUT SPUSED[I]
  IF SPUSED[I] THEN
   SPCHR I OUT SPU[I],SPV[I],SPW[I],SPH[I],SPA[I]
   SPSCALE I OUT SPSX[I],SPSY[I]
   SPCOLOR I OUT SPC32[I]
   SPLINK I OUT SPLINK[I]
   SPOFS I OUT SPX[I],SPY[I],SPZ[I]
   SPHOME I OUT SPHX[I],SPHY[I]
   SPROT I OUT SPDR[I]
  ENDIF
 NEXT
 VAR VP,WP
 GPAGE OUT VP,WP
 VISIBLE 1,1,0,1
 DIM B0[0],B1[0],B2[0],B3[0]
 VAR BPP=BGPAGE()
 VAR SPP=SPPAGE()
 BGSAVE 0,B0
 BGSAVE 1,B1
 BGSAVE 2,B2
 BGSAVE 3,B3
 PRUN_RESTORE
 OTX_CONT
 ACLS
 FOR CY=0 TO 29
  FOR CX=0 TO 49
   LOCATE CX,CY
   ?CHR$(CON[CX,CY]);
  NEXT
 NEXT
 LOCATE CCSRX,CCSRY,CCSRZ
 FOR P=0TO 5
  IF GPRESULT[P]==TRUE THEN LOAD FORMAT$("GRP%D:@GRPPAGE%D",P,P)
 NEXT
 FOR I=0TO 511
  FOR J=0TO 7
   SPVAR I,J,SPVAR[I,J]
  NEXT
  IF SPUSED[I] THEN
   SPSET I,SPU[I],SPV[I],SPW[I],SPH[I],SPA[I]
   SPSCALE I,SPSX[I],SPSY[I]
   SPCOLOR I,SPC32[I]
   IF NOT SPLINK[I]THEN SPLINK I,SPLINK[I]
   SPOFS I,SPX[I],SPY[I],SPZ[I]
   SPHOME I,SPHX[I],SPHY[I]
   SPROT I,SPDR[I]
  ENDIF
 NEXT
 VISIBLE 1,1,1,1
 GPAGE VP,WP
 BGPAGE BPP
 SPPAGE SPP
 BGLOAD 0,B0
 BGLOAD 1,B1
 BGLOAD 2,B2
 BGLOAD 3,B3
END

DEF PRUN_EDITPRG
 PRGEDIT 2,1
 VAR I,L=PRGSIZE(2)
 VAR H$="INT"+HEX$(RND(&HFFFF),4)
 VAR L$=":"+H$
 VAR H2$=HEX$(RND(&H7FFFFFFF),8)
 VAR Y=CSRY
 FOR I=1TO L
  LOCATE 0,Y
  ?I/L*100;"%";
  VAR __$=PRGGET$()
  PRGINS H$,0
      __$=PRGGET$()
  CONTINUE
  PRGEDIT 2,I
  VAR P$=PRGGET$()
  IF LEN(P$)&&ASC(P$[LEN(P$)-1])==10THEN P$=LEFT$(P$,LEN(P$)-1)
  PRUN_RMFIRSTSP P$
  IF LEN(P$)&&!PRUN_ISTHEN(P$)THEN
   PRGEDIT 2,I
   PRGSET P$+L$
  ENDIF
 NEXT
 __$=PRGGET$()
 PRGINS "",1
 __$=PRGGET$()
 PRGINS"DEF "+H$
 PRGINS"IF BUTTON()=="+STR$(512+64)+" THEN GOTO"+CHR$(34)+"2:@"+H2$
 PRGINS"IF BUTTON()=="+STR$(512+64+128)+" THEN __PRUN_CONT"
 PRGINS"END"
 PRGINS "@"+H2$
 PRGINS "END"
END
DEF PRUN_RESTORE
 ACLS
 VAR NW=GetChildWindow(GetRootWindow())AND NUWIDMASK
 GPAGE OTW_SP,OTW_DP
  '290
  SPSET OTW_MOUSESP,0
  OTW_SHADOWSP=1
  SPSET OTW_SHADOWSP,0
  VOID ResetCursor(OTW_CURCUR)
  OTW_MOVWINSP=2
  SPSET OTW_MOVWINSP,0
  SPSCALE OTW_MOVWINSP,1,1
  SPHIDE OTW_MOVWINSP
  SPVAR OTW_MOVWINSP,0,1
  OTW_MOVWINCOL=RGB(128,128,128,128)
  OTW_MOVWINCOL=RGB(128,255,255,255)
  SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
 
 WHILE NW
  VAR SP=WIN_SP[NW]AND 511,SP2
  IF SP THEN
   SPSET SP,WIN_RX[NW],WIN_RY[NW],WIN_AW[NW]+1,WIN_AH[NW]+1,1
   SPOFS SP,WIN_RX[NW],WIN_RY[NW]
  IF OTW_ENABLE_SHADOW THEN
   SPSET 2,511,0 OUT SP2
   IF SP>SP2 THEN
    SWAP SP,SP2
    SPSET SP,WIN_RX[NW],WIN_RY[NW],WIN_AW[NW]+1,WIN_AH[NW]+1,1
    SPOFS SP,WIN_RX[NW],WIN_RY[NW]
    SPSET SP2,511
   ENDIF
   SPVAR SP,1,SP2
   SPLINK SP2,SP
   SPSCALE SP2,WIN_WIDTH[NW]+1,WIN_HEIGHT[NW]+1
   SPCOLOR SP2,RGB(128,063,063,063)
   SPOFS SP2,3,3,1
   SPSHOW SP2
   SPVAR SP2,0,NUWIDToWND(NW)
  ENDIF
  ENDIF
  NW=WIN_NEXT[NW]
 WEND
 GPRIO 1023
 OTW_SPSORT
 RepaintAllWindow WIN_ROOTWND,0,0,0,0
END
COMMON DEF PRUNNotificationHandler NDW,C,T,CW,_
 IF PRUN_CONT THEN
  OTX_BREAK
  RETURN
 ENDIF
 VAR TW=GetWindowVar(NDW,0)
 VAR I
 GCLIP 1
 LOCATE 0,29
 ?"Now loading..."
 LOAD"PRG2:"+GetWindowName$(TW),0
 ?"OK"
 ?"EXEC..."
 PRUN_EDITPRG
 ACLS
 EXEC 2
 PRUN_RESTORE
 PRUN_CONT=0
END
VAR PRUNCTL
COMMON DEF I_PRUN
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!PRUNCTL THEN
  ExtendControl "PRUN",GetWindowControl() OUT PRUNCTL,E
 ENDIF
 VAR WND
 NewTopLevelStyleWindow PRUNCTL,"PRUN",128,32,WindowResizableStyle()OR WindowMinMaxStyle() OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 E=SetControlNotificationHandler(PRUNCTL,"PRUNNotificationHandler")
 SetProcessVar WND
 VAR TW
 NewWindow GetButtonControl(),"RUN Program",0,10,32+68,10,WND,0OUT TW,E
 NewWindow GetTextBoxControl(),"",0,0,128,8,WND,0OUT TW,E
 SetWindowVar WND,0,TW
END
COMMON DEF L_PRUN
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END
COMMON DEF LOADERNotificationHandler NDW,C,T,CW,_
 VAR TW=GetWindowVar(NDW,0)
 EXEC"PRG2:"+GetWindowName$(TW)
END
VAR LOADERCTL
COMMON DEF I_LOADER
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!LOADERCTL THEN
  ExtendControl "LOADER",GetWindowControl() OUT LOADERCTL,E
 ENDIF
 VAR WND
 NewTopLevelStyleWindow LOADERCTL,"LOADER",128,32,WindowResizableStyle()OR WindowMinMaxStyle() OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 E=SetControlNotificationHandler(LOADERCTL,"LOADERNotificationHandler")
 SetProcessVar WND
 VAR TW
 NewWindow GetButtonControl(),"Load",0,10,40,10,WND,0OUT TW,E
 NewWindow GetTextBoxControl(),"",0,0,128,8,WND,0OUT TW,E
 SetWindowVar WND,0,TW
END
COMMON DEF L_LOADER
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END

VAR TSKBARCTL
VAR TSKBAR_ROWC
DIM TB_TASKLIST$[0]
DIM TB_TASKLIST_TW[0]
DIM TB_TASKLIST_ACTV[0]
VAR TSKBAR_MENU_EXIT
VAR TSKBAR_WV_MENU
VAR TSKBAR_WV_PRGITEMS
VAR TSKBAR_WV_BTNST
VAR TSKBAR_WV_PAGE
VAR TSKBAR_WV_COUNT
DEF TSKBAR_ARE
 VAR RW=GetRootWindow()
 VAR W=GetWindowWidth(RW)
 VAR H=GetWindowHeight(RW)
 VAR X
 'VOID GBeginWindow(RW)
 'FOR X=-W TO W STEP 2
 ' GLINEWindow RW,X,0,X+W,W,#BLACK
 'NEXT
 'VOID GEndWindowEx(RW,FALSE)
 VAR Y
 FOR Y=0TO H STEP 2
  VOID GBeginWindow(RW)
  FOR X=0TO W STEP 2
   GPSETWindow RW,X,Y,#BLACK
  NEXT
  VOID GEndWindowEx(RW,FALSE)
 NEXT
 FOR Y=1TO H STEP 2
  VOID GBeginWindow(RW)
  FOR X=1TO W STEP 2
   GPSETWindow RW,X,Y,#BLACK
  NEXT
  VOID GEndWindowEx(RW,FALSE)
 NEXT
END

COMMON DEF TSKBARNotificationHandler WND,C,T,CW,__
 IF CW==MenuNotifID()THEN
  IF __==TSKBAR_MENU_EXIT THEN
   TSKBAR_ARE
   STOP
   void ExitWin()
   RETURN
  ENDIF
  IF 0 THEN DIM ARY[0]
  ARY=GetSBArray(GetWindowVar(WND,TSKBAR_WV_PRGITEMS))
  IF 0<=__&&__<LEN(ARY)THEN
   VOID ExecFile(GetString$(ARY[__]))
  ENDIF
 ENDIF
 IF GetWindowName$(CW)==""THEN
  ShowMenuXY2 GetWindowVar(WND,TSKBAR_WV_MENU),WND,0,GetWindowY(WND)
'  ShowContextMenu GetWindowVar(WND,TSKBAR_WV_MENU),WND
 ENDIF
END
COMMON DEF TSKBARLMD WND,C,T,X,Y
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 SetWindowVar WND,TSKBAR_WV_BTNST,0
 TSKBAR_BTN WND,TRUE,FALSE,X,Y,FALSE
 IF X>=W-5&&X<=W-5+4&&Y>=3&&Y<=8THEN
  TSKBAR_BTN1 WND,TRUE
  SetWindowVar WND,TSKBAR_WV_BTNST,-1
  VOID SetCapture(WND)
 ENDIF
 IF X>=W-5&&X<=W-5+4&&Y>=9&&Y<=14THEN
  SetWindowVar WND,TSKBAR_WV_BTNST,-2
  TSKBAR_BTN2 WND,TRUE
  VOID SetCapture(WND)
 ENDIF
 IF X<=23 THEN
  TSKBAR_NIBTN WND,TRUE
  SetWindowVar WND,TSKBAR_WV_BTNST,-3
  VOID SetCapture(WND)
 ENDIF
END
'SUCCESS:TRUE
'RESTORE MINIMIZED WINDOW
DEF TskbarRestore(TW)
 IF HasProp(TW,"TSKBAR_MINIMIZED")THEN
  RemoveProp TW,"TSKBAR_MINIMIZED"
  VOID ShowWindow(TW)
  VOID FrontWindow(TW)
  VOID ActiveWindow(TW)
  RETURN TRUE
 ENDIF
 RETURN FALSE
END
COMMON DEF TSKBARLMU WND,C,T,X,Y
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR BTN=GetWindowVar(WND,TSKBAR_WV_BTNST)
 VAR P
 SetWindowVar WND,TSKBAR_WV_BTNST,0
 IF BTN>=1THEN
  TB_TASKLIST_ACTV[BTN-1]=TRUE
  VAR TW=TB_TASKLIST_TW[BTN-1]
  IF !(GetWindowStyle(TW)AND WindowMinimizedStyle()&&!RestoreWindow(TW))THEN
   VOID FrontWindow(TW)
   VOID ActiveWindow(TW)
  ENDIF
 ELSEIF BTN==-1THEN
  TSKBAR_BTN1 WND,FALSE
  P=GetWindowVar(WND,TSKBAR_WV_PAGE)
  
  IF P>0 THEN
   SetWindowVar WND,TSKBAR_WV_PAGE,P-1
   TSKBAR_BTN WND,FALSE,FALSE,X,Y,FALSE
  ENDIF
 ELSEIF BTN==-2THEN
  TSKBAR_BTN2 WND,FALSE
  C=GetWindowVar(WND,TSKBAR_WV_COUNT) DIV TSKBAR_ROWC
  P=GetWindowVar(WND,TSKBAR_WV_PAGE)
  IF C>=P+1 THEN
   SetWindowVar WND,TSKBAR_WV_PAGE,P+1
   TSKBAR_BTN WND,FALSE,FALSE,X,Y,FALSE
  ENDIF
 ELSEIF BTN==-3THEN
  TSKBAR_NIBTN WND,FALSE
  ShowMenuXY2 GetWindowVar(WND,TSKBAR_WV_MENU),WND,0,GetWindowY(WND)
 ENDIF
END
DEF TSKBAR_BTN1 WND,F
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 IF GBeginWindow(WND)THEN RETURN
 DrawButton WND,W-5,3,4,5,F
 GPSETWindow WND,2-1,1,RGB(0,0,0)
 GLINEWindow WND,1-1,2,3-1,2,RGB(0,0,0)
 SetWindowDrawPos WND,0,0
 GCLIPWindow WND,0,0,W,H
 IF GEndWindow(WND)THEN RETURN
END
DEF TSKBAR_BTN2 WND,F
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 IF GBeginWindow(WND)THEN RETURN
 DrawButton WND,W-5,9,4,5,F
 GPSETWindow WND,2-1,2,RGB(0,0,0)
 GLINEWindow WND,1-1,1,3-1,1,RGB(0,0,0)
 SetWindowDrawPos WND,0,0
 GCLIPWindow WND,0,0,W,H
 IF GEndWindow(WND)THEN RETURN
END
DEF TSKBAR_BTN WND,DWN,UP,MX,MY,MENU
 VAR GB=CheckGBegin(WND)
 VAR DRAW=FALSE
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR TSX=24
 VAR TSKW=(W-9-TSX) DIV 8,TC,TCM=(W-9-TSX) DIV TSKW
 VAR PAGE=GetWindowVar(WND,TSKBAR_WV_PAGE)*TCM
 FOR TC=PAGE TO PAGE+TCM-1
  VAR TASKW2=TSKW
  IF TC==PAGE+TCM-1THEN
   TASKW2=TSKW-6
  ENDIF
  VAR BTNX=TSKW*(TC-PAGE)+(TC-PAGE)*2+TSX
  VAR BTNY=3
  VAR BTNH=11
  IF LEN(TB_TASKLIST_TW)<=TC THEN
   IF DWN||UP THEN BREAK
   GFILLWindow WND,BTNX,BTNY,BTNX+TASKW2,BTNY+BTNH,GetBackColor()
   CONTINUE
  ENDIF
  IF !TB_TASKLIST_TW[TC]THEN BREAK
  VAR PUSHF=FALSE
  IF MENU||DWN THEN
   IF MX>=BTNX&&MX<=BTNX+TASKW2&&MY>=BTNY&&MY<=BTNY+BTNH THEN
    IF DWN THEN
     PUSHF=TRUE
     SetWindowVar WND,TSKBAR_WV_BTNST,TC+1
     VOID SetCapture(WND)
    ELSEIF MENU THEN
     ShowSystemMenu TB_TASKLIST_TW[TC],CalcWindowX(TB_TASKLIST_TW[TC],WND)+MX,CalcWindowY(TB_TASKLIST_TW[TC],WND)+MY
     BREAK
    ENDIF
   ELSE
    CONTINUE
   ENDIF
  ELSE
   PUSHF=TB_TASKLIST_ACTV[TC]
  ENDIF
  IF UP THEN
   IF UP!=TC+1 THEN
    CONTINUE
   ENDIF
   
   CONTINUE
  ENDIF
  IF !DRAW&&!GB THEN
   VOID GBeginWindow(WND)
   DRAW=TRUE
  ENDIF
  
  DrawButton WND,BTNX,BTNY,TASKW2,BTNH,PUSHF
  GPRINTWindow WND,1,1,TB_TASKLIST$[TC],#BLACK
  SetWindowDrawPos WND,0,0
  GCLIPWindow WND,0,0,W,H
 NEXT
 IF DRAW&&!GB&&GEndWindow(WND)THEN RETURN
END
DEF TSKBAR_NIBTN WND,F
 VAR W=GetWindowWidth(WND)
 VAR TSX=24
 VAR CGB=CheckGBegin(WND)
 IF !CGB&&GBeginWindow(WND)THEN RETURN
 DrawButton WND,1,3,TSX-3,11,F
 GPRINTWindow WND,2,1,"",#BLACK
 ClearGCLIPWindow WND
 SetWindowDrawPos WND,0,0
 IF !CGB&&GEndWindow(WND)THEN RETURN
END
COMMON DEF TSKBARP WND,C,T,CW,_
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,GetBackColor()
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 GLINEWindow WND,0,0,W,0,RGB(0,0,0)
 GLINEWindow WND,0,1,W,1,RGB(255,255,255)
 TSKBAR_BTN WND,FALSE,FALSE,0,0,FALSE
 DrawButton WND,W-5,3,4,5, FALSE
 GPSETWindow WND,2-1,1,RGB(0,0,0)
 GLINEWindow WND,1-1,2,3-1,2,RGB(0,0,0)
 SetWindowDrawPos WND,0,0
 GCLIPWindow WND,0,0,W,H
 DrawButton WND,W-5,9,4,5, FALSE
 GPSETWindow WND,2-1,2,RGB(0,0,0)
 GLINEWindow WND,1-1,1,3-1,1,RGB(0,0,0)
 SetWindowDrawPos WND,0,0
 GCLIPWindow WND,0,0,W,H
 TSKBAR_NIBTN WND,GetWindowVar(WND,TSKBAR_WV_BTNST)==-3
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF TSKBARCTXMENU WND,C,T,X,Y
 TSKBAR_BTN WND,FALSE,FALSE,X,Y,TRUE
END
DEF TSKBAR_CONTRUCTMENU PRG$,ARY OUT MENU
 IF 0 THEN DIM DIR$[0]
 VAR ERR
 GetFiles PRG$ OUT DIR$,ERR
 IF ERR THEN MENU=0RETURN
 NewMenu OUT MENU,ERR
 IF ERR THEN RETURN
 VAR I
 VAR ITEMCOUNT
 FOR I=0TO LEN(DIR$)-1
  UpdateMouse
  IF DIR$[I]=="/.."THEN CONTINUE
  INC ITEMCOUNT
  VAR I$=MID$(DIR$[I],1,LEN(DIR$[I]))
  VAR PATH$=CombinePath$(PRG$,I$)
  IF DIR$[I][0]=="/"THEN
   VAR CMENU
   TSKBAR_CONTRUCTMENU PATH$,ARY OUT CMENU
   AddSubMenuItem MENU,I$,CMENU
  ELSE
   VAR EXT$=GetFileExtension$(I$)
   ToUpper EXT$
   IF EXT$=="LNK"THEN
    AddMenuItem MENU,GetFileNameWithoutExt$(I$),LEN(ARY)
    PUSH ARY,AllocString(PATH$)
   ELSE
    AddMenuItem MENU,I$,LEN(ARY)
    PUSH ARY,AllocString(PATH$)
   ENDIF
  ENDIF
 NEXT
 IF !ITEMCOUNT THEN
  AddMenuItem MENU,"<NONE>",-1
  DisableMenuItem MENU,-1
 ENDIF
END
COMMON DEF TskbarChildWinHandler WND,CTL,TYPE,A1,CWND
 VAR W1,W2,H1,H2,ERR
 IF A1==WindowMaximizeEvent()THEN
'  GetWindowFrameSize CWND OUT W1,H1,W2,H2,ERR
 ' VOID MoveResizeWindow(CWND,0,0,GetWindowWidth(GetParentWindow(CWND))-W1-W2,GetWindowHeight(GetParentWindow(CWND))-H2-H1-17)
  RETURN
 ELSEIF A1==WindowMinimizeEvent()THEN
  SetProp CWND,"TSKBAR_MINIMIZED",TRUE
  VOID HideWindow(CWND)
'  VOID MoveResizeWindow(CWND,0,GetWindowHeight(GetParentWindow(CWND))-16,32,16)
  RETURN
 ELSEIF A1==WindowRestoreEvent()THEN
  IF TskbarRestore(CWND)THEN
   RETURN
  ENDIF
 ENDIF
 VOID SendChildWindowEvent(GetParentWindow(WND),A1,CWND)
END
COMMON DEF I_TSKBAR
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!TSKBARCTL THEN
  NewControl "TSKBAR" OUT TSKBARCTL,E
  E=SetControlPainter(TSKBARCTL,"TSKBARP")
  E=SetControlLMouseDownHandler(TSKBARCTL,"TSKBARLMD")
  E=SetControlLMouseUpHandler(TSKBARCTL,"TSKBARLMU")
  E=SetControlNotificationHandler(TSKBARCTL,"TSKBARNotificationHandler")
  E=SetControlContextMenuHandler(TSKBARCTL,"TSKBARCTXMENU")
  TSKBAR_MENU_EXIT=&H1178
  TSKBAR_WV_MENU=1
  TSKBAR_WV_PRGITEMS=2
  TSKBAR_WV_BTNST=3
  TSKBAR_WV_PAGE=4
  TSKBAR_WV_COUNT=5
 ENDIF
 VAR SW=GetWindowWidth(GetRootWindow())
 VAR SH=GetWindowHeight(GetRootWindow())
 VAR WND
 VAR H=16,W=SW
 NewStyleWindow TSKBARCTL,"TSKBAR",0,SH-H,W,H,GetRootWindow(),WindowFrontFlag(),WindowTopMostStyle() OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 SetSysWindowProperty WND,"SHADOW",FALSE OUT E
 E=SetControlChildWindowHandler(GetControl(GetRootWindow()),"TskbarChildWinHandler")
 SetWorkArea GetRootWindow(),0,0,W,SH-H-1 OUT E
 SetProcessVar WND
 VAR TW
 VAR TSX=24
 VAR TSKW=(SW-9-TSX) DIV 8,TC,TCM=(SW-9-TSX) DIV TSKW
 TB_TASKLIST$=NewArray$(TCM)
 TB_TASKLIST_TW=NewArray(TCM)
 TB_TASKLIST_ACTV=NewArray(TCM)
 TSKBAR_ROWC=TCM
 SetWindowVar WND,0,TW
 VAR PRG$=CombinePath$(GetHomeDir$(),"programs")
 VAR MENU,PMENU
 NewMenu OUT MENU,E
 DIM ARY[0]
 TSKBAR_CONTRUCTMENU PRG$,ARY OUT PMENU
 AddMenuItem MENU,"",-1
 AddSubMenuItem MENU,"Program",PMENU
 AddMenuItemSeparator MENU
 AddMenuItem MENU,"Exit",TSKBAR_MENU_EXIT
 SetWindowVar WND,TSKBAR_WV_MENU,MENU
 VAR ARYI=AllocSBArray()
 SetSBArray ARYI,ARY
 SetWindowVar WND,TSKBAR_WV_PRGITEMS,ARYI
END
DEF UPDATE_TSKBAR TSKBAR_WND
 VAR RDW=FALSE
 VAR TSKW=84,TC,TSX=24,TCM=LEN(TB_TASKLIST_TW)
 VAR RW=GetRootWindow()
 VAR CW=GetChildWindow(RW)
 VAR UPDFLG
 VAR I
 VAR CTSKCOUNT
 VAR DECCOUNT
 VAR ACTV=GetActiveWindow()
 FOR I=0TO TCM-1
  VAR W=TB_TASKLIST_TW[I]
  IF!W THEN BREAK
  UPDFLG=1
  IF CheckWindow(W)THEN CONTINUE
  COPY TB_TASKLIST_TW,I,TB_TASKLIST_TW,I+1,LEN(TB_TASKLIST_TW)-I-1
  INC DECCOUNT
  RDW=TRUE
 NEXT
 CTSKCOUNT=I-DECCOUNT
 IF DECCOUNT THEN
  FOR I=CTSKCOUNT TO TCM-1
   TB_TASKLIST_TW[I]=0
  NEXT
 ENDIF
 
 WHILE GetNextWindow(CW)
  VAR N$=GetWindowName$(CW)
  IF!IsControlExtend(GetControl(CW),GetWindowControl())THEN
   CW=GetNextWindow(CW)
   CONTINUE
  ENDIF
  IF GetOwnerWindow(CW)!=RW THEN
   CW=GetNextWindow(CW)
   CONTINUE
  ENDIF
  FOR I=0TO TCM-1
   IF TB_TASKLIST_TW[I]==CW THEN @FOUND
  NEXT
  IF CTSKCOUNT<TCM THEN
   TB_TASKLIST_TW[CTSKCOUNT]=CW
   TB_TASKLIST$[CTSKCOUNT]=N$
   TB_TASKLIST_ACTV[CTSKCOUNT]=FALSE
   INC CTSKCOUNT
  ELSE
   PUSH TB_TASKLIST_TW,CW
   PUSH TB_TASKLIST$,N$
   PUSH TB_TASKLIST_ACTV,FALSE
   INC TCM
   INC CTSKCOUNT
  ENDIF
  RDW=TRUE
  CW=GetNextWindow(CW)
  CONTINUE
  @FOUND
  IF ACTV!=TSKBAR_WND THEN
   IF IsActiveWindow(CW)THEN
    IF!TB_TASKLIST_ACTV[I]THEN RDW=TRUE
    TB_TASKLIST_ACTV[I]=TRUE
   ELSE
    IF TB_TASKLIST_ACTV[I]THEN RDW=TRUE
    TB_TASKLIST_ACTV[I]=FALSE
   ENDIF
  ENDIF
  IF TB_TASKLIST$[I]!=N$THEN
   RDW=TRUE
   TB_TASKLIST$[I]=N$
  ENDIF
  CW=GetNextWindow(CW)
 WEND
 FOR I=0TO TCM-1
  W=TB_TASKLIST_TW[I]
  IF!W THEN BREAK
 NEXT
 SetWindowVar TSKBAR_WND,TSKBAR_WV_COUNT,CTSKCOUNT
 IF RDW THEN
  VOID RepaintWindow(TSKBAR_WND)
 ENDIF
END
VAR TSKBAR_TIMER
VAR TSKBAR_CWND
COMMON DEF L_TSKBAR
 IF 1||TSKBAR_TIMER!=MAINCNT DIV 10THEN
  UPDATE_TSKBAR GetProcessVar()
'  TSKBAR_CWND=OCW
  TSKBAR_TIMER=MAINCNT DIV 10
  IF 0THEN
  VAR Y,M,D,H,MI
  DTREAD OUT Y,M,D
  TMREAD OUT H,MI,
  IF M>9THEN
   VAR _$="/"
  ELSE
   _$="/0"
  ENDIF
  IF D>9THEN
   VAR __$="/"
  ELSE
   __$="/0"
  ENDIF
  IF H>9THEN
   VAR ___$=" "
  ELSE
   ___$=" 0"
  ENDIF
  IF MI>9THEN
   VAR ____$=":"
  ELSE
   ____$=":0"
  ENDIF
  SetMenuItem GetWindowVar(GetProcessVar(),TSKBAR_WV_MENU),STR$(Y)+_$+STR$(M)+__$+STR$(D)+___$+STR$(H)+____$+STR$(MI),-1
  ENDIF

 ENDIF
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END
VAR CLIPBRDCTL
VAR CLIPBRD_MENU_UPDATE
VAR CLIPBRD_MENU_ABOUT
COMMON DEF CLIPBRDNOTIF WND,CTL,TYP,A1,A2
 IF A2==CLIPBRD_MENU_UPDATE THEN
  VOID RepaintWindow(WND)
 ENDIF
END
DEF SUGOIGPRINTWindow WND,X,Y,W,H,TXT$,COL OUT OX,OY
 W=W DIV 8
 H=H DIV 8
 VAR I,J
 VAR LF$=LF$()
 WHILE 1
  VAR T$=MID$(TXT$,I,W)
  IF!LEN(T$)THEN BREAK
  VAR LFPOS=INSTR(T$,LF$)
  IF LFPOS!=-1THEN
   T$=MID$(T$,0,LFPOS)
   I=I+LFPOS+1
  ELSE
   I=I+W
  ENDIF
  GPRINTWindow WND,X,Y,T$,COL
  J=J+1
  IF H<J THEN BREAK
  Y=Y+8
 WEND
 OX=X
 OY=Y
END
COMMON DEF CLIPBRDPAINTER WND,CTL,TYP,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 
 IF GBeginWindow(WND)THEN RETURN
 IF ClipboardContainsText()THEN
  GCLSWindow WND,-1
 ELSE
  GCLSWindow WND,GetBackColor()
 ENDIF
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 VAR X,Y
 IF ClipboardContainsText()THEN
  VAR TXT$=ClipboardGetText$()
  
  SUGOIGPRINTWindow WND,0,Y,W,H-Y,"Text:",RGB(0,0,0) OUT X,Y
  SUGOIGPRINTWindow WND,0,Y,W,H-Y,TXT$,RGB(0,0,0) OUT X,Y
 ELSE
 ENDIF
 IF ClipboardContainsFile()THEN
  VAR CUT,FILE$
  ClipboardGetFile OUT CUT,FILE$
  IF!CUT THEN
   SUGOIGPRINTWindow WND,0,Y,W,H-Y,"File:",RGB(0,0,0) OUT X,Y
  ELSE
   SUGOIGPRINTWindow WND,0,Y,W,H-Y,"File(cut):",RGB(0,0,0) OUT X,Y
  ENDIF
  SUGOIGPRINTWindow WND,0,Y,W,H-Y,FILE$,RGB(0,0,0) OUT X,Y
 ENDIF
 E=GEndWindow(WND)
END
COMMON DEF I_CLIPBRD
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!CLIPBRDCTL THEN
  ExtendControl "ClipBook Viewer",GetWindowControl() OUT CLIPBRDCTL,E
  E=SetControlPainter(CLIPBRDCTL,"CLIPBRDPAINTER")
  E=SetControlNotifHandler(CLIPBRDCTL,"CLIPBRDNOTIF")
 ENDIF
 VAR MENU
 NewTopLevelStyleWindow CLIPBRDCTL,"ClipBook Viewer",128,64,WINDOWRESIZABLESTYLE()OR WINDOWMENUSTYLE()OR WindowMinMaxStyle() OUT WND,E
 NewMenu OUT MENU,E
 CLIPBRD_MENU_UPDATE=1
 AddMenuItem MENU,"Update",CLIPBRD_MENU_UPDATE
 AddSubMenuItem GetWindowMenu(WND),"View",MENU
 NewMenu OUT MENU,E
 CLIPBRD_MENU_ABOUT=2
 AddMenuItem MENU,"About",CLIPBRD_MENU_ABOUT
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 SetProcessVar WND
END
COMMON DEF L_CLIPBRD
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR EDITORSELCTL
COMMON DEF EDITORSELNOTIF A,B,C,D,E
 IF E==0THEN
  VAR CMD$
   GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

  VAR PRC
  NewProcess GetListBoxSelectedText$(D),CMD$ OUT PRC,E
  VOID DeleteWindow(A)
 ENDIF
END
COMMON DEF I_EDITORSEL
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!EDITORSELCTL THEN
  ExtendControl "EditorSelector",GetWindowControl() OUT EDITORSELCTL,E
  E=SetControlNotifHandler(EDITORSELCTL,"EDITORSELNOTIF")
 ENDIF
 NewTopLevelWindow EDITORSELCTL,"EditorSelector",128,40 OUT WND,E
 SetProcessVar WND
 VAR CMD$
 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

 NewWindow GetLabelControl(),"Open "+CMD$,1,1,128,7,WND,0 OUT E,E
 NewWindow GetListBoxControl(),"",0,9,127,31,WND,0 OUT WND,E
 AddListBoxItem WND,"TXTED"
 AddListBoxItem WND,"PRGED"
END
COMMON DEF L_EDITORSEL
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR IMGVIEWCTL
VAR IMGOPTCTL
COMMON DEF IMGVIEWNOTIF WND,CTL,TYP,A1,A2
 VAR B$=GetWindowName$(A1)
 IF B$=="Open"THEN
  VAR E=NewModalDialogBox(IMGOPTCTL,"Option",128,40,WND)
 ENDIF
END
COMMON DEF IMGVIEWOPTCREATE WND,CTL,TYP,A1,A2
END
COMMON DEF I_IMGVIEW
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!IMGVIEWCTL THEN
  ExtendControl "Image Viewer",GetWindowControl() OUT IMGVIEWCTL,E
  E=SetControlNotifHandler(IMGVIEWCTL,"IMGVIEWNOTIF")
  ExtendControl "Option",GetWindowControl() OUT IMGOPTCTL,E
  E=SetControlCreateHandler(IMGOPTCTL,"IMGVIEWOPTCREATE")

 ENDIF
 VAR W1=128+32
 VAR W=128+32+52
 NewTopLevelWindow IMGVIEWCTL,"Image Viewer",W,32 OUT WND,E
 VAR CMD$
 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

 NewWindow GetLabelControl(),"File:",1,2,39,7,WND,0 OUT E,E
 NewWindow GetTextBoxControl(),"File:",41,1,W1-41,8,WND,0 OUT E,E
 NewWindow GetButtonControl(),"Browse",W1+1,0,51,10,WND,0 OUT E,E
 NewWindow GetButtonControl(),"Open",1,12,51,10,WND,0 OUT E,E
' NewWindow GetButtonControl(),"Option",54,12,51,10,WND,0 OUT E,E
 
 SetProcessVar WND
END
COMMON DEF L_IMGVIEW
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
DIM CMATRIX[4,4]
DEF CONVDITHERCOLOR X,Y,R,G,B OUT RGB
 VAR PX=X MOD 4
 VAR PY=Y MOD 4
 IF CMATRIX[PX,PY]>=R THEN R=0 ELSE R=255
 IF CMATRIX[PX,PY]>=G THEN G=0 ELSE G=255
 IF CMATRIX[PX,PY]>=B THEN B=0 ELSE B=255
 RGB=RGB(R,G,B)
END
COMMON DEF COLORPAINT WND,CTL,TYP,XY,WH
 VAR E=CallBaseControlHandler(WND,CTL,TYP,XY,WH)
 VAR X=XY AND 65535,Y=XY>>16
 VAR W1=GetWindowWidth(WND)
 VAR H1=GetWindowHeight(WND)
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 IF WH THEN
  W=X+(WH AND 65535)'GetWindowWidth(WND)
  H=Y+(WH>>16)'GetWindowHeight(WND)
  
 ENDIF
 IF!W||!H THEN RETURN
' GBOXWindow WND,X,Y,X+W,Y+H,-1
 E=GEndWindow(WND)
 VAR X1,Y1
 ?"AAAAA",X,Y,W,H
 FOR Y1=Y TO H
  FOR X1=X TO W
   VAR XC=X1*(255/W1)
   VAR YC=Y1*(255/H1)
   VAR C=CONVDITHERCOLOR(X1,Y1,255-YC,XC,YC-XC)'RGB(255,X1*(255/W1),Y1*(255/H1),255)
   IF X1==X THEN C=-1
   IF Y1==Y THEN C=-1
   IF X1==H THEN C=-1
   IF Y1==W THEN C=-1
   __GPSETWindow__ WND,X1,Y1,C
  NEXT
  UpdateMouse
 NEXT
END
VAR COLORCTL
COMMON DEF I_COLOR
IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!COLORCTL THEN
  CMATRIX=NewArray2(4,4)
  COPY CMATRIX,"@CMATRIX"
  VAR I
  FOR I=0TO 15
  CMATRIX[I DIV 4,I MOD 4]=CMATRIX[I DIV 4,I MOD 4]*16'DIV 2' 2'8
  NEXT
  ExtendControl "COLOR-DITHER",GetWindowControl() OUT COLORCTL,E
  E=SetControlPainter(COLORCTL,"COLORPAINT")
@CMATRIX
DATA 00,08,02,10
DATA 12,04,14,06
DATA 03,11,01,09
DATA 15,07,13,05
 ENDIF
 NewTopLevelStyleWindow COLORCTL,"COLOR",64,64,WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle() OUT WND,E
 SetWindowBackColor WND,0
 SetProcessVar WND
END
COMMON DEF L_COLOR
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR OTYMINE_MINE
VAR OTYMINE_FLAG
VAR OTYMINE_UNK
VAR OTYMINE_OPENED
VAR OTYMINE_MISS
VAR OTYMINE_1

VAR OTYMINE_MENU_START=1
VAR OTYMINE_MENU_EASY=2
VAR OTYMINE_MENU_NORMAL=3
VAR OTYMINE_MENU_HARD=4
VAR OTYMINE_MENU_EXIT=5
VAR OTYMINE_MENU_ABOUT=101

VAR OTYMINE_WV_CX
VAR OTYMINE_WV_CY
VAR OTYMINE_WV_CNT
VAR OTYMINE_WV_ARY
VAR OTYMINE_WV_END
VAR OTYMINE_WV_GEN

DEF OTYMINE_INC F,X,Y,CX,CY
 IF X<0||Y<0||X>=CX||Y>=CY THEN RETURN
 IF F[X,Y]==OTYMINE_MINE THEN RETURN
 IF!F[X,Y]THEN F[X,Y]=OTYMINE_1:RETURN
 IF F[X,Y]>=OTYMINE_1 THEN
  INC F[X,Y]
 ENDIF
END
DEF OTYMINE_GENEMPTYFIELD(CX,CY,CNT)
 DIM F[CX,CY]
 RETURN F
END
DEF OTYMINE_GENFIELD F,CX,CY,CNT,MX,MY
 FILL F,0
 VAR X,Y,I
 VAR SIZE=1
 CNT=MIN(CX*CY-(SIZE*2+1)*(SIZE*2+1),CNT)
 VAR MX1=MX-SIZE
 VAR MX2=MX+SIZE
 VAR MY1=MY-SIZE
 VAR MY2=MY+SIZE
 FOR I=0TO CNT-1
  X=RND(CX)
  Y=RND(CY)
  IF X>=MX1&&X<=MX2&&Y>=MY1&&Y<=MY2 THEN
   DEC I
   CONTINUE
  ENDIF
  IF F[X,Y]THEN
   DEC I
   CONTINUE
  ENDIF
  F[X,Y]=OTYMINE_MINE
 NEXT
 FOR Y=0TO CY-1
  FOR X=0TO CX-1
   IF F[X,Y]==OTYMINE_MINE THEN
    OTYMINE_INC F,X-1,Y,CX,CY
    OTYMINE_INC F,X-1,Y+1,CX,CY
    OTYMINE_INC F,X,Y-1,CX,CY
    OTYMINE_INC F,X+1,Y-1,CX,CY
    OTYMINE_INC F,X+1,Y+1,CX,CY
    OTYMINE_INC F,X+1,Y,CX,CY
    OTYMINE_INC F,X,Y+1,CX,CY
    OTYMINE_INC F,X-1,Y-1,CX,CY
   ENDIF
  NEXT
 NEXT
END
DEF OTYMINE_INIT WND
 VAR CX=8'DEFAULT
 VAR CY=8'DEFAULT
 VAR CNT=10'DEFAULT
 
 VAR ARY=AllocSBArray()
 IF !ARY THEN RETURN
 SetSBArray ARY,OTYMINE_GENEMPTYFIELD(CX,CY,CNT)
 OTYMINE_WV_ARY=0
 OTYMINE_WV_CX=1
 OTYMINE_WV_CY=2
 OTYMINE_WV_CNT=3
 OTYMINE_WV_END=4
 OTYMINE_WV_GEN=5
 SetWindowVar WND,OTYMINE_WV_ARY,ARY
 SetWindowVar WND,OTYMINE_WV_CX,CX
 SetWindowVar WND,OTYMINE_WV_CY,CY
 SetWindowVar WND,OTYMINE_WV_CNT,CNT
 SetWindowVar WND,OTYMINE_WV_END,FALSE
 SetWindowVar WND,OTYMINE_WV_GEN,FALSE
END
DEF OTYMINE_RESTART WND
 VAR CX,CY,CNT,ARY
 GetWindowVar WND,OTYMINE_WV_CX OUT CX
 GetWindowVar WND,OTYMINE_WV_CY OUT CY
 GetWindowVar WND,OTYMINE_WV_CNT OUT CNT
 GetWindowVar WND,OTYMINE_WV_ARY OUT ARY
 SetSBArray ARY,OTYMINE_GENEMPTYFIELD(CX,CY,CNT)
 SetWindowVar WND,OTYMINE_WV_END,FALSE
 SetWindowVar WND,OTYMINE_WV_GEN,FALSE
 VOID RepaintWindow(WND)
END
DEF OTYMINE_CHBOARD WND,CX,CY,CNT
 SetWindowVar WND,OTYMINE_WV_CX,CX
 SetWindowVar WND,OTYMINE_WV_CY,CY
 SetWindowVar WND,OTYMINE_WV_CNT,CNT
 OTYMINE_RESTART WND
END
DEF OTYMINE_ADJUST WND
 VAR W2=GetwindowVar(WND,0)
 VAR CX,CY
 GetWindowVar W2,OTYMINE_WV_CX OUT CX
 GetWindowVar W2,OTYMINE_WV_CY OUT CY
 VOID ResizeWindow(WND,CX*12-1,CY*12-1)
 VOID ResizeWindow(W2,CX*12-1,CY*12-1)
END
VAR OTYMINE_CTBL[0]
DEF ONOTYMINELMD WND,CTL,TYP,A1,A2
END
DEF OTYMINE_TOGGLEFLG FIELD,X,Y,CX,CY
 IF X<0||Y<0||X>=CX||Y>=CY THEN RETURN
 IF FIELD[X,Y]AND OTYMINE_OPENED THEN RETURN
 IF FIELD[X,Y]AND OTYMINE_FLAG THEN
  FIELD[X,Y]=FIELD[X,Y] AND NOT OTYMINE_FLAG OR OTYMINE_UNK
  RETURN
 ENDIF
 IF FIELD[X,Y]AND OTYMINE_UNK THEN
  FIELD[X,Y]=FIELD[X,Y] AND NOT OTYMINE_UNK
  RETURN
 ENDIF
 FIELD[X,Y]=FIELD[X,Y] OR OTYMINE_FLAG
END
DEF OTYMINE_OPENALL FIELD,CX,CY
 VAR X,Y
 FOR X=0TO CX-1
  FOR Y=0TO CY-1
   IF (FIELD[X,Y] AND &B1111)==OTYMINE_MINE THEN
    FIELD[X,Y]=FIELD[X,Y] OR OTYMINE_OPENED
   ENDIF
  NEXT
 NEXT
END
DEF OTYMINE_CHECKCLEAR(FIELD,CX,CY,CNT)
 VAR X,Y
 VAR B=CX*CY
 FOR X=0TO CX-1
  FOR Y=0TO CY-1
   IF FIELD[X,Y] AND OTYMINE_OPENED THEN
    DEC B
   ENDIF
  NEXT
 NEXT
 RETURN B<=CNT
END
DEF OTYMINE_OPEN FIELD,X,Y,CX,CY
 IF X<0||Y<0||X>=CX||Y>=CY THEN RETURN
 IF FIELD[X,Y]AND OTYMINE_OPENED THEN RETURN
 IF FIELD[X,Y]AND OTYMINE_FLAG THEN RETURN
 IF (FIELD[X,Y]AND &B1111)==OTYMINE_MINE THEN RETURN
 FIELD[X,Y]=FIELD[X,Y] OR OTYMINE_OPENED
 IF (FIELD[X,Y] AND &B1111)>=OTYMINE_1 THEN RETURN
 OTYMINE_OPEN FIELD,X,Y-1,CX,CY
 OTYMINE_OPEN FIELD,X-1,Y,CX,CY
 OTYMINE_OPEN FIELD,X-1,Y-1,CX,CY
 OTYMINE_OPEN FIELD,X,Y+1,CX,CY
 OTYMINE_OPEN FIELD,X+1,Y,CX,CY
 OTYMINE_OPEN FIELD,X+1,Y+1,CX,CY
 OTYMINE_OPEN FIELD,X+1,Y-1,CX,CY
 OTYMINE_OPEN FIELD,X-1,Y+1,CX,CY
END
VAR OTYMINE_FIELDIMG[0]
DEF ONOTYMINELMU WND,CTL,TYP,X,Y
 IF GetWindowVar(WND,OTYMINE_WV_END)THEN RETURN
 X=X DIV 12
 Y=Y DIV 12
 IF 0THEN DIM FIELD[0]
 FIELD=GetSBArray(GetWindowVar(WND,OTYMINE_WV_ARY))
 VAR CX=GetWindowVar(WND,OTYMINE_WV_CX)
 VAR CY=GetWindowVar(WND,OTYMINE_WV_CY)
 VAR CNT=GetWindowVar(WND,OTYMINE_WV_CNT)
 IF CX<=X||CY<=Y THEN RETURN
 IF FIELD[X,Y]AND OTYMINE_FLAG THEN RETURN
 IF (FIELD[X,Y]AND&B1111)==OTYMINE_MINE THEN
  SetWindowVar WND,4,TRUE'GAMEOVER
  FIELD[X,Y]=FIELD[X,Y] OR OTYMINE_MISS
  OTYMINE_OPENALL FIELD,CX,CY
 ENDIF
 VAR GEN=GetWindowVar(WND,OTYMINE_WV_GEN)
 IF!GEN THEN
  OTYMINE_GENFIELD FIELD,CX,CY,CNT,X,Y
  SetWindowVar WND,OTYMINE_WV_GEN,TRUE
 ENDIF
 OTYMINE_OPEN FIELD,X,Y,CX,CY
 IF (FIELD[X,Y]AND &B1111)>=OTYMINE_1 THEN
  VOID RepaintWindowWithARect(WND,X*12,Y*12,X*12+11,Y*12+11)
 ELSE
  VOID RepaintWindow(WND)
 ENDIF
 IF!GetWindowVar(WND,OTYMINE_WV_END)&&OTYMINE_CHECKCLEAR(FIELD,CX,CY,CNT)THEN
  VOID MessageBox(WND,"Minesweeper","Congratulations!",MessageBoxOK())
  SetWindowVar WND,OTYMINE_WV_END,TRUE'GAMEOVER
 ENDIF
END
DEF ONOTYMINERMD WND,CTL,TYP,X,Y
 IF GetWindowVar(WND,OTYMINE_WV_END)THEN RETURN
 X=X DIV 12
 Y=Y DIV 12
 IF 0THEN DIM FIELD[0]
 FIELD=GetSBArray(GetWindowVar(WND,OTYMINE_WV_ARY))
 VAR CX=GetWindowVar(WND,OTYMINE_WV_CX)
 VAR CY=GetWindowVar(WND,OTYMINE_WV_CY)
 IF CX<=X||CY<=Y THEN RETURN
 OTYMINE_TOGGLEFLG FIELD,X,Y,CX,CY
 VOID RepaintWindow(WND)
END
DEF ONOTYMINEDEL WND,CTL,TYP,A1,A2
 VAR ARY=GetWindowVar(WND,OTYMINE_WV_ARY)
 FreeSBArray ARY
END
DEF ONOTYMINEPAINT WND,CTL,TYP,XY,WH
 IF GBeginWindow(WND)THEN RETURN
  VAR CX=GetWindowVar(WND,OTYMINE_WV_CX)
  VAR CY=GetWindowVar(WND,OTYMINE_WV_CY)
  IF XY&&WH THEN
   VAR RX=XY AND 65535,RY=XY>>16
   VAR RW=WH AND 65535,RH=WH>>16
   GFILLWindow WND,RX,RY,RX+RW,RY+RH,RGB(192,192,192)
   RW=CEIL((RW+RX)/12)
   RH=CEIL((RH+RY)/12)
   RX=RX DIV 12
   RY=RY DIV 12
   CX=MIN(CX,RW)
   CY=MIN(CY,RH)
  ELSE
   GCLSWindow WND,RGB(192,192,192)
  ENDIF
  IF 0THEN DIM FIELD[0]
  FIELD=GetSBArray(GetWindowVar(WND,OTYMINE_WV_ARY))
  VAR X,Y
  FOR Y=RY TO CY-1
   FOR X=RX TO CX-1
    VAR X12=X*12
    VAR Y12=Y*12
    VAR F=FIELD[X,Y]
    IF F AND OTYMINE_OPENED THEN
     VAR F2=F
     F=F AND &B1111
     GLINEWindow WND,X12,Y12,X12+11,Y12,RGB(128,128,128)
     GLINEWindow WND,X12,Y12,X12,Y12+11,RGB(128,128,128)
     IF F>=OTYMINE_1 THEN
      VAR C=F-OTYMINE_1+1
      GPRINTWindow WND,X12+2,Y12+2,CHR$(C+48),OTYMINE_CTBL[C]
      GPRINTWindow WND,X12+3,Y12+2,CHR$(C+48),OTYMINE_CTBL[C]
      GPRINTWindow WND,X12+4,Y12+2,CHR$(C+48),OTYMINE_CTBL[C]
     ENDIF
     IF F==OTYMINE_MINE THEN
      IF F2 AND OTYMINE_MISS THEN
       GFILLWindow WND,X12+1,Y12+1,X12+11,Y12+11,#RED
      ENDIF
      GLINEWindow WND,X12+3,Y12+3,X12+9,Y12+9,#BLACK
      GLINEWindow WND,X12+3,Y12+9,X12+9,Y12+3,#BLACK
      GLINEWindow WND,X12+6,Y12+2,X12+6,Y12+10,#BLACK
      GLINEWindow WND,X12+2,Y12+6,X12+10,Y12+6,#BLACK
      GFILLWindow WND,X12+4,Y12+4,X12+8,Y12+8,#BLACK
      GPSETWindow WND,X12+5,Y12+5,#WHITE
      IF F2 AND OTYMINE_FLAG THEN
       GLINEWindow WND,X12+2,Y12+2,X12+10,Y12+10,#RED
       GLINEWindow WND,X12+3,Y12+2,X12+11,Y12+10,#RED
       GLINEWindow WND,X12+10,Y12+2,X12+2,Y12+10,#RED
       GLINEWindow WND,X12+11,Y12+2,X12+3,Y12+10,#RED
      ENDIF
     ENDIF
    ELSE
     GLOADWindow WND,X12,Y12,12,12,OTYMINE_FIELDIMG,1,1
     IF F AND OTYMINE_FLAG THEN
      GLINEWindow WND,X12+5,Y12+5,X12+5,Y12+6,RGB(0,0,0)
      GTRIWindow WND,X12+5,Y12+7,X12+3,Y12+9,X12+7,Y12+9,RGB(0,0,0)
      GTRIWindow WND,X12+5,Y12+3,X12+8-6,Y12+4,X12+5,Y12+5,RGB(255,0,0)
     ENDIF
     IF F AND OTYMINE_UNK THEN
      GPRINTWindow WND,X12+2,Y12+2,"?",RGB(0,0,0)
      GPRINTWindow WND,X12+3,Y12+2,"?",RGB(0,0,0)
      GPRINTWindow WND,X12+4,Y12+2,"?",RGB(0,0,0)
     ENDIF
    ENDIF
   NEXT
  NEXT
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF ONOTYMINEBUTTON WND,CTL,TYP,A1,A2
 VAR Z=12
 IF A1 AND #LEFT THEN
  MoveMouse GetMouseX()-Z,GetMouseY()
 ENDIF
 IF A1 AND #RIGHT THEN
  MoveMouse GetMouseX()+Z,GetMouseY()
 ENDIF
 IF A1 AND #UP THEN
  MoveMouse GetMouseX(),GetMouseY()-Z
 ENDIF
 IF A1 AND #DOWN THEN
  MoveMouse GetMouseX(),GetMouseY()+Z
 ENDIF
END
VAR OTYMINEWNDCTL
VAR OTYMINECTL
VAR OTYMINEABOUTCTL
DEF ONOTYMINENOTIF WND,CTL,TYP,A1,A2
 IF A2==OTYMINE_MENU_START THEN 
  OTYMINE_RESTART GetWindowVar(WND,0)
  RETURN
 ENDIF
 IF A2==OTYMINE_MENU_EASY THEN 
  OTYMINE_CHBOARD GetWindowVar(WND,0),8,8,10
  OTYMINE_ADJUST WND
  RETURN
 ENDIF
 IF A2==OTYMINE_MENU_NORMAL THEN 
  OTYMINE_CHBOARD GetWindowVar(WND,0),16,16,40
  OTYMINE_ADJUST WND
  RETURN
 ENDIF
 IF A2==OTYMINE_MENU_HARD THEN 
  OTYMINE_CHBOARD GetWindowVar(WND,0),30,16,99
  OTYMINE_ADJUST WND
  RETURN
 ENDIF
 IF A2==OTYMINE_MENU_EXIT THEN
  VOID DeleteWindow(WND)
 ENDIF
 IF A2==OTYMINE_MENU_ABOUT THEN
  VOID NewModalDialogBox(OTYMINEABOUTCTL,"About",128,40,WND)
  RETURN
 ENDIF
END
DEF OTYMINEABOUTONONCREATE WND,CTL,TYP,A1,A2
 VAR LWND,E
 NewWindow GetLabelControl(),"OTW Minesweeper",0,0,15*8,8,WND,0 OUT LWND,E
 NewWindow GetButtonControl(),"OK",(128-24)/2,14,24,12,WND,0 OUT LWND,E
END
DEF OTYMINEABOUTONONNOTIF WND,CTL,TYP,A1,A2
 VOID DeleteWindow(WND)
END
COMMON DEF I_OTYMINE
 OTYMINE_MINE=1
 OTYMINE_FLAG=32
 OTYMINE_UNK=64
 OTYMINE_MISS=128
 OTYMINE_OPENED=16
 OTYMINE_1=4
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTYMINECTL THEN
  OTYMINE_CTBL=NewArray(9)
  OTYMINE_CTBL[1]=RGB(&H00,&H00,&HFF)
  OTYMINE_CTBL[2]=RGB(&H00,&H80,&H00)
  OTYMINE_CTBL[3]=RGB(&HFF,&H00,&H00)
  OTYMINE_CTBL[4]=RGB(&H00,&H00,&H80)
  OTYMINE_CTBL[5]=RGB(&H80,&H00,&H00)
  OTYMINE_CTBL[6]=RGB(&H00,&H80,&H80)
  OTYMINE_CTBL[7]=RGB(&H00,&H00,&H00)
  OTYMINE_CTBL[8]=RGB(&H80,&H80,&H80)
  @OTYMINE
  DATA "F",&HFFFFFFFF
  DATA "G",&HFF808080
  DATA " ",&HFFC0C0C0
  DATA ""
  DATA 12,12
  DATA "FFFFFFFFFFFG"
  DATA "FFFFFFFFFFGG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FF        GG"
  DATA "FGGGGGGGGGGG"
  DATA "GGGGGGGGGGGG"
  RESTORE @OTYMINE
  NewImageArrayFromDATA 1,TRUE OUT OTYMINE_FIELDIMG,,
  OTYMINE_MENU_START=1
  OTYMINE_MENU_EASY=2
  OTYMINE_MENU_NORMAL=3
  OTYMINE_MENU_HARD=4
  OTYMINE_MENU_EXIT=5
  OTYMINE_MENU_ABOUT=101
  ExtendControl "OTYMINEWND",GetWindowControl() OUT OTYMINEWNDCTL,E
  ExtendControl "OTYMINEABOUT",GetWindowControl() OUT OTYMINEABOUTCTL,E
  NewControl "OTYMINE" OUT OTYMINECTL,E
  IF SetControlNotifHandler(OTYMINEWNDCTL,"ONOTYMINENOTIF")THEN @ERR
  IF SetControlPainter(OTYMINECTL,"ONOTYMINEPAINT")THEN @ERR
  IF SetControlButtonHandler(OTYMINECTL,"ONOTYMINEBUTTON")THEN @ERR
  IF SetControlLMouseDownHandler(OTYMINECTL,"ONOTYMINELMD")THEN @ERR
  IF SetControlLMouseUpHandler(OTYMINECTL,"ONOTYMINELMU")THEN @ERR
  IF SetControlRMouseDownHandler(OTYMINECTL,"ONOTYMINERMD")THEN @ERR
  IF SetControlDeleteHandler(OTYMINECTL,"ONOTYMINEDEL")THEN @ERR
  IF SetControlCreateHandler(OTYMINEABOUTCTL,"OTYMINEABOUTONONCREATE")THEN @ERR
  IF SetControlNotifHandler(OTYMINEABOUTCTL,"OTYMINEABOUTONONNOTIF")THEN @ERR
 ENDIF
 NewTopLevelStyleWindow OTYMINEWNDCTL,"Minesweeper",95,95,WindowMinMaxStyle()OR WindowDisableMaxStyle()OR WindowMenuStyle() OUT WND,E
 IF E THEN
  E=DeleteWindow(WND)
  GOTO @ERR
 ENDIF
 SetProcessVar WND
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"Start",OTYMINE_MENU_START
 AddMenuItemSeparator MENU
 AddMenuItem MENU,"Easy",OTYMINE_MENU_EASY
 AddMenuItem MENU,"Normal",OTYMINE_MENU_NORMAL
 AddMenuItem MENU,"Hard",OTYMINE_MENU_HARD
 AddMenuItemSeparator MENU
 AddMenuItem MENU,"Exit",OTYMINE_MENU_EXIT
 AddSubMenuItem GetWindowMenu(WND),"Game",MENU NewMenu OUT MENU,E
 AddMenuItem MENU,"About",OTYMINE_MENU_ABOUT
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 VAR MWND
 NewWindow OTYMINECTL,"",0,0,95,95,WND,0 OUT MWND,E
 IF E THEN
  E=DeleteWindow(GetProcessVar())
  E=DeleteWindow(WND)
  GOTO @ERR
 ENDIF
 SetwindowVar WND,0,MWND
 OTYMINE_INIT MWND
 RETURN
 @ERR
 ExitProcess 1
END
COMMON DEF L_OTYMINE
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END

DEF DEFIM_KEY IM,KEY
 IF!OTW_ENABLEKEY THEN RETURN
 VOID SendIMText(IM,CHR$(KEY))
END
COMMON DEF I_DEFIM
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR IM,ERR
 NewIM OUT IM,ERR
 IF ERR THEN
  ExitProcess ERR
  RETURN
 ENDIF
 ERR=SetIMKeyHandler(IM,"DEFIM_KEY")
 SetProcessVar IM
 KEY 1,"KEY OFF"
END
COMMON DEF L_DEFIM
 VAR X,Y,MMM
 TOUCH OUT MMM,X,Y
 IF MMM&&!OTW_ENKEY_STATE&&X>=5&&X<=63&&Y>=5&&Y<=16THEN
  OTW_ENKEY_STATE=1
  OTW_ENABLEKEY=!OTW_ENABLEKEY
  IF OTW_ENABLEKEY THEN
   KEY 1,"KEY ON"
  ELSE
   KEY 1,"KEY OFF"
  ENDIF
  BEEP 9
 ENDIF
 IF!MMM THEN OTW_ENKEY_STATE=0
 IF ProcessIM(GetProcessVar())THEN
  VOID DeleteIM(GetProcessVar())
  ExitProcess 0
 ENDIF
END
VAR RIM_MODE,RIM_KEYBUF$
VAR RIM_CTL
DEF RIM_ISROMA(C)
 RETURN (C>=65&&C<=65+26)||(C>=97&&C<=97+26)
END
'aeiuo
DEF RIM_ISVOWEL(C)
 IF C>=97&&C<=97+26THEN C=C-32
 RETURN C==65||C==69||C==73||C==79||C==85
END
DEF RIM_VOWEL$(C)
 IF C>=97&&C<=97+26THEN C=C-32
 IF C==65THEN RETURN"あ"
 IF C==69THEN RETURN"え"
 IF C==73THEN RETURN"い"
 IF C==79THEN RETURN"お"
 IF C==85THEN RETURN"う"
 RETURN""
END
DEF RIM_ADD_DAKUTEN$(K$)
 RETURN CHR$(ASC(K$)+1)
END
DEF RIM_ADD_HDAKUTEN$(K$)
 RETURN CHR$(ASC(K$)+2)
END
DEF RIM_SMALL$(K$)
 RETURN CHR$(ASC(K$)-1)
END
DEF RIM_HIRA$(C$,V$)
 IF C$==""THEN@A
 IF C$=="K"THEN@KA
 IF C$=="Q"THEN@QA
 IF C$=="C"THEN@CA
 IF C$=="G"THEN RETURN RIM_ADD_DAKUTEN$(RIM_HIRA$("K",V$))
 IF C$=="S"THEN@SA
 IF C$=="Z"THEN RETURN RIM_ADD_DAKUTEN$(RIM_HIRA$("S",V$))
 IF C$=="SH"THEN@SHA
 IF C$=="T"THEN@TA
 IF C$=="D"THEN RETURN RIM_ADD_DAKUTEN$(RIM_HIRA$("T",V$))
 IF C$=="TH"THEN@THU
 IF C$=="TS"THEN@TSA
 IF C$=="CH"THEN@CHA
 IF C$=="N"THEN@NA
 IF C$=="H"THEN@HA
 IF C$=="F"THEN@FA
 IF C$=="B"THEN RETURN RIM_ADD_DAKUTEN$(RIM_HIRA$("H",V$))
 IF C$=="P"THEN RETURN RIM_ADD_HDAKUTEN$(RIM_HIRA$("H",V$))
 IF C$=="M"THEN@MA
 IF C$=="Y"THEN@YA
 IF C$=="R"THEN@RA
 IF C$=="W"THEN@WA
 IF C$=="J"THEN@JA
 IF C$=="V"THEN@VA
 RETURN C$+V$
 @A
 IF V$=="A"THEN RETURN"あ"
 IF V$=="I"THEN RETURN"い"
 IF V$=="U"THEN RETURN"う"
 IF V$=="E"THEN RETURN"え"
 IF V$=="O"THEN RETURN"お"
 RETURN C$+V$
 @KA
 IF V$=="A"THEN RETURN"か"
 IF V$=="I"THEN RETURN"き"
 IF V$=="U"THEN RETURN"く"
 IF V$=="E"THEN RETURN"け"
 IF V$=="O"THEN RETURN"こ"
 RETURN C$+V$
 @QA
 IF V$=="A"THEN RETURN"くぁ"
 IF V$=="I"THEN RETURN"くぃ"
 IF V$=="U"THEN RETURN"く"
 IF V$=="E"THEN RETURN"くぇ"
 IF V$=="O"THEN RETURN"くぉ"
 RETURN C$+V$
 @CA
 IF V$=="I"THEN RETURN"し"
 IF V$=="E"THEN RETURN"せ"
 GOTO @KA
 @SA
 IF V$=="A"THEN RETURN"さ"
 IF V$=="I"THEN RETURN"し"
 IF V$=="U"THEN RETURN"す"
 IF V$=="E"THEN RETURN"せ"
 IF V$=="O"THEN RETURN"そ"
 RETURN C$+V$
 @SHA
 IF V$=="A"THEN RETURN"しゃ"
 IF V$=="I"THEN RETURN"し"
 IF V$=="U"THEN RETURN"しゅ"
 IF V$=="E"THEN RETURN"しぇ"
 IF V$=="O"THEN RETURN"しょ"
 RETURN C$+V$
 @TA
 IF V$=="A"THEN RETURN"た"
 IF V$=="I"THEN RETURN"ち"
 IF V$=="U"THEN RETURN"つ"
 IF V$=="E"THEN RETURN"て"
 IF V$=="O"THEN RETURN"と"
 RETURN C$+V$
 @THU
 IF V$=="A"THEN RETURN"てゃ"
 IF V$=="I"THEN RETURN"てぃ"
 IF V$=="U"THEN RETURN"てゅ"
 IF V$=="E"THEN RETURN"てぇ"
 IF V$=="O"THEN RETURN"てょ"
 RETURN C$+V$
 @TSA
 IF V$=="A"THEN RETURN"つぁ"
 IF V$=="I"THEN RETURN"つぃ"
 IF V$=="U"THEN RETURN"つ"
 IF V$=="E"THEN RETURN"つぇ"
 IF V$=="O"THEN RETURN"つぉ"
 RETURN C$+V$
 @CHA
 IF V$=="A"THEN RETURN"ちゃ"
 IF V$=="I"THEN RETURN"ち"
 IF V$=="U"THEN RETURN"ちゅ"
 IF V$=="E"THEN RETURN"ちぇ"
 IF V$=="O"THEN RETURN"ちょ"
 RETURN C$+V$
 @NA
 IF V$=="A"THEN RETURN"な"
 IF V$=="I"THEN RETURN"に"
 IF V$=="U"THEN RETURN"ぬ"
 IF V$=="E"THEN RETURN"ね"
 IF V$=="O"THEN RETURN"の"
 RETURN C$+V$
 @HA
 IF V$=="A"THEN RETURN"は"
 IF V$=="I"THEN RETURN"ひ"
 IF V$=="U"THEN RETURN"ふ"
 IF V$=="E"THEN RETURN"へ"
 IF V$=="O"THEN RETURN"ほ"
 RETURN C$+V$
 @FA
 IF V$=="A"THEN RETURN"ふぁ"
 IF V$=="I"THEN RETURN"ふぃ"
 IF V$=="U"THEN RETURN"ふ"
 IF V$=="E"THEN RETURN"ふぇ"
 IF V$=="O"THEN RETURN"ふぉ"
 RETURN C$+V$
 @MA
 IF V$=="A"THEN RETURN"ま"
 IF V$=="I"THEN RETURN"み"
 IF V$=="U"THEN RETURN"む"
 IF V$=="E"THEN RETURN"め"
 IF V$=="O"THEN RETURN"も"
 RETURN C$+V$
 @YA
 IF V$=="A"THEN RETURN"や"
 IF V$=="I"THEN RETURN"い"
 IF V$=="U"THEN RETURN"ゆ"
 IF V$=="E"THEN RETURN"いぇ"
 IF V$=="O"THEN RETURN"よ"
 RETURN C$+V$
 @RA
 IF V$=="A"THEN RETURN"ら"
 IF V$=="I"THEN RETURN"り"
 IF V$=="U"THEN RETURN"る"
 IF V$=="E"THEN RETURN"れ"
 IF V$=="O"THEN RETURN"ろ"
 RETURN C$+V$
 @WA
 IF V$=="A"THEN RETURN"わ"
 IF V$=="I"THEN RETURN"うぃ"
 IF V$=="U"THEN RETURN"う"
 IF V$=="E"THEN RETURN"うぇ"
 IF V$=="O"THEN RETURN"を"
 @JA
 IF V$=="A"THEN RETURN"じゃ
 IF V$=="I"THEN RETURN"じ"
 IF V$=="U"THEN RETURN"じゅ"
 IF V$=="E"THEN RETURN"じぇ"
 IF V$=="O"THEN RETURN"じょ"
 @VA
 IF V$=="A"THEN RETURN"ヴぁ"
 IF V$=="I"THEN RETURN"ヴぃ"
 IF V$=="U"THEN RETURN"ヴ"
 IF V$=="E"THEN RETURN"ヴぇ"
 IF V$=="O"THEN RETURN"ヴぉ"
 RETURN C$+V$
END
DEF RIM_ROMA$(C$,V$)
 VAR D$=TOUPPER$(C$)
 VAR W$=TOUPPER$(V$)
 VAR S$,P$
 IF LEN(D$)>1&&RIGHT$(D$,1)=="Y"&&RIGHT$(D$,2)!="YY"THEN
  IF D$[0]!="X"&&D$[0]!="L"THEN
   D$=LEFT$(D$,LEN(D$)-1)
   IF W$=="A"THEN S$="ゃ"
   IF W$=="I"THEN S$="ぃ"
   IF W$=="U"THEN S$="ゅ"
   IF W$=="E"THEN S$="ぇ"
   IF W$=="O"THEN S$="ょ"
   W$="I"
  ENDIF
 ENDIF
 IF LEN(D$)>1&&(MID$(D$,LEN(D$)-2,1)==RIGHT$(D$,1))THEN
  D$=LEFT$(D$,LEN(D$)-1)
  P$="っ"
 ENDIF
 IF LEN(D$)>1&&LEFT$(D$,2)!="NN"&&LEFT$(D$,1)=="N"&&!RIM_ISVOWEL(ASC(MID$(D$,1,1)))THEN
  D$=MID$(D$,1,LEN(D$))
  INC P$,"ん"
 ENDIF
 IF RIGHT$(D$,3)=="SSH"||RIGHT$(D$,3)=="CCH"THEN
  RemoveStrB D$,LEN(D$)-2,1
  P$="っ"
 ENDIF
 
 VAR R$
 IF LEN(D$)&&D$[0]=="L"||D$[0]=="X"THEN
  R$=RIM_HIRA$(MID$(D$,1,LEN(D$)),V$)
  IF R$=="いぇ"THEN
   R$="ゅ"
  ELSE
   R$=RIM_SMALL$(R$)
  ENDIF
 ELSE
  R$=RIM_HIRA$(D$,W$)
 ENDIF
 RETURN P$+R$+S$
END
DEF RIM_K$(K$)
 IF RIM_MODE!=3&&RIM_MODE!=2THEN RETURN K$
 VAR I
 FOR I=0TO LEN(K$)-1
  VAR KI$=K$[I]
  IF RIM_MODE==3&&KI$>="ぁ"&&KI$<="ん"THEN
   K$[I]=CHR$(ASC(K$[I])+96)
   CONTINUE
  ENDIF
  IF KI$=="-"THEN K$[I]="ー"CONTINUE
  IF KI$=="."THEN K$[I]="。"CONTINUE
  IF KI$==","THEN K$[I]="、"CONTINUE
 NEXT
 RETURN K$
END
VAR RIM_BUF2$
VAR RIM_WND
DEF RIM_UPDATEWINDOW K$
 SetWindowName RIM_WND,K$
 VOID ResizeWindow(RIM_WND,LEN(K$)*8-1,7)
 VOID ShowWindow(RIM_WND)
END
DEF RIM_SENDKEY(IM,K$)
 PUSH RIM_BUF2$,K$
 RIM_UPDATEWINDOW RIM_BUF2$
END
DIM RIM_CURBUNSETSU$[0]
DIM RIM_CURTXT$[0]
VAR RIM_CONVF
VAR RIM_SELBUNSETSU
VAR RIM_CANDWND
VAR RIM_TARGETWND
DEF RIM_CLEAR
 VOID DeleteWindow(RIM_CANDWND)
 RIM_CANDWND=0
 RIM_BUF2$=""
 RIM_KEYBUF$=""
 RIM_CONVF=0
 VOID FocusWindow(RIM_TARGETWND)
 RIM_TARGETWND=0
 VOID HideWindow(RIM_WND)
END
DEF RIM_SEND(IM)
 VOID FocusWindow(RIM_TARGETWND)
 RIM_TARGETWND=0
 IF!LEN(RIM_BUF2$)THEN
  VOID HideWindow(RIM_WND)
  VOID DeleteWindow(RIM_CANDWND)
  IF LEN(RIM_KEYBUF$)THEN
   VAR RK$=RIM_KEYBUF$
   RIM_KEYBUF$=""
   RETURN SendIMText(IM,RK$)
  ENDIF
  RETURN SendIMText(IM,CR$())
 ENDIF
 IF RIM_CONVF THEN
  IF RIM_CANDWND THEN
   RIMNOTIF 0,0,0,RIM_CANDWND,0
  ENDIF
  RIM_CONVF=0
  VAR ERR=SendIMText(IM,Join$(RIM_CURTXT$,""))
 ELSE
  ERR=SendIMText(IM,RIM_BUF2$+RIM_KEYBUF$)
  RIM_KEYBUF$=""
 ENDIF
 VOID HideWindow(RIM_WND)
 VOID DeleteWindow(RIM_CANDWND)
 RIM_CANDWND=0
 RIM_BUF2$=""
 RETURN ERR
END
DEF RIM_CALC_X()
 VAR X,I
 FOR I=0TO LEN(RIM_CURTXT$)-1
  IF I==RIM_SELBUNSETSU THEN
   RETURN X
  ENDIF
  X=X+LEN(RIM_CURTXT$[I])*8
 NEXT
 RETURN X
END
DEF RIM_MAXLEN(A$)
 VAR I,M=&H80000000
 FOR I=0TO LEN(A$)-1
  IF M<LEN(A$[I])THEN
   M=LEN(A$[I])
  ENDIF
 NEXT
 RETURN M
END
VAR OTYIME_LOADED
DEF RIM_ENTER(IM)
 IF!LEN(RIM_BUF2$)THEN
  VAR RK$=RIM_KEYBUF$
  RIM_KEYBUF$=""
  RETURN SendIMText(IM,RK$+" ")
 ENDIF
 IF RIM_CONVF THEN
  DIM CAND$[0]
  OTYIME_GETCAND RIM_CURBUNSETSU$[RIM_SELBUNSETSU] OUT CAND$
  VAR RW=GetParentWindow(RIM_WND),E
  VAR Y=GetWindowY(RIM_WND)-64
  IF Y<0 THEN
   Y=GetWindowY(RIM_WND)+8
  ENDIF
  VAR W=RIM_MAXLEN(CAND$)*8+12
  VAR X=MAX(GetWindowX(RIM_WND)+MIN(RW-W,RIM_CALC_X()),0)
  VAR H=65
  IF RIM_CANDWND THEN
   ClearListBox RIM_CANDWND
   E=MoveResizeWindow(RIM_CANDWND,X,Y,W,H)
  ELSE
   NewWindow GetListBoxControl(),"",X,Y,W,H,RW,WindowFrontFlag() OUT RIM_CANDWND,E
   JoinWindowGroup RIM_WND,RIM_CANDWND OUT E
  ENDIF
  VAR I
  FOR I=0TO LEN(CAND$)-1
   AddListBoxItem RIM_CANDWND,CAND$[I]
  NEXT
  RETURN 0
 ENDIF
 IF!OTYIME_LOADED THEN
  IF!CHKCALL("OTYIME_INIT")THEN
   VOID MessageBox(GetRootWindow(),"IM","OTYIME is not loaded.",MessageBoxOK()OR MessageBoxError())
   
   RETURN 0
  ENDIF
  OTYIME_INIT
  CLS
  OTYIME_LOADED=TRUE
 ENDIF
 RIM_CONVF=TRUE
 IF 0 THEN DIM A$[0],B$[0]
 'OTYIME_K2K RIM_BUF2$+RIM_KEYBUF$ OUT A$,B$
  KKC2 RIM_BUF2$+RIM_KEYBUF$ OUT A$,B$
' B$=NewArray$(LEN(A$))
' COPY B$,A$
 RIM_KEYBUF$=""
 RIM_CURTXT$=A$
 RIM_CURBUNSETSU$=B$
 RIM_SELBUNSETSU=0
 RIM_BUF2$=Join$(A$,"")
 RIM_UPDATEWINDOW RIM_BUF2$
 RETURN 0'ERR
END
DEF RIM_KEY IM,KEY
 IF!RIM_MODE THEN RETURN
 IF!LEN(RIM_BUF2$)&&RIM_MODE==1 THEN
  VOID SendIMText(IM,CHR$(KEY))
  RETURN
 ENDIF
 IF!LEN(RIM_BUF2$)&&KEY==8THEN
  VOID SendIMText(IM,CHR$(KEY))
  RETURN
 ENDIF
 IF KEY==13THEN
  VOID RIM_SEND(IM)
  RETURN
 ENDIF
 IF KEY==32THEN
  VOID RIM_ENTER(IM)
  RETURN
 ENDIF
 IF KEY==8 THEN
  IF LEN(RIM_KEYBUF$)THEN
   VOID POP(RIM_KEYBUF$)
  ELSEIF LEN(RIM_BUF2$)THEN
   VOID POP(RIM_BUF2$)
  ENDIF
  IF!LEN(RIM_BUF2$)&&!LEN(RIM_KEYBUF$)THEN
   RIM_CLEAR
   RETURN
  ENDIF
  RIM_UPDATEWINDOW RIM_BUF2$+RIM_KEYBUF$
  RETURN
 ENDIF
 IF!RIM_CONVF&&!RIM_TARGETWND THEN
  VAR W=GetActiveWindow()
  RIM_TARGETWND=W
  VAR X,Y,E
  GetWindowIMCursor W OUT X,Y,E
  IF !E THEN
   X=CalcWindowX(GetParentWindow(RIM_WND),W)+X
   Y=CalcWindowY(GetParentWindow(RIM_WND),W)+Y
   VOID MoveWindow(RIM_WND,X,Y)
   VOID FrontWindow(RIM_WND)
  ELSE
   VOID MoveWindow(RIM_WND,0,GetWindowHeight(GetParentWindow(RIM_WND))-7)
   VOID FrontWindow(RIM_WND)
  ENDIF
 ENDIF
 IF RIM_CONVF THEN RETURN
 'KEY ON
 IF RIM_MODE==1THEN
  VOID RIM_SENDKEY(IM,RIM_KEYBUF$+CHR$(KEY))
  RIM_KEYBUF$=""
  RETURN
 ENDIF
 IF!RIM_ISROMA(KEY)THEN
  IF LEN(RIM_KEYBUF$)THEN
   IF RIGHT$(RIM_KEYBUF$,1)=="N"THEN
    RIM_KEYBUF$[LEN(RIM_KEYBUF$)-1]=RIM_K$("ん")
   ENDIF
   VOID RIM_SENDKEY(IM,RIM_KEYBUF$)
   RIM_KEYBUF$=""
  ENDIF
  VOID RIM_SENDKEY(IM,RIM_K$(CHR$(KEY)))
  RETURN
 ENDIF
 IF RIM_ISVOWEL(KEY)THEN
  IF LEN(RIM_KEYBUF$)THEN
   VOID RIM_SENDKEY(IM,RIM_K$(RIM_ROMA$(RIM_KEYBUF$,CHR$(KEY))))
   RIM_KEYBUF$=""
   RETURN
  ENDIF
  VOID RIM_SENDKEY(IM,RIM_K$(RIM_VOWEL$(KEY)))
  RETURN
 ENDIF
 PUSH RIM_KEYBUF$,CHR$(KEY)
 RIM_UPDATEWINDOW RIM_BUF2$+RIM_KEYBUF$
 IF ToUpper$(RIM_KEYBUF$)=="NN"THEN
  VOID RIM_SENDKEY(IM,RIM_K$("ん"))
  RIM_KEYBUF$=""
  RETURN
 ENDIF
END
VAR RIM_WV_BTNRPT
COMMON DEF RIMNOTIF WND,CTL,TYP,A1,A2
 IF A1==RIM_CANDWND THEN
  IF A2==ListBoxChItem()THEN RETURN
  VAR T$=GetListBoxSelectedText$(A1)
  IF!LEN(T$)THEN RETURN
  RIM_CURTXT$[RIM_SELBUNSETSU]=T$
  VOID DeleteWindow(A1)
  RIM_CANDWND=0
  RIM_UPDATEWINDOW2
 ENDIF
END
DEF RIM_UPDATEWINDOW2
 VAR I,L=LEN(RIM_CURTXT$)-1
 VAR W
 FOR I=0TO L
  W=W+LEN(RIM_CURTXT$[I])*8
 NEXT
 VOID ResizeWindow(RIM_WND,W-1,7)
END
COMMON DEF RIMBTN WND,CTL,TYP,BTN,__
 IF!BTN THEN RETURN
 IF (BTN AND (#UP OR #DOWN))&&RIM_CANDWND THEN
  VOID SendButtonWindow(RIM_CANDWND,BTN)
  RETURN
 ENDIF
 IF RIM_CANDWND THEN
  RIMNOTIF WND,CTL,TYP,RIM_CANDWND,0
  VOID DeleteWindow(RIM_CANDWND)
  RIM_CANDWND=0
 ENDIF
 IF BTN==#LEFT&&RIM_SELBUNSETSU>0 THEN
  DEC RIM_SELBUNSETSU
  RIM_UPDATEWINDOW2
 ENDIF
 IF BTN==#RIGHT&&LEN(RIM_CURTXT$)>RIM_SELBUNSETSU+1 THEN
  INC RIM_SELBUNSETSU
  RIM_UPDATEWINDOW2
 ENDIF
 IF BTN==#UP&&LEN(RIM_CURTXT$)>RIM_SELBUNSETSU+1 THEN
  PUSH RIM_CURBUNSETSU$[RIM_SELBUNSETSU],RIM_CURBUNSETSU$[RIM_SELBUNSETSU+1][0]
  IF LEN(RIM_CURBUNSETSU$[RIM_SELBUNSETSU+1])==1THEN
   COPY RIM_CURTXT$,RIM_SELBUNSETSU+1,RIM_CURTXT$,RIM_SELBUNSETSU+2,LEN(RIM_CURBUNSETSU$)-RIM_SELBUNSETSU-2
   COPY RIM_CURBUNSETSU$,RIM_SELBUNSETSU+1,RIM_CURBUNSETSU$,RIM_SELBUNSETSU+2,LEN(RIM_CURBUNSETSU$)-RIM_SELBUNSETSU-2
   VOID POP(RIM_CURBUNSETSU$)
   VOID POP(RIM_CURTXT$)
   RIM_CURTXT$[RIM_SELBUNSETSU]=RIM_CURBUNSETSU$[RIM_SELBUNSETSU]
  ELSE
   VOID SHIFT(RIM_CURBUNSETSU$[RIM_SELBUNSETSU+1])
   RIM_CURTXT$[RIM_SELBUNSETSU]=RIM_CURBUNSETSU$[RIM_SELBUNSETSU]
   RIM_CURTXT$[RIM_SELBUNSETSU+1]=RIM_CURBUNSETSU$[RIM_SELBUNSETSU+1]
  ENDIF
  RIM_UPDATEWINDOW2
 ENDIF
 IF BTN==#DOWN THEN
  IF LEN(RIM_CURBUNSETSU$[RIM_SELBUNSETSU])==1THEN RETURN
  IF LEN(RIM_CURTXT$)==RIM_SELBUNSETSU+1THEN
   PUSH RIM_CURTXT$,""
   PUSH RIM_CURBUNSETSU$,""
  ENDIF
  UNSHIFT RIM_CURBUNSETSU$[RIM_SELBUNSETSU+1],POP(RIM_CURBUNSETSU$[RIM_SELBUNSETSU])
  RIM_CURTXT$[RIM_SELBUNSETSU]=RIM_CURBUNSETSU$[RIM_SELBUNSETSU]
  RIM_CURTXT$[RIM_SELBUNSETSU+1]=RIM_CURBUNSETSU$[RIM_SELBUNSETSU+1]
  RIM_UPDATEWINDOW2
 ENDIF
END
COMMON DEF RIMPAINT WND,CTL,TYP,XY,WH
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,-1
 IF RIM_CONVF THEN
  VAR I,L=LEN(RIM_CURTXT$)-1,X
  FOR I=0TO L
   VAR C$=RIM_CURTXT$[I]
   IF RIM_SELBUNSETSU==I THEN
    GFILLWindow WND,X,0,X+LEN(C$)*8-1,7,GetSelectionColor()
    GPRINTWindow WND,X,0,C$,GetSelectionTextColor()
   ELSE
    GPRINTWindow WND,X,0,C$,#BLACK
   ENDIF
   X=X+LEN(C$)*8
  NEXT
 ELSE
  GPRINTWindow WND,0,0,GetWindowName$(WND),#BLACK
 ENDIF
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF I_RIM
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 NewControl "RIM" OUT RIM_CTL,E
 E=SetControlPainter(RIM_CTL,"RIMPAINT")
 E=SetControlButtonHandler(RIM_CTL,"RIMBTN")
 E=SetControlNotifHandler(RIM_CTL,"RIMNOTIF")
 VAR RWND=GetRootWindow()
 VAR WND
 NewWindow RIM_CTL,"",0,GetWindowHeight(RWND)-7,GetWindowWidth(RWND),7,RWND,WindowFrontFlag() OUT WND,E
 SetSysWindowProperty WND,"SHADOW",FALSE OUT E
 VOID HideWindow(WND)
 RIM_WND=WND
 VAR IM,ERR
 NewIM OUT IM,ERR
 IF ERR THEN
  ExitProcess ERR
  RETURN
 ENDIF
 ERR=SetIMKeyHandler(IM,"RIM_KEY")
 
 SetProcessVar IM
 KEY 1,"KEY OFF"
 USE 3
 'EXEC 3
END
COMMON DEF L_RIM
 VAR X,Y,MMM
 TOUCH OUT MMM,X,Y
 IF MMM&&!OTW_ENKEY_STATE&&X>=5&&X<=63&&Y>=5&&Y<=16THEN
  OTW_ENKEY_STATE=1
  RIM_MODE=(RIM_MODE+1)MOD 3
  IF RIM_MODE==1 THEN
   SetKeyboardMode!TRUE
   KEY 1,"KEY ON"
   SYSBEEP=TRUE
  ELSEIF RIM_MODE==2THEN
   SetKeyboardMode!TRUE
   KEY 1,"かな ON"
   SYSBEEP=TRUE
  ELSEIF RIM_MODE==3THEN
   SetKeyboardMode!TRUE
   KEY 1,"カナ ON"
   SYSBEEP=TRUE
  ELSE
   SetKeyboardMode TRUE
   KEY 1,"KEY OFF"
   SYSBEEP=FALSE
  ENDIF
  BEEP 9
 ENDIF
 IF!MMM THEN OTW_ENKEY_STATE=0
 IF ProcessIM(GetProcessVar())THEN
  VOID DeleteIM(GetProcessVar())
  ExitProcess 0
 ENDIF
 IF RIM_CONVF THEN VOID ActiveWindow(RIM_WND)
 IF UpdateWindow(RIM_WND)THEN
  RETURN
 ENDIF
END
VAR OTWTERMCTL
DIM OTWTERMCOLORTBL[0]
COMMON DEF OTWTERMKEY WND,CTL,TYP,A1,A2
 VAR STR$=GetString$(GetWindowVar(WND,4))
 IF A1==13THEN A1=10
 PUSH STR$,CHR$(A1)
END
COMMON DEF OTWTERMPAINT WND,CTL,TYP,XY,WH
 VAR E=CallBaseControlHandler(WND,CTL,TYP,XY,WH)
 'fast
 IF GBeginDirect(WND)THEN RETURN
 IF 0THEN DIM CONSOLE[0]
 CONSOLE=GetSBArray(GetWindowVar(WND,0))
 VAR CW,CH
 SplitInt GetWindowVar(WND,2) OUT CW,CH
 VAR X,Y
 DEC CW
 DEC CH
 'GCLIP 1,0,0,CW*8+7,CH*8+7
 GCLS RGB(0,0,0)
 VAR CX,CY
 SplitInt GetWindowVar(WND,3) OUT CX,CY
 
 VAR CW8=CW*8
 VAR CH8=CH*8
 WHILE Y<=CH8
  X=0
  VAR I=(Y DIV 8)*CW+(Y DIV 8)'Y*CW+Y
  WHILE X<=CW8
   VAR C=CONSOLE[I]
   'IF C==0&&(X!=CX||Y!=CY)THEN CONTINUE
   VAR BACK=OTWTERMCOLORTBL[(C>>20)AND&HF]
   IF BACK THEN
    GFILL X,Y,X+7,Y+7,BACK
   ENDIF
   'IF!C THEN CONTINUE
   GPUTCHR X,Y,C,OTWTERMCOLORTBL[(C>>16)AND&HF]
   X=X+8
   I=I+1
  WEND
  Y=Y+8
 WEND
 GFILL CX*8,CY*8,CX*8+1,CY*8+7,-1
 IF GCopyDirect(WND,0,0,CW*8+7,CH*8+7,0,0,1)THEN RETURN
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF OTWTERMRESIZE WND,CTL,TYP,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 VAR CW=W DIV 8,CH=H DIV 8
 IF 0THEN DIM CONSOLE[0]
 CONSOLE=GetSBArray(GetWindowVar(WND,0))
 IF LEN(CONSOLE)<CW*CH THEN
  VAR I,L=CW*CH-LEN(CONSOLE)
  FOR I=0TO L
   PUSH CONSOLE,GetWindowVar(WND,5)<<16
  NEXT
 ENDIF
 SetWindowVar WND,2,JoinInt(CW,CH)
 VAR X,Y
 SplitInt GetWindowVar(WND,3) OUT X,Y
 SetWindowVar WND,3,JoinInt(MAX(0,MIN(X,CW-1)),MAX(0,MIN(Y,CH-1)))
END
COMMON DEF OTWTERMDELETE WND,CTL,TYP,A1,WH
 VAR PRC=GetWindowVar(WND,6)
 'FIXME:おやこをまとめてころしたい
 VOID KillProcess(PRC)
 VOID DeleteConsole(GetConsole())
 FreeString GetWindowVar(WND,4)
 FreeSBArray GetWindowVar(WND,0)

END
COMMON DEF OTWTERM_GETSIZE CON OUT W,H,ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN
 SplitInt GetWindowVar(WND,2) OUT W,H
END
COMMON DEF OTWTERM_RD CON,LEN OUT RES$,ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN
 VAR S=GetWindowVar(WND,4)
 VAR STR$=GetString$(S)
 RES$=MID$(STR$,0,LEN)
 SetString S,MID$(STR$,LEN,LEN(STR$))
END
COMMON DEF OTWTERM_PUT CON,BUF$ OUT ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN
 IF!LEN(BUF$)THEN RETURN
 VAR X,Y,W,H
 SplitInt GetWindowVar(WND,3) OUT X,Y
 SplitInt GetWindowVar(WND,2) OUT W,H
 IF 0THEN DIM CONSOLE[0]
 CONSOLE=GetSBArray(GetWindowVar(WND,0))
 VAR L=LEN(BUF$)-1,I
 VAR STYLE=GetWindowVar(WND,5)
 FOR I=0TO L
  VAR D$=BUF$[I],D=ASC(D$)
  IF D==10THEN
   OTWTERM_SCROLL_Y CONSOLE,X,Y,W,H,STYLE OUT X,Y
   CONTINUE
  ENDIF
  IF D==9THEN
   IF X MOD TABSTEP THEN
    X=X+X MOD TABSTEP
   ELSE
    X=X+TABSTEP
   ENDIF
   IF X>=W THEN
    OTWTERM_SCROLL_Y CONSOLE,X,Y,W,H,STYLE OUT X,Y
   ENDIF
   CONTINUE
  ENDIF
  IF D==8THEN 'BS
   X=X-1
   IF X<0THEN
    X=0
    Y=MAX(0,Y-1)
   ENDIF
   CONTINUE
  ENDIF
  CONSOLE[Y*W+X]=(STYLE<<16) OR D
  INC X
  IF X>=W THEN
   OTWTERM_SCROLL_Y CONSOLE,X,Y,W,H,STYLE OUT X,Y
  ENDIF
 NEXT
 SetWindowVar WND,3,JoinInt(X,Y)
 ERR=RepaintWindow(WND)
END
DEF OTWTERM_SCROLL_Y CONSOLE,X,Y,W,H,STYLE OUT X_,Y_
 X=0
 INC Y
 IF Y>=H THEN
  VAR I
  COPY CONSOLE,0,CONSOLE,W,LEN(CONSOLE)-W
  DEC Y
  FILL CONSOLE,STYLE<<16,W*(H-1),W
 ENDIF
 X_=X
 Y_=Y
END
COMMON DEF OTWTERM_GETFORE CON OUT C,ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN
 VAR DAT=GetWindowVar(WND,5)
 C=DAT AND &HF
END
COMMON DEF OTWTERM_SETFORE CON,C OUT ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 C=C AND &HF
 IF ERR THEN RETURN
 VAR DAT=GetWindowVar(WND,5)
 C=(DAT AND (NOT &HF)) OR C
 SetWindowVar WND,5,C
END
COMMON DEF OTWTERM_GETBACK CON OUT C,ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN
 VAR DAT=GetWindowVar(WND,5)
 C=(DAT>>4) AND &HF
END
COMMON DEF OTWTERM_SETBACK CON,C OUT ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 C=C AND &HF
 IF ERR THEN RETURN
 VAR DAT=GetWindowVar(WND,5)
 C=(DAT AND (NOT &HF0)) OR (C<<4)
 SetWindowVar WND,5,C
END
COMMON DEF OTWTERM_GETCUR CON OUT X,Y,ERR
 VAR WND
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN
 VAR DAT=GetWindowVar(WND,5)
 SplitInt GetWindowVar(WND,3) OUT X,Y
 ERR=0
END
COMMON DEF OTWTERM_SETCUR(CON,X,Y)
 VAR WND,ERR
 GetConsoleVar CON OUT WND,ERR
 IF ERR THEN RETURN ERR
 VAR DAT=GetWindowVar(WND,5)
 VAR CW,CH
 SplitInt GetWindowVar(WND,2) OUT CW,CH
 IF X<0||Y<0||X>=CW||Y>=CH THEN RETURN 1
 SetWindowVar WND,3,JoinInt(X,Y)
 RETURN 0
END
COMMON DEF I_OTWTERM
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTWTERMCTL THEN
  ExtendControl "OTWTERM",GetWindowControl() OUT OTWTERMCTL,E
  E=SetControlPainter(OTWTERMCTL,"OTWTERMPAINT")
  E=SetControlKeyHandler(OTWTERMCTL,"OTWTERMKEY")
  E=SetControlResizeHandler(OTWTERMCTL,"OTWTERMRESIZE")
  E=SetControlDeleteHandler(OTWTERMCTL,"OTWTERMDELETE")
  OTWTERMCOLORTBL=NewArray(16)
  COPY OTWTERMCOLORTBL,@OTWTERMCOLORTBL
  @OTWTERMCOLORTBL
  DATA &H00000000
  DATA &HFF000000
  DATA &HFF800000
  DATA &HFFF80000
  DATA &HFF008000
  DATA &HFF00F800
  DATA &HFF808000
  DATA &HFFF8F800
  DATA &HFF000080
  DATA &HFF0000F8
  DATA &HFF800080
  DATA &HFFF800F8
  DATA &HFF008080
  DATA &HFF00F8F8
  DATA &HFF808080
  DATA &HFFF8F8F8
 ENDIF
 VAR CON
 NewConsole OUT CON,E
 SetGetConsoleSizeHandler CON,"OTWTERM_GETSIZE"OUT E
 SetReadConsoleHandler CON,"OTWTERM_RD"OUT E
 SetPutConsoleHandler CON,"OTWTERM_PUT"OUT E
 SetGetConsoleCursorHandler CON,"OTWTERM_GETCUR"OUT E
 SetGetConsoleForeHandler CON,"OTWTERM_GETFORE"OUT E
 SetSetConsoleForeHandler CON,"OTWTERM_SETFORE"OUT E
 SetGetConsoleBackHandler CON,"OTWTERM_GETBACK"OUT E
 SetSetConsoleBackHandler CON,"OTWTERM_SETBACK"OUT E
 SetSetConsoleCursorHandler CON,"OTWTERM_SETCUR"OUT E
 SetGetConsoleCursorHandler CON,"OTWTERM_GETCUR"OUT E
 VAR CW=40
 VAR CH=20
 NewTopLevelStyleWindow OTWTERMCTL,"OTWTERM",CW*8,CH*8,WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle() OUT WND,E
 E=SetConsoleVar(CON,WND)
 VAR DEFSTYLE=14
 SetWindowVar WND,0,AllocSBArray()
 SetSBArray GetWindowVar(WND,0),NewArray(CH*CW)
 FILL GetSBArray(GetWindowVar(WND,0)),DEFSTYLE<<16
 SetWindowVar WND,1,CON
 SetWindowVar WND,2,JoinInt(CW,CH)
 SetWindowVar WND,3,JoinInt(0,0)
 SetWindowVar WND,4,AllocString("")
 SetWindowVar WND,5,DEFSTYLE
 VAR PRC
 SetConsole CON
 NewProcess "sh","" OUT PRC,E
 SetWindowVar WND,6,PRC
 SetProcessVar WND
END
COMMON DEF L_OTWTERM
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR ODE_CTL
VAR ODE_WV_FILES
VAR ODE_WV_CURRENT
VAR ODE_WV_ICONS
VAR ODE_IW
VAR ODE_IH
VAR ODE_IX
VAR ODE_IY
DIM ODEPAL[0]
DEF ODE_GETITEM WND,X,Y OUT I,IX,IY
 X=X-ODE_IX
 Y=Y-ODE_IY
 IX=X DIV ODE_IW
 IY=Y DIV ODE_IH
 I=IY+(IX*(GetWindowHeight(WND)DIV ODE_IH))
END
COMMON DEF ODE_LDC WND,CTL,TYP,X,Y
 VAR I
 ODE_GETITEM WND,X,Y OUT I,X,Y
 IF I<0THEN RETURN
 SetWindowVar WND,ODE_WV_CURRENT,I
 IF 0 THEN DIM DIR$[0]
 VAR ARY=GetWindowVar(WND,ODE_WV_FILES)
 DIR$=GetSBArray(ARY)
 IF I>=LEN(DIR$)THEN RETURN
 VAR F$=DIR$[I]
 F$=MID$(F$,1,LEN(F$))
 F$=CombinePath$(CombinePath$(GetHomeDir$(),"desktop"),F$)
 VAR E=ExecFile(F$)
END
COMMON DEF ODE_LMD WND,CTL,TYP,X,Y
 IF 0 THEN DIM DIR$[0]
 VAR ARY=GetWindowVar(WND,ODE_WV_FILES)
 DIR$=GetSBArray(ARY)
 VAR I,L=LEN(DIR$)-1
 VAR IX=ODE_IX,IY=ODE_IY
 VAR IW=ODE_IW
 VAR IH=ODE_IH
 VAR ICONSX=(IW-16) DIV 2
 VAR ITW=IW DIV 8
 ODE_GETITEM WND,X,Y OUT I,X,Y
 IF I<0THEN RETURN
 SetWindowVar WND,ODE_WV_CURRENT,I
 ODE_PAINTER WND,CTL,TYP,0,0
END
COMMON DEF ODE_PAINTER WND,CTL,TYP,XY,WH
 'delete loading window
 VAR WGM=GetWindowGroupMember(WND)
 IF WGM THEN
  VOID DeleteWindow(WGM)
 ENDIF
 VAR X,Y,W,H
 VAR SW,SH
 SW=GetWindowWidth(WND)
 SH=GetWindowHeight(WND)
 IF WH THEN
  SplitInt WH OUT W,H
  SplitInt XY OUT X,Y
 ELSE
  W=SW
  H=SH
 ENDIF

 IF GBeginDirect(WND)THEN @END
 GCLS RGB(0,128,128)
 IF 0 THEN DIM DIR$[0]
 IF 0 THEN DIM ICON[0]
 VAR ARY=GetWindowVar(WND,ODE_WV_FILES)
 DIR$=GetSBArray(ARY)
 ICON=GetSBArray(GetWindowVar(WND,ODE_WV_ICONS))
 VAR I,L=LEN(DIR$)-1
 VAR IX=ODE_IX,IY=ODE_IY
 VAR IW=ODE_IW
 VAR IH=ODE_IH
 VAR ICONSX=(IW-16) DIV 2
 VAR ITW=IW DIV 8
 VAR CUR=GetWindowVar(WND,ODE_WV_CURRENT)
 VAR SC=GetSelectionColor()
 
 FOR I=0TO L
  VAR D$=DIR$[I]
  IF D$=="/.."THEN CONTINUE
  VAR NAME$=MID$(D$,1,LEN(D$))
  VAR TC=&HFF000000
  IF I==CUR THEN
   GFILL IX,IY+16,IX+IW-1,IY+IH-1,SC
   TC=GetSelectionTextColor()
  ENDIF
  GLOADImage IX+ICONSX,IY,ICON[I],FALSE
 'GLOADImagePalette IX+ICONSX,IY,ICON[I],ODEPAL,FALSE
  GPUTCHR IX+(IW-MIN(ITW,LEN(NAME$))*8)DIV 2,IY+16,MID$(NAME$,0,ITW),TC
  IF LEN(NAME$)>ITW THEN
   GPUTCHR IX+(IW-MIN(ITW,LEN(NAME$)-ITW)*8)DIV 2,IY+24,MID$(NAME$,ITW,ITW),TC
   IF LEN(NAME$)>ITW+ITW THEN
    GPUTCHR IX+(IW-MIN(ITW,LEN(NAME$)-ITW-ITW)*8)DIV 2,IY+32,MID$(NAME$,ITW+ITW,ITW),TC
   ENDIF
  ENDIF
  IF I==CUR THEN
   GPUTCHR IX+ICONSX,IY,"",SC
   GPUTCHR IX+ICONSX,IY+8,"",SC
  ENDIF
  IY=IY+IH
  IF IY+IH>=SH THEN IY=ODE_IY:IX=IX+ODE_IW
 NEXT
 IF GCopyDirect(WND,X,Y,X+W,Y+H,X,Y,1)THEN RETURN
 @END
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF ODE_DEL WND,CTL,TYP,A1,A2
 FreeSBArray GetWindowVar(WND,ODE_WV_FILES)
 FreeSBArray GetWindowVar(WND,ODE_WV_ICONS)
END
VAR ODE_IMAGE_TXT
VAR ODE_IMAGE_DAT
VAR ODE_IMAGE_DIR
DEF ODE_UPDATEFILES WND
 VAR ERR
 IF 0 THEN DIM DIR$[0]
 VAR D$=CombinePath$(GetHomeDir$(),"desktop/")
 GetFiles D$ OUT DIR$,ERR
 VAR ARY=GetWindowVar(WND,ODE_WV_FILES)
 SetSBArray ARY,DIR$
 DIM ICONS[LEN(DIR$)]
 VAR I
 FOR I=0TO LEN(DIR$)-1
  ICONS[I]=ODE_IMAGE_TXT
  
  UpdateMouse
  IF ToUpper$(GetFileExtension$(DIR$[I]))=="LNK"THEN
   VAR F$
   LoadFile CombinePath$(D$,MID$(DIR$[I],1,LEN(DIR$[I]))) OUT F$,ERR
   UpdateMouse
   IF ERR THEN CONTINUE
   IF 0THEN DIM K$[0],V$[0]
   LoadConfigFile F$ OUT K$,V$
   VAR I16=FindArray(K$,"icon16")
   IF I16==-1THEN CONTINUE
   VAR IMG
   LoadImage V$[I16],16,16 OUT IMG,ERR
   UpdateMouse
   IF ERR THEN CONTINUE
   ICONS[I]=IMG
  ELSEIF DIR$[I][0]=="*"THEN
   ICONS[I]=ODE_IMAGE_TXT
  ELSEIF DIR$[I][0]=="/"THEN
   ICONS[I]=ODE_IMAGE_DIR
  ELSEIF DIR$[I][0]==" "THEN
   ICONS[I]=ODE_IMAGE_DAT
  ENDIF
 NEXT
 ARY=GetWindowVar(WND,ODE_WV_ICONS)
 SetSBArray ARY,ICONS
END
VAR ODELD_CTL
COMMON DEF ODELD_PAINTER WND,CTL,TYP,A1,A2
 VOID CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 VOID GBeginWindow(WND)
 GPRINTWindow WND,0,0,"Starting...",#BLACK
 VOID GEndWindow(WND)
END
COMMON DEF I_ODE
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!ODE_CTL THEN
  IF 0THEN
   VAR I
   ODEPAL=NewArray(65536)
   FOR I=1TO 65535 STEP 2
    VAR R=((I>>11AND 31)<<3+0)XOR 255'DIV 2
    VAR G=((I>>6AND 31)<<3+0)XOR 255'DIV 2
    VAR B=(((I>>1AND 31)<<3))XOR 255'+255)DIV 2
    VAR A=(I AND 1)*255
    ODEPAL[I]=RGB(A,R,G,B)'R>>3<<11OR G>>3<<6OR B>>3<<1OR !!A
   NEXT
  ENDIF
  RC_OTYFIL
  NewImage ImageAttrPhy1Dim(),OTYFILICOTXT,16,16 OUT ODE_IMAGE_TXT,E
  NewImage ImageAttrPhy1Dim(),OTYFILICODAT,16,16 OUT ODE_IMAGE_DAT,E
  NewImage ImageAttrPhy1Dim(),OTYFILICODIR,16,16 OUT ODE_IMAGE_DIR,E
  ExtendControl "otya desktop environment:LOADING",GetWindowControl() OUT ODELD_CTL,E
  E=SetControlPainter(ODELD_CTL,"ODELD_PAINTER")
  NewControl "otya desktop environment" OUT ODE_CTL,E
  E=SetControlPainter(ODE_CTL,"ODE_PAINTER")
  E=SetControlLMouseDownHandler(ODE_CTL,"ODE_LMD")
  E=SetControlLDoubleClickHandler(ODE_CTL,"ODE_LDC")
  E=SetControlDeleteHandler(ODE_CTL,"ODE_DEL")
  ODE_WV_FILES=0
  ODE_WV_CURRENT=1
  ODE_WV_ICONS=2
  ODE_IW=48
  ODE_IH=44
  ODE_IX=8
  ODE_IY=8
 ENDIF
 VAR RWND=GetRootWindow()
 VAR LDWND
 NewWindow ODELD_CTL,"desktop",(GetWindowWidth(RWND)-100)DIV 2,(GetWindowHeight(RWND)-32)DIV 2,100,32,RWND,WindowFrontFlag() OUT LDWND,E
 VOID SetCursor(GetWaitCursor())
 IF UpdateWindow(LDWND)THEN ENDIF
 NewStyleWindow ODE_CTL,"",0,0,GetWindowWidth(RWND),GetWindowHeight(RWND),RWND,WindowBackFlag(),0 OUT WND,E
 SetSysWindowProperty WND,"SHADOW",FALSE OUT E
 JoinWindowGroup WND,LDWND OUT E

 SetWindowVar WND,ODE_WV_FILES,AllocSBArray()
 SetWindowVar WND,ODE_WV_CURRENT,-1
 SetWindowVar WND,ODE_WV_ICONS,AllocSBArray()
 ODE_UPDATEFILES WND
 SetProcessVar WND
 NewProcess "TSKBAR","" OUT E,E
END
COMMON DEF L_ODE
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 0
END
COMMON DEF I_LINKOPEN
 VAR CMD$,FIL$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT FIL$,I
 IF I!=-1THEN
  VAR C2$=GetProcessArgs$()
  C2$=MID$(C2$,I,LEN(C2$))
 ENDIF
 VAR ERR
 VAR RESULT$
 LoadFile FIL$ OUT RESULT$,ERR
 IF ERR THEN
  ExitProcess ERR
  RETURN
 ENDIF
 IF 0 THEN DIM K$[0],V$[0]
 LoadConfigFile RESULT$ OUT K$,V$
 VAR F=FindArray(K$,"function")
 IF F!=-1THEN
  VAR P
  NewProcess V$[F],C2$ OUT P,ERR
  ExitProcess ERR
  RETURN
 ENDIF
 ExitProcess 1
END
COMMON DEF L_LINKOPEN
END

VAR OTWBENCHCTL
VAR OTWBENCH_MENU_NEW
COMMON DEF OTWBENCHNOTIF WND,C,T,A1,A2
 IF A1==MenuNotifID()THEN
  IF A2==OTWBENCH_MENU_NEW THEN
   SetWindowVar WND,0,0
   SetWindowVar WND,1,0
   SetWindowVar WND,2,TRUE
   VOID RepaintWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF OTWBENCHPAINTER WND,C,T,XY,WH
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 IF GetWindowVar(WND,2)THEN
  VAR M=GetWindowVar(WND,0)
  IF!M THEN
   M=MILLISEC+5000
   SetWindowVar WND,0,M
  ENDIF
  SetWindowVar WND,1,GetWindowVar(WND,1)+1
  IF GBeginWindow(WND)THEN RETURN
   GFILLWindow WND,RND(W+1),RND(H+1),RND(W+1),RND(H+1),RGB(RND(32)*8,RND(32)*8,RND(32)*8)
  IF GEndWindow(WND)THEN RETURN
  RETURN
 ENDIF
 VAR E=CallBaseControlHandler(WND,C,T,XY,WH)
 IF GBeginWindow(WND)THEN RETURN
  GPRINTWindow WND,0,0,STR$(GetWindowVar(WND,1)),#BLACK
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF I_OTWBENCH
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTWBENCHCTL THEN
  ExtendControl "Benchmark",GetWindowControl() OUT OTWBENCHCTL,E
  E=SetControlPainter(OTWBENCHCTL,"OTWBENCHPAINTER")
  E=SetControlNotifHandler(OTWBENCHCTL,"OTWBENCHNOTIF")
  OTWBENCH_MENU_NEW=1
 ENDIF
 VAR MENU
 NewTopLevelStyleWindow OTWBENCHCTL,"Benchmark",128,32,WINDOWMENUSTYLE() OUT WND,E
 NewMenu OUT MENU,E
 AddMenuItem MENU,"New",OTWBENCH_MENU_NEW
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 SetProcessVar WND
END
COMMON DEF L_OTWBENCH
 VAR WND=GetProcessVar()
  VAR M=GetWindowVar(WND,0)
  IF M>=MILLISEC THEN
   VOID RepaintWindow(WND)
  ELSE
   VOID RepaintWindow(WND)
   SetWindowVar WND,2,FALSE
  ENDIF
 IF UpdateWindow(WND)THEN ExitProcess 1
END
VAR OTWCLOCKCTL
COMMON DEF OTWCLOCKPAINT WND,CTL,TYP,XY,WH_
 VAR E=CallBaseControlHandler(WND,CTL,TYP,XY,WH_)
 OTWCLOCKDRAW WND
END
DEF OTWCLOCKDRAW WND
 VAR H,M,S
 TMREAD OUT H,M,S
 SetWindowVar WND,0,S
 VAR WW=GetWindowWidth(WND)
 VAR WH=GetWindowHeight(WND)
 WW=MIN(WW,WH)
 WH=WW
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,GetWindowBackColor(WND)
 SetWindowDrawPos WND,(GetWindowWidth(WND)-WW)DIV 2,(GetWindowHeight(WND)-WW)DIV 2
 VAR S2=H*60*60+M*60+S
 ?S2,H,M,S
 VAR H#=RAD(S2/3600*(360/24)+90)'H*(360/24))
 VAR M#=RAD(S2/60*(360/60)+270)'M*(360/60))
 VAR S#=RAD(S*(360/60))
 H=S
 VAR C=WW DIV 2
 GLINEWindow WND,C,C,C+COS(S#)*(C),C+SIN(S#)*(C),#BLACK
 GCIRCLEWindow WND,C,C,C,#BLACK
' GLINEWindow WND,C,C,C+COS(H#)*(C)*0.5,C+SIN(H#)*(C)*0.5,#BLACK
 VAR R#=RAD(3)
 GTRIWindow WND,C,C,C+COS(H#-R#)*(WW/8),C+SIN(H#-R#)*(WW/8),C+COS(H#)*C,C+SIN(H#)*C,#BLACK
 GTRIWindow WND,C,C,C+COS(H#+R#)*(WW/8),C+SIN(H#+R#)*(WW/8),C+COS(H#)*(C),C+SIN(H#)*(C),#BLACK
'GLINEWindow WND,C,C,C+COS(M#)*(C),C+SIN(M#)*(C)*0.9,#BLACK
 GTRIWindow WND,C,C,C+COS(M#-R#)*(WW/8),C+SIN(M#-R#)*(WW/8),C+COS(M#)*C,C+SIN(M#)*C,#BLACK
 GTRIWindow WND,C,C,C+COS(M#+R#)*(WW/8),C+SIN(M#+R#)*(WW/8),C+COS(M#)*(C),C+SIN(M#)*(C),#BLACK
 IF GEndWindow(WND)THEN RETURN
END
COMMON DEF I_OTWCLOCK
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTWCLOCKCTL THEN
  ExtendControl "CLOCK",GetWindowControl() OUT OTWCLOCKCTL,E
  E=SetControlPainter(OTWCLOCKCTL,"OTWCLOCKPAINT")
 ENDIF
  NewTopLevelStyleWindow OTWCLOCKCTL,"CLOCK",64,64,WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle() OUT WND,E
 SetProcessVar WND
END
COMMON DEF L_OTWCLOCK
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
 VAR S
 TMREAD OUT ,,S
 IF GetWindowVar(GetProcessVar(),0)!=S THEN
  OTWCLOCKDRAW GetProcessVar()
 ENDIF
END

VAR PAINTCTL
VAR PAINTCANVASCTL
VAR PAINTIMPORTDLGCTL

VAR PAINT_IMAGE
VAR PAINT_WND
VAR PAINT_CANVAS
VAR PAINT_SCRH
VAR PAINT_SCRV
VAR PAINT_CMOUSEX
VAR PAINT_CMOUSEY
VAR PAINT_CMOUSEX2
VAR PAINT_CMOUSEY2
VAR PAINT_TOOL
VAR PAINT_ZOOM
VAR PAINT_COLOR
VAR PAINT_BACK
VAR PAINT_PAL_RLNK
VAR PAINT_PAL_GLNK
VAR PAINT_PAL_BLNK
VAR PAINT_PAL_RSCR
VAR PAINT_PAL_GSCR
VAR PAINT_PAL_BSCR
VAR PAINT_FILE
VAR PAINT_
VAR PAINT_SIZE

VAR PAINT_ZOOM_BASE
DEF PAINT_ALLOC OUT P
 P=AllocSBArray()
 VAR I
 PAINT_IMAGE=I:INC I
 PAINT_WND=I:INC I
 PAINT_CANVAS=I:INC I
 PAINT_SCRH=I:INC I
 PAINT_SCRV=I:INC I
 PAINT_CMOUSEX=I:INC I
 PAINT_CMOUSEY=I:INC I
 PAINT_CMOUSEX2=I:INC I
 PAINT_CMOUSEY2=I:INC I
 PAINT_TOOL=I:INC I
 PAINT_ZOOM=I:INC I
 PAINT_COLOR=I:INC I
 PAINT_BACK=I:INC I
 PAINT_PAL_RLNK=I:INC I
 PAINT_PAL_GLNK=I:INC I
 PAINT_PAL_BLNK=I:INC I
 PAINT_PAL_RSCR=I:INC I
 PAINT_PAL_GSCR=I:INC I
 PAINT_PAL_BSCR=I:INC I
 PAINT_FILE=I:INC I
 
 PAINT_SIZE=I:INC I
 SetSBArray P,NewArray(PAINT_SIZE)
END


VAR PAINT_MENU_NEW
VAR PAINT_MENU_OPEN
VAR PAINT_MENU_SAVE
VAR PAINT_MENU_SAVEAS
VAR PAINT_MENU_PEN
VAR PAINT_MENU_ERASER
VAR PAINT_MENU_LINE
VAR PAINT_MENU_BOX
VAR PAINT_MENU_FILLEDBOX
VAR PAINT_MENU_ZOOMIN
VAR PAINT_MENU_ZOOMOUT
VAR PAINT_MENU_HAND
VAR PAINT_MENU_PAINT
VAR PAINT_MENU_SPOIT
VAR PAINT_MENU_ABS
VAR PAINT_MENU_REL

DEF PAINT_GET WND OUT A
 GetSBArray GetWindowVar(WND,0) OUT A
END
COMMON DEF PAINTDELETE WND,CTL,TYP,A1,A2
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 
 VAR E
 DeleteImage A[PAINT_IMAGE] OUT E
 VAR FILE=A[PAINT_FILE]
 IF FILE THEN
  FreeString FILE
 ENDIF
 FreeSBArray GetWindowVar(WND,0)
END
COMMON DEF PAINTCANVASCREATE WND,CTL,TYP,A1,A2
END
COMMON DEF PAINTCANVASNOTIF WND,CTL,TYP,A1,A2
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 IF A1==A[PAINT_SCRV]THEN
  VOID RepaintWindow(WND)
 ENDIF
 IF A1==A[PAINT_SCRH]THEN
  VOID RepaintWindow(WND)
 ENDIF
END
DEF PAINTUpdateScrollBar A
 VAR WND=A[PAINT_CANVAS]
 VAR SW,SH
 SW=GetWindowWidth(WND)
 SH=GetWindowHeight(WND)
 VAR Z=A[PAINT_ZOOM]
 VAR Z#=(Z/PAINT_ZOOM_BASE)
 VAR HIMG=A[PAINT_IMAGE]
 VAR IW=GetImageWidth(HIMG)
 VAR IH=GetImageHeight(HIMG)
 SetScrollBarSize A[PAINT_SCRH],MAX(0,(IW-(SW-GetScrollBarWidth()) DIV Z#))
 SetScrollBarSize A[PAINT_SCRV],MAX(0,IH-(SH-GetScrollBarHeight()) DIV Z#)
END
COMMON DEF PAINTCANVASPAINT WND,CTL,TYP,XY,WH
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 VAR E=CallBaseControlHandler(WND,CTL,TYP,XY,WH)
 VAR SY=GetScrollBarPosition(A[PAINT_SCRV])
 VAR SX=GetScrollBarPosition(A[PAINT_SCRH])
 VAR X,Y,W,H
 VAR SW,SH
 SW=GetWindowWidth(WND)
 SH=GetWindowHeight(WND)
 IF WH THEN
  SplitInt WH OUT W,H
  SplitInt XY OUT X,Y
 ELSE
  W=SW
  H=SH
 ENDIF
 PAINTUpdateScrollBar A
 VAR Z=A[PAINT_ZOOM]
 VAR Z#=(Z/PAINT_ZOOM_BASE)
 VAR HIMG=A[PAINT_IMAGE]
 VAR IW=GetImageWidth(HIMG)
 VAR IH=GetImageHeight(HIMG)
 VAR PT=A[PAINT_TOOL]
 IF Z!=PAINT_ZOOM_BASE THEN
  IF 0THEN DIM IMG[0]

  GetImageArray(HIMG) OUT IMG,
  IF GBeginDirect(WND)THEN @ERR
  GCLIP 1,X,Y,X+W,Y+H
  VAR R,G,B
  RGBREAD A[PAINT_BACK] OUT R,G,B
  R=R XOR 255
  G=G XOR 255
  B=B XOR 255
  GCLS A[PAINT_BACK]'-1
  VAR IX,IY
  VAR Z2=Z DIV PAINT_ZOOM_BASE
  VAR IX2=SX+SW DIV Z2
  VAR IY2=SY+SH DIV Z2
  VAR DX
  VAR DY
  VAR GRC=RGB(R,G,B)
  VAR GRC2=RGB(128,128,128)

  IX2=MIN(IX2,IW-1)
  IY2=MIN(IY2,IH-1)
  GCLIP 1,MAX(0,-SX*Z#),MAX(0,-SY*Z#),MAX(0,MIN(511,(IW-SX)*Z#)),MAX(0,MIN(511,(IH-SY)*Z#))
  VAR GRX=8
  VAR GRY=8
  FOR IY=SY TO IY2
   FOR IX=SX TO IX2
    VAR C=IMG[IX+IY*IW]
    IF C AND 1THEN
     GFILL DX,DY,DX+Z2-1,DY+Z2-1,RGB((C>>11AND 31)<<3,(C>>6AND 31)<<3,(C>>1AND 31)<<3)
    ENDIF
    DX=DX+Z2
   NEXT
   IF !(IY MOD GRY) THEN
    GLINE X,DY,X+W,DY,GRC2
   ELSE
    GLINE X,DY,X+W,DY,GRC
   ENDIF
   UpdateMouse
   DY=DY+Z2
   DX=0
  NEXT
  
  FOR IX=SX TO IX2
   IF !(IX MOD GRX) THEN
    GLINE DX,Y,DX,Y+H,GRC2
   ELSE
    GLINE DX,Y,DX,Y+H,GRC
   ENDIF
   DX=DX+Z2
  NEXT
  IF GCopyDirect(WND,X,Y,X+W,Y+H,X,Y,0)THEN @ERR
 ELSE
  IF GBeginWindow(WND)THEN @ERR
  GCLSWindow WND,A[PAINT_BACK]'GetWindowBackColor(WND)
'  GFILLWindow WND,-SX,-SY,IW-SX-1,IH-SY-1,A[PAINT_BACK]
  GLOADImageWindow WND,-SX,-SY,A[PAINT_IMAGE],0
 ENDIF
 VAR CW=GetCapture()
 'tool preview
 IF CW==WND THEN
  IF PT==PAINT_MENU_LINE THEN
   GLINEWindow WND,A[PAINT_CMOUSEX]-SX*Z#,A[PAINT_CMOUSEY]-SY*Z#,A[PAINT_CMOUSEX2]-SX*Z#,A[PAINT_CMOUSEY2]-SY*Z#,A[PAINT_COLOR]
  ELSEIF PT==PAINT_MENU_BOX THEN
   GBOXWindow WND,A[PAINT_CMOUSEX]-SX*Z#,A[PAINT_CMOUSEY]-SY*Z#,A[PAINT_CMOUSEX2]-SX*Z#,A[PAINT_CMOUSEY2]-SY*Z#,A[PAINT_COLOR]
  ELSEIF PT==PAINT_MENU_FILLEDBOX THEN
   GFILLWindow WND,A[PAINT_CMOUSEX]-SX*Z#,A[PAINT_CMOUSEY]-SY*Z#,A[PAINT_CMOUSEX2]-SX*Z#,A[PAINT_CMOUSEY2]-SY*Z#,A[PAINT_COLOR]
  ENDIF
 ENDIF
 IF GEndWindow(WND)THEN @ERR
 RETURN
 @ERR
 RETURN
END
DEF PAINT_CALCCANVASPOS WND OUT CX,CY,CW,CH
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 CX=26
 CY=0
 CW=W-CX-0
 CH=H'16
END
COMMON DEF PAINTCANVASLMD WND,CTL,TYP,MX,MY
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A

 VAR Z#=(A[PAINT_ZOOM]/PAINT_ZOOM_BASE)
 VAR SY=GetScrollBarPosition(A[PAINT_SCRV])*Z#
 VAR SX=GetScrollBarPosition(A[PAINT_SCRH])*Z#
 VAR X=MX+SX
 VAR Y=MY+SY
 VAR PT=A[PAINT_TOOL]
 IF PT==PAINT_MENU_PEN||PT==PAINT_MENU_ERASER||PT==PAINT_MENU_LINE||PT==PAINT_MENU_BOX||PT==PAINT_MENU_FILLEDBOX THEN
  A[PAINT_CMOUSEX]=X
  A[PAINT_CMOUSEY]=Y
  VOID SetCapture(WND)
  PAINTCANVASMMOVE WND,CTL,TYP,MX,MY
 ELSEIF PT==PAINT_MENU_HAND THEN
  A[PAINT_CMOUSEX]=MX DIV Z#
  A[PAINT_CMOUSEY]=MY DIV Z#
  VOID SetCapture(WND)
 ELSEIF PT==PAINT_MENU_ZOOMOUT THEN
  A[PAINT_ZOOM]=MAX(A[PAINT_ZOOM]-PAINT_ZOOM_BASE*4,PAINT_ZOOM_BASE)
  VOID RepaintWindow(WND)
 ELSEIF PT==PAINT_MENU_ZOOMIN THEN
  'CLICK ちゅうしん
  VAR Z2=A[PAINT_ZOOM]+PAINT_ZOOM_BASE*4
  VAR Z2#=Z2/PAINT_ZOOM_BASE
  VAR W=(GetWindowWidth(WND)-GetScrollBarWidth())DIV Z2# DIV 2
  VAR H=(GetWindowHeight(WND)-GetScrollBarHeight())DIV Z2# DIV 2
  X=X DIV Z#
  Y=Y DIV Z#
  '?X,Y,W,H
  A[PAINT_ZOOM]=Z2
  PAINTUpdateScrollBar A
  X=MIN(GetScrollBarSize(A[PAINT_SCRH]),MAX(0,X-W))
  Y=MIN(GetScrollBarSize(A[PAINT_SCRV]),MAX(0,Y-H))
  SetScrollBarPosition A[PAINT_SCRV],Y
  SetScrollBarPosition A[PAINT_SCRH],X
  
  VOID RepaintWindow(WND)
 ELSEIF PT==PAINT_MENU_PAINT THEN
  VOID GBeginDirect(WND)
  GLOADImage 0,0,A[PAINT_IMAGE],1
  GPAINT X DIV Z#,Y DIV Z#,A[PAINT_COLOR]
  GSAVEImage 0,0,A[PAINT_IMAGE]',1
  
  VOID GEndDirect(WND)
  VOID RepaintWindow(WND)
  
 ENDIF
END
COMMON DEF PAINTCANVASLMU WND,CTL,TYP,X,Y
 VOID ReleaseCapture(WND)
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 VAR Z#=(A[PAINT_ZOOM]/PAINT_ZOOM_BASE)
 VAR SY=GetScrollBarPosition(A[PAINT_SCRV])*Z#
 VAR SX=GetScrollBarPosition(A[PAINT_SCRH])*Z#
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 X=X+SX
 Y=Y+SY
 VAR PT=A[PAINT_TOOL]
 IF PT==PAINT_MENU_LINE||PT==PAINT_MENU_FILLEDBOX||PT==PAINT_MENU_BOX THEN
  IF 0THEN DIM I[0]

  GetImageArray(A[PAINT_IMAGE]) OUT I,
  VAR IW=GetImageWidth(A[PAINT_IMAGE])
  VAR IH=GetImageHeight(A[PAINT_IMAGE])
 
  VAR C=A[PAINT_COLOR]
  IF PT==PAINT_MENU_LINE THEN
   GLINEArray I,IW,IH,A[PAINT_CMOUSEX] DIV Z#,A[PAINT_CMOUSEY] DIV Z#,X DIV Z#,Y DIV Z#,C
  ELSEIF PT==PAINT_MENU_FILLEDBOX THEN
   GFILLArray I,IW,IH,A[PAINT_CMOUSEX] DIV Z#,A[PAINT_CMOUSEY] DIV Z#,X DIV Z#,Y DIV Z#,C
  ELSEIF PT==PAINT_MENU_BOX THEN
   GBOXArray I,IW,IH,A[PAINT_CMOUSEX] DIV Z#,A[PAINT_CMOUSEY] DIV Z#,X DIV Z#,Y DIV Z#,C
  ENDIF
  PAINTCANVASPAINT WND,CTL,TYP,0,0
 ENDIF
END
COMMON DEF GFILLArray M,W,H,X,Y,X2,Y2,COL
 IF X2<X THEN SWAP X2,X
 IF Y2<Y THEN SWAP Y2,Y
 IF X2<0THEN RETURN
 IF Y2<0THEN RETURN
 IF X>=W THEN RETURN
 IF Y>=H THEN RETURN
 COL=RGBToShort(COL)
 X=MAX(0,X)
 X2=MIN(W-1,X2)
 Y=MAX(0,Y)
 Y2=MIN(H-1,Y2)
 VAR CNT=X2-X+1
 REPEAT
  FILL M,COL,X+Y*W,CNT
  Y=Y+1
 UNTIL Y2<Y
END
DIM TESTM[0]
DIM TESTCOL
DIM TESTW
DIM TESTH
DEF PLOT X,Y,C#
 IF X<0||X>=TESTW THEN RETURN
 IF Y<0||Y>=TESTH THEN RETURN
 TESTM[(0OR X)+(0OR Y)*TESTW]=RGBToShort(RGB((255*C#*255)DIV 255,(255*C#*255)DIV 255,(255*C#*255)DIV 255))
END
COMMON DEF GLINEAAArray M,W,H,X,Y,X2,Y2,COL
' IF!(X-X2)||!(Y-Y2) THEN
'  M[X+Y*W]=RGBToShort(COL)
'  RETURN
' ENDIF
 TESTM=M
 TESTW=W
 TESTH=H
 VAR STEEP=ABS(Y2-Y)>ABS(X2-X)
 IF STEEP THEN
  SWAP X,Y
  SWAP X2,Y2
 ENDIF
 IF X>X2 THEN
  SWAP X,X2
  SWAP Y,Y2
 ENDIF
 VAR DX=X2-X
 VAR DY=Y2-X
 IF DX==0 THEN
  VAR GRAD#=1
 ELSE
  GRAD#=DY/DX
 ENDIF
 VAR XEND=X
 VAR YEND#=Y+GRAD#*(XEND-X)
 VAR XGAP#=0.5'RFPART#(X2+0.5)
 VAR XPXL1=XEND
 VAR YPXL1=YEND#
 'RFPART=1-X#+FLOOR(X#)
 'RFPART=1-X+X=1
 'FPART=X#-FLOOR(X#)
 'FPART=X-X=0
 IF STEEP THEN
  PLOT YPXL1,XPXL1,(1-YEND#+FLOOR(YEND#))*XGAP#
  PLOT YPXL1+1,XPXL1,(YEND#-FLOOR(YEND#))*XGAP#
 ELSE
  PLOT XPXL1,YPXL1,(1-YEND#+FLOOR(YEND#))*XGAP#
  PLOT XPXL1,YPXL1+1,(YEND#-FLOOR(YEND#))*XGAP#
 ENDIF
 VAR INTERY#=YEND#+GRAD#
 XEND=X2
 YEND#=Y2+GRAD#*(XEND-X2)
 XGAP#=0.5
 VAR XPXL2=XEND
 VAR YPXL2=YEND#
 IF STEEP THEN
  PLOT YPXL2,XPXL2,(1-YEND#+FLOOR(YEND#))*XGAP#
  PLOT YPXL2+1,XPXL2,(YEND#-FLOOR(YEND#))*XGAP#
 ELSE
  PLOT XPXL2,YPXL2,(1-YEND#+FLOOR(YEND#))*XGAP#
  PLOT XPXL2,YPXL2+1,(YEND#-FLOOR(YEND#))*XGAP#
 ENDIF
 IF STEEP THEN
  FOR X=XPXL1+1 TO XPXL2-1
   PLOT INTERY#,X,1-INTERY#+FLOOR(INTERY#)
   PLOT INTERY#+1,X,INTERY#-FLOOR(INTERY#)
   INTERY#=INTERY#+GRAD#
  NEXT
 ELSE
  FOR X=XPXL1+1 TO XPXL2-1
   PLOT X,INTERY#,1-INTERY#+FLOOR(INTERY#)
   PLOT X,INTERY#+1,INTERY#-FLOOR(INTERY#)
   INTERY#=INTERY#+GRAD#
  NEXT
 ENDIF
END
COMMON DEF GBOXArray M,W,H,X,Y,X2,Y2,COL
 COL=RGBToShort(COL)
 IF X2<X THEN SWAP X2,X
 IF Y2<Y THEN SWAP Y2,Y
 IF X2<0THEN RETURN
 IF Y2<0THEN RETURN
 IF X>=W THEN RETURN
 IF Y>=H THEN RETURN
 VAR CNT=MIN(W-1,X2)-MAX(X,0)+1
 IF Y>=0THEN
  FILL M,COL,MAX(0,X)+Y*W,CNT
 ENDIF
 IF Y2<H THEN
  FILL M,COL,MAX(0,X)+Y2*W,CNT
 ENDIF
 Y2=MIN(H-1,Y2)
 Y=MAX(Y,0)
 CNT=Y2-Y+1
 IF X>=0&&X2<W THEN
  REPEAT
   M[X+Y*W]=COL
   M[X2+Y*W]=COL
   Y=Y+1
  UNTIL Y2<Y
 ELSEIF X>=0THEN
  REPEAT
   M[X+Y*W]=COL
   Y=Y+1
  UNTIL Y2<Y
 ELSEIF X2<W THEN
  REPEAT
   M[X2+Y*W]=COL
   Y=Y+1
  UNTIL Y2<Y
 ENDIF
END

COMMON DEF PAINTCANVASMMOVE WND,CTL,TYP,OX,OY
 IF GetCapture()!=WND THEN
  RETURN
 ENDIF
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 VAR Z#=(A[PAINT_ZOOM]/PAINT_ZOOM_BASE)
 VAR SY=GetScrollBarPosition(A[PAINT_SCRV])*Z#
 VAR SX=GetScrollBarPosition(A[PAINT_SCRH])*Z#
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR X=OX+SX
 VAR Y=OY+SY
 VAR X1=MIN(A[PAINT_CMOUSEX],X)
 VAR Y1=MIN(A[PAINT_CMOUSEY],Y)
 VAR X2=MAX(A[PAINT_CMOUSEX],X)
 VAR Y2=MAX(A[PAINT_CMOUSEY],Y)
 VAR PT=A[PAINT_TOOL]
 IF PT==PAINT_MENU_HAND THEN
  SetScrollBarPosition A[PAINT_SCRH],GetScrollBarPosition(A[PAINT_SCRH])+A[PAINT_CMOUSEX]-OX DIV Z#
  SetScrollBarPosition A[PAINT_SCRV],GetScrollBarPosition(A[PAINT_SCRV])+A[PAINT_CMOUSEY]-OY DIV Z#
  PAINTCANVASPAINT WND,CTL,TYP,0,0
  A[PAINT_CMOUSEX]=OX DIV Z#
  A[PAINT_CMOUSEY]=OY DIV Z#
 ELSEIF PT==PAINT_MENU_LINE||PT==PAINT_MENU_BOX||PT==PAINT_MENU_FILLEDBOX THEN
  A[PAINT_CMOUSEX2]=X
  A[PAINT_CMOUSEY2]=Y
  PAINTCANVASPAINT WND,CTL,TYP,0,0
 ELSEIF PT==PAINT_MENU_PEN||PT==PAINT_MENU_ERASER THEN
  IF 0THEN DIM I[0]

  GetImageArray(A[PAINT_IMAGE]) OUT I,
  VAR IW=GetImageWidth(A[PAINT_IMAGE])
  VAR IH=GetImageHeight(A[PAINT_IMAGE])
 
  VAR C=A[PAINT_COLOR]
  IF A[PAINT_TOOL]==PAINT_MENU_ERASER THEN C=0
  GLINEArray I,IW,IH,A[PAINT_CMOUSEX] DIV Z#,A[PAINT_CMOUSEY] DIV Z#,X DIV Z#,Y DIV Z#,C
 ' IF GBeginDirect(WND)THEN RETURN
 'GCLIP 1,X1,Y1,X2,Y2
 ' GLOADImage 0,0,A[PAINT_IMAGE],1
 ' GLINE A[PAINT_CMOUSEX],A[PAINT_CMOUSEY],X,Y
 ' GSAVEImage 0,0,A[PAINT_IMAGE]
  PAINTCANVASPAINT WND,CTL,TYP,0,0

  A[PAINT_CMOUSEX]=X
  A[PAINT_CMOUSEY]=Y
 ENDIF
END

COMMON DEF PAINTRESIZE WND,CTL,TYP,A1,A2
 VAR CX,CY,CW,CH
 PAINT_CALCCANVASPOS WND OUT CX,CY,CW,CH
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 VOID ResizeWindow(A[PAINT_CANVAS],CW,CH)
END
VAR PAINTNEWDLGCTL
VAR PAINTOFDID
VAR PAINTSFDID
DEF PAINT_IMPORT(WND,F1$,W,H,D)
 VAR ERR,F$
 GetSBFile F1$ OUT F$,ERR
 IF ERR THEN RETURN 1
 IF MID$(F$,0,4)!="DAT:"THEN RETURN 1
 IF D>2THEN
  RETURN 1
 ENDIF
 IF 0THEN DIM IMG[0]
 PAINT_NEW WND,W,H
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 GetImageArray A[PAINT_IMAGE] OUT IMG,ERR
 IF ERR THEN RETURN 1
 IF D==2 THEN
  DIM ARY[W,H]
  LOAD F$,ARY,FALSE
  COPY IMG,ARY
  ARY=NewArray(0)
 ELSE
  LOAD F$,IMG,FALSE
 ENDIF
 PAINT_SETFILE A,F1$
 RETURN 0
END
DEF PAINT_SETFILE A,F$
 VAR F2$=GetAbsolutePath$(F$)
 IF!A[PAINT_FILE]THEN
  A[PAINT_FILE]=AllocString(F2$)
 ELSE
  SetString A[PAINT_FILE],(F2$)
 ENDIF
END
DEF PAINT_SAVEGRP(WND,F$)
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 PAINT_SETFILE A,F$
 RETURN SaveImage(A[PAINT_IMAGE],F$)
END
DEF PAINT_LOADGRP WND,F1$
 VAR ERR,PAGE1,PAGE2,F$
 GetSBFile F1$ OUT F$,ERR
 IF ERR THEN RETURN
 IF MID$(F$,0,4)!="DAT:"THEN RETURN
 IF GBeginDirect(WND)THEN @ERR
 GetDirectGPAGE WND OUT PAGE1,PAGE2,ERR
 IF ERR THEN @ERR
 REPEAT
  VAR C=RGB(0,RND(32)*8,RND(32)*8,RND(32)*8)
 UNTIL C!=RGB(0,0,0)'|C==
 GCLS C
 
 F$="GRP"+STR$(PAGE2)+MID$(F$,3,&H7FFFFFFF)
 LOAD F$,0
 VAR WIDTH
 FOR WIDTH=0TO 511
  IF GSPOIT(WIDTH,0)==C THEN
   BREAK
  ENDIF
 NEXT
 VAR HEIGHT
 FOR HEIGHT=0TO 511
  IF GSPOIT(0,HEIGHT)==C THEN
   BREAK
  ENDIF
 NEXT
 PAINT_NEW WND,WIDTH,HEIGHT
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 IF 0THEN DIM IMG[0]

 GetImageArray A[PAINT_IMAGE] OUT IMG,
 GSAVE PAGE2,0,0,WIDTH,HEIGHT,IMG,1
 PAINT_SETFILE A,F1$
 @ERR
 IF GEndDirect(WND)THEN @ERR
END
COMMON DEF PAINTSTRNOTIF WND,C,T,A1,A2$
END
DEF PAINT_SAVEFILE WND,A1,A2
 VAR F$=GetFileDialogInfoFile$(A2)
 VAR T$=GetFileDialogInfoType$(A2)
 VOID DeleteFileDialogInfo(A2)
 IF T$=="GRP"THEN
  VAR E=PAINT_SAVEGRP(WND,F$)
 ENDIF
 IF E THEN
   VOID MessageBox(WND,"Paint","Could not save.",MessageBoxOK()OR MessageBoxError())
 ENDIF
END
DEF PAINT_OPENFILE WND,A1,A2
 VAR F$=GetFileDialogInfoFile$(A2)
 VAR T$=GetFileDialogInfoType$(A2)
 VOID DeleteFileDialogInfo(A2)
 IF T$=="GRP"THEN
  PAINT_LOADGRP WND,F$
 ELSEIF T$=="Auto"THEN
  VAR EXT$=GetFileExtension$(F$)
  ToUpper EXT$
  IF EXT$=="GRP"||EXT$=="GRPF"THEN
   'GRP
   PAINT_LOADGRP WND,F$
  ELSE
   SHOW_PAINT_IMPORT_DIALOG WND,F$
  ENDIF
 ELSE
  SHOW_PAINT_IMPORT_DIALOG WND,F$
 ENDIF
END
COMMON DEF PAINTNOTIF WND,C,T,A1,A2
 IF A1&&A1==PAINTOFDID THEN
  PAINT_OPENFILE WND,A1,A2
  RETURN
 ENDIF
 IF A1&&A1==PAINTSFDID THEN
  PAINT_SAVEFILE WND,A1,A2
  RETURN
 ENDIF
 IF A1==MenuNotifID()THEN
  PAINT_MENU WND,A2
 ENDIF
END
DEF PAINT_MENU WND,A2
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 ON A2 GOTO @ERR,@NEW,@OPEN,@SAVE,@SAVEAS,@PEN,@ERASER,@LINE,@BOX,@FILLEDBOX,@ZOOMIN,@ZOOMOUT,@HAND,@PAINT,@SPOIT,@REL,@ABS
 @ERR
 RETURN
 @NEW
 NewDialogBoxWithArg PAINTNEWDLGCTL,"New",170,35,WND,TRUE,GetWindowVar(WND,0),0 OUT ,
 RETURN
 @OPEN
  PAINTOFDID=-1
  DIM LIST$[0]
  PUSH LIST$,"Auto"
  PUSH LIST$,"GRP"
  PUSH LIST$,"Raw image"
  VOID OpenFileDialogEx(WND,"DAT",PAINTOFDID,LIST$)
 RETURN
 @SAVE
  IF A[PAINT_FILE]THEN
   VAR E=PAINT_SAVEGRP(WND,GetString$(A[PAINT_FILE]))
   IF E THEN
    VOID MessageBox(WND,"Paint","Could not save.",MessageBoxOK()OR MessageBoxError())
   ENDIF
  ELSE
   GOTO @SAVEAS
  ENDIF
 RETURN
 @SAVEAS
  PAINTSFDID=-2
  DIM LIST2$[0]
  PUSH LIST2$,"GRP"
  VOID SaveFileDialogEx(WND,"DAT",PAINTSFDID,LIST2$)
 RETURN
 @PEN
 @ERASER
 @LINE
 @BOX
 @FILLEDBOX
 @ZOOMIN
 @ZOOMOUT
 @HAND
 @PAINT
 @SPOIT
 A[PAINT_TOOL]=A2
 RETURN
 @REL
 SetMouseMode FALSE
 RETURN
 @ABS
 SetMouseMode TRUE
 RETURN
END
COMMON DEF PAINTNEWDLGCREATE WND,CTL,TYP,A1,A2
 SetWindowVar WND,0,A1
 VAR LWND,E
 
 VAR H=GetWindowHeight(WND)
 VAR W=GetWindowWidth(WND)
 VAR LABELW=64
 NewWindow GetLabelControl(),"Width",0,0,LABELW-1,8,WND,0 OUT LWND,E
 NewWindow GetLabelControl(),"Height",0,10,LABELW-1,8,WND,0 OUT LWND,E
 NewWindow GetTextBoxControl(),"400",LABELW,0,W-LABELW,8,WND,0 OUT LWND,E
 SetWindowVar WND,1,LWND
 NewWindow GetTextBoxControl(),"240",LABELW,10,W-LABELW,8,WND,0 OUT LWND,E
 SetWindowVar WND,2,LWND
 NewWindow GetButtonControl(),"OK",0,H-12,20,12,WND,0 OUT LWND,E
 SetWindowVar WND,3,LWND
 NewWindow GetButtonControl(),"Cancel",24,H-12,52,12,WND,0 OUT LWND,E
 SetWindowVar WND,4,LWND
END
COMMON DEF PAINTNEWDLGNOTIF WND,CTL,TYP,A1,A2
 VAR CANCELBTN=GetWindowVar(WND,4)
 VAR OKBTN=GetWindowVar(WND,3)
 VAR HTXTBOX=GetWindowVar(WND,2)
 VAR WTXTBOX=GetWindowVar(WND,1)
 IF A1==OKBTN THEN
  VAR H=VAL(GetWindowName$(HTXTBOX))
  VAR W=VAL(GetWindowName$(WTXTBOX))
  IF H>0&&W>0 THEN
   PAINT_NEW WND,W,H
   VOID DeleteWindow(WND)
  ELSE
   VOID MessageBox(WND,"Paint","Invalid size",MessageBoxOK()OR MessageBoxError())
  ENDIF
 ENDIF
 IF A1==CANCELBTN THEN
  VOID DeleteWindow(WND)
 ENDIF
END
DEF PAINT_NEW P,W,H
 IF 0THEN DIM A[0]
 PAINT_GET P OUT A
 IF A[PAINT_IMAGE] THEN
  VOID DeleteImage(A[PAINT_IMAGE])
 ENDIF
 VAR IMG,E
 NewImage ImageAttrPhy1Dim(),NewArray(W*H),W,H OUT IMG,E
 A[PAINT_IMAGE]=IMG
 SetScrollBarSize A[PAINT_SCRH],W
 SetScrollBarSize A[PAINT_SCRV],H
 VOID RepaintWindow(A[PAINT_CANVAS])
END
COMMON DEF PAINTCANVASBUTTON WND,CTL,TYP,A1,A2
 IF 0THEN DIM A[0]
 A=PAINT_GET(WND)
 VAR Z=A[PAINT_ZOOM]DIV PAINT_ZOOM_BASE
 IF A1 AND #LEFT THEN
  MoveMouse GetMouseX()-Z,GetMouseY()
 ENDIF
 IF A1 AND #RIGHT THEN
  MoveMouse GetMouseX()+Z,GetMouseY()
 ENDIF
 IF A1 AND #UP THEN
  MoveMouse GetMouseX(),GetMouseY()-Z
 ENDIF
 IF A1 AND #DOWN THEN
  MoveMouse GetMouseX(),GetMouseY()+Z
 ENDIF
END
VAR PAINTCOLORCTL
COMMON DEF PAINTCOLORNOTIF WND,CTL,TYP,A1,A2
 VAR N$=GetWindowName$(A1)
 
 IF IsControlExtend(GetControl(A1),GetHScrollBarControl())&&(N$=="R"||N$=="G"||N$=="B")THEN
  IF 0THEN DIM PAL[0]
  PAL=GetSBArray(GetWindowVar(WND,5))
  VAR SELC=GetWindowVar(WND,4)
  VAR OLDR,OLDG,OLDB
  RGBREAD PAL[SELC]OUT OLDR,OLDG,OLDB
  VAR R=GetScrollBarPosition(GetWindowVar(WND,1))
  VAR G=GetScrollBarPosition(GetWindowVar(WND,2))
  VAR B=GetScrollBarPosition(GetWindowVar(WND,3))

  IF 0THEN DIM A[0]
  A=PAINT_GET(WND)
  VAR RLNK=IsCheckedButton(A[PAINT_PAL_RLNK])
  VAR GLNK=IsCheckedButton(A[PAINT_PAL_GLNK])
  VAR BLNK=IsCheckedButton(A[PAINT_PAL_BLNK])
  IF N$=="R"&&!RLNK THEN
   GLNK=FALSE
   BLNK=FALSE
  ELSEIF N$=="G"&&!GLNK THEN
   RLNK=FALSE
   BLNK=FALSE
  ELSEIF N$=="B"&&!BLNK THEN
   RLNK=FALSE
   GLNK=FALSE
  ENDIF
  VAR DIFF
  IF N$=="R"THEN RLNK=FALSE:DIFF=R-OLDR DIV 8
  IF N$=="G"THEN GLNK=FALSE:DIFF=G-OLDG DIV 8
  IF N$=="B"THEN BLNK=FALSE:DIFF=B-OLDB DIV 8
  IF RLNK THEN
   R=R+DIFF
  ENDIF
  IF GLNK THEN
   G=G+DIFF
  ENDIF
  IF BLNK THEN
   B=B+DIFF
  ENDIF
  PAL[SELC]=RGB(R*8,G*8,B*8)
  PAINTPAL_SELECT WND,SELC
  IF SELC==0THEN
   A[PAINT_BACK]=PAL[0]
   VOID RepaintWindow(PAINT_GET(WND)[PAINT_CANVAS])
  ENDIF
  VOID RepaintWindow(WND)
 ENDIF
END
COMMON DEF PAINTCOLORCREATE WND,CTL,TYP,A1,A2
'--- low color palette
@PALDATA
DATA 255,255,255
DATA  63, 63, 63
DATA 255, 31,  0
DATA 255, 95,192
DATA   0, 63,240
DATA 127, 63,255
DATA   0,191,255
DATA 151, 94, 46
'
DATA 255,160,  0
DATA 255,203,167
DATA   0,127,  0
DATA   0,240, 31
DATA 255,224,  0
DATA 191,191,191
DATA   0,  0,  0
DATA 255,255,255
 VAR Y=(65 DIV 6)*6+8
 VAR X=10
 DIM PAL[66]
 FILL PAL,#BLACK
 VAR I
 RESTORE @PALDATA
 FOR I=0TO 15
  VAR R,G,B
  READ R,G,B
  PAL[I]=RGB(R,G,B)
 NEXT
 VAR A=AllocSBArray()
 SetSBArray A,PAL
 SetWindowVar WND,5,A
 SetWindowVar WND,0,A1
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 IF 0THEN DIM P[0]
 P=PAINT_GET(WND)
 P[PAINT_BACK]=PAL[0]
 VAR BW,E
 NewWindow GetToggleButtonControl(),"R",0,Y,X-1,8,WND,0 OUT BW,E
 P[PAINT_PAL_RLNK]=BW
 VAR CW
 NewWindow GetHScrollBarControl(),"R",X,Y,W-X,GetScrollBarHeight(),WND,0 OUT CW,E
 SetWindowVar WND,1,CW
 P[PAINT_PAL_RSCR]=CW
 Y=Y+10
 SetScrollBarSize CW,31
 NewWindow GetHScrollBarControl(),"G",X,Y,W-X,GetScrollBarHeight(),WND,0 OUT CW,E
 NewWindow GetToggleButtonControl(),"G",0,Y,X-1,8,WND,0 OUT BW,E
 P[PAINT_PAL_GLNK]=BW
 SetWindowVar WND,2,CW
 P[PAINT_PAL_GSCR]=CW
 Y=Y+10
 SetScrollBarSize CW,31
 NewWindow GetHScrollBarControl(),"B",X,Y,W-X,GetScrollBarHeight(),WND,0 OUT CW,E
 NewWindow GetToggleButtonControl(),"B",0,Y,X-1,8,WND,0 OUT BW,E
 P[PAINT_PAL_BLNK]=BW
 P[PAINT_PAL_BSCR]=CW
 SetWindowVar WND,3,CW
 SetScrollBarSize CW,31

 PAINTPAL_SELECT WND,14
END
DEF PAINTPAL_SELECT WND,SELC
 IF 0THEN DIM PAL[0]
 PAL=GetSBArray(GetWindowVar(WND,5))
 VAR R,G,B
 RGBREAD PAL[SELC]OUT R,G,B
 SetScrollBarPosition GetWindowVar(WND,1),R DIV 8
 SetScrollBarPosition GetWindowVar(WND,2),G DIV 8
 SetScrollBarPosition GetWindowVar(WND,3),B DIV 8
 SetWindowVar WND,4,SELC
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 IF SELC THEN
  A[PAINT_COLOR]=PAL[SELC]
 ELSE
  A[PAINT_COLOR]=RGB(0,0,0,0)
 ENDIF
END
COMMON DEF PAINTCOLORLMD WND,CTL,TYP,X,Y
 VOID SetCapture(WND)
 'RGB
 'YATTSUKE HANTEI
 
 PAINTCOLORMM WND,CTL,TYP,X,Y
END
COMMON DEF PAINTCOLORMM WND,CTL,TYP,X,Y
 IF GetCapture()!=WND THEN RETURN
 VAR SELC=GetWindowVar(WND,4)
 VAR W=GetWindowWidth(WND)
 VAR IX=X DIV 10
 VAR IY=Y DIV 6
 VAR I=IX+IY*(W DIV 10)
 IF 0>I||I>=66THEN RETURN
 IF SELC==I THEN RETURN
 IF 0THEN DIM PAL[0]
 PAL=GetSBArray(GetWindowVar(WND,5))
 PAINTPAL_SELECT WND,I
 VOID RepaintWindow(WND)
END
COMMON DEF PAINTCOLORBTN WND,CTL,TYP,BTN,A2
 VAR SELC=GetWindowVar(WND,4)
 VAR IX=SELC MOD 6
 VAR IY=SELC DIV 6
 
 IF BTN AND #UP THEN
  DEC IY
 ENDIF
 IF BTN AND #DOWN THEN
  INC IY
 ENDIF
 IF BTN AND #LEFT THEN
  DEC IX
 ENDIF
 IF BTN AND #RIGHT THEN
  INC IX
 ENDIF
 VAR W=GetWindowWidth(WND)
 VAR I=IX+IY*(W DIV 10)
 IF I<0||I>65THEN RETURN
 PAINTPAL_SELECT WND,I
 VOID RepaintWindow(WND)
END
COMMON DEF PAINTCOLORPAINTER WND,CTL,TYP,XY,WH
 IF CallBaseControlHandler(WND,CTL,TYP,XY,WH)THEN @ERR
 VAR X,Y,W,H
 VAR SW,SH
 SW=GetWindowWidth(WND)
 SH=GetWindowHeight(WND)
 IF WH THEN
  SplitInt WH OUT W,H
  SplitInt XY OUT X,Y
 ELSE
  W=SW
  H=SH
 ENDIF
X=0Y=0
  W=SW
  H=SH
 IF GBeginDirect(WND)THEN @ERR
 VAR I
 GCLIP 1,X,Y,X+W,Y+H
 GCLS GetWindowBackColor(WND)
 VAR SELC=GetWindowVar(WND,4)
 IF 0THEN DIM PAL[0]
 PAL=GetSBArray(GetWindowVar(WND,5))
 VAR R,G,B
 RGBREAD PAL[SELC]OUT R,G,B
 FOR I=0TO 65
  VAR IX=I MOD 6
  VAR IY=I DIV 6
  GFILL IX*10+1,IY*6+1,IX*10+9,IY*6+5,PAL[I]
  IF I==0THEN
   VAR SR,SG,SB
   RGBREAD PAL[I]OUT SR,SG,SB
   SR=SR XOR 255
   SG=SG XOR 255
   SB=SB XOR 255
   GLINE IX*10+1,IY*6+1,IX*10+9,IY*6+5,RGB(SR,SG,SB)
  ENDIF
  IF I==SELC THEN
   RGBREAD PAL[I]OUT SR,SG,SB
   SR=SR XOR 255
   SG=SG XOR 255
   SB=SB XOR 255
   GBOX IX*10+1,IY*6+1,IX*10+9,IY*6+5,RGB(SR,SG,SB)
'   GBOX  IX*10,IY*6,IX*10+10,IY*6+6,#BLACK
  ENDIF
 NEXT
 IY=IY*6+8
 IF 0THEN DIM A[0]
 PAINT_GET WND OUT A
 IY=IY+10
 IY=IY+10
 IY=IY+10
 GFILL W-2,IY+1,W-31,IY+20,RGB(R,G,B)
 GBOX W-2+1,IY+1-1,W-31-1,IY+20+1,RGB(0,0,0)
 VAR S$=STR$(R)
 GPUTCHR 8*3-LEN(S$)*8,IY,S$,#RED
 IY=IY+8
 S$=STR$(G)
 GPUTCHR 8*3-LEN(S$)*8,IY,S$,#GREEN
 IY=IY+8
 S$=STR$(B)
 GPUTCHR 8*3-LEN(S$)*8,IY,S$,#BLUE
 IY=IY+8
 IF GCopyDirect(WND,X,Y,X+W,Y+H,X,Y,0)THEN @ERR
 IF GEndWindow(WND)THEN @ERR
 @ERR
END
DEF SHOW_PAINT_IMPORT_DIALOG WND,FILE$
 NewDialogBoxWithArg PAINTIMPORTDLGCTL,"Import "+FILE$,170,49,WND,TRUE,GetWindowVar(WND,0),AllocString(FILE$) OUT ,
END
VAR PAINTIMPORT_WV_PAINT
VAR PAINTIMPORT_WV_FILE
VAR PAINTIMPORT_WV_OKBTN
VAR PAINTIMPORT_WV_CANCELBTN
VAR PAINTIMPORT_WV_WTXTBOX
VAR PAINTIMPORT_WV_HTXTBOX
VAR PAINTIMPORT_WV_DTXTBOX
COMMON DEF PAINTIMPORTCREATE WND,CTL,TYP,A1,A2
 PAINTIMPORT_WV_PAINT=0
 PAINTIMPORT_WV_FILE=1
 PAINTIMPORT_WV_OKBTN=2
 PAINTIMPORT_WV_CANCELBTN=3
 PAINTIMPORT_WV_WTXTBOX=4
 PAINTIMPORT_WV_HTXTBOX=5
 PAINTIMPORT_WV_DTXTBOX=6
 VAR FILE$=GetString$(A2)
 SetWindowVar WND,PAINTIMPORT_WV_PAINT,A1
 VAR ROW1=9*8
 VAR WIDTHTXTBOX,HEIGHTTXTBOX,DIMTXTBOX
 VAR OKBTN,CANCELBTN
 NewWindow GetLabelControl(),"Type     Raw image",0,0,18*8-1,7,WND,0 OUT ,
 NewWindow GetLabelControl(),"Width",0,9,5*8-1,7,WND,0 OUT ,
 NewWindow GetLabelControl(),"Height",0,19,6*8-1,7,WND,0 OUT ,
 NewWindow GetTextBoxControl(),"",ROW1,8,10*8,8,WND,0 OUT WIDTHTXTBOX,
 NewWindow GetTextBoxControl(),"",ROW1,18,10*8,8,WND,0 OUT HEIGHTTXTBOX,
 NewWindow GetLabelControl(),"Dimension",0,29,9*8-1,7,WND,0 OUT ,
 NewWindow GetTextBoxControl(),"1",ROW1,28,10*8,8,WND,0 OUT DIMTXTBOX,
 NewWindow GetButtonControl(),"OK",1,38,20,10,WND,0 OUT OKBTN,
 NewWindow GetButtonControl(),"Cancel",ROW1,38,8*6+4,10,WND,0 OUT CANCELBTN,
 SetWindowVar WND,PAINTIMPORT_WV_FILE,A2
 SetWindowVar WND,PAINTIMPORT_WV_WTXTBOX,WIDTHTXTBOX
 SetWindowVar WND,PAINTIMPORT_WV_HTXTBOX,HEIGHTTXTBOX
 SetWindowVar WND,PAINTIMPORT_WV_DTXTBOX,DIMTXTBOX
 SetWindowVar WND,PAINTIMPORT_WV_OKBTN,OKBTN
 SetWindowVar WND,PAINTIMPORT_WV_CANCELBTN,CANCELBTN
END
COMMON DEF PAINTIMPORTNOTIF WND,CTL,TYP,A1,A2
 VAR OK=GetWindowVar(WND,PAINTIMPORT_WV_OKBTN)
 IF A1==OK THEN
  VAR W=VAL(GetWindowName$(GetWindowVar(WND,PAINTIMPORT_WV_WTXTBOX)))
  VAR H=VAL(GetWindowName$(GetWindowVar(WND,PAINTIMPORT_WV_WTXTBOX)))
  VAR D=VAL(GetWindowName$(GetWindowVar(WND,PAINTIMPORT_WV_DTXTBOX)))
  IF W>0&&H>0&&D>0 THEN
   VAR STR=GetWindowVar(WND,PAINTIMPORT_WV_FILE)
   VAR ERR=PAINT_IMPORT(WND,GetString$(STR),W,H,D)
   IF ERR THEN
    VOID MessageBox(WND,"Paint","Could not import.",MessageBoxOK()OR MessageBoxError())
    RETURN
   ENDIF
  ELSE
   VOID MessageBox(WND,"Paint","Invalid size",MessageBoxOK()OR MessageBoxError())
   RETURN
  ENDIF
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
 VAR CANCEL=GetWindowVar(WND,PAINTIMPORT_WV_CANCELBTN)
 IF A1==CANCEL THEN
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
END
COMMON DEF PAINTIMPORTDELETE WND,CTL,TYP,A1,A2
 VAR STR=GetWindowVar(WND,PAINTIMPORT_WV_FILE)
 FreeString STR
END
DEF PAINT_IMPORTDLG_CTL_INIT OUT E
 ExtendControl"PAINTIMPORTDLGCTL",GetWindowControl() OUT PAINTIMPORTDLGCTL,E
 IF E THEN @ERR_CTL
 IF SetControlCreateHandler(PAINTIMPORTDLGCTL,"PAINTIMPORTCREATE")THEN @ERR_CTL
 IF SetControlNotifHandler(PAINTIMPORTDLGCTL,"PAINTIMPORTNOTIF")THEN @ERR_CTL
 IF SetControlDeleteHandler(PAINTIMPORTDLGCTL,"PAINTIMPORTDELETE")THEN @ERR_CTL
 @ERR_CTL
END

DEF PAINT_CTL_INIT OUT E
 ExtendControl "PAINT",GetWindowControl() OUT PAINTCTL,E
 IF E THEN @ERR_CTL
 IF SetControlDeleteHandler(PAINTCTL,"PAINTDELETE")THEN @ERR_CTL
 IF SetControlResizeHandler(PAINTCTL,"PAINTRESIZE")THEN @ERR_CTL
 IF SetControlNotifHandler(PAINTCTL,"PAINTNOTIF")THEN @ERR_CTL
 IF SetControlStrNotifHandler(PAINTCTL,"PAINTSTRNOTIF")THEN @ERR_CTL
 @ERR_CTL
END
DEF PAINT_CANVAS_CTL_INIT OUT E
 NewControl "PAINT_CANVAS" OUT PAINTCANVASCTL,E
 IF E THEN @ERR_CTL
 IF SetControlCreateHandler(PAINTCANVASCTL,"PAINTCANVASCREATE")THEN @ERR_CTL
 IF SetControlPainter(PAINTCANVASCTL,"PAINTCANVASPAINT")THEN @ERR_CTL
 IF SetControlMouseMoveHandler(PAINTCANVASCTL,"PAINTCANVASMMOVE")THEN @ERR_CTL
 IF SetControlLMouseDownHandler(PAINTCANVASCTL,"PAINTCANVASLMD")THEN @ERR_CTL
 IF SetControlLMouseUpHandler(PAINTCANVASCTL,"PAINTCANVASLMU")THEN @ERR_CTL
 IF SetControlNotifHandler(PAINTCANVASCTL,"PAINTCANVASNOTIF")THEN @ERR_CTL
 IF SetControlButtonHandler(PAINTCANVASCTL,"PAINTCANVASBUTTON")THEN @ERR_CTL
 @ERR_CTL
END
DEF PAINT_NEWDLG_CTL_INIT OUT E
 ExtendControl"PAINTNEWDLGCTL",GetWindowControl() OUT PAINTNEWDLGCTL,E
 IF E THEN @ERR_CTL
 IF SetControlCreateHandler(PAINTNEWDLGCTL,"PAINTNEWDLGCREATE")THEN @ERR_CTL
 IF SetControlNotifHandler(PAINTNEWDLGCTL,"PAINTNEWDLGNOTIF")THEN @ERR_CTL

 @ERR_CTL
END
DEF PAINT_COLOR_CTL_INIT OUT E
 ExtendControl"PAINTCOLORCTL",GetWindowControl() OUT PAINTCOLORCTL,E
 IF E THEN @ERR_CTL
 IF SetControlPainter(PAINTCOLORCTL,"PAINTCOLORPAINTER")THEN @ERR_CTL
 IF SetControlCreateHandler(PAINTCOLORCTL,"PAINTCOLORCREATE")THEN @ERR_CTL
 IF SetControlNotifHandler(PAINTCOLORCTL,"PAINTCOLORNOTIF")THEN @ERR_CTL
 IF SetControlLMouseDownHandler(PAINTCOLORCTL,"PAINTCOLORLMD")THEN @ERR_CTL
 IF SetControlMouseMoveHandler(PAINTCOLORCTL,"PAINTCOLORMM")THEN @ERR_CTL
 IF SetControlButtonHandler(PAINTCOLORCTL,"PAINTCOLORBTN")THEN @ERR_CTL
 @ERR_CTL
END
COMMON DEF I_PAINT
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!PAINTCTL THEN
  IF PAINT_CTL_INIT()THEN @ERR_CTL
  IF PAINT_CANVAS_CTL_INIT()THEN @ERR_CTL
  IF PAINT_NEWDLG_CTL_INIT()THEN @ERR_CTL
  IF PAINT_COLOR_CTL_INIT()THEN @ERR_CTL
  IF PAINT_IMPORTDLG_CTL_INIT()THEN @ERR_CTL
 ENDIF
 VAR COLORWND
 NewStyleWindow PAINTCTL,"PAINT",0,0,300,128,GetRootWindow(),WindowFrontFlag(),WINDOWRESIZABLESTYLE()OR WINDOWMENUSTYLE()OR WindowMinMaxStyle() OUT WND,E
 IF E THEN @ERR
 VAR CX,CY,CW,CH
 VAR CWND
 PAINT_CALCCANVASPOS WND OUT CX,CY,CW,CH
 NewWindow PAINTCANVASCTL,"",CX,CY,CW,CH,WND,WindowBackFlag() OUT CWND,E
 IF E THEN @ERR
 SetProcessVar WND
 VAR P
 PAINT_ALLOC OUT P
 SetWindowVar WND,0,P
 SetWindowVar CWND,0,P
 IF 0THEN DIM A[0]
 A=GetSBArray(P)
 A[PAINT_WND]=WND
 A[PAINT_CANVAS]=CWND
 PAINT_ZOOM_BASE=100
 A[PAINT_ZOOM]=PAINT_ZOOM_BASE
 A[PAINT_COLOR]=RGB(0,0,0)
 NewStyleWindowArg PAINTCOLORCTL,"COLOR",GetWindowWidth(GetRootWindow())-80,GetWindowY(WND),60,120,GetRootWindow(),WindowToolFlag(),WindowNarrowStyle(),P,0 OUT COLORWND,E
 'NewWindow PAINTCOLORCTL,"COLOR",GetWindowWidth(GetRootWindow())-80,GetWindowY(WND),60,120,GetRootWindow(),WindowToolFlag() OUT COLORWND,E
 IF E THEN @ERR
 JoinWindowGroup WND,COLORWND OUT E
 IF E THEN @ERR
 VAR WIDTH=400
 VAR HEIGHT=240
 VAR IMG

 VAR SCRV,SCRH
 NewHVScrollBar CWND,WIDTH,HEIGHT OUT SCRH,SCRV,E
 A[PAINT_SCRH]=SCRH
 A[PAINT_SCRV]=SCRV
 VAR CMD$
 GetCommandArg GetCommandArgsWithoutName$(GetProcessArgs$()),0 OUT CMD$,

 IF LEN(CMD$)THEN
  'LOAD CNDLINE
  PAINT_LOADGRP WND,CMD$
 ELSE
  NewImage ImageAttrPhy1Dim(),NewArray(WIDTH*HEIGHT),WIDTH,HEIGHT OUT IMG,E
  A[PAINT_IMAGE]=IMG
 ENDIF
 VAR MENU
 VAR MI=1
 NewMenu OUT MENU,E
 PAINT_MENU_NEW=MI:INC MI
 PAINT_MENU_OPEN=MI:INC MI
 PAINT_MENU_SAVE=MI:INC MI
 PAINT_MENU_SAVEAS=MI:INC MI
 PAINT_MENU_PEN=MI:INC MI
 PAINT_MENU_ERASER=MI:INC MI
 PAINT_MENU_LINE=MI:INC MI
 PAINT_MENU_BOX=MI:INC MI
 PAINT_MENU_FILLEDBOX=MI:INC MI
 PAINT_MENU_ZOOMIN=MI:INC MI
 PAINT_MENU_ZOOMOUT=MI:INC MI
 PAINT_MENU_HAND=MI:INC MI
 PAINT_MENU_PAINT=MI:INC MI
 PAINT_MENU_SPOIT=MI:INC MI
 PAINT_MENU_REL=MI:INC MI
 PAINT_MENU_ABS=MI:INC MI
 A[PAINT_TOOL]=PAINT_MENU_PEN
 AddMenuItem MENU,"New",PAINT_MENU_NEW
 AddMenuItem MENU,"Open",PAINT_MENU_OPEN
 AddMenuItem MENU,"Save",PAINT_MENU_SAVE
 AddMenuItem MENU,"Save as",PAINT_MENU_SAVEAS
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 NewMenu OUT MENU,E
 AddSubMenuItem GetWindowMenu(WND),"Tool",MENU
 AddRadioMenuItem MENU,"Pen",PAINT_MENU_PEN,TRUE
 AddRadioMenuItem MENU,"Eraser",PAINT_MENU_ERASER,FALSE
 AddRadioMenuItem MENU,"Box",PAINT_MENU_BOX,FALSE
 AddRadioMenuItem MENU,"Filled box",PAINT_MENU_FILLEDBOX,FALSE
 AddRadioMenuItem MENU,"Line",PAINT_MENU_LINE,FALSE
 AddRadioMenuItem MENU,"Zoom in",PAINT_MENU_ZOOMIN,FALSE
 AddRadioMenuItem MENU,"Zoom out",PAINT_MENU_ZOOMOUT,FALSE
 AddRadioMenuItem MENU,"Hand",PAINT_MENU_HAND,FALSE
 AddRadioMenuItem MENU,"Paint",PAINT_MENU_PAINT,FALSE
 AddRadioMenuItem MENU,"GSPOIT",PAINT_MENU_SPOIT,FALSE
 AddMenuItemSeparator MENU
 AddMenuItem MENU,"Pen",0
 NewMenu OUT MENU,E
 AddSubMenuItem GetWindowMenu(WND),"Mouse",MENU
 AddRadioMenuItem MENU,"Relative",PAINT_MENU_REL,TRUE
 AddRadioMenuItem MENU,"Absolute",PAINT_MENU_ABS,FALSE

 RETURN
 
 @ERR_CTL
  VOID DeleteControl(PAINTCTL)
  VOID DeleteControl(PAINTCANVASCTL)
  ExitProcess 1
  RETURN
 @ERR
  VOID DeleteWindow(WND)
  VOID DeleteWindow(COLORWND)
  VOID DeleteWindow(CWND)
  ExitProcess 1
END
COMMON DEF L_PAINT
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR EYESCTL
DEF DrawFilledCircle WND,X,Y,W,H,COL
 DrawStrokedCircle WND,X,Y,W,H,MIN(W,H),COL
END
DEF DrawStrokedCircle WND,X,Y,W,H,S,COL
 VAR R=180 DIV 20
 VAR I
 VAR X#=W/2
 VAR Y#=H/2
 VAR OX,OY,F
 VAR SX#=X#-S
 VAR SY#=Y#-S
 VAR OX2,OY2
' IF X#-X THEN STOP
' W=W-(X#-X)
 'FOR I=90TO 270 STEP R'359 STEP R
 FOR I=00TO 360 STEP R'359 STEP R
  VAR NX=X+COS(RAD(I))*X#,NY=Y+SIN(RAD(I))*Y#
  VAR NX2=X+COS(RAD(I))*SX#,NY2=Y+SIN(RAD(I))*SY#
  IF F THEN
'   GTRIWindow WND,NX,NY,OX,OY,NX2,NY2,COL
'   GTRIWindow WND,NX2,NY2,OX2,OY2,OX,OY,COL
   GTRI NX,NY,OX,OY,NX2,NY2,COL
   GTRI NX2,NY2,OX2,OY2,OX,OY,COL
'   GTRIWindow WND,W-NX,NY,W-OX,OY,W-NX2,NY2,COL
'   GTRIWindow WND,W-NX2,NY2,W-OX2,OY2,W-OX,OY,COL
  ENDIF
  OX=NX
  OY=NY
  OX2=NX2
  OY2=NY2
  F=TRUE
 NEXT
END
COMMON DEF EYESPainter WND,CTL,TYP,XY,WH
 IF CallBaseControlHandler(WND,CTL,TYP,XY,WH)THEN @ERR
 EYESPaint WND
 @ERR
END
DEF EYESDrawEye WND,CX,CY,CW,CH,ERASE
 IF!CH||!CW THEN
  RETURN
 ENDIF
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 VAR EW=WIDTH DIV 2

 VAR MIN=MIN(EW,HEIGHT)
 VAR EYEH=MIN DIV 5
 VAR EYEW=MIN DIV 8
 
 
 VAR COLOR=#BLACK
 VAR AX=GetWindowAX(WND)
 VAR AY=GetWindowAY(WND)
 IF!ERASE THEN
  VAR MX=GetMouseX()
  VAR MY=GetMouseY()
  SetWindowVar WND,0,MX
  SetWindowVar WND,1,MY
 ELSE
  GetWindowVar WND,0OUT MX
  GetWindowVar WND,1OUT MY
  COLOR=#WHITE
 ENDIF
'VAR EYEH=MIN DIV 7
 VAR ACX=AX+CX'absolute center
 VAR ACY=AY+CY'absolute center
 VAR MX#=ATAN(MY-ACY,MX-ACX)
 VAR D#=POW((MX-ACX)/(CW/CH),2)+POW(MY-ACY,2)
 VAR D2#=POW((COS(MX#)*CW)/(CW/CH),2)+POW(SIN(MX#)*CH,2)
 IF D2#>D# THEN
  IF ERASE THEN
   'FAST!
   GFILL MX-AX-EYEW DIV 2-1,MY-AY-EYEH DIV 2-1,MX-AX+EYEW DIV 2+1,MY-AY+EYEH DIV 2+1,#WHITE
   RETURN
  ENDIF
  DrawFilledCircle WND,MX-AX,MY-AY,EYEW,EYEH,COLOR
 ELSE
  MX#=ATAN(MY-ACY,(MX-ACX)/(CW/CH))
  IF ERASE THEN
   'FAST!
   GFILL COS(MX#)*CW+CX-EYEW DIV 2-1,SIN(MX#)*CH+CY-EYEH DIV 2-1,COS(MX#)*CW+CX+EYEW DIV 2+1,SIN(MX#)*CH+CY+EYEH DIV 2+1,#WHITE
   RETURN
  ENDIF
  DrawFilledCircle WND,COS(MX#)*CW+CX,SIN(MX#)*CH+CY,EYEW,EYEH,COLOR
 ENDIF
END
COMMON DEF EYESUpdateEyes WND
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 IF HEIGHT<0THEN RETURN
 IF GBeginDirect(WND)THEN @ERR
 GCLIP 1,0,0,WIDTH,HEIGHT
 GCLS
 VAR EW=WIDTH DIV 2
 VAR CX1=EW DIV 2
 VAR CY1=HEIGHT DIV 2
 VAR CX2=WIDTH DIV 2+EW/2
 VAR CY2=HEIGHT/2
 EYESDrawEye WND,CX1,CY1,EW DIV 4,HEIGHT DIV 4,TRUE
 EYESDrawEye WND,CX2,CY2,EW DIV 4,HEIGHT DIV 4,TRUE
 
 EYESDrawEye WND,CX1,CY1,EW DIV 4,HEIGHT DIV 4,FALSE
 EYESDrawEye WND,CX2,CY2,EW DIV 4,HEIGHT DIV 4,FALSE

 IF GCopyDirect(WND,0,0,WIDTH,HEIGHT,0,0,0)THEN:ENDIF
 IF GEndWindow(WND)THEN @ERR
 @ERR
 
END
COMMON DEF EYESPaint WND
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 IF HEIGHT<0THEN
  VOID GEndWindow(WND)
  RETURN
 ENDIF
 IF GBeginDirect(WND)THEN @ERR
 'IF GBeginWindow(WND)THEN @ERR
 GCLIP 1,0,0,WIDTH,HEIGHT
 GCLS GetWindowBackColor(WND)
 VAR EW=WIDTH DIV 2
 VAR CX=EW DIV 2
 VAR CY=HEIGHT DIV 2
 EYESDrawEye WND,CX,CY,EW DIV 4,HEIGHT DIV 4,FALSE

 
 VAR MIN=MIN(EW,HEIGHT)
 DrawStrokedCircle WND,CX,CY,EW,HEIGHT,MIN/10,#BLACK
 CX=WIDTH DIV 2+EW/2
 CY=HEIGHT/2
 DrawStrokedCircle WND,CX,CY,EW,HEIGHT,MIN/10,#BLACK
 EYESDrawEye WND,CX,CY,EW DIV 4,HEIGHT DIV 4,FALSE

 UpdateMouse
 IF GCopyDirect(WND,0,0,WIDTH,HEIGHT,0,0,0)THEN @ERR
 IF GEndWindow(WND)THEN @ERR
 RETURN
 @ERR
END
COMMON DEF I_EYES
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!EYESCTL THEN
  ExtendControl "eyes",GetWindowControl() OUT EYESCTL,E
  SetControlPainter EYESCTL,"EYESPainter" OUT E
 ENDIF
 NewTopLevelStyleWindow EYESCTL,"eyes",64,64,WINDOWRESIZABLESTYLE()OR WindowMinMaxStyle()OR WindowDisableMaxStyle() OUT WND,E
 SetWindowBackColor WND,#WHITE
 SetProcessVar WND
END
COMMON DEF L_EYES
 VAR W=GetProcessVar()
 IF GetMouseX()!=GetWindowVar(W,0)||GetMouseY()!=GetWindowVar(W,1)THEN
  EYESUpdateEyes W
 ENDIF
 IF UpdateWindow(W)THEN ExitProcess 1
END
VAR WINLISTCTL

DEF WINLIST_Update LISTBOX
 ClearListBox LISTBOX
 VAR W=GetRootWindow()
 WINLIST_Add LISTBOX,W,""
END
DEF WINLIST_Add LISTBOX,WND,P$
 WHILE WND
  VAR C=GetChildWindow(WND)
  VAR N=GetNextWindow(WND)
  IF N THEN
   AddListBoxItem LISTBOX,P$+""+GetControlName$(GetControl(WND))+":"+GetWindowName$(WND)
   IF C THEN WINLIST_Add LISTBOX,C,P$+""
  ELSE
   AddListBoxItem LISTBOX,P$+""+GetControlName$(GetControl(WND))+":"+GetWindowName$(WND)
   IF C THEN WINLIST_Add LISTBOX,C,P$+" "
  ENDIF
  WND=N
 WEND
END
COMMON DEF WINLISTNOTIF WND,CTL,TYP,A1,A2
 IF A1==MenuNotifID()&&A2==1THEN
  WINLIST_Update GetWindowVar(WND,0)
 ENDIF
END
COMMON DEF WINLISTRESIZE WND,CTL,TYP,A1,A2
 VOID ResizeWindow(GetWindowVar(WND,0),GetWindowWidth(WND),GetWindowHeight(WND))
END
COMMON DEF I_WINLIST
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!WINLISTCTL THEN
  ExtendControl "Window list",GetWindowControl() OUT WINLISTCTL,E
  IF SetControlResizeHandler(WINLISTCTL,"WINLISTRESIZE")THEN @ERR_CTL
  IF SetControlNotifHandler(WINLISTCTL,"WINLISTNOTIF")THEN @ERR_CTL
 ENDIF
 NewTopLevelStyleWindow WINLISTCTL,"Window list",128,128,WINDOWRESIZABLESTYLE()OR WINDOWMENUSTYLE()OR WindowMinMaxStyle() OUT WND,E
 SetProcessVar WND
 VAR LB
 NewWindow GetListBoxControl(),"",0,0,128,128,WND,0 OUT LB,E
 WINLIST_Update LB
 SetWindowVar WND,0,LB
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"Update",1
 AddSubMenuItem GetWindowMenu(WND),"View",MENU
 
END
COMMON DEF L_WINLIST
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR OTWFREEMEMCTL
COMMON DEF OTWFREEMEMPainter WND,CTL,TYP,XY,WH
 IF CallBaseControlHandler(WND,CTL,TYP,XY,WH)THEN @ERR
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR MFR=8192*1024
 GFILLWindow WND,0,H-8,MFR/MFR*W,H-1,RGB(00,00,00)
 GFILLWindow WND,0,H-8,GetMemorySize1()/MFR*W,H-1,RGB(96,96,96)
 GPRINTPWindow WND,W-LEN("SMILEBASIC")*6,H-8,"SMILEBASIC",#WHITE
 GFILLWindow WND,0,H-8,GetMemorySize()/MFR*W,H-1,RGB(128,0,0)
 GPRINTPWindow WND,FREEMEM/MFR*W,H-8,"USED",#WHITE
 GFILLWindow WND,0,H-8,FREEMEM/MFR*W,H-1,RGB(0,128,0)
 GPRINTPWindow WND,0,H-8,"FREE",#WHITE
 @ERR
END
DEF OTWFREEMEM_FORMAT$(F)
 VAR KIB#=F/1024
 VAR MIB#=KIB#/1024
 IF MIB#>=1THEN
  RETURN FORMAT$("%.2FMiB",MIB#)
 ENDIF
 IF KIB#>=1THEN
  RETURN FORMAT$("%.2FKiB",KIB#)
 ENDIF
 RETURN FORMAT$("%DB",F)
END
DEF OTWFREEMEM$(FM)
 RETURN OTWFREEMEM_FORMAT$(FM)+"/"+OTWFREEMEM_FORMAT$(GetMemorySize())
END
VAR OTWFMEM_WV_MEM
VAR OTWFMEM_WV_LABEL
COMMON DEF I_OTWFREEMEM
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTWFREEMEMCTL THEN
  ExtendControl "FREEMEM",GetWindowControl() OUT OTWFREEMEMCTL,E
  SetControlPainter OTWFREEMEMCTL,"OTWFREEMEMPainter" OUT E
 ENDIF
 VAR W
 IF 0&&HARDWARE==0||HARDWARE==1THEN
  W=56*2-1+8'LEN("8.XXMiB")*8
 ELSE'WiiU?
  W=88*2-1+8'LEN("128.XXMiB")*8
 ENDIF
 NewTopLevelStyleWindow OTWFREEMEMCTL,"FREEMEM",W,20,WindowMinMaxStyle()OR WindowDisableMaxStyle() OUT WND,E
 VAR LABEL
 VAR FM=FREEMEM
 NewWindow GetLabelControl(),OTWFREEMEM$(FM),0,1,W,7,WND,0 OUT LABEL,E
 SetLabelAlignRight LABEL
 SetProcessVar WND
 OTWFMEM_WV_MEM=0
 OTWFMEM_WV_LABEL=1
 SetWindowVar WND,OTWFMEM_WV_MEM,FM
 SetWindowVar WND,OTWFMEM_WV_LABEL,LABEL
END
COMMON DEF L_OTWFREEMEM
 VAR WND=GetProcessVar()
 IF GetWindowVar(WND,OTWFMEM_WV_MEM)!=FREEMEM THEN
  VAR FM=FREEMEM
  VAR L=GetWindowVar(WND,OTWFMEM_WV_LABEL)
  SetWindowName L,OTWFREEMEM$(FM)
  VOID RepaintWindow(L)
  SetWindowVar WND,OTWFMEM_WV_MEM,FM
 ENDIF
 IF UpdateWindow(WND)THEN ExitProcess 1
END
'[MOD:DLGED]
VAR DLGEDCTL
VAR DLGED_DLGCTL
VAR DLGED_CONTENTCTL
VAR DLGED_BTNCTL
VAR DLGED_LBLCTL
VAR DLGED_TXTBXCTL
VAR DLGED_DLGWV_OWNER
VAR DLGED_MENU_NEW
VAR DLGED_MENU_OPN
VAR DLGED_MENU_SAS
VAR DLGED_MENU_SAV
VAR DLGED_MENU_ADD
VAR DLGED_MENU_BTN
VAR DLGED_MENU_TXT
VAR DLGED_MENU_TBX
VAR DLGED_MENU_ABT

VAR DLGED_MENU_EDITTEXT
VAR DLGED_MENU_PROP
VAR DLGED_MENU_DEL
VAR DLGED_MENU_COPY
VAR DLGED_MENU_CUT

VAR DLGED_WV_PAINTQUEUE
VAR DLGED_WV_MENU
VAR DLGED_WV_DLG
'==GLOBAL STATE==
VAR G_DLGED_DRAG
VAR G_DLGED_DRAGWND
VAR G_DLGED_DRAGOX
VAR G_DLGED_DRAGOY
VAR G_DLGED_DRAGMX
VAR G_DLGED_DRAGMY
VAR G_DLGED_DRAGOW
VAR G_DLGED_DRAGOH
'==GLOBAL STATE==
COMMON DEF DLGED_CONTENTCTLPAINTQUEUE WND,CTL,TYP,XY,WH
 IF CallBaseControlHandler(WND,CTL,TYP,XY,WH)THEN @ERR
 SetWindowVar GetProcessVar(),DLGED_WV_PAINTQUEUE,TRUE
END
COMMON DEF DLGED_CONTENTCTLPAINT WND,CTL,TYP,XY,WH
 'IF CallBaseControlHandler(WND,CTL,TYP,XY,WH)THEN @ERR
 VOID GBeginWindow(WND)
 VAR X,Y,W,H
 VAR SW,SH
 SW=GetWindowWidth(WND)
 SH=GetWindowHeight(WND)
 IF WH THEN
  SplitInt WH OUT W,H
  SplitInt XY OUT X,Y
 ELSE
  W=SW
  H=SH
 ENDIF
 GFILLWindow WND,X,Y,X+W,Y+H,GetWindowBackColor(WND)
 'GBOXWindow WND,X,Y,X+W,Y+H,#BLACK
 VOID GEndWindow(WND)
END

DEF DLGEDMOUSEDWN(WND,X,Y,CAPWND,MOVONLY)

 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR PW=GetParentWindow(WND)
 VAR BX=0'GetWindowX(PW)
 VAR BY=0'GetWindowY(PW)
 X=X+BX
 Y=Y+BY
 VAR X1,Y1,X2,Y2,X3,Y3
 DLGED_CALC WND,BX,BY OUT X1,Y1,X2,Y2,X3,Y3
 '?X,Y,X1,Y1,X2,Y2,X3,Y3
 VAR S=4
 VAR CENTER=DLGED_HASCENTER(W,H)

 VAR FX1=X>=X1-S&&X<=X1+S
 VAR FY1=Y>=Y1-S&&Y<=Y1+S
 VAR FX3=X>=X2-S&&X<=X2+S
 VAR FY3=Y>=Y2-S&&Y<=Y2+S
 VAR FX2=CENTER&&X>=X3-S&&X<=X3+S
 VAR FY2=CENTER&&Y>=Y3-S&&Y<=Y3+S
 VAR F=0
 IF FX1&&FY1 THEN F=1
 IF FX2&&FY1 THEN F=2
 IF FX3&&FY1 THEN F=3
 IF FX3&&FY2 THEN F=4
 IF FX3&&FY3 THEN F=5
 IF FX2&&FY3 THEN F=6
 IF FX1&&FY3 THEN F=7
 IF FX1&&FY2 THEN F=8
 IF!F||MOVONLY THEN
  VAR _X=GetWindowX(WND)
  VAR _Y=GetWindowY(WND)
  IF X>=_X&&Y>=_Y&&X<=_X+W&&Y<=_Y+H THEN
   G_DLGED_DRAG=-1
   VOID SetCapture(CAPWND)
   G_DLGED_DRAGWND=WND
   G_DLGED_DRAGOX=GetWindowX(WND)
   G_DLGED_DRAGOY=GetWindowY(WND)
   G_DLGED_DRAGMX=-X+G_DLGED_DRAGOX
   G_DLGED_DRAGMY=-Y+G_DLGED_DRAGOY
   G_DLGED_DRAGOW=GetWindowWidth(WND)
   G_DLGED_DRAGOH=GetWindowHeight(WND)
  ENDIF
  RETURN 0
 ENDIF
 F=0
 IF FX1 THEN F=F OR 1
 IF FY1 THEN F=F OR 2
 IF FX2 THEN F=F OR 4
 IF FY2 THEN F=F OR 8
 IF FX3 THEN F=F OR 16
 IF FY3 THEN F=F OR 32
 IF F THEN
  G_DLGED_DRAG=F
  VOID SetCapture(CAPWND)
  G_DLGED_DRAGWND=WND
  G_DLGED_DRAGOX=GetWindowX(WND)
  G_DLGED_DRAGOY=GetWindowY(WND)
  G_DLGED_DRAGMX=-X+G_DLGED_DRAGOX
  G_DLGED_DRAGMY=-Y+G_DLGED_DRAGOY
  G_DLGED_DRAGOW=W
  G_DLGED_DRAGOH=H
 ENDIF
 RETURN 1
END
'
'  X1  X3    X2
'Y1 123 
'           
'           
'Y3 8       4 
'           
'           
'Y2 765 
'              
DEF DLGED_CALC CW,BX,BY OUT _X1,_Y1,_X2,_Y2,_X3,_Y3
 VAR X=BX+GetWindowX(CW)
 VAR Y=BY+GetWindowY(CW)
 VAR W=GetWindowWidth(CW)
 VAR H=GetWindowHeight(CW)
 
 VAR S=1
 VAR W1,H1,W2,H2,E
 GetWindowFrameSize CW OUT W1,H1,W2,H2,E
 DEC X,W1
 DEC Y,H1
 INC W,W2+W1
 INC H,H2+H1
 VAR X3=X+W DIV 2
 VAR Y3=Y+H DIV 2
 _X1=X
 _Y1=Y
 _X3=X3
 _Y3=Y3
 _X2=X+W
 _Y2=Y+H
END
COMMON DEF DLGED_CTLRMOUSEUP WND,CTL,TYP,A1,A2
 VAR PARENT=GetParentWindow(WND)
 VAR OWNER=GetWindowVar(PARENT,DLGED_DLGWV_OWNER)
 VAR MENU=GetWindowVar(OWNER,DLGED_WV_MENU)
 'DESELECT
 DLGED_DESELECT WND
 SetProp WND,"DLGED",TRUE
 SetWindowVar GetProcessVar(),DLGED_WV_PAINTQUEUE,TRUE
 
 ShowContextMenu MENU,OWNER
END
COMMON DEF DLGED_CTLMOUSEUP WND,CTL,TYP,A1,A2
' IF GetCapture()==WND THEN
  VOID ClearWindowMoveFrame(WND)
' ENDIF
 G_DLGED_DRAG=0
END
COMMON DEF DLGED_DLGMOUSEUP WND,CTL,TYP,A1,A2
' IF GetCapture()==WND THEN
  VOID ClearWindowMoveFrame(WND)
' ENDIF
 G_DLGED_DRAG=0
END
DEF DLGED_DESELECT WND
 VAR CW=GetChildWindow(GetParentWindow(WND))
 VAR RP
 WHILE CW
  IF WND!=CW THEN
   IF SetProp2(CW,"DLGED",FALSE) THEN
    RP=TRUE
   ENDIF
  ENDIF
  CW=GetNextWindow(CW)
 WEND
 IF RP THEN
  VOID RepaintWindow(GetParentWindow(WND))
  CW=GetChildWindow(GetParentWindow(WND))
  WHILE CW
   VOID RepaintWindow(CW)
   CW=GetNextWindow(CW)
  WEND
 ENDIF
 
END
COMMON DEF DLGED_CTLMOUSEDWN WND,CTL,TYP,A1,A2
 DLGED_DESELECT WND

 IF!SetProp2(WND,"DLGED",TRUE)THEN
  SetWindowVar GetProcessVar(),0,TRUE
  VOID DLGEDMOUSEDWN(WND,GetWindowX(WND)+A1,GetWindowY(WND)+A2,WND,TRUE)
 ELSE
  VOID DLGEDMOUSEDWN(WND,GetWindowX(WND)+A1,GetWindowY(WND)+A2,WND,FALSE)
 ENDIF
 
END
COMMON DEF DLGED_DLGMOUSEDWN WND,CTL,TYP,A1,A2
 VAR CW1=WND
 VAR BX=GetWindowX(CW1)
 VAR BY=GetWindowY(CW1)
 VAR CW=GetChildWindow(CW1)
 VAR CLK=FALSE
 VAR ADDITEM=TRUE
 WHILE CW
  VAR CX=GetWindowX(CW)
  VAR CY=GetWindowY(CW)
  IF GetProp(CW,"DLGED")THEN
   CLK=DLGEDMOUSEDWN(CW,A1,A2,WND,FALSE)||CLK
   ADDITEM=FALSE
  ENDIF
  CW=GetNextWindow(CW)
 WEND
 IF!CLK THEN
  CW=GetChildWindow(CW1)
  WHILE CW
   SetProp CW,"DLGED",FALSE
   VOID RepaintWindow(CW)
   CW=GetNextWindow(CW)
  WEND
  VOID RepaintWindow(WND)
 ENDIF
 IF ADDITEM THEN
  VAR OWNERWND=GetWindowVar(WND,DLGED_DLGWV_OWNER)
  VAR MENU=GetWindowMenu(OWNERWND)
  VAR ID
  GetSubMenuByID MENU,DLGED_MENU_ADD OUT MENU
  GetCheckedRadioMenuItem MENU,DLGED_MENU_BTN OUT ID
  VAR W,H
  VAR TXT$
  VAR ECTL
  IF ID==DLGED_MENU_BTN THEN
   ECTL=DLGED_BTNCTL
   TXT$="BUTTON"
   W=48
   H=14
  ELSEIF ID==DLGED_MENU_TXT THEN
   ECTL=DLGED_LBLCTL
   TXT$="TEXT"
   W=48
   H=7
  ELSEIF ID==DLGED_MENU_TBX THEN
   ECTL=DLGED_TXTBXCTL
   TXT$="TEXTBOX"
   W=48
   H=10
  ENDIF
  NewWindow ECTL,TXT$,A1-W DIV 2,A2-H DIV 2,W,H,WND,WindowFrontFlag() OUT ,
 ENDIF
END
COMMON DEF DLGED_DLGMOUSEMOV WND,CTL,TYP,A1,A2
 DLGED_CTLMOUSEMOV WND,CTL,TYP,A1-G_DLGED_DRAGOX,A2-G_DLGED_DRAGOY
END
COMMON DEF DLGED_CTLMOUSEMOV WND,CTL,TYP,A1,A2
 
 IF GetCapture()==WND THEN
  IF WND==G_DLGED_DRAGWND THEN
   A1=GetWindowX(WND)+A1-G_DLGED_DRAGOX
   A2=GetWindowY(WND)+A2-G_DLGED_DRAGOY
  ENDIF
  IF G_DLGED_DRAG THEN
   VAR W=G_DLGED_DRAGOW
   VAR H=G_DLGED_DRAGOH
   VAR DX=0
   VAR DY=0
   VAR DW=W
   VAR DH=H
   IF G_DLGED_DRAG AND 1THEN
    DX=G_DLGED_DRAGMX+A1
    DW=W-A1
   ENDIF
   IF G_DLGED_DRAG AND 2THEN
    DY=G_DLGED_DRAGMY+A2
    DH=H-A2
   ENDIF
   IF G_DLGED_DRAG AND 32THEN
    DH=H+G_DLGED_DRAGMY+A2
   ENDIF
   IF G_DLGED_DRAG AND 16THEN
    DW=W+G_DLGED_DRAGMX+A1
   ENDIF
   VAR _X,_Y
   IF G_DLGED_DRAG==-1THEN
    DW=W
    DH=H
   ENDIF
   VAR SC=4'GRID SIZE
   VAR SIZ=1
   VOID MoveResizeWindow(G_DLGED_DRAGWND,ROUND((G_DLGED_DRAGOX+DX)/SC)*SC,ROUND((G_DLGED_DRAGOY+DY)/SC)*SC,ROUND(DW/SC)*SC-SIZ,ROUND(DH/SC)*SC-SIZ)
  ENDIF
 ENDIF
END
DEF DLGED_HASCENTER(W,H)
 RETURN H>=14
END
COMMON DEF DLGED_CONTENTCTLPAINT2 WND,CTL,TYP,XY,WH
 VOID GBeginWindow(WND)
 VAR CW1=WND
 VAR BX=0'GetWindowX(CW1)
 VAR BY=0'GetWindowY(CW1)
 VAR CW=GetChildWindow(CW1)
 WHILE CW
  IF!GetProp(CW,"DLGED")THEN
   CW=GetNextWindow(CW)
   CONTINUE
  ENDIF
  VAR X=BX+GetWindowX(CW)
  VAR Y=BY+GetWindowY(CW)
  VAR W=GetWindowWidth(CW)
  VAR H=GetWindowHeight(CW)
  
  VAR S=1
  VAR W1,H1,W2,H2,E
  GetWindowFrameSize CW OUT W1,H1,W2,H2,E
  DEC X,W1
  DEC Y,H1
  INC W,W2+W1
  INC H,H2+H1
  VAR X3=X+W DIV 2
  VAR Y3=Y+H DIV 2
  VAR CENTER=DLGED_HASCENTER(W,H)
  GFILLWindow WND,X-S,Y-S,X+S,Y+S,#BLACK
  GFILLWindow WND,X+W-S,Y-S,X+W+S,Y+S,#BLACK
  GFILLWindow WND,X+W-S,Y+H-S,X+W+S,Y+H+S,#BLACK
  GFILLWindow WND,X-S,Y+H-S,X+S,Y+H+S,#BLACK

  IF CENTER THEN
   GFILLWindow WND,X3-S,Y-S,X3+S,Y+S,#BLACK
   GFILLWindow WND,X+W-S,Y3-S,X+W+S,Y3+S,#BLACK
   GFILLWindow WND,X-S,Y3-S,X+S,Y3+S,#BLACK
   GFILLWindow WND,X3-S,Y+H-S,X3+S,Y+H+S,#BLACK
  ENDIF
  CW=GetNextWindow(CW)
 WEND
 @ERR
 VOID GEndWindowEx(WND,FALSE)
END

VAR DLGED_IMG
COMMON DEF DLGED_PAINT WND,CTL,TYP,XY,WH
 IF CallBaseControlHandler(WND,CTL,TYP,XY,WH)THEN @ERR
 VOID GBeginWindow(WND)
 'GLOADImageWindow WND,0,0,DLGED_IMG,0
 VOID GEndWindow(WND)
 @ERR
END
DEF DLGED_DELETEITEM WND
 VAR DLGWND=GetWindowVar(WND,DLGED_WV_DLG)
 VAR CW=GetChildWindow(DLGWND)
 WHILE CW
  IF GetProp(CW,"DLGED")THEN
   VAR DEL=CW
   CW=GetNextWindow(CW)
   VOID DeleteWindow(DEL)
   CONTINUE
  ENDIF
  CW=GetNextWindow(CW)
 WEND
END
COMMON DEF DLGED_NOTIF WND,C,T,A1,A2
 IF A1==MenuNotifID()THEN
  IF A2==DLGED_MENU_DEL THEN
   DLGED_DELETEITEM WND
  ENDIF
 ENDIF
END
COMMON DEF DLGED_RESIZE WND,C,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 VAR CHILD=FindWindowByControl(WND,DLGED_CONTENTCTL,FALSE)
 IF!CHILD THEN RETURN
 VOID ResizeWindow(CHILD,W-GetWindowX(CHILD),H-GetWindowY(CHILD))
END
DEF DLGED_EXTENDCTL(CTL)
 VAR E,ECTL
 ExtendControl "DLGED_BTN",CTL OUT ECTL,E
 IF E THEN @E
 IF SetControlLMouseDownHandler(ECTL,"DLGED_CTLMOUSEDWN")THEN @E
 IF SetControlLMouseUpHandler(ECTL,"DLGED_CTLMOUSEUP")THEN @E
 IF SetControlRMouseUpHandler(ECTL,"DLGED_CTLRMOUSEUP")THEN @E
 IF SetControlMouseMoveHandler(ECTL,"DLGED_CTLMOUSEMOV")THEN @E
 RETURN ECTL
 @E
 E=DeleteControl(ECTL)
 RETURN 0
END
COMMON DEF I_DLGED
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!DLGEDCTL THEN
  ExtendControl "DLGED",GetWindowControl() OUT DLGEDCTL,E
  E=SetControlPainter(DLGEDCTL,"DLGED_PAINT")
  E=SetControlNotifHandler(DLGEDCTL,"DLGED_NOTIF")
  E=SetControlResizeHandler(DLGEDCTL,"DLGED_RESIZE")
  NewControl "DLGED_CONTENT" OUT DLGED_CONTENTCTL,E
  E=SetControlPainter(DLGED_CONTENTCTL,"DLGED_CONTENTCTLPAINT")
  ExtendControl "DLGED_DLGCTL",GetWindowControl() OUT DLGED_DLGCTL,E
  E=SetControlPainter(DLGED_DLGCTL,"DLGED_CONTENTCTLPAINTQUEUE")
  E=SetControlLMouseDownHandler(DLGED_DLGCTL,"DLGED_DLGMOUSEDWN")
  E=SetControlMouseMoveHandler(DLGED_DLGCTL,"DLGED_DLGMOUSEMOV")
' E=SetControlClickFrameHandler(DLGED_DLGCTL,"")
' E=SetControlMMoveFrameHandler(DLGED_DLGCTL,"")

  E=SetControlLMouseUpHandler(DLGED_DLGCTL,"DLGED_DLGMOUSEUP")
  DLGED_BTNCTL=DLGED_EXTENDCTL(GetButtonControl())
  DLGED_LBLCTL=DLGED_EXTENDCTL(GetLabelControl())
  DLGED_TXTBXCTL=DLGED_EXTENDCTL(GetTextBoxControl())
 ENDIF
 VAR CNTWND
 NewTopLevelStyleWindow DLGEDCTL,"DLGED",128,128,WINDOWRESIZABLESTYLE()OR WINDOWMENUSTYLE()OR WindowMinMaxStyle() OUT WND,E
 NewWindow DLGED_CONTENTCTL,"",28,0,100,128,WND,0 OUT CNTWND,E
 SetWindowBackColor CNTWND,GetWorkspaceColor()
 VAR DLGWND
 NewStyleWindow DLGED_DLGCTL,"DIALOG",0,0,64,64,CNTWND,0,WINDOWRESIZABLESTYLE() OUT DLGWND,E
 DLGED_WV_PAINTQUEUE=0
 DLGED_WV_MENU=1
 DLGED_WV_DLG=2
 SetWindowVar WND,DLGED_WV_DLG,DLGWND
 
 DLGED_DLGWV_OWNER=0
 SetWindowVar DLGWND,DLGED_DLGWV_OWNER,WND
 NewWindow DLGED_BTNCTL,"TEST",8,8,48,16,DLGWND,0 OUT ,E
 NewWindow DLGED_BTNCTL,"TEST",8,16,48,16,DLGWND,0 OUT ,E
'COMMON DEF NewStyleWindowArg CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE,A1,A2 OUT WND,ERR

VAR _
' NewStyleWindowArg DLGEDCTL,"COLOR",0,0,60,120,GetRootWindow(),WindowToolFlag(),WindowNarrowStyle(),0,0 OUT _,E
' NewWindow DLGED_DLGCTL,"AAAA",0,0,60,120,GetRootWindow(),0 OUT _,E
' JoinWindowGroup WND,_ OUT E

 SetProcessVar WND
 VAR MENU
 NewMenu OUT MENU,E
 VAR I
 DLGED_MENU_NEW=I:INC I
 DLGED_MENU_OPN=I:INC I
 DLGED_MENU_SAS=I:INC I
 DLGED_MENU_SAV=I:INC I
 DLGED_MENU_ADD=I:INC I
 DLGED_MENU_BTN=I:INC I
 DLGED_MENU_TXT=I:INC I
 DLGED_MENU_TBX=I:INC I
 DLGED_MENU_ABT=I:INC I
 AddMenuItem MENU,"New",DLGED_MENU_NEW
 AddMenuItem MENU,"Open",DLGED_MENU_OPN
 AddMenuItem MENU,"Save",DLGED_MENU_SAV
 AddMenuItem MENU,"Save as",DLGED_MENU_SAS
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 NewMenu OUT MENU,E
 AddRadioMenuItem MENU,"Button",DLGED_MENU_BTN,TRUE
 AddRadioMenuItem MENU,"Text",DLGED_MENU_TXT,FALSE
 AddRadioMenuItem MENU,"Textbox",DLGED_MENU_TBX,FALSE
 AddSubMenuItemID GetWindowMenu(WND),"Add",MENU,DLGED_MENU_ADD
 NewMenu OUT MENU,E
 AddMenuItem MENU,"About",DLGED_MENU_ABT
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 
 NewMenu OUT MENU,E
 DLGED_MENU_EDITTEXT=I:INC I
 DLGED_MENU_PROP=I:INC I
 DLGED_MENU_DEL=I:INC I
 DLGED_MENU_COPY=I:INC I
 DLGED_MENU_CUT=I:INC I
 AddMenuItem MENU,"Edit text",DLGED_MENU_EDITTEXT
 AddMenuItem MENU,"Properties",DLGED_MENU_PROP
 AddMenuItem MENU,"Delete",DLGED_MENU_DEL
 AddMenuItem MENU,"Copy",DLGED_MENU_COPY
 AddMenuItem MENU,"Cut",DLGED_MENU_CUT
 DisableMenuItem MENU,DLGED_MENU_CUT
 SetWindowVar WND,DLGED_WV_MENU,MENU
 VAR W
 W=GetChildWindow(WND)
 WHILE W
  E=DisableWindowClipping(W)
  W=GetNextWindow(W)
 WEND
 'LoadImage2 "/DAT/DLGED.IMG",17,96 OUT DLGED_IMG,E

END
COMMON DEF L_DLGED
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
 IF GetWindowVar(GetProcessVar(),DLGED_WV_PAINTQUEUE)THEN
  SetWindowVar GetProcessVar(),DLGED_WV_PAINTQUEUE,FALSE
  VAR W=GetChildWindow(GetProcessVar())
  DLGED_CONTENTCTLPAINT2 GetChildWindow(W),0,0,0,0
 ENDIF
END

VAR TOPMOSTCTL
COMMON DEF I_TOPMOST
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "This program requires window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!TOPMOSTCTL THEN
  ExtendControl "TOPMOST",GetWindowControl() OUT TOPMOSTCTL,E
 ENDIF
 NewTopLevelStyleWindow TOPMOSTCTL,"TOPMOST",64,64,WindowTopMostStyle() OUT WND,E
 SetProcessVar WND
END
COMMON DEF L_TOPMOST
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END

