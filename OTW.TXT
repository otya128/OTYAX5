OPTION STRICT
OPTION DEFINT
'====================
' OTYA WINDOW SYSTEM 
'====================
'グローバルへんすうのていぎ
VAR WIN_BKGND,WIN_BTNBACK
VAR OTW_ENABLE_SHADOW
VAR OTW_INIT,OTW_MOUSESP,OTW_SHADOWSP,OTW_MOVWINSP,OTW_MOVWINCOL
VAR OTW_MOVWINNUWID
'1:MOV
'2:RESIZE
VAR OTW_MOVWINFLG
VAR OTW_MOUSEX
VAR OTW_MOUSEY
VAR OTW_MOUSEX#,OTW_MOUSEY#
VAR OTW_LASTUPD
VAR OTW_FNT[0,0]
VAR OTW_FNTPAL[0]
VAR OTW_FNTTBL[0]
VAR OTW_CONSOLEPAL[0]
'=======================
'        WINDOW         
'=======================
VAR WIN_MAX,WIN_MSGMAX
DIM WIN_NAME$  [0]
DIM WIN_WID    [0]
DIM WIN_X      [0]
DIM WIN_Y      [0]
DIM WIN_WIDTH  [0]
DIM WIN_HEIGHT [0]
DIM WIN_AX     [0]
DIM WIN_AY     [0]
DIM WIN_AW     [0]
DIM WIN_AH     [0]
DIM WIN_RX     [0]
DIM WIN_RY     [0]
DIM WIN_RFX    [0]
DIM WIN_RFY    [0]
DIM WIN_FX     [0]
DIM WIN_FY     [0]
DIM WIN_FW1    [0]
DIM WIN_FH1    [0]
DIM WIN_FW2    [0]
DIM WIN_FH2    [0]
DIM WIN_AFW    [0]
DIM WIN_AFH    [0]
DIM WIN_CTL    [0]
DIM WIN_PID    [0]
DIM WIN_NUPID  [0]
VAR WIN_VARSIZ
DIM WIN_VAR    [0,0]
DIM WIN_NEXT   [0]
DIM WIN_PREV   [0]
DIM WIN_CHILD  [0]
DIM WIN_PARENT [0]
DIM WIN_BEGIN  [0]
DIM WIN_SP     [0]
DIM WIN_MENU   [0]
DIM WIN_GROUP  [0]
DIM WIN_GNEXT  [0]
DIM WIN_GPREV  [0]
DIM WIN_GPARENT[0]
DIM WIN_STYLE  [0]
DIM WIN_BACKGND[0]
DIM WIN_IMAGE  [0]
'QUEUE
DIM WIN_MSGS   [0]
DIM WIN_MSGE   [0]
DIM WIN_MSGBUF [0,0,0]
DIM WIN_MSGCNT [0,0]
DIM WIN_USER   [0,0]
DIM WIN_HIDE   [0]
DIM WIN_MINW   [0]
DIM WIN_MINH   [0]
VAR WIN_FREE
VAR WIN_WIDCNT
VAR WIN_MSGARGSIZE
VAR WIDSHIFT
VAR NUWIDMASK
VAR WIN_FRAMEFLG
'DRAW PAGE
VAR OTW_DP
'SHOW PAGE
VAR OTW_SP
'BUFFER PAGE
VAR OTW_BP
'GPAGE
VAR OTW_GP
'VAR WIN_FWIDTH1
'VAR WIN_FHEIGHT1
'VAR WIN_FWIDTH2
'VAR WIN_FHEIGHT2
'H1
'          
'
'          
'          
'          
'          
'          
'H2
'⇔⇔
'W1         W2
'
VAR WIN_STYLE_NONE
VAR WIN_STYLE_MODAL
VAR WIN_STYLE_RESIZ
VAR WIN_STYLE_TRANS
VAR WIN_STYLE_HIDE
VAR WIN_STYLE_OWNERDRAW
VAR WIN_ACTIVENUWID
'DOUBLE CLICK
'まえ CLICK した WINDOW
VAR OTW_LCLKWND
'そのFRAME
VAR OTW_LCLKF
'なんFRAMEまで DOUBLE CLICKか
VAR OTW_DBLCLKF
'MOUSEのずれのキョヨウはんい
VAR OTW_DBLCLKXY
VAR OTW_DBLCLKX
VAR OTW_DBLCLKY
DEF OTW_WIN_INITARRAY
 PrintConsoleln "Init window..."
 VAR FM=FREEMEM
 OTW_DBLCLKF=30
 OTW_DBLCLKXY=4'±4
 WIN_STYLE_MODAL=1
 WIN_STYLE_RESIZ=2
 WIN_STYLE_TRANS=4
 WIN_STYLE_HIDE=8
 WIN_STYLE_OWNERDRAW=16
'WIN_FWIDTH1=0
'WIN_FHEIGHT1=10
'WIN_FWIDTH2=0
'WIN_FHEIGHT2=0
 WIN_MAX=256
 WIN_MSGMAX=64
 WIN_MSGARGSIZE=3
 WIDSHIFT=12
 NUWIDMASK=4095
 WIN_FRAMEFLG=32768
 WIN_VARSIZ=8
 WIN_NAME$     =NewArray$(WIN_MAX)
 WIN_WID       =NewArray(WIN_MAX)
 WIN_X         =NewArray(WIN_MAX)
 WIN_Y         =NewArray(WIN_MAX)
 WIN_WIDTH     =NewArray(WIN_MAX)
 WIN_HEIGHT    =NewArray(WIN_MAX)
 WIN_AX        =NewArray(WIN_MAX)
 WIN_AY        =NewArray(WIN_MAX)
 WIN_AW        =NewArray(WIN_MAX)
 WIN_AH        =NewArray(WIN_MAX)
 WIN_RX        =NewArray(WIN_MAX)
 WIN_RY        =NewArray(WIN_MAX)
 WIN_RFX       =NewArray(WIN_MAX)
 WIN_RFY       =NewArray(WIN_MAX)
 WIN_FX        =NewArray(WIN_MAX)
 WIN_FY        =NewArray(WIN_MAX)
 WIN_FW1       =NewArray(WIN_MAX)
 WIN_FH1       =NewArray(WIN_MAX)
 WIN_FW2       =NewArray(WIN_MAX)
 WIN_FH2       =NewArray(WIN_MAX)
 WIN_AFW       =NewArray(WIN_MAX)
 WIN_AFH       =NewArray(WIN_MAX)
 WIN_CTL       =NewArray(WIN_MAX)
 WIN_PID       =NewArray(WIN_MAX)
 WIN_NUPID     =NewArray(WIN_MAX)
 WIN_VAR       =NewArray2(WIN_MAX,WIN_VARSIZ)
 WIN_NEXT      =NewArray(WIN_MAX)
 WIN_PREV      =NewArray(WIN_MAX)
 WIN_CHILD     =NewArray(WIN_MAX)
 WIN_PARENT    =NewArray(WIN_MAX)
 WIN_BEGIN     =NewArray(WIN_MAX)
 WIN_SP        =NewArray(WIN_MAX)
 WIN_HIDE      =NewArray(WIN_MAX)
 WIN_MINW      =NewArray(WIN_MAX)
 WIN_MINH      =NewArray(WIN_MAX)
 WIN_MENU      =NewArray(WIN_MAX)
 WIN_GROUP     =NewArray(WIN_MAX)
 WIN_GNEXT     =NewArray(WIN_MAX)
 WIN_GPREV     =NewArray(WIN_MAX)
 WIN_GPARENT   =NewArray(WIN_MAX)
 WIN_STYLE     =NewArray(WIN_MAX)
 WIN_IMAGE     =NewArray(WIN_MAX)
 WIN_BACKGND   =NewArray(WIN_MAX)
 WIN_MSGS      =NewArray(WIN_MAX)
 WIN_MSGE      =NewArray(WIN_MAX)
 WIN_MSGBUF    =NewArray3(WIN_MAX,WIN_MSGMAX,WIN_MSGARGSIZE)
 WIN_MSGCNT    =NewArray2(WIN_MAX,16)
 WIN_FREE=1
 OTW_INITLIST WIN_NEXT
 OTW_MENU_INITARRAY
 OTW_IMAGE_INITARRAY
 WIN_WID[0]=&Hdeadbeef
END
DIM IMAGE_PTR[0]
DIM IMAGE_HEIGHT[0]
DIM IMAGE_WIDTH[0]
DIM IMAGE_ID[0]
DIM IMAGE_NEXT[0]
VAR IMAGE_MAX
VAR IMAGE_IDCNT
VAR IMAGE_FREE
VAR IMAGE_NOALLOC
DEF OTW_IMAGE_INITARRAY
 IMAGE_NOALLOC=1
 IMAGE_MAX=256
 IMAGE_IDCNT=1
 IMAGE_FREE=1
 IMAGE_PTR=NewArray(IMAGE_MAX)
 IMAGE_WIDTH=NewArray(IMAGE_MAX)
 IMAGE_HEIGHT=NewArray(IMAGE_MAX)
 IMAGE_ID=NewArray(IMAGE_MAX)
 IMAGE_NEXT=NewArray(IMAGE_MAX)
 OTW_INITLIST IMAGE_NEXT
END
'=======================
'MENU
'=======================
'Item
DIM MENU_INAME$[0]
DIM MENU_INEXT[0]
DIM MENU_IPREV[0]
DIM MENU_ICHILD[0]
DIM MENU_IPARENT[0]
DIM MENU_ISTYLE[0]
DIM MENU_IVAR[0]
VAR MENU_ITEMMAX
VAR MENU_ITEMFREE

DIM MENU_WIDTH[0]
DIM MENU_HEIGHT[0]
DIM MENU_NUWID[0]
DIM MENU_OWNER[0]
DIM MENU_ITEM[0]
DIM MENU_SHOW[0]
DIM MENU_NEXT[0]
DIM MENU_LAST[0]
'Select
DIM MENU_SEL[0]
DIM MENU_ID[0]
VAR MENU_MAX
VAR MENU_IDCNT
VAR MENU_FREE
VAR MENUCTL
VAR MENU_STYLE_SEPARATOR
VAR MENU_SEPARATOR_HEIGHT
DEF OTW_MENU_INITARRAY
 PrintConsoleln "Init menu..."
 MENU_ITEMMAX=256
 MENU_INAME$=NewArray$(MENU_ITEMMAX)
 MENU_INEXT=NewArray(MENU_ITEMMAX)
 MENU_IPREV=NewArray(MENU_ITEMMAX)
 MENU_ICHILD=NewArray(MENU_ITEMMAX)
 MENU_IPARENT=NewArray(MENU_ITEMMAX)
 MENU_ISTYLE=NewArray(MENU_ITEMMAX)
 MENU_STYLE_SEPARATOR=1
 MENU_SEPARATOR_HEIGHT=4
 MENU_IVAR=NewArray(MENU_ITEMMAX)
 OTW_INITLIST MENU_INEXT
 MENU_ITEMFREE=1
 MENU_MAX=64
 MENU_WIDTH=NewArray(MENU_MAX)
 MENU_HEIGHT=NewArray(MENU_MAX)
 MENU_NUWID=NewArray(MENU_MAX)
 MENU_OWNER=NewArray(MENU_MAX)
 MENU_ITEM=NewArray(MENU_MAX)
 MENU_LAST=NewArray(MENU_MAX)
 MENU_SEL=NewArray(MENU_MAX)
 MENU_SHOW=NewArray(MENU_MAX)
 MENU_IDCNT=0
 MENU_ID=NewArray(MENU_MAX)
 MENU_NEXT=MENU_ITEM
 OTW_INITLIST MENU_NEXT
 MENU_FREE=1
 VAR E
END
'FILE
VAR ASSOC_LEN
DIM ASSOC_TYP$[0]
DIM ASSOC_EXT$[0]
DIM ASSOC_NAME$[0]
DEF OTW_ASSOC_INIT
 ASSOC_TYP$=NewArray$(0)
 ASSOC_EXT$=NewArray$(0)
 ASSOC_NAME$=NewArray$(0)
 VAR E=AssociateFile("TXT","","EDITORSEL")
 E=AssociateFile("TXT","TXT","TXTED")
 E=AssociateFile("TXT","PRG","PRGED")
 E=AssociateFile("TXT","MML","MPLAY")
END
DEF GetAssociatedIndex(TYP$,EXT$)
 VAR I
 FOR I=0TO ASSOC_LEN-1
  IF ASSOC_EXT$[I]==EXT$&&ASSOC_TYP$[I]==TYP$THEN 
   RETURN I
  ENDIF
 NEXT
 RETURN -1
END
COMMON DEF GetAssociatedProgram$(TYP$,EXT$)
 VAR I=GetAssociatedIndex(TYP$,EXT$)
 IF I!=-1THEN RETURN ASSOC_NAME$[I]
 RETURN ""
END
COMMON DEF AssociateFile(TYP$,EXT$,NAME$)
 VAR I=GetAssociatedIndex(TYP$,EXT$)
 IF I!=-1THEN
  ASSOC_NAME$[I]=NAME$
  RETURN 0
 ENDIF
 PUSH ASSOC_EXT$,EXT$
 PUSH ASSOC_TYP$,TYP$
 PUSH ASSOC_NAME$,NAME$
 INC ASSOC_LEN
 RETURN 0
END
'IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
'ExitProcess 1
'ENDIF
VAR OTWRunning
COMMON DEF IsWinRunning()
 RETURN OTWRunning
END
'=======================
'CONTROL
'=======================
VAR CTL_MAX
VAR CTL_HANDLER_MAX
DIM CTL_NAME$    [0]
DIM CTL_CID      [0]
DIM CTL_DAT      [0]
DIM CTL_FW1      [0]
DIM CTL_FH1      [0]
DIM CTL_FW2      [0]
DIM CTL_FH2      [0]
DIM CTL_NEXT     [0]
DIM CTL_PARENTCTL[0]
DIM CTL_HANDLER$ [0,0]
DIM CTL_NDHNDLR[0]
VAR CTL_FREE
VAR CTL_CIDCNT
VAR CTL_PAINTHANDLER
COMMON DEF RepaintControlEvent()
 RETURN CTL_PAINTHANDLER
END
VAR CTL_LBTNUPHANDLER
VAR CTL_LBTNDWNHANDLER
VAR CTL_RBTNUPHANDLER
VAR CTL_RBTNDWNHANDLER
VAR CTL_FRMBTNHANDLER
VAR CTL_DRWFRMHANDLER
VAR CTL_NOTIFHANDLER
VAR CTL_KEYHANDLER
VAR CTL_BTNHANDLER
VAR CTL_CHFOCUSHANDLER
VAR CTL_MOUSEMVHANDLER
VAR CTL_FRMMOUSEMVHANDLER
VAR CTL_CREATEHANDLER
VAR CTL_STRNOTIFHANDLER
VAR CTL_DELETEHANDLER
VAR CTL_LDBLCLKHANDLER
VAR CTL_MSLEAVEHANDLER
VAR CTL_RESIZEHANDLER
VAR CTL_LBTNFLG
VAR CTL_RBTNFLG
VAR CTL_BTNDWNFLG
VAR CTL_BTNUPFLG
VAR CTL_LEAVEFLG
VAR CTL_WINDOWCTL
VAR CTL_BUTTONCTL
VAR CTL_TGLBTNCTL
VAR CTL_TXTBOXCTL
VAR CTL_LABELCTL
VAR CTL_VSCRBARCTL
VAR CTL_NUMUPDWNCTL
VAR CTL_DRPDWNCTL

VAR CTL_LSTBOXCTL
VAR CTL_DRPDWNBOXCTL
'CONTROL STYLE
'クリックしてもFOCUSしない
VAR CTL_STYLE_NCFOCUS
DEF OTW_CTL_INITARRAY
 PrintConsoleln "Init control..."
 CTL_STYLE_NCFOCUS=1
 CTL_MAX=64
 CTL_HANDLER_MAX=18
 CTL_NAME$     =NewArray$(CTL_MAX)
 CTL_DAT       =NewArray(CTL_MAX)
 CTL_FW1       =NewArray(CTL_MAX)
 CTL_FH1       =NewArray(CTL_MAX)
 CTL_FW2       =NewArray(CTL_MAX)
 CTL_FH2       =NewArray(CTL_MAX)
 CTL_CID       =NewArray(CTL_MAX)
 CTL_NEXT      =NewArray(CTL_MAX)
 CTL_PARENTCTL =NewArray(CTL_MAX)
 CTL_HANDLER$  =NewArray2$(CTL_MAX,CTL_HANDLER_MAX)
 CTL_NDHNDLR=NewArray(CTL_MAX)
 CTL_FREE=1
 OTW_INITLIST CTL_NEXT
 VAR E
 NewControl "WINDOW" OUT CTL_WINDOWCTL,E
 NewControl "BUTTON" OUT CTL_BUTTONCTL,E
 NewControl "TXTBOX" OUT CTL_TXTBOXCTL,E
 NewControl "LABEL" OUT CTL_LABELCTL,E
 NewControl "VSCRBAR" OUT CTL_VSCRBARCTL,E
 CTL_PAINTHANDLER=0
 CTL_NDHNDLR[CTL_PAINTHANDLER]=TRUE
 CTL_LBTNDWNHANDLER=1
 CTL_LBTNUPHANDLER=2
 CTL_RBTNUPHANDLER=3
 CTL_RBTNDWNHANDLER=4

 CTL_FRMBTNHANDLER=5
 CTL_NOTIFHANDLER=6
 CTL_KEYHANDLER=7
 CTL_BTNHANDLER=8
 CTL_CHFOCUSHANDLER=9
 CTL_MOUSEMVHANDLER=10
 CTL_FRMMOUSEMVHANDLER=11
 CTL_CREATEHANDLER=12
 CTL_STRNOTIFHANDLER=13
 CTL_DELETEHANDLER=14
 CTL_LDBLCLKHANDLER=15
 CTL_MSLEAVEHANDLER=16
 CTL_RESIZEHANDLER=17
 'A1=,A2=bit16~31Y,Xbit0~15
 CTL_LBTNFLG=4
 CTL_RBTNFLG=8
 CTL_BTNDWNFLG=1
 CTL_BTNUPFLG=2
 CTL_LEAVEFLG=64
' CTL_DRWFRMHANDLER=3
'E=SetControlFrameSize(CTL_WINDOWCTL,WIN_FWIDTH1,WIN_FHEIGHT1,WIN_FWIDTH2,WIN_FHEIGHT2)
 E=SetControlFrameSize(CTL_WINDOWCTL,1,12,1,1)
 E=SetControlPainter(CTL_WINDOWCTL,"WindowPainter")
 E=SetControlLMouseDownHandler(CTL_WINDOWCTL,"WindowLMouseDown")
 E=SetControlClickFrameHandler(CTL_WINDOWCTL,"WindowClickFrame")
 E=SetControlMMoveFrameHandler(CTL_WINDOWCTL,"WindowMMoveFrame")
 E=SetControlChFocusHandler(CTL_WINDOWCTL,"WindowChFocus")
 E=SetControlPainter(CTL_BUTTONCTL,"ButtonPainter")
 E=SetControlLMouseUpHandler(CTL_BUTTONCTL,"ButtonLMouseUP")
 E=SetControlLMouseDownHandler(CTL_BUTTONCTL,"ToggleButtonLMouseDown")
 E=SetControlPainter(CTL_TXTBOXCTL,"TextBoxPainter")
 E=SetControlLMouseDownHandler(CTL_TXTBOXCTL,"TextBoxLMouseDown")
 E=SetControlKeyHandler(CTL_TXTBOXCTL,"TextBoxKey")
 E=SetControlButtonHandler(CTL_TXTBOXCTL,"TextBoxButton")
 E=SetControlChFocusHandler(CTL_TXTBOXCTL,"TextBoxChFocus")
 E=SetControlPainter(CTL_LABELCTL,"LabelPainter")

 E=SetControlPainter(CTL_VSCRBARCTL,"VSCRBARPainter")
 E=SetControlLMouseUpHandler(CTL_VSCRBARCTL,"VSCRBARLMouseUP")
 E=SetControlLMouseDownHandler(CTL_VSCRBARCTL,"VSCRBARLMouseDown")


 ExtendControl "ToggleButton",CTL_BUTTONCTL OUT CTL_TGLBTNCTL,E
 E=SetControlLMouseUpHandler(CTL_TGLBTNCTL,"ToggleButtonLMouseUP")
 E=SetControlLMouseDownHandler(CTL_TGLBTNCTL,"ToggleButtonLMouseDown")

 ExtendControl "NUMUPDWN",CTL_TXTBOXCTL OUT CTL_NUMUPDWNCTL,E
 E=SetControlLMouseUpHandler(CTL_NUMUPDWNCTL,"NumUpDownLMouseUP")
 E=SetControlLMouseDownHandler(CTL_NUMUPDWNCTL,"NumUpDownLMouseDown")
 E=SetControlPainter(CTL_NUMUPDWNCTL,"NumUpDownPainter")
 E=SetControlKeyHandler(CTL_NUMUPDWNCTL,"NumUpDownKey")
 E=SetControlCreateHandler(CTL_NUMUPDWNCTL,"NumUpDownCreate")
 'MENU
 NewControl"POPUPMENU" OUT MENUCTL,E
 E=SetControlPainter(MENUCTL,"MenuPainter")
 E=SetControlMouseMoveHandler(MENUCTL,"MenuMouseMove")
 E=SetControlLMouseUpHandler(MENUCTL,"MenuLMouseUp")
 E=SetControlChFocusHandler(MENUCTL,"MenuChFocus")


 OTW_CTL_LIST
 NewControl "DROPDOWNLIST" OUT CTL_DRPDWNCTL,E
 E=SetControlPainter(CTL_DRPDWNCTL,"DropDownListPainter")
 E=SetControlLMouseDownHandler(CTL_DRPDWNCTL,"DropDownListLMD")
 E=SetControlLMouseUpHandler(CTL_DRPDWNCTL,"DropDownListLMU")

 ExtendControl "DROPDOWNLISTBOX",GetListBoxControl() OUT CTL_DRPDWNBOXCTL,E
 E=SetControlChFocusHandler(CTL_DRPDWNBOXCTL,"DropDownListBoxChFocus")
 PrintConsoleln "Init textbox..."
 INIT_TXTBOXEX
 CTL_CID[0]=&Hdeadbeef
END
DIM LISTSTR$[0]
DIM LISTSTRNEXT[0]
DIM LISTSTRPREV[0]
DIM LISTSTRPARENT[0]
DIM LISTSTRCHILD[0]
VAR LISTSTR_FREE
VAR LISTSTR_MAX
DEF OTW_CTL_LIST
 LISTSTR_MAX=256
 LISTSTR$=NewArray$(LISTSTR_MAX)
 LISTSTRNEXT=NewArray(LISTSTR_MAX)
 LISTSTRPREV=NewArray(LISTSTR_MAX)
 OTW_INITLIST LISTSTRNEXT
 LISTSTR_FREE=1
 VAR E
 NewControl "LSTBOX" OUT CTL_LSTBOXCTL,E
 E=SetControlPainter(CTL_LSTBOXCTL,"ListBoxPainter")
 E=SetControlCreateHandler(CTL_LSTBOXCTL,"ListBoxCreate")
 E=SetControlNotifHandler(CTL_LSTBOXCTL,"ListBoxNotif")
 E=SetControlLMouseDownHandler(CTL_LSTBOXCTL,"ListBoxLMD")
 E=SetControlLDoubleClickHandler(CTL_LSTBOXCTL,"ListBoxLMD")
 E=SetControlDeleteHandler(CTL_LSTBOXCTL,"ListBoxDelete")
 E=SetControlResizeHandler(CTL_LSTBOXCTL,"ListBoxResize")
END
DEF OTW_INITLIST ARY[]
 VAR I
 FOR I=1TO LEN(ARY)-2
  ARY[I]=I+1
 NEXT
END
VAR WIN_NOALLOC
VAR WIN_INVALIDID
VAR WIN_EVENTERR
'びょうが ふか
VAR WIN_NODRAW
VAR CTL_NOALLOC
VAR CTL_INVALIDID
DEF OTW_INIT_ERR
 WIN_NOALLOC=1
 WIN_INVALIDID=2
 WIN_EVENTERR=3
 WIN_NODRAW=3
 CTL_NOALLOC=201
 CTL_INVALIDID=202
END
COMMON DEF GetWindowControl()
 RETURN CTL_WINDOWCTL
END
COMMON DEF GetButtonControl()
 RETURN CTL_BUTTONCTL
END
COMMON DEF GetToggleButtonControl()
 RETURN CTL_TGLBTNCTL
END
COMMON DEF GetTextBoxControl()
 RETURN CTL_TXTBOXCTL
END
COMMON DEF GetLabelControl()
 RETURN CTL_LABELCTL
END
COMMON DEF GetVScrollBarControl()
 RETURN CTL_VSCRBARCTL
END
COMMON DEF GetListBoxControl()
 RETURN CTL_LSTBOXCTL
END
COMMON DEF GetNumUpDownControl()
 RETURN CTL_NUMUPDWNCTL
END
COMMON DEF GetDropDownListControl()
 RETURN CTL_DRPDWNCTL
END
'CONTROL
COMMON DEF FindControl(NAME$)
 VAR I
 FOR I=0TO CTL_MAX-1
  IF CTL_NAME$[I]==NAME$THEN RETURN CTL_CID[I]<<12OR I
 NEXT
 RETURN 0
END
COMMON DEF NewControl NAME$ OUT CTL,ERR
 IF!CTL_FREE THEN
  ERR=CTL_NOALLOC
  CTL=0
  RETURN
 ENDIF
 INC CTL_CIDCNT
 ERR=0
 CTL=CIDNUCIDToCTL(CTL_FREE,CTL_CIDCNT)
 CTL_FREE=CTL_NEXT[CTL_FREE]
 CTL_CID[CTL AND 4095]=CTL_CIDCNT
 CTL_NEXT[CTL AND 4095]=0
 CTL_NAME$[CTL AND 4095]=NAME$
END
COMMON DEF ExtendControl NAME$,PARENT OUT CTL,ERR
 IF!CheckControl(PARENT)THEN
  CTL=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 NewControl NAME$ OUT CTL,ERR
 IF ERR THEN RETURN
 VAR NUCID=CTL AND 4095
 CTL_PARENTCTL[NUCID]=PARENT
 VAR I,P=PARENT AND 4095
 FOR I=0TO CTL_HANDLER_MAX-1
  CTL_HANDLER$[NUCID,I]=CTL_HANDLER$[P,I]
 NEXT
 CTL_FW1[NUCID]=CTL_FW1[P]
 CTL_FH1[NUCID]=CTL_FH1[P]
 CTL_FW2[NUCID]=CTL_FW2[P]
 CTL_FH2[NUCID]=CTL_FH2[P]
END
COMMON DEF CheckControl(CTL)
 RETURN CTL_CID[CTL AND 4095]==CTL>>12
END
COMMON DEF DeleteControl(CTL)
 IF!CheckControl(CTL) THEN RETURN CTL_INVALIDID
 VAR NUCID=CTL AND 4095,CID=CTL>>12
 CTL_NEXT[NUCID]=CTL_FREE
 CTL_FREE=NUCID
 CTL_CID[NUCID]=0
 CTL_FW1[NUCID]=0
 CTL_FH1[NUCID]=0
 CTL_FW2[NUCID]=0
 CTL_FH2[NUCID]=0
 CTL_DAT[NUCID]=0
 CTL_NAME$[NUCID]=""
 VAR I
 FOR I=0TO CTL_HANDLER_MAX-1
  CTL_HANDLER$[NUCID,I]=""
 NEXT
END
COMMON DEF IsControlExtend(CTL,PARENT)
 VAR N=CTL AND 4095
 VAR P=PARENT AND 4095
 WHILE N
  IF N==P THEN RETURN 1
  N=CTL_PARENTCTL[N]AND 4095
 WEND
 RETURN 0
END
COMMON DEF SetControlPainter(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_PAINTHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlLMouseUpHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_LBTNUPHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlLMouseDownHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_LBTNDWNHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlRMouseUpHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_RBTNUPHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlRMouseDownHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_RBTNDWNHANDLER]=HANDLER$
 RETURN 0
END
DEF SetControlClickFrameHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_FRMBTNHANDLER]=HANDLER$
 RETURN 0
END
DEF SetControlMMoveFrameHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_FRMMOUSEMVHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlNotificationHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_NOTIFHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlNotifHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_NOTIFHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlKeyHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_KEYHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlButtonHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_BTNHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlChFocusHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CHFOCUSHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlMouseMoveHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_MOUSEMVHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlCreateHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_CREATEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlStrNotifHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_STRNOTIFHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlDeleteHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_DELETEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlLDoubleClickHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_LDBLCLKHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlMouseLeaveHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_MSLEAVEHANDLER]=HANDLER$
 RETURN 0
END
COMMON DEF SetControlResizeHandler(CTL,HANDLER$)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL_HANDLER$[CTL AND 4095,CTL_RESIZEHANDLER]=HANDLER$
 RETURN 0
END
DEF SetControlFrameSize(CTL,W1,H1,W2,H2)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 VAR C=CTL AND 4095
 CTL_FW1[C]=W1
 CTL_FH1[C]=H1
 CTL_FW2[C]=W2
 CTL_FH2[C]=H2
 RETURN 0
END
DEF CIDNUCIDToCTL(CID,NUCID)
 RETURN CID<<12OR NUCID
END
'Clipboard API
'ClearClipboard<-じゅうよう
'                Setしただけでは ほかの しゅるいの データが のこる
'->ClipboardSetText
VAR CLPBRD
VAR CLPBRDCTXT
VAR CLPBRDCFIL
VAR CLPBRDFIL$
VAR CLPBRDFILCUT
VAR CLPBRD$
VAR CLPBRD#
VAR CLPBRDPTR
COMMON DEF ClearClipboard
 CLPBRDCTXT=FALSE
 CLPBRDCFIL=FALSE
END
COMMON DEF ClipboardContainsText()
 RETURN CLPBRDCTXT
END
COMMON DEF ClipboardGetText$()
 IF CLPBRDCTXT THEN RETURN CLPBRD$
 RETURN ""
END
COMMON DEF ClipboardSetText V$
 CLPBRDCTXT=1
 CLPBRD$=V$
END
COMMON DEF ClipboardContainsFile()
 RETURN CLPBRDCFIL
END
COMMON DEF ClipboardGetFile OUT ISCUT,PATH$
 IF CLPBRDCFIL THEN
  PATH$=CLPBRDFIL$
  ISCUT=CLPBRDFILCUT
  RETURN
 ENDIF
 ISCUT=FALSE
 PATH$=""
END
COMMON DEF ClipboardSetFile ISCUT,PATH$
 CLPBRDFIL$=PATH$
 CLPBRDFILCUT=ISCUT
 CLPBRDCFIL=TRUE
END
COMMON DEF NewImage WIDTH,HEIGHT OUT IMG,E
 IF !IMAGE_FREE THEN IMG=0:E=IMAGE_NOALLOC:RETURN
 VAR PTR=malloc(WIDTH*HEIGHT)
 IF!PTR THEN IMG=0:E=IMAGE_NOALLOC:RETURN
 INC IMAGE_IDCNT
 IMAGE_ID[IMAGE_FREE]=IMAGE_IDCNT
 IMAGE_HEIGHT[IMAGE_FREE]=WIDTH
 IMAGE_WIDTH[IMAGE_FREE]=HEIGHT
 IMAGE_PTR[IMAGE_FREE]=PTR
 IMG=IMAGE_FREE OR IMAGE_IDCNT<<12
 IMAGE_FREE=IMAGE_NEXT[IMAGE_FREE]
 E=0
 RETURN
END
COMMON DEF CheckImage(IMG)
 RETURN IMAGE_ID[IMG AND 4095]==IMG>>12
END
COMMON DEF DeleteImage(IMG)
 IF!CheckImage(IMG)THEN RETURN IMAGE_NOALLOC
 VAR I=IMG AND 4095
 free IMAGE_PTR[I]
 IMAGE_NEXT[I]=IMAGE_FREE
 IMAGE_FREE=I
 RETURN 0
END
VAR MENU_NOALLOC
COMMON DEF NewMenu OUT MENU,E
 IF !MENU_FREE THEN MENU=0:E=MENU_NOALLOC:RETURN
 INC MENU_IDCNT
 E=0
 MENU_ID[MENU_FREE]=MENU_IDCNT
 MENU_HEIGHT[MENU_FREE]=4
 MENU_WIDTH[MENU_FREE]=0
 MENU=MENU_FREE OR MENU_IDCNT<<12
 MENU_FREE=MENU_NEXT[MENU_FREE]
END
COMMON DEF SetMenuBar MENU,WND
 NOIMPL FORMAT$("NOIMPL SetMenuBar %D,%D",MENU,WND)
END
'===
'ShowContextMenu
'MOUSEノCOORDニMENUヲSHOW
'===
COMMON DEF ShowContextMenu MENU,WND
 VAR X=GetMouseX()
 VAR Y=GetMouseY()
 ShowMenuXY MENU AND 4095,WND,X,Y
END
COMMON DEF ShowMenu MENU,WND
 NOIMPL FORMAT$("NOIMPL ShowMenu %D,%D",MENU,WND)
END
DEF ShowMenuXY MENU,WND,X,Y
 VAR W=WND AND NUWIDMASK
 VAR E
 NewWindow MENUCTL,"",X,Y,MENU_WIDTH[MENU],MENU_HEIGHT[MENU],GetRootWND(),WindowFrontFlag()OUT MENU_NUWID[MENU],E
 VOID JoinWindowGroup(WND,MENU_NUWID[MENU])
 SetWindowVar MENU_NUWID[MENU],0,MENU
 MENU_NUWID[MENU]=MENU_NUWID[MENU]AND NUWIDMASK
 MENU_SHOW[MENU]=WND
 WIN_ACTIVENUWID=MENU_NUWID[MENU]
' MENU_SEL[C],WND,X-1,0
END
DEF ShowMenu_ MENU,WND,X,Y
 VAR W=WND AND NUWIDMASK
 ShowMenuXY MENU,WND,WIN_AX[W]+WIN_FW1[W]+X,WIN_AY[W]+Y+WIN_FH1[W]
END
DEF NewMenuItem(STR$,PREV,STYLE)
 VAR I=MENU_ITEMFREE
 IF!I THEN RETURN
 MENU_INAME$[I]=STR$
 MENU_IPREV[I]=PREV
 IF PREV THEN MENU_INEXT[PREV]=I
 MENU_IPARENT[I]=PREV
 MENU_ITEMFREE=MENU_INEXT[I]
 MENU_INEXT[I]=0
 MENU_ISTYLE[I]=STYLE
 RETURN I
END
COMMON DEF GetWindowMenu(WND)
 RETURN WIN_MENU[WND AND NUWIDMASK]
END
COMMON DEF AddMenuItem MENU,STR$,IVAR
 AddMenuItemStyle MENU,STR$,IVAR,0'STYLE
END
'COMMON?
DEF AddMenuItemStyle MENU,STR$,IVAR,STYLE
 IF!CheckMenu(MENU)THEN RETURN
 VAR N=MENU AND 4095
 VAR I=NewMenuItem(STR$,MENU_LAST[N],STYLE)
 IF!MENU_LAST[N]THEN
  MENU_LAST[N]=I
  MENU_ITEM[N]=I
 ELSE
  MENU_LAST[N]=I
 ENDIF
 MENU_IVAR[I]=IVAR
 IF STYLE AND MENU_STYLE_SEPARATOR THEN
  INC MENU_HEIGHT[N],MENU_SEPARATOR_HEIGHT
 ELSE
  INC MENU_HEIGHT[N],8
 ENDIF
 '3 IS MENU WIDTH
 IF MENU_WIDTH[N]<LEN(STR$)*8+3THEN
  MENU_WIDTH[N]=LEN(STR$)*8+3
 ENDIF
END
COMMON DEF AddMenuItemSeparator MENU
 AddMenuItemStyle MENU,"",0,MENU_STYLE_SEPARATOR'STYLE
END
COMMON DEF AddSubMenuItem MENU,STR$,SUBMENU
 AddMenuItem MENU,STR$,0
 VAR N=MENU AND 4095
 IF!MENU_LAST[N]THEN RETURN
 MENU_ICHILD[MENU_LAST[N]]=SUBMENU AND 4095
END
COMMON DEF CheckMenu(MENU)
 RETURN MENU_ID[MENU AND 4095]==MENU>>12
END
DEF MenuLMouseUp WND,C,T,X,Y
 VAR M=GetWindowVar(WND,0)
 IF X>0&&Y>0&&X<MENU_WIDTH[M]&&Y<MENU_HEIGHT[M]THEN
  VOID SendNotifWindow(GetWindowGroupOwner(WND),0,MENU_IVAR[MENU_SEL[M]])
 ENDIF
 VOID DeleteWindow(WND)
 VOID ActiveWindow(MENU_SHOW[M])
 MENU_SHOW[M]=0
END
DEF MenuChFocus WND,C,T,F,_
 IF!F THEN
  VAR M=GetWindowVar(WND,0)
  VOID DeleteWindow(WND)
 ' VOID ActiveWindow(MENU_SHOW[M])
  MENU_SHOW[M]=0
 ENDIF
END
DEF MenuMouseMove WND,C,T,X,Y
 VAR SX=2
 VAR M=GetWindowVar(WND,0)
 VAR I=MENU_ITEM[M],Y1=2,Y2=Y1
 VAR OS=MENU_SEL[M]
 VAR BEG,G,SELF=0'SELECT FLAG
 WHILE I
  IF MENU_ISTYLE[I]AND MENU_STYLE_SEPARATOR THEN
   INC Y2,MENU_SEPARATOR_HEIGHT
   GOTO @SKIP
  ENDIF
  INC Y2,8
  IF Y1<=Y&&Y2>Y THEN
   SELF=1
   IF OS!=I&&!G THEN 
   MENU_SEL[M]=I
   IF!BEG&&GBeginWindow(WND)THEN :'BREAK
   BEG=1
   GFILLWindow WND,SX,Y1,MENU_WIDTH[M]-SX,Y2-1,RGB(0,0,255)
   GPRINTWindow WND,SX,Y1,MENU_INAME$[I],-1
   G=0
   ENDIF
   IF!OS THEN BREAK
  ELSE
   IF I==OS THEN
    IF!BEG&&GBeginWindow(WND)THEN :'BREAK
    GFILLWindow WND,SX,Y1,MENU_WIDTH[M]-SX,Y2-1,WIN_BKGND
    GPRINTWindow WND,SX,Y1,MENU_INAME$[I],&HFF000000
    OS=0
    IF BEG THEN BREAK
    BEG=1
   ENDIF
  ENDIF
  @SKIP
  Y1=Y2
  I=MENU_INEXT[I]
 WEND
 IF!SELF THEN
  MENU_SEL[M]=0
 ENDIF
 IF BEG THEN BEG=GEndWindow(WND)
END
DEF MenuPainter WND,C,T,XY,WH
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,WIN_BKGND
 VAR SX=2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 GBOXWindow WND,0,0,W,H,&HFF000000
 GBOXWindow WND,1,1,W-1,H-1,RGB(128,128,128)
 
 GLINEWindow WND,0,0,W-1,0,WIN_BKGND
 GLINEWindow WND,0,0,0,H-1,WIN_BKGND
 
 GLINEWindow WND,1,1,W-2,1,RGB(255,255,255)
 GLINEWindow WND,1,1,1,H-2,RGB(255,255,255)
 VAR M=GetWindowVar(WND,0)
 VAR I=MENU_ITEM[M],Y=2
 WHILE I
  IF MENU_ISTYLE[I]AND MENU_STYLE_SEPARATOR THEN
   GLINEWindow WND,SX+1,Y+1,W-SX-1,Y+1,RGB(128,128,128)
   GLINEWindow WND,SX+1,Y+2,W-SX-1,Y+2,-1
   INC Y,MENU_SEPARATOR_HEIGHT
  ELSE
   GPRINTWindow WND,SX,Y,MENU_INAME$[I],&HFF000000
   INC Y,8
  ENDIF
  I=MENU_INEXT[I]
 WEND
 VAR E=GEndWindow(WND)
END
'WINDOW
DEF WIDNUWIDToWND(WID,NUWID)
 RETURN WID<<12OR NUWID
END
DEF NUWIDToWND(NUWID)
 RETURN WIN_WID[NUWID]<<12OR NUWID
END
'WND2 Join WND Group
COMMON DEF JoinWindowGroup(WND,WND2)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 IF!CheckWindow(WND2)THEN RETURN WIN_INVALIDID
 VAR NW1=WND AND NUWIDMASK'OW
 VAR NW2=WND2 AND NUWIDMASK'CW
 IF WIN_GROUP[NW1]THEN
  VAR NW3=WIN_GROUP[NW1]
  WIN_GNEXT[NW2]=WIN_GROUP[NW1]
  WIN_GPREV[NW3]=NW2
 ENDIF
 WIN_GPARENT[NW2]=NW1
 WIN_GROUP[NW1]=NW2
 RETURN 0
END
COMMON DEF LeaveWindowGroup WND
 NOIMPL "LeaveWindowGroup"
END
COMMON DEF GetWindowGroupMember(WND)
 RETURN NUWIDToWND(WIN_GROUP[WND AND NUWIDMASK])
END
COMMON DEF GetNextWindowGroupMember(WND)
 VAR NXT=WIN_GNEXT[WND AND NUWIDMASK]
 IF!NXT THEN RETURN 0
 RETURN NUWIDToWND(NXT)
END
COMMON DEF GetPrevWindowGroupMember(WND)
 VAR PRV=WIN_GNEXT[WND AND NUWIDMASK]
 IF!PRV THEN RETURN 0
 RETURN NUWIDToWND(PRV)
END
COMMON DEF GetWindowGroupOwner(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 RETURN NUWIDToWND(WIN_GPARENT[WND AND NUWIDMASK])
END
VAR WIN_ROOTWND
VAR WIN_ROOTWND2
COMMON DEF GetRootWND()
 RETURN WIN_ROOTWND2
END
COMMON DEF CheckWindow(WND)
 RETURN WIN_WID[WND AND NUWIDMASK]==WND>>WIDSHIFT
END
VAR WIN_TopLevelX
VAR WIN_TopLevelY
VAR OTW_TOPLEVELCNT
COMMON DEF WindowBackFlag()
 RETURN 1
END
COMMON DEF WindowFrontFlag()
 RETURN 2
END
COMMON DEF WindowHideFlag()
 RETURN 4
END
COMMON DEF WindowOwnerDrawFlag()
 RETURN 8
END
DEF WindowOnCreate WND,CTL,ARG1,ARG2
 VAR NUCID=CTL AND 4095
 IF LEN(CTL_HANDLER$[NUCID,CTL_CREATEHANDLER])THEN
  CALL CTL_HANDLER$[NUCID,CTL_CREATEHANDLER],WND,CTL,CTL_CREATEHANDLER,ARG1,ARG2
 ENDIF
END
DEF WindowOnDelete NUWID
 VAR CTL=WIN_CTL[NUWID]
 VAR NUCID=CTL AND 4095
 IF LEN(CTL_HANDLER$[NUCID,CTL_DELETEHANDLER])THEN
  CALL CTL_HANDLER$[NUCID,CTL_DELETEHANDLER],NUWIDToWND(NUWID),CTL,CTL_DELETEHANDLER,0,0
 ENDIF
END
COMMON DEF GetWindowMinSize WND OUT W,H
 IF!CheckWindow(WND)THEN
  W=-1
  H=-1
  RETURN
 ENDIF
 VAR NUWID=WND AND NUWIDMASK
 W=WIN_MINW[NUWID]
 H=WIN_MINH[NUWID]
 RETURN
END
COMMON DEF SetWindowMinSize WND,W,H
 IF!CheckWindow(WND)THEN RETURN
 VAR NUWID=WND AND NUWIDMASK
 WIN_MINW[NUWID]=W
 WIN_MINH[NUWID]=H
 RETURN
END
COMMON DEF NewWindow CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG OUT WND,ERR
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 IF!WIN_FREE THEN
  WND=0
  ERR=WIN_NOALLOC
  RETURN
 ENDIF
 VAR NC=CTL AND 4095
 ERR=0
 INC WIN_WIDCNT
 VAR NUWID,WID
 VAR PNUWID=PARENT AND NUWIDMASK
 NUWID=WIN_FREE
 WIN_FREE=WIN_NEXT[WIN_FREE]
 WID=WIN_WIDCNT
 WND=WIDNUWIDToWND(WID,NUWID)
 WIN_WID[NUWID]=WID
 WIN_CTL[NUWID]=CTL
 WIN_NAME$[NUWID]=NAME$
 '
 WIN_X[NUWID]=X
 WIN_Y[NUWID]=Y
 
 WIN_AX[NUWID]=WIN_FX[PNUWID]+X
 WIN_AY[NUWID]=WIN_FY[PNUWID]+Y '
 WIN_FW1[NUWID]=CTL_FW1[NC]
 WIN_FH1[NUWID]=CTL_FH1[NC]
 WIN_FW2[NUWID]=CTL_FW1[NC]+CTL_FW2[NC]
 WIN_FH2[NUWID]=CTL_FH1[NC]+CTL_FH2[NC]
 INC WIDTH,WIN_FW2[NUWID]
 WIN_WIDTH[NUWID]=WIDTH
 INC HEIGHT,WIN_FH2[NUWID]
 WIN_HEIGHT[NUWID]=HEIGHT
 WIN_AW[NUWID]=WIN_WIDTH[NUWID]
 WIN_AH[NUWID]=WIN_HEIGHT[NUWID]
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 WIN_NEXT[NUWID]=0
 WIN_PARENT[NUWID]=PARENT AND NUWIDMASK
 WIN_MINW[NUWID]=WIN_FW2[NUWID]
 WIN_MINH[NUWID]=WIN_FH2[NUWID]
 WIN_HIDE[NUWID]=FLG AND 4
 WIN_STYLE[NUWID]=(FLG AND 4)*2
 OTW_CLIPWindow NUWID
 IF PNUWID THEN 
  IF FLG AND WindowFrontFlag()THEN
   IF WIN_CHILD[PNUWID]THEN
    VAR N=WIN_CHILD[PNUWID]
    WHILE 1
     IF!WIN_NEXT[N]THEN
      WIN_NEXT[N]=NUWID
      WIN_PREV[NUWID]=N
      BREAK
     ENDIF
     N=WIN_NEXT[N]
    WEND
   ELSE
    WIN_CHILD[PNUWID]=NUWID
   ENDIF
   OTW_DrawMap NUWID
  ELSE
   N=WIN_CHILD[PNUWID]
   WIN_CHILD[PNUWID]=NUWID
   OTW_DrawMap NUWID
   IF N THEN
    WIN_NEXT[NUWID]=N
    WIN_PREV[N]=NUWID
    VAR B=NUWID
    WHILE B
     OTW_DrawMap B
     IF WIN_CHILD[B]THEN
      B=WIN_CHILD[B]
      CONTINUE
     ENDIF
     IF!WIN_NEXT[B]THEN
      WHILE B
       B=WIN_PARENT[B]
       IF B==PNUWID THEN BREAK
       IF WIN_NEXT[B]THEN B=WIN_NEXT[B]:BREAK
      WEND
      IF B==PNUWID THEN BREAK
     ENDIF
     B=WIN_NEXT[B]
     IF B==PNUWID THEN BREAK
    WEND
   ENDIF
  ENDIF
 ENDIF
 WIN_MSGS[NUWID]=0
 VOID RepaintWindow(WND)
 IF PARENT==WIN_ROOTWND THEN
  SPAllocWindow WND
 ENDIF
 WIN_BACKGND[NUWID]=WIN_BKGND
 IF (FLG AND 8)==8THEN
  WIN_STYLE[NUWID]=WIN_STYLE[NUWID] OR WIN_STYLE_OWNERDRAW
 ENDIF
 IF (FLG AND 512)!=512THEN
  WindowOnCreate WND,CTL,0,0
 ENDIF
 VOID ActiveWindow(WND)
END
DEF InitWindow WND,ARG1,ARG2
 IF!CheckWindow(WND)THEN RETURN
 WindowOnCreate WND,WIN_CTL[WND AND NUWIDMASK],ARG1,ARG2
END
COMMON DEF SetWindowBackColor WND,RGB
 IF!CheckWindow(WND)THEN RETURN
 WIN_BACKGND[WND AND NUWIDMASK]=RGB
 VOID RepaintWindow(WND)
END
COMMON DEF GetWindowBackColor(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 RETURN WIN_BACKGND[WND AND NUWIDMASK]
END
DEF SPAllocWindow WND
 INC OTW_TOPLEVELCNT
 VAR SP=2,NUWID=WND AND NUWIDMASK
 IF TRUE THEN
  VAR SP2
  SPSET 2,511,0 OUT SP
  IF OTW_ENABLE_SHADOW THEN
   SPSET 2,511,0 OUT SP2
   SPVAR SP,1,SP2
   SPLINK SP2,SP
   SPSCALE SP2,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
   SPCOLOR SP2,RGB(128,063,063,063)
   SPOFS SP2,3,3,1
   SPSHOW SP2
   SPVAR SP2,0,WND
  ENDIF
  WIN_SP[NUWID]=SP OR 512
 ELSE
 'FOR 3.0.X?
 WHILE SPVAR(SP,0)
  SP=(SP+1)MOD 255
 WEND
 WIN_SP[NUWID]=SP OR 512
 'SPSET SP,WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1,1
 SPSET SP,0
 ENDIF
 SPOFS SP,WIN_AX[NUWID],WIN_AY[NUWID],0
 SPSCALE SP,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
 SPSHOW SP
 SPVAR SP,0,WND
 OTW_SPSORT
END
COMMON DEF NewTopLevelMenuWindow CTL,NAME$,WIDTH,HEIGHT OUT WND,ERR
 NewTopLevelStyleWindow CTL,NAME$,WIDTH,HEIGHT,1 OUT WND,ERR
END
COMMON DEF WindowMenuStyle()
 RETURN 1
END
COMMON DEF WindowResizableStyle()
 RETURN 2
END
COMMON DEF WindowTransStyle()
 RETURN 4
END
COMMON DEF WindowHideStyle()
 RETURN 8
END
VAR WIN_TopLevelX2
DEF IncTopLevelPos NUCID
 INC WIN_TopLevelX,CTL_FH1[NUCID]-1
 INC WIN_TopLevelY,CTL_FH1[NUCID]-1
 IF WIN_TopLevelY>=240THEN
  WIN_TopLevelY=0
  INC WIN_TopLevelX2,CTL_FH1[NUCID]-1
  IF WIN_TopLevelX2>=400THEN
   WIN_TopLevelX2=0
  ENDIF
  WIN_TopLevelX=WIN_TopLevelX2
 ENDIF
END
COMMON DEF NewStyleWindowArg CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE,A1,A2 OUT WND,ERR
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 VAR NUCID=CTL AND 4095
' INC OTW_TOPLEVELCNT
 VAR _H=CTL_FH1[NUCID]
 'ごういん
 IF STYLE AND 1THEN
  INC CTL_FH1[NUCID],10
 ENDIF
 IF STYLE AND 2THEN
  INC CTL_FH1[NUCID],1
  INC CTL_FW1[NUCID],1
  INC CTL_FH2[NUCID],1
  INC CTL_FW2[NUCID],1
 ENDIF
 NewWindow CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG OR 512 OUT WND,ERR
 VAR MW=32
 IF MW>WIDTH THEN MW=WIDTH
 VAR NUWID=WND AND NUWIDMASK,SP
 SetWindowMinSize WND,CTL_FW1[NUCID]+MW,WIN_FH2[NUWID]
 CTL_FH1[NUCID]=_H
 IF ERR THEN RETURN
 'MENU
 IF STYLE AND 1THEN
  NewMenu OUT WIN_MENU[NUWID],ERR
  WIN_MENU[NUWID]=WIN_MENU[NUWID]
 ENDIF
 'RESIZABLE
 IF STYLE AND 2THEN
  WIN_STYLE[NUWID]=WIN_STYLE_RESIZ
  DEC CTL_FW1[NUCID],1
  DEC CTL_FH2[NUCID],1
  DEC CTL_FW2[NUCID],1
 ENDIF
 'TRANS
 IF STYLE AND 4THEN
  WIN_STYLE[NUWID]=WIN_STYLE_TRANS
  NOIMPL "TRANS
  NewImage WIDTH,HEIGHT,WIN_IMAGE[NUWID]
 ENDIF
 WIN_STYLE[NUWID]=STYLE
 IF STYLE AND WIN_STYLE_HIDE THEN
  WIN_HIDE[NUWID]=1
  IF WIN_SP[NUWID]THEN SPHIDE WIN_SP[NUWID]AND 511
 ENDIF
 InitWindow WND,A1,A2
END
COMMON DEF NewStyleWindow CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE OUT WND,ERR
 NewStyleWindowArg CTL,NAME$,X,Y,WIDTH,HEIGHT,PARENT,FLG,STYLE,0,0 OUT WND,ERR
END
COMMON DEF NewTopLevelStyleWindowArg CTL,NAME$,WIDTH,HEIGHT,STYLE,A1,A2 OUT WND,ERR
 NewStyleWindowArg CTL,NAME$,WIN_TopLevelX,WIN_TopLevelY,WIDTH,HEIGHT,WIN_ROOTWND2,WindowFrontFlag()OR 512,STYLE,A1,A2 OUT WND,ERR
 IF ERR THEN RETURN
 VAR NUCID=CTL AND 4095
 IncTopLevelPos NUCID
END
COMMON DEF NewTopLevelStyleWindow CTL,NAME$,WIDTH,HEIGHT,STYLE OUT WND,ERR
 NewTopLevelStyleWindowArg CTL,NAME$,WIDTH,HEIGHT,STYLE,0,0 OUT WND,ERR
 RETURN
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 VAR NUCID=CTL AND 4095
' INC OTW_TOPLEVELCNT
 VAR _H=CTL_FH1[NUCID]
 'ごういん
 IF STYLE AND 1THEN
  INC CTL_FH1[NUCID],10
 ENDIF
 IF STYLE AND 2THEN
  INC CTL_FH1[NUCID],1
  INC CTL_FW1[NUCID],1
  INC CTL_FH2[NUCID],1
  INC CTL_FW2[NUCID],1
 ENDIF
 NewWindow CTL,NAME$,WIN_TopLevelX,WIN_TopLevelY,WIDTH,HEIGHT,WIN_ROOTWND2,WindowFrontFlag()OR 512 OUT WND,ERR
 VAR MW=32
 IF MW>WIDTH THEN MW=WIDTH
 VAR NUWID=WND AND NUWIDMASK,SP
 SetWindowMinSize WND,CTL_FW1[NUCID]+MW,WIN_FH2[NUWID]
 CTL_FH1[NUCID]=_H
 IF ERR THEN RETURN
 'MENU
 IF STYLE AND 1THEN
  NewMenu OUT WIN_MENU[NUWID],ERR
  WIN_MENU[NUWID]=WIN_MENU[NUWID]
 ENDIF
 'RESIZABLE
 IF STYLE AND 2THEN
  WIN_STYLE[NUWID]=WIN_STYLE_RESIZ
  DEC CTL_FW1[NUCID],1
  DEC CTL_FH2[NUCID],1
  DEC CTL_FW2[NUCID],1
 ENDIF
 'TRANS
 IF STYLE AND 4THEN
  WIN_STYLE[NUWID]=WIN_STYLE_TRANS
  NOIMPL "TRANS
  NewImage WIDTH,HEIGHT,WIN_IMAGE[NUWID]
 ENDIF
 WIN_STYLE[NUWID]=STYLE
 IF STYLE AND WIN_STYLE_HIDE THEN
  WIN_HIDE[NUWID]=1
  IF WIN_SP[NUWID]THEN SPHIDE WIN_SP[NUWID]AND 511
 ENDIF
 IncTopLevelPos NUCID
' InitWindow WND,A1,A2
END
COMMON DEF NewTopLevelWindow CTL,NAME$,WIDTH,HEIGHT OUT WND,ERR
 IF WIN_ROOTWND THEN
  NewTopLevelStyleWindow CTL,NAME$,WIDTH,HEIGHT,0 OUT WND,ERR
  RETURN
 ENDIF
 IF!CheckControl(CTL)THEN
  WND=0
  ERR=CTL_INVALIDID
  RETURN
 ENDIF
 IF!WIN_FREE THEN
  WND=0
  ERR=WIN_NOALLOC
  RETURN
 ENDIF
 ERR=0
' INC OTW_TOPLEVELCNT
 INC WIN_WIDCNT
 VAR NUWID,WID
 NUWID=WIN_FREE
 WIN_FREE=WIN_NEXT[WIN_FREE]
 WID=WIN_WIDCNT
 WND=WIDNUWIDToWND(WID,NUWID)
 WIN_WID[NUWID]=WID
 WIN_CTL[NUWID]=CTL
 WIN_NAME$[NUWID]=NAME$
 '
 WIN_X[NUWID]=0
 WIN_Y[NUWID]=0
 
 WIN_AX[NUWID]=0
 WIN_AY[NUWID]=0
 WIN_AX[NUWID]=WIN_TopLevelX
 WIN_AY[NUWID]=WIN_TOPLEVELY
 '
 VAR NUCID=CTL AND 4095
 WIN_WIDTH[NUWID]=WIDTH
 WIN_HEIGHT[NUWID]=HEIGHT
 WIN_FW2[NUWID]=CTL_FW1[NUCID]+CTL_FW2[NUCID]
 WIN_FH2[NUWID]=CTL_FH1[NUCID]+CTL_FH2[NUCID]
 WIN_NEXT[NUWID]=0
 GCLIP 1,0,240,400,480
 VOID RepaintWindow(WND)
 IF!WIN_ROOTWND THEN
  GFILL WIN_AX[NUWID],WIN_AY[NUWID]+240,WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID]+240,ShortToRGB(NUWID)
  GCLIP 1,0,0,400,239
  WIN_AW[NUWID]=WIDTH
  WIN_AH[NUWID]=HEIGHT
  WIN_AFW[NUWID]=WIDTH
  WIN_AFH[NUWID]=HEIGHT
' SPSET SP,WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID],1
' SPSHOW SP
' SPOFS SP,WIN_AX[NUWID],WIN_AY[NUWID],1023
  WIN_ROOTWND2=WND
  RETURN
 ENDIF
 
 VAR ROOTNUWID=WIN_ROOTWND2 AND NUWIDMASK
 VAR C=WIN_CHILD[ROOTNUWID],N
 WIN_PARENT[NUWID]=ROOTNUWID
 IF!C THEN
  WIN_CHILD[ROOTNUWID]=NUWID
 ELSE
  N=C
  WHILE 1
   C=N
   N=WIN_NEXT[N]
   IF!N THEN
    WIN_NEXT[C]=NUWID
    WIN_PREV[NUWID]=C
    BREAK
   ENDIF
  WEND
 ENDIF
 WIN_FW1[NUWID]=CTL_FW1[NUCID]'WIN_TopLevelX
 WIN_FH1[NUWID]=CTL_FH1[NUCID]'WIN_TOPLEVELY
 WIN_AX[NUWID]=WIN_TopLevelX
 WIN_AY[NUWID]=WIN_TOPLEVELY
 WIN_X[NUWID]=WIN_TopLevelX
 WIN_Y[NUWID]=WIN_TOPLEVELY
IncTopLevelPos NUCID
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_RFY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
' WIN_WIDTH[NUWID]=WIDTH+WIN_FWIDTH+
' WIN_HEIGHT[NUWID]=HEIGHT
 
 WIN_HEIGHT[NUWID]=WIN_HEIGHT[NUWID]+CTL_FH1[NUCID]+CTL_FH2[NUCID]
 WIN_WIDTH[NUWID]=WIN_WIDTH[NUWID]+CTL_FW1[NUCID]+CTL_FW2[NUCID]
 WIN_AW[NUWID]=WIN_WIDTH[NUWID]
 WIN_AH[NUWID]=WIN_HEIGHT[NUWID]
 OTW_CLIPWindow NUWID
 OTW_DrawMap NUWID
 GCLIP 1,0,0,400,239
' GFILL WIN_AX[NUWID],WIN_AY[NUWID],WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID],RGB(255,255,255)
 SPAllocWindow WND
 WindowOnCreate WND,CTL
 VOID ActiveWindow(WND)
END
COMMON DEF NewDialogBoxWithArg(CTL,NAME$,WIDTH,HEIGHT,OWNER,FLAG,A1,A2)
 IF!CheckControl(CTL)THEN
  RETURN CTL_INVALIDID
 ENDIF
 IF!WIN_FREE THEN
  RETURN WIN_NOALLOC
 ENDIF
 VAR O=OWNER AND NUWIDMASK
 VAR AX=WIN_AX[O]+(WIN_WIDTH[O]-WIDTH)/2
 VAR AY=WIN_AY[O]+(WIN_HEIGHT[O]-HEIGHT)/2
 VAR WND,E
 IF AX<0THEN AX=0
 IF AY<0THEN AY=0
 NewWindow CTL,NAME$,AX,AY,WIDTH,HEIGHT,GetRootWND(),WindowFrontFlag()OR 512 OUT WND,E
 IF FLAG THEN
  WIN_STYLE[WND AND NUWIDMASK]=WIN_STYLE_MODAL
 ENDIF
 IF E THEN RETURN E
 InitWindow WND,A1,A2
 E=JoinWindowGroup(OWNER,WND)
 RETURN E
END
COMMON DEF NewDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER,FLAG)
 RETURN NewDialogBoxWithArg(CTL,NAME$,WIDTH,HEIGHT,OWNER,FLAG,0,0)
END
COMMON DEF NewModalDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER)
 RETURN NewDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER,1)
END
COMMON DEF NewModelessDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER)
 RETURN NewDialogBox(CTL,NAME$,WIDTH,HEIGHT,OWNER,0)
END
COMMON DEF DeleteWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR X=WIN_RX[NUWID],Y=WIN_RY[NUWID],W=WIN_AW[NUWID],H=WIN_AH[NUWID]
 VAR E=DeleteWindowNUWID(NUWID)
 RepaintAllWindow WIN_ROOTWND,X,Y,W,H
 RETURN E
END
COMMON DEF DeleteWindowNUWID(NUWID)
 VAR E
 WindowOnDelete NUWID
 IF WIN_WID[NUWID]<=0THEN RETURN WIN_INVALIDID
 WIN_STYLE[NUWID]=0
 WIN_MENU[NUWID]=0
 WIN_WID[NUWID]=0
 WIN_MSGS[NUWID]=0
 WIN_MSGE[NUWID]=0
 VAR I
 FOR I=0TO 7
  WIN_VAR[NUWID,I]=0
 NEXT
 FOR I=0TO 15
  WIN_MSGCNT[NUWID,I]=0
 NEXT
 VAR N=WIN_NEXT[NUWID]
 VAR P=WIN_PREV[NUWID]
 IF WIN_CHILD[WIN_PARENT[NUWID]]==NUWID THEN
  WIN_CHILD[WIN_PARENT[NUWID]]=N
 ENDIF
 IF WIN_CHILD[NUWID]THEN
  VAR C=WIN_CHILD[NUWID]
  VAR D
  WHILE C
   D=WIN_NEXT[C]
   E=DeleteWindowNUWID(C)
   C=D
  WEND
 ENDIF
 IF N THEN
  WIN_PREV[N]=P
 ENDIF
 IF P THEN
  WIN_NEXT[P]=N
 ENDIF
 WIN_NEXT[NUWID]=WIN_FREE
 WIN_PREV[NUWID]=0
 WIN_PARENT[NUWID]=0
 WIN_CHILD[NUWID]=0
 WIN_FREE=NUWID
 WIN_NAME$[NUWID]=""
 IF WIN_SP[NUWID]THEN
  SPVAR WIN_SP[NUWID]AND 511,0,0
  IF OTW_ENABLE_SHADOW THEN
   SPVAR SPVAR(WIN_SP[NUWID]AND 511,1),0,0
   SPCLR SPVAR(WIN_SP[NUWID]AND 511,1)
  ENDIF
  SPCLR WIN_SP[NUWID]AND 511
  WIN_SP[NUWID]=0
  DEC OTW_TOPLEVELCNT
  OTW_SPSORT
 ENDIF
 IF WIN_GPARENT[NUWID]THEN
  'NOIMPL "DeleteWindow - Group"
  
  IF WIN_GNEXT[NUWID]THEN
   WIN_GPREV[WIN_GNEXT[NUWID]]=WIN_GPREV[NUWID]
  ENDIF
  IF WIN_GPREV[NUWID]THEN
   WIN_GNEXT[WIN_GPREV[NUWID]]=WIN_GNEXT[NUWID]
  ELSE
   WIN_GROUP[WIN_GPARENT[NUWID]]=WIN_GNEXT[NUWID]
  ENDIF
  IF WIN_ACTIVENUWID==NUWID THEN VOID ActiveWindow(NUWIDToWND(WIN_GPARENT[NUWID]))
  WIN_GPARENT[NUWID]=0
  WIN_GPREV[NUWID]=0
  WIN_GNEXT[NUWID]=0
  IF WIN_GROUP[NUWID]THEN 
   NOIMPL "DeleteWindow - Group"
  ENDIF
  
 ENDIF
 RETURN 0
END

DEF OTW_SPSORT
 VAR I,Z=0
 IF OTW_TOPLEVELCNT-1THEN Z=(1022+255)/MAX(OTW_TOPLEVELCNT,1)
 VAR NUWID=WIN_CHILD[WIN_ROOTWND AND NUWIDMASK]
'IF!WIN_NEXT[NUWID]THEN I=
 I=1022+255
 WHILE NUWID
  I=I-Z
  IF WIN_HIDE[NUWID]THEN
   SPHIDE WIN_SP[NUWID]AND 511
  ELSE
   SPSHOW WIN_SP[NUWID]AND 511
  ENDIF
  SPOFS WIN_SP[NUWID]AND 511,,,-255+I
'  SPOFS (WIN_SP[NUWID]>>10),,,-255+I+1
  NUWID=WIN_NEXT[NUWID]
 WEND
END
DEF OTW_DrawMap NUWID
 IF WIN_HIDE[NUWID]THEN RETURN
 GPAGE OTW_SP,OTW_DP
 GCLIP 1,0,240,400,480
 GFILL WIN_RX[NUWID],WIN_RY[NUWID]+240,WIN_RX[NUWID]+WIN_AW[NUWID],WIN_RY[NUWID]+WIN_AH[NUWID]+240,ShortToRGB(WIN_FRAMEFLG OR NUWID)
'VAR W=WIN_AW[NUWID]-WIN_FW2[NUWID]
'VAR H=WIN_AH[NUWID]-WIN_FH2[NUWID]
'IF WIN_WIDTH[NUWID]!=WIN_AW[NUWID]THEN INC W,WIN_FW1[NUWID]
'IF WIN_HEIGHT[NUWID]!=WIN_AH[NUWID]THEN INC H,WIN_FH1[NUWID]
'GFILL WIN_RFX[NUWID],WIN_RFY[NUWID]+240,WIN_RFX[NUWID]+W,WIN_RFY[NUWID]+240+H,ShortToRGB(NUWID)
 IF WIN_AFW[NUWID]<0||WIN_AFH[NUWID]<0THEN
  GCLIP 1,0,0,400,239
  RETURN
 ENDIF
 GFILL WIN_RFX[NUWID],WIN_RFY[NUWID]+240,WIN_RFX[NUWID]+WIN_AFW[NUWID],WIN_RFY[NUWID]+240+WIN_AFH[NUWID],ShortToRGB(NUWID)
 GCLIP 1,0,0,400,239
END
COMMON DEF ActiveWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 WIN_ACTIVENUWID=NUWID
 RETURN 0
END
COMMON DEF FrontWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR N,C=WIN_NEXT[NUWID]
 IF C THEN
  WHILE 1
   IF!WIN_NEXT[C]THEN 
    VAR NUP=WIN_PREV[NUWID]
    VAR NUN=WIN_NEXT[NUWID]
    IF NUP THEN
     WIN_NEXT[NUP]=NUN
    ELSE
    WIN_CHILD[WIN_PARENT[NUWID]]=NUN
    ENDIF
    IF NUN THEN
     IF NUP THEN WIN_NEXT[NUP]=NUN
     WIN_PREV[NUN]=NUP
    ENDIF
    WIN_NEXT[C]=NUWID
    WIN_PREV[NUWID]=C
    WIN_NEXT[NUWID]=0
    BREAK
   ENDIF
   C=WIN_NEXT[C]
  WEND
  IF WIN_SP[NUWID] THEN
   OTW_SPSORT
  ENDIF
  RepaintAllWindow WND,0,0,0,0
 ENDIF
 VAR G=WIN_GROUP[NUWID],E=ActiveWindow(WND)
 WHILE G
  IF WIN_STYLE[G]AND WIN_STYLE_MODAL THEN
   BEEP 
   IF WIN_SP[NUWID]THEN
    SPANIM WIN_SP[NUWID]AND 511,6,-10,RGB(128,128,128),-10,RGB(255,255,255)
   ENDIF
   E=FrontWindow(NUWIDToWND(G))
  ENDIF
  G=WIN_GNEXT[G]
 WEND
 RETURN 0
END

DEF RepaintAllWindow WND,X,Y,W,H
 VAR NXT=WND AND NUWIDMASK
 VAR B=NXT
' WHILE NXT
'  VOID RepaintWindow(NXT OR(WIN_WID[NXT]<<WIDHIFT))
'  OTW_DrawMap NXT
'  IF WIN_CHILD[NXT]THEN
'   B=WIN_CHILD[NXT]
   WHILE B
    IF!WIN_HIDE[B]THEN VOID RepaintWindow(B OR(WIN_WID[B]<<WIDSHIFT))
    OTW_DrawMap B
    IF WIN_CHILD[B]THEN
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
  '    IF B==NXT THEN BREAK
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN RETURN
 '    IF B==NXT THEN BREAK
    ENDIF
    B=WIN_NEXT[B]
 '   IF B==NXT THEN BREAK
   WEND
'  ENDIF
'  NXT=WIN_NEXT[NXT]
' WEND
END
DEF OTW_CLIPWindow NUWID
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_AW[NUWID]=WIN_WIDTH[NUWID]
 WIN_AH[NUWID]=WIN_HEIGHT[NUWID]
 WIN_AFW[NUWID]=WIN_WIDTH[NUWID]-WIN_FW2[NUWID]
 WIN_AFH[NUWID]=WIN_HEIGHT[NUWID]-WIN_FH2[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 'ひだり はみで の しょり
 IF WIN_RX[NUWID]<WIN_RFX[PNUWID]THEN
  DEC WIN_AW[NUWID],WIN_RFX[PNUWID]-WIN_RX[NUWID]
  WIN_RX[NUWID]=WIN_RFX[PNUWID]
 ENDIF
 IF WIN_RFX[NUWID]<WIN_RFX[PNUWID]THEN
  DEC WIN_AFW[NUWID],WIN_RFX[PNUWID]-WIN_RFX[NUWID]
  WIN_RFX[NUWID]=WIN_RFX[PNUWID]
 ENDIF
 IF WIN_RY[NUWID]<WIN_RFY[PNUWID]THEN
  DEC WIN_AH[NUWID],WIN_RFY[PNUWID]-WIN_RY[NUWID]
  WIN_RY[NUWID]=WIN_RFY[PNUWID]
 ENDIF
 IF WIN_RFY[NUWID]<WIN_RFY[PNUWID]THEN
  DEC WIN_AFH[NUWID],WIN_RFY[PNUWID]-WIN_RFY[NUWID]
  WIN_RFY[NUWID]=WIN_RFY[PNUWID]
 ENDIF
 'みぎ はみで の しょり
 IF WIN_RFX[NUWID]+WIN_AFW[NUWID]>WIN_RFX[PNUWID]+WIN_AFW[PNUWID]THEN
  DEC WIN_AFW[NUWID],(WIN_RFX[NUWID]+WIN_AFW[NUWID])-(WIN_RFX[PNUWID]+WIN_AFW[PNUWID])
 ENDIF
 IF WIN_RX[NUWID]+WIN_AW[NUWID]>WIN_RFX[PNUWID]+WIN_AFW[PNUWID]THEN
  DEC WIN_AW[NUWID],(WIN_RX[NUWID]+WIN_AW[NUWID])-(WIN_RFX[PNUWID]+WIN_AFW[PNUWID])
 ENDIF

 IF WIN_RFY[NUWID]+WIN_AFH[NUWID]>WIN_RFY[PNUWID]+WIN_AFH[PNUWID]THEN
  DEC WIN_AFH[NUWID],(WIN_RFY[NUWID]+WIN_AFH[NUWID])-(WIN_RFY[PNUWID]+WIN_AFH[PNUWID])
 ENDIF
 IF WIN_RY[NUWID]+WIN_AH[NUWID]>WIN_RFY[PNUWID]+WIN_AFH[PNUWID]THEN
  DEC WIN_AH[NUWID],(WIN_RY[NUWID]+WIN_AH[NUWID])-(WIN_RFY[PNUWID]+WIN_AFH[PNUWID])
 ENDIF

 WIN_HIDE[NUWID]=WIN_STYLE[NUWID] AND WIN_STYLE_HIDE
 IF WIN_HIDE[PNUWID]THEN WIN_HIDE[NUWID]=1
 
' IF WIN_STYLE[PNUWID] AND WIN_STYLE_HIDE THEN WIN_HIDE[NUWID]=1
 IF WIN_AH[NUWID]<0THEN
  WIN_HIDE[NUWID]=1
  RETURN
 ENDIF
 IF WIN_AW[NUWID]<0THEN
  WIN_HIDE[NUWID]=1
  RETURN
 ENDIF
END
DEF OTW_CLIPCHILD NUWID
 WHILE NUWID
  OTW_CLIPWINDOW NUWID
  IF WIN_CHILD[NUWID]THEN
   OTW_CLIPCHILD WIN_CHILD[NUWID]
  ENDIF
  NUWID=WIN_NEXT[NUWID]
 WEND
END
COMMON DEF ShowWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_STYLE[NUWID] AND WIN_STYLE_HIDE THEN
  WIN_HIDE[NUWID]=FALSE
  WIN_STYLE[NUWID]=WIN_STYLE[NUWID] AND NOT WIN_STYLE_HIDE
  IF WIN_SP[NUWID]THEN
   OTW_SPSHOW NUWID
   OTW_SPCHR NUWID
  ENDIF
 ELSE
  RETURN 0
 ENDIF
 OTW_DrawMap NUWID
 RETURN RepaintWindow(WND)
END
COMMON DEF HideWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_STYLE[NUWID] AND WIN_STYLE_HIDE THEN RETURN 0
 WIN_HIDE[NUWID]=TRUE
 WIN_STYLE[NUWID]=WIN_STYLE[NUWID] OR WIN_STYLE_HIDE
 IF WIN_SP[NUWID]THEN
  OTW_SPHIDE NUWID 
 ENDIF
 RepaintAllWindow GetParentWindow(WND),WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
 RETURN 0
END
COMMON DEF BeginWindowOP(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 RETURN 0
END
COMMON DEF EndWindowOp(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 RepaintAllWindow WND,0,0,0,0
 RETURN 0
END
COMMON DEF MoveWindow2(WND,X,Y)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR MX=X-WIN_X[NUWID],MY=Y-WIN_Y[NUWID]
 IF!MX&&!MY THEN RETURN 0
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_X[NUWID]=X'INC WIN_X[NUWID],MX
 WIN_Y[NUWID]=Y'INC WIN_Y[NUWID],MY
 WIN_AX[NUWID]=WIN_AX[PNUWID]+WIN_FW1[PNUWID]+X
 WIN_AY[NUWID]=WIN_AY[PNUWID]+WIN_FH1[PNUWID]+Y
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 OTW_CLIPWindow NUWID
 VAR NXT=WIN_CHILD[WIN_PARENT[NUWID]],B

 IF!NXT THEN RETURN 0
 B=NXT
 IF WIN_PARENT[NUWID]==(WIN_ROOTWND AND NUWIDMASK) THEN
  IF WIN_SP[NUWID]THEN
   WIN_SP[NUWID]=WIN_SP[NUWID] OR 512
  ENDIF
 ENDIF
 VAR MOVEF=0
 B=WIN_PARENT[NUWID]
   WHILE B
    IF MOVEF THEN
     WIN_AX[B]=WIN_AX[B]+MX
     WIN_AY[B]=WIN_AY[B]+MY
     WIN_FX[B]=WIN_AX[B]+WIN_FW1[B]'+MX
     WIN_FY[B]=WIN_AY[B]+WIN_FH1[B]'+MY
     WIN_RFX[B]=WIN_FX[B]'+MX
     WIN_RFY[B]=WIN_FY[B]'+MY
     WIN_RX[B]=WIN_AX[B]'+MX
     WIN_RY[B]=WIN_AY[B]'+MY
     OTW_CLIPWindow B
     MOVEF=1
    ENDIF
    IF WIN_CHILD[B]THEN
     IF B==NUWID THEN MOVEF=1
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
      IF B==NUWID THEN MOVEF=0
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN RETURN 0
    ENDIF
    B=WIN_NEXT[B]
   WEND
 RETURN 0
END
COMMON DEF MoveWindow(WND,X,Y)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 VAR MX=X-WIN_X[NUWID],MY=Y-WIN_Y[NUWID]
 IF!MX&&!MY THEN RETURN 0
 VAR PNUWID=WIN_PARENT[NUWID]
 WIN_X[NUWID]=X'INC WIN_X[NUWID],MX
 WIN_Y[NUWID]=Y'INC WIN_Y[NUWID],MY
 WIN_AX[NUWID]=WIN_AX[PNUWID]+WIN_FW1[PNUWID]+X
 WIN_AY[NUWID]=WIN_AY[PNUWID]+WIN_FH1[PNUWID]+Y
 WIN_FX[NUWID]=WIN_AX[NUWID]+WIN_FW1[NUWID]
 WIN_FY[NUWID]=WIN_AY[NUWID]+WIN_FH1[NUWID]
 WIN_RFX[NUWID]=WIN_FX[NUWID]
 WIN_RFY[NUWID]=WIN_FY[NUWID]
 WIN_RX[NUWID]=WIN_AX[NUWID]
 WIN_RY[NUWID]=WIN_AY[NUWID]
 OTW_CLIPWindow NUWID
 VAR NXT=WIN_CHILD[WIN_PARENT[NUWID]],B
 VOID RepaintWindow(WIN_PARENT[NUWID]OR(WIN_WID[WIN_PARENT[NUWID]]<<WIDSHIFT))

 IF!NXT THEN RETURN 'WIN_
 B=NXT
 IF WIN_PARENT[NUWID]==(WIN_ROOTWND AND NUWIDMASK) THEN
  IF WIN_SP[NUWID]THEN
   WIN_SP[NUWID]=WIN_SP[NUWID] OR 512
  ENDIF
  GPAGE OTW_SP,OTW_GP
  GCOPY OTW_DP,WIN_AX[NUWID]-MX,WIN_AY[NUWID]-MY,WIN_AX[NUWID]-MX+WIN_WIDTH[NUWID],WIN_AY[NUWID]-MY+WIN_HEIGHT[NUWID],WIN_AX[NUWID],WIN_AY[NUWID],0
  GPAGE OTW_SP,OTW_DP
  GFILL WIN_AX[NUWID]-MX,WIN_AY[NUWID]-MY,WIN_AX[NUWID]-MX+WIN_WIDTH[NUWID],WIN_AY[NUWID]-MY+WIN_HEIGHT[NUWID],WIN_BKGND
  GCOPY OTW_GP,WIN_AX[NUWID],WIN_AY[NUWID],WIN_AX[NUWID]+WIN_WIDTH[NUWID],WIN_AY[NUWID]+WIN_HEIGHT[NUWID],WIN_AX[NUWID],WIN_AY[NUWID],0
  OTW_SPCHR NUWID
 ENDIF
 OTW_DrawMap WIN_PARENT[NUWID]
 '   B=WIN_CHILD[NXT]
 VAR MOVEF=0
 B=WIN_PARENT[NUWID]
   WHILE B
    IF MOVEF THEN
     WIN_AX[B]=WIN_AX[B]+MX
     WIN_AY[B]=WIN_AY[B]+MY
     WIN_FX[B]=WIN_AX[B]+WIN_FW1[B]'+MX
     WIN_FY[B]=WIN_AY[B]+WIN_FH1[B]'+MY
     WIN_RFX[B]=WIN_FX[B]'+MX
     WIN_RFY[B]=WIN_FY[B]'+MY
     WIN_RX[B]=WIN_AX[B]'+MX
     WIN_RY[B]=WIN_AY[B]'+MY
     OTW_CLIPWindow B
     MOVEF=1
    ENDIF
    IF!WIN_HIDE[B]THEN
     VOID RepaintWindow(B OR(WIN_WID[B]<<WIDSHIFT))
     OTW_DrawMap B
    ENDIF

    IF WIN_CHILD[B]THEN
     IF B==NUWID THEN MOVEF=1
     B=WIN_CHILD[B]
     CONTINUE
    ENDIF
    IF!WIN_NEXT[B]THEN
     WHILE B
      B=WIN_PARENT[B]
      IF B==NUWID THEN MOVEF=0
      IF WIN_NEXT[B]THEN BREAK
     WEND
     IF!B THEN RETURN 0
    ENDIF
    B=WIN_NEXT[B]
   WEND
 RETURN
END
DEF ResizeWindowF(WND,W,H)
 VAR NUWID=WND AND NUWIDMASK
 'ちいさい
 IF W+1<WIN_MINW[NUWID]THEN
  W=WIN_MINW[NUWID]-1
 ENDIF
 IF H+1<WIN_MINH[NUWID]THEN
  H=WIN_MINH[NUWID]-1
 ENDIF
 VOID FireResizeWindow(WND,W-WIN_FW2[NUWID],H-WIN_FH2[NUWID])
 WIN_WIDTH[NUWID]=W
 WIN_HEIGHT[NUWID]=H
 OTW_CLIPWindow NUWID
 OTW_CLIPCHILD NUWID
 RepaintAllWindow GetParentWindow(WND),WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
'WIN_AX[NUWID],WIN_AY[NUWID],WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
 RETURN 0
END
DEF MoveResizeWindowF(WND,X,Y,W,H)
 VAR NUWID=WND AND NUWIDMASK
 VAR E=MoveWindow2(WND,X,Y)
 IF E THEN RETURN E
 RETURN ResizeWindowF(WND,W,H)
END
COMMON DEF ResizeWindow(WND,W,H)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 RETURN ResizeWindowF(WND,W+WIN_FW2[NUWID],H+WIN_FH2[NUWID])
END
COMMON DEF MoveResizeWindow(WND,X,Y,W,H)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 RETURN MoveResizeWindowF(WND,X,Y,W+WIN_FW2[NUWID],H+WIN_FH2[NUWID])
END
COMMON DEF SendWindowEvent(WND,TYPE,A1,A2)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF(WIN_MSGS[NUWID]+1)MOD WIN_MSGMAX==WIN_MSGE[NUWID] THEN RETURN WIN_EVENTERR
 IF!LEN(CTL_HANDLER$[WIN_CTL[NUWID]AND 4095,TYPE])THEN RETURN 0
 IF CTL_NDHNDLR[TYPE]THEN
  IF WIN_MSGCNT[NUWID,TYPE]THEN RETURN 0
  INC WIN_MSGCNT[NUWID,TYPE]
 ENDIF
 WIN_MSGBUF[NUWID,WIN_MSGS[NUWID],0]=TYPE
 WIN_MSGBUF[NUWID,WIN_MSGS[NUWID],1]=A1
 WIN_MSGBUF[NUWID,WIN_MSGS[NUWID],2]=A2
 INC WIN_MSGS[NUWID]
 IF WIN_MSGS[NUWID]>=WIN_MSGMAX THEN WIN_MSGS[NUWID]=0
 RETURN 0
END
COMMON DEF RepaintWindow(WND)
 IF WIN_HIDE[WND AND NUWIDMASK]THEN RETURN 0
 RETURN SendWindowEvent(WND,CTL_PAINTHANDLER,0,0)
END
COMMON DEF SendNotificationWindow(WND,DAT,DAT2)
 RETURN SendWindowEvent(WND,CTL_NOTIFHANDLER,DAT,DAT2)
END
COMMON DEF SendNotifWindow(WND,DAT,DAT2)
 RETURN SendWindowEvent(WND,CTL_NOTIFHANDLER,DAT,DAT2)
END
COMMON DEF SendKeyWindow(WND,KEY)
 RETURN SendWindowEvent(WND,CTL_KEYHANDLER,KEY,0)
END
COMMON DEF SendButtonWindow(WND,BTN)
 RETURN SendWindowEvent(WND,CTL_BTNHANDLER,BTN,0)
END
COMMON DEF SendChFocusWindow(WND,FLG,FOCUSW)
 RETURN SendWindowEvent(WND,CTL_CHFOCUSHANDLER,FLG,FOCUSW)
END
COMMON DEF SendStrNotifWindow(WND,A1,STR$)
 RETURN SendWindowEvent(WND,CTL_STRNOTIFHANDLER,A1,AllocString(STR$))
END
DEF MouseMoveWindow(NUWID)
 RETURN SendWindowEvent(NUWIDToWND(NUWID),CTL_MOUSEMVHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF MouseLeaveWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_MSLEAVEHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF LMouseUpWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_LBTNUPHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF LMouseDownWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_LBTNDWNHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF LDoubleClickWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_LDBLCLKHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF RMouseUpWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_RBTNUPHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF RMouseDownWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_RBTNDWNHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF RDoubleClickWindow(WND)
 VAR NUWID=WND AND NUWIDMASK
 'FIXME:RDBLCLK
 RETURN SendWindowEvent(WND,CTL_LDBLCLKHANDLER,OTW_MOUSEX-WIN_AX[NUWID]-WIN_FW1[NUWID],OTW_MOUSEY-WIN_AY[NUWID]-WIN_FH1[NUWID])
END
DEF MouseMoveWindowOnFrame(NUWID)
 RETURN SendWindowEvent(NUWIDToWND(NUWID),CTL_FRMMOUSEMVHANDLER,0,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF LMouseDownWindowOnFrame(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_LBTNFLG OR CTL_BTNDWNFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF LMouseUpWindowOnFrame(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_LBTNFLG OR CTL_BTNUPFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF RMouseDownWindowOnFrame(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_RBTNFLG OR CTL_BTNDWNFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF RMouseUpWindowOnFrame(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMBTNHANDLER,CTL_RBTNFLG OR CTL_BTNUPFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF MouseLeaveWindowOnFrame(WND)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_FRMMOUSEMVHANDLER,CTL_LEAVEFLG,JoinInt(OTW_MOUSEX-WIN_AX[NUWID],OTW_MOUSEY-WIN_AY[NUWID]))
END
DEF FireResizeWindow(WND,W,H)
 VAR NUWID=WND AND NUWIDMASK
 RETURN SendWindowEvent(WND,CTL_RESIZEHANDLER,0,JoinInt(W,H))
END
COMMON DEF CallBaseControlHandler(WND,CTL,TYPE,A1,A2)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 CTL=CTL_PARENTCTL[CTL AND 4095]
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID 
 IF LEN(CTL_HANDLER$[CTL AND 4095,TYPE])THEN CALL CTL_HANDLER$[CTL AND 4095,TYPE],WND,CTL,TYPE,A1,A2
 RETURN 0
END
COMMON DEF CallControlHandler(WND,CTL,TYPE,A1,A2)
 IF!CheckControl(CTL)THEN RETURN CTL_INVALIDID
 IF LEN(CTL_HANDLER$[CTL AND 4095,TYPE])THEN CALL CTL_HANDLER$[CTL AND 4095,TYPE],WND,CTL,TYPE,A1,A2
 RETURN 0
END
COMMON DEF PeekWindowEvent(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_MSGS[NUWID]==WIN_MSGE[NUWID]THEN RETURN -1
 RETURN WIN_MSGBUF[NUWID,WIN_MSGE[NUWID],0]
END
COMMON DEF UpdateWindowOnly(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_GROUP[NUWID]THEN
  VAR G=WIN_GROUP[NUWID]
  WHILE G
   'TODO:TORIAEZU STACK OVERFLOW TAISAKU
   'IF G==WIN_GROUP[NUWID]THEN BREAK
   IF G==NUWID THEN BREAK
   IF UpdateWindow(G OR WIN_WID[G]<<12)THEN BREAK
   G=WIN_GNEXT[G]
  WEND
 ENDIF
 IF WIN_MSGS[NUWID]==WIN_MSGE[NUWID]THEN RETURN 0
 VAR NUCID=WIN_CTL[NUWID] AND 4095
 WHILE WIN_MSGS[NUWID]!=WIN_MSGE[NUWID]
 VAR S=WIN_MSGE[NUWID],S2=WIN_MSGS[NUWID]
 VAR TYPE=WIN_MSGBUF[NUWID,S,0]

 INC WIN_MSGE[NUWID]
 IF WIN_MSGE[NUWID]>=WIN_MSGMAX THEN WIN_MSGE[NUWID]=0
 IF TYPE==13THEN
  'CTL_STRNOTIFHANDLER
  CALL CTL_HANDLER$[NUCID,TYPE],WND,WIN_CTL[NUWID],TYPE,WIN_MSGBUF[NUWID,S,1],GetString$(WIN_MSGBUF[NUWID,S,2])
  FreeString WIN_MSGBUF[NUWID,S,2]
 ELSE
  CALL CTL_HANDLER$[NUCID,TYPE],WND,WIN_CTL[NUWID],TYPE,WIN_MSGBUF[NUWID,S,1],WIN_MSGBUF[NUWID,S,2]
 ENDIF
 IF WIN_WID[NUWID]<=0THEN RETURN WIN_INVALIDID
 IF WIN_BEGIN[NUWID]THEN VOID GEndWindow(WND)
 IF CTL_NDHNDLR[TYPE]THEN
  DEC WIN_MSGCNT[NUWID,TYPE]
 ENDIF
 IF S2!=WIN_MSGS[NUWID]THEN BREAK
 BREAK
 WEND
 RETURN 0
END
COMMON DEF UpdateWindow(WND)
 VAR E=UpdateWindowOnly(WND)
 VAR NUWID=WND AND NUWIDMASK
 IF E THEN RETURN E
 @END
 VAR B=WIN_CHILD[NUWID]
 VAR DB=B,PB=NUWID
 WHILE B
  IF B==NUWID THEN BREAK
  E=UpdateWindowOnly(B OR WIN_WID[B]<<WIDSHIFT)
  IF E THEN B=DB
  IF!B THEN B=PB
  IF WIN_CHILD[B]THEN
   B=WIN_CHILD[B]
   CONTINUE
  ENDIF
  IF!WIN_NEXT[B]THEN
   WHILE B
    B=WIN_PARENT[B]
    IF B==NUWID THEN BREAK
    IF WIN_NEXT[B]THEN BREAK
   WEND
   IF!B THEN BREAK
   IF B==NUWID THEN BREAK
   PB=B
   B=WIN_NEXT[B]
   CONTINUE
  ENDIF
  DB=B
  B=WIN_NEXT[B]
 WEND 
 RETURN 0
END

DEF GetWindowFrameWidth(WND)
 RETURN WIN_WIDTH[WND AND NUWIDMASK]
END
DEF GetWindowFrameHeight(WND)
 RETURN WIN_FH1[WND AND NUWIDMASK]'CTL_FH2[NUCID]
END
DEF GetWindowFrameHeight2(WND)
 RETURN WIN_FH2[WND AND NUWIDMASK]'CTL_FH2[NUCID]
END
common def GetWindowName$(wnd)
 if!checkwindow(wnd)then return ""
 return win_name$[wnd and nuwidmask]
end
common def SetWindowName wnd,name$
 if!checkwindow(wnd)then return
 win_name$[wnd and nuwidmask]=name$
end
COMMON DEF GetWindowWidth(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 RETURN WIN_WIDTH[WND AND NUWIDMASK]-WIN_FW2[WND AND NUWIDMASK]
END
COMMON DEF GetWindowHeight(WND)
 IF!CheckWindow(WND)THEN RETURN -1
 RETURN WIN_HEIGHT[WND AND NUWIDMASK]-WIN_FH2[WND AND NUWIDMASK]
END
COMMON DEF GetWindowX(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FX[WND AND NUWIDMASK]
 RETURN WIN_X[WND AND NUWIDMASK]+WIN_FW1[WND AND NUWIDMASK]
END
COMMON DEF GetWindowY(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FY[WND AND NUWIDMASK]
 RETURN WIN_Y[WND AND NUWIDMASK]+WIN_FH1[WND AND NUWIDMASK]
END
'ROOT WINDOWからの ぜっだいざびょう
COMMON DEF GetWindowAX(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FX[WND AND NUWIDMASK]
 RETURN WIN_AX[WND AND NUWIDMASK]+WIN_FW1[WND AND NUWIDMASK]-WIN_AX[WIN_ROOTWND2 AND NUWIDMASK]-WIN_FW1[WIN_ROOTWND2 AND NUWIDMASK]
END
'ROOT WINDOWからの ぜっだいざびょう
COMMON DEF GetWindowAY(WND)
 IF!CheckWindow(WND)THEN RETURN -1
'RETURN WIN_FY[WND AND NUWIDMASK]
 RETURN WIN_AY[WND AND NUWIDMASK]+WIN_FH1[WND AND NUWIDMASK]-WIN_AY[WIN_ROOTWND2 AND NUWIDMASK]-WIN_FH1[WIN_ROOTWND2 AND NUWIDMASK]
END
COMMON DEF GetWindowVar(WND,I)
 RETURN WIN_VAR[WND AND NUWIDMASK,I]
END
COMMON DEF SetWindowVar WND,I,V
 WIN_VAR[WND AND NUWIDMASK,I]=V
END
COMMON DEF GetControl(WND)
 RETURN WIN_CTL[WND AND NUWIDMASK]
END
COMMON DEF IsFocusWindow(WND)
 RETURN(WND AND NUWIDMASK)==WIN_ACTIVENUWID
END
COMMON DEF FocusWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR OLD=WIN_ACTIVENUWID
 WIN_ACTIVENUWID=WND AND NUWIDMASK
 IF OLD==WIN_ACTIVENUWID THEN RETURN 0
 VAR E=SendChFocusWindow(NUWIDToWND(OLD),FALSE,WND)
 E=SendChFocusWindow(WND,TRUE,NUWIDToWND(OLD)) RETURN 0
END
COMMON DEF IsActiveWindow(WND)
 VAR N=(WND AND NUWIDMASK)
 VAR P=WIN_ACTIVENUWID
 WHILE P
  IF P==N THEN RETURN 1
  P=WIN_PARENT[P]
 WEND
 RETURN 0
END
COMMON DEF GetMouseX()
 RETURN OTW_MOUSEX
END
COMMON DEF GetMouseY()
 RETURN OTW_MOUSEY
END
VAR WIN_DRAGHANDLER$
VAR WIN_DRAGHANDLER_A1
VAR WIN_DRAGHANDLER_A2
VAR WIN_DRAGHANDLER_USE
VAR WIN_DRAGHANDLER_WND
VAR WIN_DRG_USE
VAR WIN_DRG_NUSE
DEF SetWindowDragHandler(NAME$,WND,A1,A2)
 IF WIN_DRAGHANDLER_USE&&CheckWindow(WIN_DRAGHANDLER_WND)THEN
  RETURN WIN_DRG_USE
 ENDIF
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 WIN_DRAGHANDLER_USE=TRUE
 WIN_DRAGHANDLER$=NAME$
 WIN_DRAGHANDLER_A1=A1
 WIN_DRAGHANDLER_A2=A2
 WIN_DRAGHANDLER_WND=WND
 RETURN 0
END
DEF ClearWindowDragHandler()
 IF!WIN_DRAGHANDLER_USE THEN RETURN WIN_DRG_NUSE
 WIN_DRAGHANDLER_USE=FALSE
 WIN_DRAGHANDLER$=""
 WIN_DRAGHANDLER_A1=0
 WIN_DRAGHANDLER_A2=0
 WIN_DRAGHANDLER_WND=0
 RETURN 0
END
VAR CAPTURE_WND
COMMON DEF GetCapture()
 RETURN CAPTURE_WND
END
COMMON DEF SetCapture(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 VAR OLD=CAPTURE_WND
 CAPTURE_WND=WND
 RETURN OLD
END
COMMON DEF ReleaseCapture(WND)
 IF!CheckWindow(WND)THEN RETURN 0
 IF CAPTURE_WND!=WND THEN RETURN 0
 CAPTURE_WND=0
 RETURN 1
END
VAR OTW_MOUSECLIPX
VAR OTW_MOUSECLIPY
VAR OTW_MOUSECLIPX2
VAR OTW_MOUSECLIPY2
DEF MouseClip X,Y,W,H
 OTW_MOUSECLIPX=X
 OTW_MOUSECLIPY=Y
 OTW_MOUSECLIPX2=W+X
 OTW_MOUSECLIPY2=H+Y
END
DEF MouseClipDef
 MouseClip 0,0,399,239
END
COMMON DEF GetTextWidth(STR$)
 RETURN LEN(STR$)*8
END
COMMON DEF GetParentWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_PARENT[WND AND NUWIDMASK])
END
COMMON DEF GetChildWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_CHILD[WND AND NUWIDMASK])
END
COMMON DEF GetNextWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_NEXT[WND AND NUWIDMASK])
END
COMMON DEF GetPrevWindow(WND)
 IF!CheckWindow(WND)THEN
  RETURN 0
 ENDIF
 RETURN NUWIDToWND(WIN_PREV[WND AND NUWIDMASK])
END
''WINDOW GRAPHIC
VAR GB_WND
VAR WING_SX
VAR WING_SY
COMMON DEF SetWindowDrawPos WND,X,Y
 IF!CheckWindow(WND)THEN RETURN
 VAR NUWID=WND AND NUWIDMASK
 WING_SX=X+WIN_FX[NUWID]
 WING_SY=Y+WIN_FY[NUWID]
END
COMMON DEF GBeginWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_HIDE[NUWID]THEN RETURN WIN_NODRAW
 IF WIN_BEGIN[NUWID]==1THEN RETURN WIN_EVENTERR
 VAR AX=WIN_RFX[NUWID]'WIN_FW1[NUWID]
 VAR AY=WIN_RFY[NUWID]'WIN_FH1[NUWID]
 VAR W=WIN_AFW[NUWID]
 VAR H=WIN_AFH[NUWID]
 WING_SX=WIN_FX[NUWID]
 WING_SY=WIN_FY[NUWID]
 IF W<0||H<0THEN RETURN WIN_NODRAW
 GPAGE OTW_SP,OTW_BP
'OTW1C 3.1 の GCLIP BUG の ため
 GCLIP 1,AX,AY,AX+W,AY+H
 IF WIN_BEGIN[NUWID]>=2THEN RETURN 0
 WIN_BEGIN[NUWID]=TRUE
 GB_WND=NUWID
' GCLS
 GFILL AX,AY,AX+W,AY+H,0
 RETURN 0
END
DEF ReGBeginWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 WIN_BEGIN[NUWID]=2
 RETURN GBeginWindow(WND)
END
DEF GBeginFrameWindow(WND)
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_BEGIN[NUWID]THEN RETURN WIN_EVENTERR
 WIN_BEGIN[NUWID]=TRUE+TRUE
 VAR AX=WIN_RX[NUWID]
 VAR AY=WIN_RY[NUWID]
 VAR W=WIN_AW[NUWID]'WIN_WIDTH[NUWID]
 VAR H=WIN_AH[NUWID]'WIN_HEIGHT[NUWID]
 WING_SX=WIN_FX[NUWID]
 WING_SY=WIN_FY[NUWID]
 GB_WND=NUWID
 GPAGE OTW_SP,OTW_BP
'OTW1C 3.1 の GCLIP BUG の ため
' GCLIP 1,AX,AY,AX+W,AY+H
' GCLS' WIN_BKGND
 GFILL AX,AY,AX+W,AY+H,0
 RETURN 0
END
COMMON DEF GEndWindow(WND)
 GB_WND=0
 IF!CheckWindow(WND)THEN RETURN WIN_INVALIDID
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_HIDE[NUWID]THEN RETURN WIN_NODRAW
 IF!WIN_BEGIN[NUWID]THEN RETURN WIN_EVENTERR
 'ごうせい
 WIN_PARENT[0]=0
 WIN_NEXT[0]=0
 VAR AX=WIN_RX[NUWID]
 VAR AY=WIN_RY[NUWID]
 VAR W=WIN_AW[NUWID]
 VAR H=WIN_AH[NUWID]
 IF WIN_BEGIN[NUWID]!=2THEN
  AX=WIN_RFX[NUWID]
  AY=WIN_RFY[NUWID]
  W=WIN_AFW[NUWID]
  H=WIN_AFH[NUWID]
 ENDIF
 WIN_BEGIN[NUWID]=FALSE
 GCLIP 1,AX,AY,AX+W,AY+H
 VAR PNUWID
 IF WIN_CHILD[NUWID]THEN
  PNUWID=WIN_CHILD[NUWID]
  VAR W2=W,H2=H
  IF W==WIN_WIDTH[NUWID]THEN DEC W,WIN_FW2[NUWID]-WIN_FW1[NUWID]
 IF H==WIN_HEIGHT[NUWID]THEN DEC H,WIN_FH2[NUWID]-WIN_FH1[NUWID]
  GCLIP 1,AX,AY,AX+W,AY+H
  WHILE PNUWID
   IF!WIN_HIDE[PNUWID]THEN GCOPY OTW_DP,WIN_RX[PNUWID],WIN_RY[PNUWID],WIN_RX[PNUWID]+WIN_AW[PNUWID],WIN_RY[PNUWID]+WIN_AH[PNUWID],WIN_RX[PNUWID],WIN_RY[PNUWID],0

   PNUWID=WIN_NEXT[PNUWID]
  WEND
  W=W2
  H=H2
  GCLIP 1,AX,AY,AX+W,AY+H
 ENDIF
 VAR _NUWID=NUWID
 PNUWID=WIN_NEXT[NUWID]
 WHILE TRUE
  IF!PNUWID THEN
   PNUWID=WIN_PARENT[_NUWID]
   IF!PNUWID THEN BREAK
   _NUWID=PNUWID
   PNUWID=WIN_NEXT[PNUWID]
   CONTINUE
  ENDIF
   IF!WIN_HIDE[PNUWID]THEN GCOPY OTW_DP,WIN_RX[PNUWID],WIN_RY[PNUWID],WIN_RX[PNUWID]+WIN_AW[PNUWID],WIN_RY[PNUWID]+WIN_AH[PNUWID],WIN_RX[PNUWID],WIN_RY[PNUWID],0
  _NUWID=PNUWID
  PNUWID=WIN_NEXT[PNUWID]
 WEND
 GPAGE OTW_SP,OTW_DP
 GCLIP 1,0,0,400,239
 GCOPY OTW_BP,AX,AY,AX+W,AY+H,AX,AY,0
 IF WIN_SP[NUWID]AND 512THEN OTW_SPCHR NUWID
 IF MAINCNT-OTW_LASTUPD>5THEN UpdateMouse
 RETURN 0
END
DEF OTW_SPCHR NUWID
 VAR SP=WIN_SP[NUWID]AND 511
 IF OTW_ENABLE_SHADOW THEN
  VAR SP2=SPVAR(SP,1)
  SPSCALE SP2,WIN_WIDTH[NUWID],WIN_HEIGHT[NUWID]
 ENDIF
 SPSCALE SP,1,1
 SPCHR SP,WIN_RX[NUWID],WIN_RY[NUWID],WIN_AW[NUWID]+1,WIN_AH[NUWID]+1,1
 SPOFS SP,WIN_RX[NUWID],WIN_RY[NUWID]
END
DEF OTW_SPSHOW NUWID
 VAR SP=WIN_SP[NUWID]AND 511
 IF OTW_ENABLE_SHADOW THEN
  VAR SP2=SPVAR(SP,1)
  SPSHOW SP2
 ENDIF
 SPSHOW SP
END
DEF OTW_SPHIDE NUWID
 VAR SP=WIN_SP[NUWID]AND 511
 IF OTW_ENABLE_SHADOW THEN
  VAR SP2=SPVAR(SP,1)
  SPHIDE SP2
 ENDIF
 SPHIDE SP
END
COMMON DEF GPSETWindow WND,X,Y,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GPSET X+AX,Y+AY,COL
END
COMMON DEF GCLSWindow WND,COL
 GCLS COL
END
COMMON DEF GFILLWindow WND,X,Y,X2,Y2,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GFILL X+AX,Y+AY,X2+AX,Y2+AY,COL
END
COMMON DEF GBOXWindow WND,X,Y,X2,Y2,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GBOX X+AX,Y+AY,X2+AX,Y2+AY,COL
END
COMMON DEF GLINEWindow WND,X,Y,X2,Y2,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GLINE X+AX,Y+AY,X2+AX,Y2+AY,COL
END
COMMON DEF GCIRCLEWindow WND,X,Y,R,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GCIRCLE X+AX,Y+AY,R,COL
END
COMMON DEF GCIRCLE2Window WND,X,Y,R,S,E,F,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GCIRCLE X+AX,Y+AY,R,S,E,F,COL
END
COMMON DEF GTRIWindow WND,X,Y,X2,Y2,X3,Y3,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GTRI X+AX,Y+AY,X2+AX,Y2+AY,X3+AX,Y3+AY,COL
END
COMMON DEF GCOPYWindow WND,X1,Y1,X2,Y2,X3,Y3,MODE
 GCOPY X1+WING_SX,Y1+WING_SY,X2+WING_SX,Y2+WING_SY,X3+WING_SX,Y3+WING_SY,MODE
END
COMMON DEF GLOADWindow WND,X,Y,W,H,IMG[],FLG,MODE
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 GLOAD X+AX,Y+AY,W,H,IMG,FLG,MODE
END
COMMON DEF GSAVEImage IMG,WND,X,Y,W,H,IX,IY
 IF (WND AND NUWIDMASK)==GB_WND THEN RETURN
 IF!CheckImage(IMG)THEN RETURN
 VAR PTR=IMAGE_PTR[IMG AND 4095]+IX*IY
 DIM I[W*H]
 ReadArray PTR,I,0,W*H
 VAR AX=WIN_FX[WND AND NUWIDMASK]
 VAR AY=WIN_FY[WND AND NUWIDMASK]
 GSAVE AX+X,AY+Y,W,H,I,1
 WriteArray PTR,I,0,W*H
END
COMMON DEF GPRINTWindowCC WND,X,Y,STR$,PAL
 GPRINTWindow WND,X,Y,STR$,OTW_CONSOLEPAL[PAL]
END
COMMON DEF GetConsolePalette(PAL)
 RETURN OTW_CONSOLEPAL[PAL]
END
COMMON DEF GLINEArrayMemory PTR,W,H,X,Y,X2,Y2,COL
 COL=RGBToShort(COL)
 DIM M[0]
 M=GetRawMemory()
 VAR I
 VAR DX=ABS(X2-X)
 VAR DY=ABS(Y2-Y)
 VAR SX,SY
 IF X<X2 THEN SX=1 ELSE SX=-1
 IF Y<Y2 THEN SY=1 ELSE SY=-1
 VAR ERR=DX-DY
 VAR E2
 WHILE 1
  IF X<W&&Y<H&&X>=0&&Y>=0THEN M[PTR+X+Y*W]=COL
  IF X==X2&&Y==Y2 THEN RETURN
  E2=2*ERR
  IF E2>-DY THEN
   DEC ERR,DY
   INC X,SX
  ENDIF
  IF E2<DX THEN
   INC ERR,DX
   INC Y,SY
  ENDIF
 WEND
END
COMMON DEF GPRINTWindow WND,X,Y,STR$,COL
 INC X,WING_SX'WIN_FX[WND AND NUWIDMASK]
 INC Y,WING_SY'WIN_FY[WND AND NUWIDMASK]
 IF COL AND&HFF000000THEN
  GPUTCHR X,Y,STR$,1,1,COL
 ENDIF
 RETURN
'3.0.x
 VAR L=LEN(STR$)-1,A,I
 FOR I=0TO L
  A=ASC(STR$[I])
  IF A==10THEN Y=Y+8:X=0:CONTINUE
  GPUTCHRWindow WND,X,Y,A,COL
  INC X,8
 NEXT
END
COMMON DEF GPRINTBWindow WND,X,Y,STR$,COL,BC
 INC X,WING_SX'WIN_FX[WND AND NUWIDMASK]
 INC Y,WING_SY'WIN_FY[WND AND NUWIDMASK]
 IF BC AND&HFF000000THEN
  GFILL X,Y,X+LEN(STR$)*8-1,Y+7,BC
 ENDIF
 IF COL AND&HFF000000THEN
  GPUTCHR X,Y,STR$,1,1,COL
 ENDIF
 RETURN
'3.0.x
 VAR L=LEN(STR$)-1,A,I
 FOR I=0TO L
  A=ASC(STR$[I])
  IF A==10THEN Y=Y+8:X=0:CONTINUE
  GPUTCHRBWindow WND,X,Y,A,COL,BC
  INC X,8
 NEXT
END
DIM OTW_FNTTMP[0]
COMMON DEF GPUTCHRWindow WND,X,Y,A,COL
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 X=X+AX:Y=Y+AY
 GPUTCHR X,Y,CHR$(A),1,1,COL
 RETURN
'3.0.x
 OTW_FNTPAL[0]=0
 OTW_FNTPAL[1]=COL
 COPY OTW_FNTTMP,0,OTW_FNT,64*OTW_FNTTBL[A],64
 VAR I
 GLOAD X,Y,8,8,OTW_FNTTMP,OTW_FNTPAL,0
END
COMMON DEF GPUTCHRSizeWindow WND,X,Y,A,SX,SY,COL
 GPUTCHR X+WING_SX,Y+WING_SY,CHR$(A),SX,SY,COL
END
COMMON DEF GPUTCHRSize1Window WND,X,Y,A,S,COL
 GPUTCHR X+WING_SX,Y+WING_SY,CHR$(A),S,S,COL
END
COMMON DEF GPUTCHRBWindow WND,X,Y,A,COL,BC
 VAR AX=WING_SX'WIN_FX[WND AND NUWIDMASK]
 VAR AY=WING_SY'WIN_FY[WND AND NUWIDMASK]
 X=X+AX:Y=Y+AY
 IF BC AND&HFF000000THEN
  GFILL X,Y,X+7,Y+7,BC
 ENDIF
 GPUTCHR X,Y,CHR$(A),1,1,COL
 RETURN
'3.0.x
 OTW_FNTPAL[0]=BC
 OTW_FNTPAL[1]=COL
 COPY OTW_FNTTMP,0,OTW_FNT,64*OTW_FNTTBL[A],64
 VAR I
 GLOAD X,Y,8,8,OTW_FNTTMP,OTW_FNTPAL,0
END
COMMON DEF GetBackColor()
 RETURN WIN_BKGND
END
DEF DesktopPainter WND,CTL,TYPE,A1,A2
RETURN
 VAR E=GBEGINWindow(WND)
 IF E THEN RETURN
 GCLSWindow WND,RGB(0,128,128)
 GFILLWindow WND,0,0,32,32,RGB(255,0,0)
 E=GENDWindow(WND)
END
DEF WindowPainter WND,CTL,TYPE,A1,A2
 VAR E=GBeginFrameWindow(WND)
 IF E THEN RETURN
 VAR NUWID=WND AND NUWIDMASK
 VAR NUCID=WIN_CTL[NUWID] AND 4095
 VAR FW=WIN_FW1[NUWID]
 VAR FH=WIN_FH1[NUWID]
 VAR H=GetWindowFrameHeight(WND)
 VAR W=GetWindowFrameWidth(WND)
 VAR H2=WIN_HEIGHT[NUWID]-H
 VAR SH=FH-12'CTL_FH1[NUCID]
 VAR SW=WIN_FW2[NUWID]-2'CTL_FW1[NUCID]-CTL_FW2[NUCID]
 IF WIN_MENU[NUWID]THEN DEC SH,10'TODO:MENU_HEIGHT
 VAR C=WIN_BKGND
 DEC H,SH
 DEC W,SW
 GCLSWindow WND,WIN_BKGND
 GFILLWindow WND,0,-H+1,W-2,-1,RGB(0,0,255)
 GPRINTWindowCC WND,1,-H+2,GetWindowName$(WND),15
 GFILLWindow WND,W-09-1,-H+1,W-1,-H+10,RGB(224,0,0)
 GLINEWindow WND,-1,-1,W-2,-1,RGB(0,0,0)
 GLINEWindow WND,W-08-1,-H+3,W-2-1,-H+9,C
 GLINEWindow WND,W-7-1,-H+3,W-1-1,-H+9,C
 GLINEWindow WND,W-2-1,-H+3,W-8-1,-H+9,C
 GLINEWindow WND,W-1-1,-H+3,W-7-1,-H+9,C
 GBOXWindow WND,-1,-H,W-1,H2,RGB(0,0,0)
 IF FW>1 THEN
  INC H,SH
  GLINEWindow WND,-1,-H+1,W-2,-H+1,-1
  GLINEWindow WND,-2,-H,W-1,-H,RGB(224,224,224)
  GLINEWindow WND,-1,-H+1,-1,H2-2,-1
  GLINEWindow WND,-2,-H+1,-2,H2-1,RGB(224,224,224)
  GLINEWindow WND,W-1,-H+1,W-1,H2-1,RGB(128,128,128)
  GLINEWindow WND,W,-H,W,H2,RGB(0,0,0)
  GLINEWindow WND,W-2,H2-1,-1,H2-1,RGB(128,128,128)
  GLINEWindow WND,W,H2,-2,H2,RGB(0,0,0)
 ENDIF
 IF WIN_MENU[NUWID]THEN
  GLINEWindow WND,0,-11,W-2,-11,RGB(0,0,0)
  GFILLWindow WND,0,-10,W-2,-2,WIN_BKGND
  C=WIN_MENU[NUWID]AND 4095
  VAR I=MENU_ITEM[C]
  VAR X=0
  WHILE I
   GPRINTWindow WND,X,-9,MENU_INAME$[I],RGB(0,0,0)
   X=X+LEN(MENU_INAME$[I])*8+4
   I=MENU_INEXT[I]
  WEND
 ENDIF
 E=ReGBeginWindow(WND)
END
DEF WindowChFocus WND,CTL,TYPE,A1,A2
 IF A1 THEN
  VAR E=FrontWindow(WND)
 ENDIF
END
DEF WindowLMouseDown WND,CTL,TYPE,A1,A2
' VAR E=FrontWindow(WND)
END
DEF WindowClickFrame WND,CTL,TYPE,BTN,POS
 VAR X,Y
 SplitInt POS OUT X,Y
 VAR W=GetWindowFrameWidth(WND)
 VAR NUWID=WND AND NUWIDMASK
 OTW_MOVWINFLG=0
 IF WIN_STYLE[NUWID]AND WIN_STYLE_RESIZ THEN
  '2     3     4
  ' 
  ' 
  '           
  '5          6
  '           
  '           
  '           
  '789
  WHILE 1
  IF Y<4&&X<4THEN
   OTW_MOVWINFLG=2'
   BREAK
  ENDIF
  VAR EX=WIN_WIDTH[NUWID]-X
  VAR EY=WIN_HEIGHT[NUWID]-Y
  IF EX<4&&Y<4THEN 
   OTW_MOVWINFLG=4'
   BREAK
  ENDIF
  IF EY<4&&X<4THEN
   OTW_MOVWINFLG=7'
   BREAK          '
  ENDIF
  IF EX<4&&EY<4THEN
   OTW_MOVWINFLG=9
   BREAK
  ENDIF
  IF EY<2THEN
   OTW_MOVWINFLG=8
   BREAK
  ENDIF
  IF EX<2THEN
   OTW_MOVWINFLG=6
   BREAK
  ENDIF
  IF Y<2THEN
   OTW_MOVWINFLG=3
   BREAK
  ENDIF
  IF X<2THEN
   OTW_MOVWINFLG=5
   BREAK
  ENDIF
  BREAK
  WEND
  IF OTW_MOVWINFLG>=2THEN
   VAR AX=WIN_AX[NUWID]
   VAR AY=WIN_AY[NUWID]
   INC X,AX
   INC Y,AY
   IF SetWindowDragHandler("WindowDragFrame",WND,AX-X,AY-Y)THEN RETURN
   SPSHOW OTW_MOVWINSP
   SPSCALE OTW_MOVWINSP,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
   SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
   SPOFS OTW_MOVWINSP,AX,AY,-256
   SPVAR OTW_MOVWINSP,1,NUWID
   SPVAR OTW_MOVWINSP,2,AX-X
   SPVAR OTW_MOVWINSP,3,AY-Y
   VAR PNUWID=WIN_PARENT[NUWID]
   MouseClip WIN_FX[PNUWID],WIN_FY[PNUWID],WIN_WIDTH[PNUWID]-WIN_FW2[PNUWID],WIN_HEIGHT[PNUWID]-WIN_FH2[PNUWID]
   RETURN
  ENDIF
 ENDIF
 IF!IsFocusWindow(WND)THEN RETURN
 IF X&&Y>11&&Y<21&&WIN_MENU[NUWID]THEN
  IF BTN AND CTL_BTNUPFLG THEN
   VAR C=WIN_MENU[NUWID]AND 4095
   IF MENU_ICHILD[MENU_SEL[C]]THEN
    VAR X1,X2,I=MENU_ITEM[C]
    WHILE I
     X1=X2
     X2=X2+LEN(MENU_INAME$[I])*8+4
     IF X1<=X&&X2>=X THEN
      ShowMenu_ MENU_ICHILD[MENU_SEL[C]],WND,X1,0
      BREAK
     ENDIF
     I=MENU_INEXT[I]
    WEND
   ENDIF
  ENDIF
  RETURN
 ENDIF
 IF X>=W-9THEN
  IF BTN AND CTL_BTNUPFLG THEN
   VAR E=DeleteWindow(WND)
  ENDIF
  RETURN
 ENDIF
 IF BTN AND CTL_LBTNFLG THEN
  IF BTN AND CTL_BTNDWNFLG THEN
 '  IF!IsFocusWindow(WND)THEN RETURN
   OTW_MOVWINFLG=1'MOV
   AX=WIN_AX[NUWID]
   AY=WIN_AY[NUWID]
   INC X,AX
   INC Y,AY
   IF SetWindowDragHandler("WindowDragFrame",WND,AX-X,AY-Y)THEN RETURN
   SPSHOW OTW_MOVWINSP
   SPSCALE OTW_MOVWINSP,WIN_WIDTH[NUWID]+1,WIN_HEIGHT[NUWID]+1
   SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
   SPOFS OTW_MOVWINSP,AX-X,AY-Y,-256
   SPLINK OTW_MOVWINSP,OTW_MOUSESP
   SPVAR OTW_MOVWINSP,1,NUWID
   SPVAR OTW_MOVWINSP,2,AX-X
   SPVAR OTW_MOVWINSP,3,AY-Y
   PNUWID=WIN_PARENT[NUWID]
   MouseClip WIN_FX[PNUWID],WIN_FY[PNUWID],WIN_WIDTH[PNUWID]-WIN_FW2[PNUWID],WIN_HEIGHT[PNUWID]-WIN_FH2[PNUWID]
  ENDIF
 ENDIF
END
DEF WindowMMoveFrame WND,CTL,TYPE,ET,XY
 IF ET AND CTL_LEAVEFLG THEN 
  OTW_INITSP 0
  RETURN
 ENDIF
 VAR X,Y
 SplitInt XY OUT X,Y
 VAR NUWID=WND AND NUWIDMASK
 IF WIN_STYLE[NUWID]AND WIN_STYLE_RESIZ THEN
  '
  '
  '
  '  
  '   
  IF Y<4&&X<4THEN
   OTW_INITSP 3
   RETURN
  ENDIF
  VAR EX=WIN_WIDTH[NUWID]-X
  VAR EY=WIN_HEIGHT[NUWID]-Y
  IF EX<4&&Y<4THEN 
   OTW_INITSP 4
   RETURN
  ENDIF
  IF EY<4&&X<4THEN
   OTW_INITSP 4
   RETURN
  ENDIF
  IF EX<4&&EY<4THEN
   OTW_INITSP 3
   RETURN
  ENDIF
  IF EY<2THEN
   OTW_INITSP 1
   RETURN
  ENDIF
  IF EX<2THEN
   OTW_INITSP 2
   RETURN
  ENDIF
  IF Y<2THEN
   OTW_INITSP 1
   RETURN
  ENDIF
  IF X<2THEN
   OTW_INITSP 2
   RETURN
  ENDIF
  OTW_INITSP 0
 ENDIF
 IF!IsActiveWindow(WND)THEN RETURN
 IF!WIN_MENU[NUWID]THEN RETURN
 VAR C=WIN_MENU[NUWID]AND 4095
 IF!(X&&Y>11&&Y<21)THEN
  IF MENU_SEL[C]THEN X=-1 ELSE RETURN
 ENDIF
 IF WIN_MENU[NUWID]THEN
  VAR I=MENU_ITEM[C]
  VAR X2=0,X1=0
  VAR OS=MENU_SEL[C]
  VAR IN=0,BEG=0,FIND
  WHILE I
   X1=X2
   X2=X2+LEN(MENU_INAME$[I])*8+4
   IF X1<=X&&X2>=X THEN
    IF OS==I THEN RETURN
    IF!BEG&&GBeginFrameWindow(WND)THEN BREAK
    BEG=1
    FIND=1
    GFILLWindow WND,X1,-10,X2-2,-2,RGB(0,0,255)
    GPRINTWindow WND,X1,-9,MENU_INAME$[I],-1
    MENU_SEL[C]=I
    IN=1
    I=MENU_INEXT[I]
    IF!OS THEN BREAK
    WHILE I
     X1=X2
     X2=X2+LEN(MENU_INAME$[I])*8+4
     IF I==OS THEN
      OS=0
      GFILLWindow WND,X1,-10,X2,-2,WIN_BKGND
      GPRINTWindow WND,X1,-9,MENU_INAME$[I],RGB(0,0,0)
      BREAK
     ENDIF
     I=MENU_INEXT[I]
    WEND
    BREAK
'   IF!OS THEN BREAK
   ELSE
    IF I==OS THEN
     IF!BEG&&GBeginFrameWindow(WND)THEN BREAK
     BEG=1
     OS=0
     GFILLWindow WND,X1,-10,X2,-2,WIN_BKGND
     GPRINTWindow WND,X1,-9,MENU_INAME$[I],RGB(0,0,0)
    IF IN THEN BREAK
    ENDIF
   ENDIF
   I=MENU_INEXT[I]
  WEND
  IF BEG THEN BEG=GEndWindow(WND)
  IF!FIND THEN MENU_SEL[C]=0
 ENDIF
END
DEF WindowDragFrame WND,MX,MY,A1X,A2Y
 VAR NUWID=WND AND NUWIDMASK
 IF OTW_MOVWINFLG==1THEN
  DEC MX,WIN_AX[WIN_PARENT[NUWID]]+WIN_FW1[WIN_PARENT[NUWID]]'WIN_Y[NUWID]WIN_FW1[WIN_PARENT[NUWID]]
  DEC MY,WIN_AY[WIN_PARENT[NUWID]]+WIN_FH1[WIN_PARENT[NUWID]]'WIN_FH1[WIN_PARENT[NUWID]]
  VAR X=MX+A1X
  VAR Y=MY+A2Y
  VAR E=MoveWindow(WND,X,Y)
  E=FrontWindow(WND)
  SPUNLINK OTW_MOVWINSP
 ELSE
  MoveWindowSP TRUE
 ENDIF
 SPHIDE OTW_MOVWINSP
 MouseClipDef
 'OTW_MOVWINFLG=0
END
COMMON DEF IsOwnerDrawWindow(WND)
 RETURN !!(WIN_STYLE[WND AND NUWIDMASK]AND WIN_STYLE_OWNERDRAW)
END
COMMON DEF IsCheckedButton(WND)
 VAR CTL=GetControl(WND)
 IF IsControlExtend(CTL,CTL_BUTTONCTL)THEN
  IF GetWindowVar(WND,1)THEN
   RETURN TRUE
  ENDIF
 ENDIF
 RETURN FALSE
END
COMMON DEF UnCheckButton WND
 VAR CTL=GetControl(WND)
 IF IsControlExtend(CTL,CTL_BUTTONCTL)THEN
  IF GetWindowVar(WND,1)THEN
   SetWindowVar WND,1,FALSE
   VOID RepaintWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF CheckButton WND
 VAR CTL=GetControl(WND)
 IF IsControlExtend(CTL,CTL_BUTTONCTL)THEN
  IF!GetWindowVar(WND,1)THEN
   SetWindowVar WND,1,TRUE
   VOID RepaintWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF UnCheckButtonsGroup WND
 VAR MEMBER=GetWindowGroupMember(WND)
 WHILE MEMBER
  UnCheckButton MEMBER
  ?MEMBER,GetWindowName$(MEMBER)
  MEMBER=GetNextWindowGroupMember(MEMBER)
 WEND
END
DEF ButtonPainter W,C,T,A1,A2
 VAR E=GBeginWindow(W)
 IF E THEN RETURN
 '2:LEFT
 '1:RIGHT
 '0:CENTER
 VAR ALIGN=GetWindowVar(W,2)
 VAR TG=GetWindowVar(W,1)
 VAR HE=GetWindowHeight(W)
 VAR WI=GetWindowWidth(W)
 VAR NA$=GetWindowName$(W)
 VAR B1=RGB(0,0,0)
 VAR B2=-1
 IF TG THEN SWAP B1,B2
 GFILLWindow W,0,0,WI,HE,WIN_BTNBACK
 VAR TX
 ON ALIGN GOTO @CENTER,@RIGHT,@LEFT,@DEFAULT
 @CENTER
 TX=(WI-GetTextWidth(NA$))/2+TG+1
 GOTO @DEFAULT
 @RIGHT
 TX=WI-GetTextWidth(NA$)+TG-1
 GOTO @DEFAULT
 @LEFT
 TX=TG+1
 @DEFAULT
 GPRINTWindow W,TX,(HE-6)/2+TG,NA$,RGB(0,0,0)
 GBOXWindow W,0,0,WI,HE,B1
 GLINEWindow W,0,0,0,HE-1,B2
 GLINEWindow W,0,0,WI-1,0,B2
 IF!IsOwnerDrawWindow(W)THEN
  E=GEndWindow(W)
 ELSE
  SetWindowDrawPos W,1+TG,1+TG
 ENDIF
END
DEF ButtonLMouseUP W,C,T,X,Y
 IF GetWindowVar(W,1)THEN
 VAR E=SendNotificationWindow(GetParentWindow(W),W,GetWindowVar(W,0))
 SetWindowVar W,1,FALSE
 VOID RepaintWindow(W)
 ENDIF
'ButtonPainter W,C,T,0,0
END
DEF ButtonLMouseDown W,C,T,X,Y
 SetWindowVar W,1,TRUE
 VOID RepaintWindow(W)
 VOID SetCapture(W)
'ButtonPainter W,C,T,0,0
END
DEF ToggleButtonLMouseUP W,C,T,X,Y
 VAR E=SendNotificationWindow(GetParentWindow(W),W,GetWindowVar(W,1))
'SetWindowVar W,1,FALSE
 VOID RepaintWindow(W)
'ButtonPainter W,C,T,0,0
END
DEF ToggleButtonLMouseDown W,C,T,X,Y
 VAR F=GetWindowVar(W,1)
 SetWindowVar W,1,!F
 VOID RepaintWindow(W)
 VOID SetCapture(W)
'ButtonPainter W,C,T,0,0
END
COMMON DEF SetButtonAlignLeft WND
 SetWindowVar WND,2,2
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetButtonAlignRight WND
 SetWindowVar WND,2,1
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetButtonAlignCenter WND
 SetWindowVar WND,2,0
 VAR E=RepaintWindow(WND)
END
'PlainTextBox
COMMON DEF SetTextBoxOwnerDraw WND,FLG
 SetWindowVar WND,7,FLG
END
DEF TextBoxPainter W,C,T,A1,A2
 IF GetWindowVar(W,7)THEN
  VAR E=RepaintWindow(W)'CallControlHandler(W,GetControl(W),T,A1,A2)
  RETURN
 ENDIF
 E=GBeginWindow(W)
 IF E THEN RETURN
 VAR HE=GetWindowHeight(W)
 VAR WI=GetWindowWidth(W)
 VAR NA$=GetWindowName$(W)
 VAR CX=GetWindowVar(W,1)
 GFILLWindow W,0,0,WI,HE,-1
 GPRINTWindow W,1,1,NA$,RGB(0,0,0)
 IF IsFocusWindow(W)THEN
  GFILLWindow W,CX*8,6,CX*8+8,7,RGB(0,0,0)
 ENDIF
 GBOXWindow W,0,0,WI,HE,RGB(0,0,0)
 E=GEndWindow(W)
END
DEF TextBoxLMouseDown W,C,T,X,Y
END
DEF TextBoxChFocus W,C,T,X,Y
 TextBoxPainter W,C,T,0,0
END
DEF TextBoxKey W,C,T,KEY,A2
 VAR K$=CHR$(KEY)
 VAR CX=GetWindowVar(W,1)
 VAR T$=GetWindowName$(W)
 IF K$==BS$()THEN
  IF CX THEN
   SetWindowName W,RemoveStr$(T$,CX-1,1)
   SetWindowVar W,1,CX-1
  ENDIF
 ELSE
  SetWindowName W,InsertStr$(T$,CX,K$)
  SetWindowVar W,1,CX+1
 ENDIF
 TextBoxPainter W,C,T,0,0
END
DEF TextBoxButton W,C,T,B,A2
 VAR F=GetWindowVar(W,2)
 VAR M=MAINCNT
 IF M-F>10THEN
  SetWindowVar W,2,M
  VAR CX=GetWindowVar(W,1)
  IF B AND 4&&CX THEN
   SetWindowVar W,1,CX-1
   TextBoxPainter W,C,T,0,0
  ENDIF
  IF B AND 8THEN
   IF LEN(GetWindowName$(W))>CX THEN
    SetWindowVar W,1,CX+1
    TextBoxPainter W,C,T,0,0
   ENDIF
  ENDIF
 ENDIF
 
' BEEP
END
'1F
COMMON DEF GetNumUpDownValue(WND)
 UpdateNumUpDown WND
 RETURN VAL(GetWindowName$(WND))
END
'?
COMMON DEF SetNumUpDownRange WND,MIN,MAX
 SetWindowVar WND,4,MIN
 SetWindowVar WND,3,MAX
 UpdateNumUpDown WND
END
COMMON DEF UpdateNumUpDown WND
 VAR MIN=GetWindowVar(WND,4)
 VAR MAX=GetWindowVar(WND,3)
 VAR VAL=VAL(GetWindowName$(WND))
 'MIN
 IF VAL<MIN THEN
  VAL=MIN
  SetWindowName WND,STR$(VAL)
  DrawNumUpDown WND,FALSE
 ENDIF
 'MAX
 IF VAL>MAX THEN
  VAL=MAX
  SetWindowName WND,STR$(VAL)
  DrawNumUpDown WND,FALSE
 ENDIF
END
DEF NumUpDownCreate WND,CTL,TYPE,X,Y
 SetTextBoxOwnerDraw WND,TRUE
 SetWindowVar WND,4,&H80000000
 SetWindowVar WND,3,&H7FFFFFFF
END
DEF NumUpDownLMouseUP WND,CTL,TYPE,X,Y
 IF ABS(GetWindowVar(WND,6))==1THEN
  SetWindowVar WND,6,3
 ELSE
  SetWindowVar WND,6,0
 ENDIF
 VAR W=GetWindowWidth(WND)
 VAR BW=8
 VAR H=GetWindowHeight(WND)
 IF GBeginWindow(WND) THEN RETURN
 DrawNumUpDownButton WND,7,H/2,W-7,0,FALSE,TRUE
 DrawNumUpDownButton WND,7,H/2-1,W-7,H/2+1,FALSE,FALSE
 VAR E=GEndWindow(WND)
 E=SendNotificationWindow(GetParentWindow(WND),WND,VAL(GetWindowName$(WND)))
 RETURN
 E=CallBaseControlHandler(WND,CTL,TYPE,X,Y)
END
DEF NumUpDownLMouseDown WND,CTL,TYPE,X,Y
 VAR BTN=GetWindowVar(WND,6)
 IF BTN THEN
  IF BTN!=3THEN
   VAR FRAME=GetWindowVar(WND,5)
   IF MAINCNT-FRAME>=4THEN
    SetWindowVar WND,5,MAINCNT
    VAR VAL=VAL(GetWindowName$(WND))+BTN
    'MIN
    IF VAL<GetWindowVar(WND,4)THEN
     VAL=GetWindowVar(WND,4)
    ENDIF
    'MAX
    IF VAL>GetWindowVar(WND,3)THEN
     VAL=GetWindowVar(WND,3)
    ENDIF
    SetWindowName WND,STR$(VAL)
    DrawNumUpDown WND,FALSE
   ENDIF
   VOID LMouseDownWindow(WND)
   RETURN
  ELSE
   SetWindowVar WND,6,FALSE
   RETURN
  ENDIF
 ENDIF
 VAR W=GetWindowWidth(WND)
 VAR BW=8
 IF W-BW<=X THEN
  VAR H=GetWindowHeight(WND)
  IF GBeginWindow(WND)THEN RETURN
  IF H/2>=Y THEN
   'UE
   DrawNumUpDownButton WND,7,H/2,W-7,0,TRUE,TRUE
   SetWindowVar WND,6,1
   VOID LMouseDownWindow(WND)
   SetWindowVar WND,5,MAINCNT
  ENDIF
  IF H/2<=Y THEN
   DrawNumUpDownButton WND,7,H/2-1,W-7,H/2+1,TRUE,FALSE
   SetWindowVar WND,6,-1
   VOID LMouseDownWindow(WND)
   SetWindowVar WND,5,MAINCNT
  ENDIF
  VAR E=GEndWindow(WND)
  RETURN
 ENDIF
 E=CallBaseControlHandler(WND,CTL,TYPE,X,Y)
END
DEF DrawNumUpDownButton W,WI,HE,X,Y,PUSH,UPF
 GFILLWindow W,X,Y,X+WI,Y+HE,RGB(192,192,192)
 VAR B1=RGB(0,0,0),B2=-1
 IF PUSH THEN SWAP B1,B2
 GBOXWindow W,X,Y,X+WI,Y+HE,B1
 GLINEWindow W,X,Y,X,Y+HE-1,B2
 GLINEWindow W,X,Y,X+WI-1,Y,B2
 IF UPF THEN
  GTRIWindow W,X+2+PUSH,Y+HE-2+PUSH,X+WI-2+PUSH,Y+HE-2+PUSH,X+(WI-2)/2+2+PUSH,Y+2+PUSH,RGB(0,0,0)
 ELSE
  GTRIWindow W,X+2+PUSH,Y+2+PUSH,X+WI-2+PUSH,Y+2+PUSH,X+(WI-2)/2+2+PUSH,Y+HE-2+PUSH,RGB(0,0,0)
 ENDIF
END
DEF NumUpDownPainter WND,CTL,TYPE,A1,A2
 DrawNumUpDown WND,TRUE
END
DEF DrawNumUpDown WND,BTNDRAWFLG
 VAR E=GBeginWindow(WND)
 IF E THEN RETURN
 VAR H=GetWindowHeight(WND)
 VAR W=GetWindowWidth(WND)
 VAR BW=8
 GFILLWindow WND,0,0,W-8,H,-1
 VAR NA$=GetWindowName$(WND)
 GBOXWindow WND,0,0,W-BW,H,RGB(0,0,0)
 GPRINTWindow WND,1,(H-8) DIV 2+1,NA$,RGB(0,0,0)
 VAR BTN=GetWindowVar(WND,6)
 IF BTNDRAWFLG&&ABS(BTN)!=1THEN
  DrawNumUpDownButton WND,7,H/2,W-7,0,FALSE,TRUE
  DrawNumUpDownButton WND,7,H/2-1,W-7,H/2+1,FALSE,FALSE
 ENDIF
 E=GEndWindow(WND)
END
DEF NumUpDownKey WND,CTL,TYPE,KEY,A2
 IF KEY>=ASC("0")&&KEY<=ASC("9")||KEY==ASC(BS$())THEN VAR E=CallBaseControlHandler(WND,CTL,TYPE,KEY,A2)
 IF KEY==&H0DTHEN
  UpdateNumUpDown WND
  E=SendNotificationWindow(GetParentWindow(WND),WND,VAL(GetWindowName$(WND)))
 ENDIF

END
COMMON DEF SetLabelAlignLeft WND
 SetWindowVar WND,1,0
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetLabelAlignRight WND
 SetWindowVar WND,1,1
 VAR E=RepaintWindow(WND)
END
COMMON DEF SetLabelAlignCenter WND
 SetWindowVar WND,1,2
 VAR E=RepaintWindow(WND)
END
DEF LabelPainter W,CT,T,A1,A2
 VAR E=GBeginWindow(W)
 IF E THEN RETURN
 VAR NA$=GetWindowName$(W)
 VAR HE=GetWindowHeight(W)
 VAR WI=GetWindowWidth(W)
 VAR A=GetWindowVar(W,1)
 GCLSWindow W,GetWindowBackColor(W)
 VAR X,Y,C,I,L=LEN(NA$),HB=WI/8
 IF!HB THEN RETURN
 IF L<HB THEN
  IF A==1THEN X=WI-L*8
  IF A==2THEN X=(WI-L*8)/2
 ENDIF
 DEC L
 FOR I=0TO L
  C=ASC(NA$[I])
  IF C==10THEN INC Y,8:X=0CONTINUE
  IF X>=WI THEN
   INC Y,8:X=0
   IF L-I<HB THEN
    IF A==1THEN X=WI-(L-I+1)*8
    IF A==2THEN X=(WI-(L-I+1)*8)/2
   ENDIF
  ENDIF
  IF Y>=HE THEN BREAK
  GPUTCHRWindow W,X,Y,C,RGB(0,0,0)
  INC X,8
 NEXT
 E=GEndWindow(W)
END
'1:FIRST
'2:LAST
'3:VIEW
'4:VSCRBAR
'5:POS
'6:LEN
'7:SEL
COMMON DEF AddArrayListBoxItem WND,ITEM$
 VAR L=LEN(ITEM$)-1
 VAR I
 FOR I=0TO L
  AddListBoxItem WND,ITEM$[I]
 NEXT
END
COMMON DEF AddListBoxItem WND,ITEM$
 VAR L=GetWindowVar(WND,2)'
 IF!LISTSTR_FREE THEN RETURN
 IF L THEN LISTSTRNEXT[L]=LISTSTR_FREE
 SetWindowVar WND,2,LISTSTR_FREE
 IF!L THEN
  SetWindowVar WND,1,LISTSTR_FREE
 ENDIF
 LISTSTR$[LISTSTR_FREE]=ITEM$
 LISTSTRPREV[LISTSTR_FREE]=L
 L=LISTSTR_FREE
 LISTSTR_FREE=LISTSTRNEXT[L]
 LISTSTRNEXT[L]=0
 VAR LEN=GetWindowVar(WND,6)+1
 SetWindowVar WND,6,LEN
 VAR S=(GetWindowHeight(WND)-2)DIV 8
 IF LEN>S THEN DEC LEN,S ELSE LEN=0
 SetScrollBarSize GetWindowVar(WND,4),LEN
END
DEF LISTBOX_ADJUSTSCRBAR WND
 VAR LEN=GetWindowVar(WND,6)
 VAR S=(GetWindowHeight(WND)-2)DIV 8
 IF LEN>S THEN DEC LEN,S ELSE LEN=0
 VAR SCR=GetWindowVar(WND,4)
 SetScrollBarSize SCR,LEN
END
DEF ListBoxLMD WND,CT,T,X,Y
 VAR W=GetWindowWidth(WND)-1
 VAR H=GetWindowHeight(WND)
 IF X<=0||Y<=0||X>=W||Y>=H THEN RETURN
 VAR V=GetWindowVar(WND,3)
 VAR Y1=1,Y2=1,S=GetWindowVar(WND,7),F,GB
 WHILE V
  INC Y2,8
  IF Y>=Y1&&Y<Y2 THEN
   SetWindowVar WND,7,V
   IF!GB&&GBeginWindow(WND)THEN RETURN
   GFILLWindow WND,1,Y1,W,Y2-1,RGB(0,0,255)
   GPRINTWindow WND,1,Y1,LISTSTR$[V],-1
   F=1
   GB=1
   IF!S THEN BREAK
  ELSE IF V==S THEN
   IF!GB&&GBeginWindow(WND)THEN RETURN
   GB=1
   GFILLWindow WND,1,Y1,W,Y2-1,-1
   GPRINTWindow WND,1,Y1,LISTSTR$[V],RGB(0,0,0)
   S=0
   IF F THEN BREAK
  ENDIF
  ENDIF
  V=LISTSTRNEXT[V]
  INC Y1,8
  Y2=Y1
  IF Y1>=H THEN BREAK
 WEND
 IF GB THEN
  'あとしまつ
  VOID GEndWindow(WND)
 ENDIF
 IF T==CTL_LDBLCLKHANDLER THEN
  VOID SendNotifWindow(GetParentWindow(WND),WND,0)
 ELSEIF GetWindowVar(WND,6)THEN
  VOID SendNotifWindow(GetParentWindow(WND),WND,1)
 ENDIF
END
COMMON DEF ListBoxChItem()
 RETURN 1
END
DEF ListBoxDelete WND,CT,T,A1,A2
 VAR L=GetWindowVar(WND,1)
 IF!L THEN RETURN
 WHILE LISTSTRNEXT[L]
  L=LISTSTRNEXT[L]
 WEND
 LISTSTRNEXT[L]=LISTSTR_FREE
 LISTSTR_FREE=GetWindowVar(WND,1)
END
DEF ListBoxNotif WND,CT,T,A1,POS
 VAR OP=GetWindowVar(WND,5)
 IF OP==POS THEN RETURN
 VAR SA=POS-OP,I
 SetWindowVar WND,5,POS
 VAR V=GetWindowVar(WND,3)
 IF SA>0THEN
  FOR I=0TO SA-1
   IF!LISTSTRNEXT[V] THEN BREAK
   V=LISTSTRNEXT[V]
  NEXT
 ELSE
  SA=-SA
  FOR I=0TO SA-1
   IF!LISTSTRPREV[V] THEN BREAK
   V=LISTSTRPREV[V]
  NEXT
 ENDIF
 SetWindowVar WND,3,V
 ListBoxPainter WND,CT,T,0,0
END
DEF ListBoxCreate WND,CT,T,A1,A2
 VAR S,E
 NewVScrollBar WND,0 OUT S,E
 SetWindowVar WND,4,S
END
DEF ListBoxPainter WND,CT,T,A1,A2
 VAR E=GBeginWindow(WND)
 IF E THEN RETURN
 GCLSWindow WND,-1
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR L=GetWindowVar(WND,3),Y=1
 IF!L THEN
  L=GetWindowVar(WND,1)
  SetWindowVar WND,3,L
 ENDIF
 VAR S=GetWindowVar(WND,7)
 WHILE L
  IF S==L THEN
   GFILLWindow WND,1,Y,W-1,Y+7,RGB(0,0,255)
   GPRINTWindow WND,1,Y,LISTSTR$[L],-1
  ELSE
   GPRINTWindow WND,1,Y,LISTSTR$[L],RGB(0,0,0)
  ENDIF
  INC Y,8
  IF Y>=H THEN BREAK
  L=LISTSTRNEXT[L]
 WEND
 GBOXWindow WND,0,0,W,H,RGB(0,0,0)
 E=GEndWindow(WND)
END
COMMON DEF ListBoxResize WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 LISTBOX_ADJUSTSCRBAR WND
 VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF GetListBoxSelectedText$(WND)
 VAR S=GetWindowVar(WND,7)
 IF!S THEN RETURN""
 RETURN LISTSTR$[S]
END
COMMON DEF SetChItemListBoxNotif WND,F
 SetWindowVar WND,6,F
END
DEF DrawButton WND,X,Y,W,H,PUSHF
 GFILLWINDOW WND,X,Y,X+W,Y+H,WIN_BTNBACK
 VAR B1C=RGB(255,255,255)
 VAR B2C=RGB(0,0,0)
 IF PUSHF THEN SWAP B1C,B2C
 GBOXWINDOW WND,X,Y,X+W,Y+H,B1C
 GLINEWINDOW WND,X,Y+H,X+W,Y+H,B2C
 GLINEWINDOW WND,X+W,Y,X+W,Y+H,B2C
 SetWindowDrawPos WND,X+1+PUSHF,Y+1+PUSHF
END
DEF DropDownListBtn WND,F
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 VAR BTNW=8
 VAR BTNH=H
 DrawButton WND,W-BTNW,H-BTNH,BTNW,BTNH,F
 GTRIWindow WND,1,5,BTNW-3,5,(BTNW-2) DIV 2,BTNH-4,RGB(0,0,0)
 GFILLWindow WND,2,2,BTNW-4,4,RGB(0,0,0)
END
COMMON DEF DropDownListPainter WND,CT,T,A1,A2
 IF GBEGINWINDOW(WND)THEN RETURN
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 GCLSWINDOW WND,-1
 VAR LSTBOX=GetWindowVar(WND,0)
 IF LSTBOX THEN
  VAR TXT$=GetListBoxSelectedText$(LSTBOX)
  GPRINTWINDOW WND,2,2,TXT$,RGB(0,0,0)
 ENDIF
 VAR BTNW=8
 VAR BTNH=H
 GBOXWINDOW WND,0,0,W-BTNW-1,H,RGB(0,0,0)
 DropDownListBtn WND,FALSE
 IF GENDWINDOW(WND)THEN RETURN
END
COMMON DEF DropDownListLMD WND,CT,T,X,Y
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 VAR BTNW=8
 VAR BTNH=H
 IF W-BTNW<=X THEN
  IF GBEGINWINDOW(WND)THEN RETURN
  DropDownListBtn WND,TRUE
  IF GENDWINDOW(WND)THEN RETURN
  ShowDropDownListBox WND
 ENDIF
END
COMMON DEF DropDownListLMU WND,CT,T,X,Y
 IF GBEGINWINDOW(WND)THEN RETURN
 DropDownListBtn WND,FALSE
 IF GENDWINDOW(WND)THEN RETURN
END
COMMON DEF GetDropDownListBox(WND)
 VAR LSTBOX=GetWindowVar(WND,0)
 IF!LSTBOX THEN
  VAR E
  NewWindow CTL_DRPDWNBOXCTL,"",0,0,0,0,GetRootWND(),0 OUT LSTBOX,E
  IF E THEN @ERR
  SetWindowVar WND,0,LSTBOX
  IF JoinWindowGroup(WND,LSTBOX) THEN @ERR
 ENDIF
 RETURN LSTBOX
 @ERR
 RETURN 0
END
DEF ShowDropDownListBox WND
 VAR LSTBOX=GetDropDownListBox(WND)
 VAR X=GetWindowAX(WND)
 VAR Y=GetWindowAY(WND)
 VAR W=GetWindowWidth(WND)
 VAR H=64
 INC Y,GetWindowHeight(WND)
 IF MoveResizeWindow(LSTBOX,X,Y,W,H)||FrontWindow(LSTBOX)||ShowWindow(LSTBOX)||FocusWindow(LSTBOX)THEN @ERR
 RETURN
 @ERR
 RETURN
END
COMMON DEF DropDownListBoxChFocus WND,CT,T,F,A2
 IF!F THEN
  IF HideWindow(WND)THEN RETURN
  VOID RepaintWindow(GetParentWindow(WND))
 ENDIF
END
DEF NewVScrollBar PARENT,SIZ OUT WND,E
 VAR W=GetWindowWidth(PARENT)
 VAR H=GetWindowHeight(PARENT)
 NewWindow GetVScrollBarControl(),"",W-8,0,8,H,PARENT,0 OUT WND,E
 SetWindowVar WND,1,SIZ
END
COMMON DEF SetScrollBarSize W,SIZ
 SetWindowVar W,1,SIZ
 VOID RepaintWindow(W)
 VAR POS=GetWindowVar(W,2)
 IF POS>SIZ THEN
  SetWindowVar W,2,SIZ
  VOID SendNotifWindow(GetParentWindow(W),W,SIZ)
 ENDIF
END
COMMON DEF GetScrollBarSize(W)
 RETURN GetWindowVar(W,1)
END
COMMON DEF IncScrollBarSize W
 SetWindowVar W,1,GetWindowVar(W,1)+1
 VOID RepaintWindow(W)
END
COMMON DEF SetScrollBarPosition W,POS
 SetWindowVar W,2,POS
 VOID RepaintWindow(W)
END
COMMON DEF GetScrollBarPosition(W)
 RETURN GetWindowVar(W,2)
END
DEF VSCRBARPainter W,_,T,XY,WH
 IF GBEGINWindow(W)THEN RETURN
 GCLSWindow W,WIN_BKGND
 VAR _W=GetWindowWidth(W)
 VAR _H=GetWindowHeight(W)
 GBOXWindow W,0,0,_W,_H,RGB(0,0,0)
 '====
 'BOX
 GLINEWindow W,0,0,0,7,-1
 GLINEWindow W,0,0,7,0,-1
 VAR C=RGB(0,0,0)
 '
 GLINEWindow W,4,2,2,4,C
 GFILLWindow W,3,3,5,6,C
 GPSETWindow W,6,4,C
 GLINEWindow W,0,8,8,8,C
 '====
 'BOX
 GLINEWindow W,0,_H-1,0,_H-8,-1
 GLINEWindow W,0,_H-8,7,_H-8,-1 
 '
 GLINEWindow W,2,_H-4,4,_H-2,C
 GFILLWindow W,3,_H-6,5,_H-3,C
 GPSETWindow W,6,_H-4,C
 
 '==BAR==
 VAR AH=_H-18
 VAR SIZ=GetWindowVar(W,1)
 VAR POS=GetWindowVar(W,2)
 'Barのながさ
 VAR BS=AH-SIZ
 VAR S=9+POS
 '10いか
 IF BS<10THEN
  BS=10
  IF SIZ THEN S=(S-9)*((AH-10)/SIZ)+9
 ENDIF
 GLINEWindow W,1,S,_W-1,S,C
 GLINEWindow W,1,S+BS,_W-1,S+BS,C
 GLINEWindow W,_W-1,S+1,_W-1,S+BS-2,RGB(128,128,128)
 GLINEWindow W,1,S+BS-1,_W-1,S+BS-1,RGB(128,128,128)
 GLINEWindow W,1,S+1,1,S+BS-2,-1
 GLINEWindow W,1,S+1,_W-2,S+1,-1
 IF GENDWindow(W)THEN RETURN
END
DEF VSCRBARLMouseUP W,C,T,X,Y
 SetWindowVar W,3,8
 VOID ReleaseCapture(W)
END
DEF VSCRBARLMouseDown W,C,T,X,Y
 VAR ID=GetWindowVar(W,3)
 IF ID<8THEN
  IF!ID THEN
   ID=1
   IF Y<9THEN
    ID=2
   ENDIF
   IF Y>GetWindowHeight(W)-9THEN
    ID=3
   ENDIF
   SetWindowVar W,3,ID
  ENDIF
  VOID SetCapture(W)
  VOID LMouseDownWindow(W)
 ELSE
  SetWindowVar W,3,0
  RETURN
 ENDIF
 VAR SIZ=GetWindowVar(W,1)
 VAR POS=GetWindowVar(W,2)
 IF ID==2&&POS>0 THEN
  SetWindowVar W,2,POS-1
  VSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,POS-1)
 ENDIF
 IF ID==3&&POS<SIZ THEN
  SetWindowVar W,2,POS+1
  VSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,POS+1)
 ENDIF
 IF ID==1THEN
  VAR _Y=POS'Y
  IF!SIZ THEN RETURN
  VAR __TEMP__#=((GetWindowHeight(W)-28)/SIZ)
  IF!__TEMP__# THEN RETURN'?
  Y=(Y-9)/__TEMP__#
  IF Y<0THEN Y=0
  IF Y>SIZ THEN Y=SIZ
  IF Y==_Y THEN RETURN
  SetWindowVar W,2,Y
  VSCRBARPainter W,C,0,0,0
  VOID SendNotifWindow(GetParentWindow(W),W,Y)
 ENDIF
END
VAR OTW_MOUSESIZE
VAR OTW_MOUSE_HOMEX
VAR OTW_MOUSE_HOMEY
'ざんてい じっそう
DEF OTW_INITSP NUM
 GCLIP 1
 GPSET 408,0,-1
 SPDEF 0,408,0,1,1,1
 VAR FORE=RGB(0,0,0)
 VAR BACK=RGB(255,255,255)
 GCOLOR FORE
 VAR SC#=1,B=416
 IF !NUM THEN
  OTW_MOUSE_HOMEX=0
  OTW_MOUSE_HOMEY=0
  GFILL B,0,B+10*SC#,18*SC#,0
  GLINE B,0*SC#,B,14*SC#
  GLINE B,0*SC#,B+10*SC#,10*SC#
  GLINE B,14*SC#,B+3*SC#,11*SC#
  GLINE B+6*SC#,16*SC#,B+3*SC#,11*SC#
  GLINE B+10*SC#,10*SC#,B+6*SC#,10*SC#
  'GLINE B+6*SC#,10*SC#,B+8*SC#,15*SC#
  GLINE B+6*SC#,10*SC#,B+8*SC#,15*SC#
  GLINE B+6*SC#,16*SC#,B+7*SC#,16*SC#'7,16
  GPAINT B+1*SC#,2*SC#,BACK,FORE
  SPDEF 290,B,0,10*SC#,17*SC#
 ELSE
  VAR SWPF=0,RVSF=0
  VAR X=0,Y,D$
  RESTORE "@"+STR$(NUM)
  VAR W
  WHILE 1
   READ D$
   IF!Y THEN
    IF ASC(D$[0])>70THEN
     IF D$[0]=="S"THEN SWPF=1
     IF D$[0]=="R"THEN RVSF=1
     READ NUM
     RESTORE "@"+STR$(NUM)
     CONTINUE
    ENDIF
    READ OTW_MOUSE_HOMEX,OTW_MOUSE_HOMEY
   ENDIF
   VAR L=LEN(D$)-1,I,X2
   IF L==-1THEN BREAK
   FOR I=0TO L
    X2=I
    IF RVSF THEN X2=L-I
    VAR C=ASC(D$[I])-48
    IF C<0THEN C=0
    IF C>9THEN DEC C,7'HEX
    IF C>9THEN IF W<X2+1 THEN W=X2+1
    IF SWPF THEN
     GPSET B+Y,X+X2,OTW_CONSOLEPAL[C]
    ELSE
     GPSET B+X+X2,Y,OTW_CONSOLEPAL[C]
    ENDIF
   NEXT
   INC Y
  WEND
  IF SWPF THEN
   SWAP W,Y
   SWAP OTW_MOUSE_HOMEX,OTW_MOUSE_HOMEY
  ENDIF
  IF RVSF THEN
   OTW_MOUSE_HOMEX=(W-1)-OTW_MOUSE_HOMEX
  ENDIF
  SPDEF 290,B,0,W*SC#,Y*SC#
 ENDIF
 GCLIP 1,0,0,400,239
 SPCHR OTW_MOUSESP,290
 SPVAR 0,0,1
 SPOFS OTW_MOUSESP,OTW_MOUSEX,OTW_MOUSEY,-256
 SPHOME OTW_MOUSESP,OTW_MOUSE_HOMEX,OTW_MOUSE_HOMEY
 SPCOL 0,0,0,1,1
 SPCHR OTW_SHADOWSP,290
 SPLINK OTW_SHADOWSP,OTW_MOUSESP
 SPOFS OTW_SHADOWSP,-2,2,-00
 SPCOLOR OTW_SHADOWSP,RGB(128,0,0,0)
 SPVAR OTW_SHADOWSP,0,1
 SPHOME OTW_SHADOWSP,OTW_MOUSE_HOMEX,OTW_MOUSE_HOMEY
 'NORMAL CURSOR
 @1
 DATA "    F    
 DATA 4,10
 DATA "   F1F   
 DATA "  F111F  
 DATA " F11111F 
 DATA "F1111111F
 DATA "FFFF1FFFF
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "   F1F   
 DATA "FFFF1FFFF
 DATA "F1111111F
 DATA " F11111F 
 DATA "  F111F  
 DATA "   F1F   
 DATA "    F    
 DATA ""
 @2
 DATA "S",1
 @3
 DATA "FFFFFFF         
 DATA 7,7
 DATA "F11111F         
 DATA "F1111F          
 DATA "F111F           
 DATA "F11F1F          
 DATA "F1F F1F         
 DATA "FF   F1F        
 DATA "      F1F       
 DATA "       F1F   FF 
 DATA "        F1F F1F 
 DATA "         F1F11F 
 DATA "          F111F 
 DATA "         F1111F 
 DATA "        F11111F 
 DATA "        FFFFFFF 
 DATA "
 @4
 DATA "R",3'REVERSE 3
END
VAR WIN_ROOTCTL
VAR TSTWND,TSTCTL
VAR TSTWND2
VAR TSTWND3

VAR OTW_MOUSELBTN
VAR OTW_MOUSERBTN
VAR OTW_LMOUSEDWN
VAR OTW_LMOUSEUP
VAR OTW_RMOUSEDWN
VAR OTW_RMOUSEUP
VAR OTW_CNT,OTW_FPS,OTW_FPSCNT
VAR OTW_FCNT,OTW_FPF#,OTW_FPFCNT
VAR OTW_KX
VAR OTW_KY
VAR OTW_KX2
VAR OTW_KY2
VAR OTW_USEBTN
VAR OTW_USEMEM
COMMON DEF S_OTW S
 BGMPLAY"L1C>B<C:1L1EDE:2L1GFG:3L1>CGC
END
COMMON DEF I_OTW
 IF!OTW_INIT THEN
  OTW_ENABLE_SHADOW=1
  WIN_BKGND=RGB(208,208,208)
  WIN_BTNBACK=RGB(192,192,192)
  VAR FM=FREEMEM
  PrintConsole "====================="+LF$()
  PrintConsole "OTYA 3D WINDOW SYSTEM"+LF$()
  PrintConsole "====================="+LF$()
  PrintConsole "Ver 5.0-B"+LF$()
' BEEP 94,-1000
  VAR M1$,M2$,M3$,M4$,M5$,M6$,G$=@77'34
  M1$=":1"+G$+"T140<<C8 C8&C2."
  M2$=":2"+G$+"T140<G8 G8&G2."
  M3$=":3"+G$+"T140<E8 E8&E2."
  M4$=":4"+G$+"T140>>>><<G8 G8&G2."
  M5$=":5"+G$+"T140>>>><<E8 E8&E2."
  M6$=":6"+G$+"T140>>>><<C8 C8&C2."
  BGMPLAY M1$+M2$+M3$+M4$+M5$+M6$
'  BEEP 96
  PrintConsole "Loading font..."+LF$()
  OTW_LOADFONT
'  BEEP 97
  PrintConsole "Init..........."+LF$()
  OTWRunning=TRUE
  OTW_WIN_INITARRAY
  OTW_CTL_INITARRAY
  OTW_INIT_ERR
  OTW_ASSOC_INIT
  PrintConsoleln "Init setting..."
  OTW_USEBTN=&B11001111
  OTW_FPS=1
  OTW_FPSCNT=1
  OTW_FPF#=1
  OTW_FPFCNT=1
  'ACLS
  OTW_DP=4
  OTW_SP=0
  OTW_BP=1
  OTW_GP=2
  PrintConsoleln "Init screen..."
  MouseClipDef
  GPAGE OTW_SP,OTW_SP
  GPRIO 1023
  GCLS
  GCLS RGB(0,192,0)
  GCLS 
  VAR I,J
' FOR J=0TO 2
'  FOR I=0TO 240/4
'  GLINE 0,I+60*J,400,I+60*J,&HFF000000 OR(I*8<<J*8)XOR &HFFFFFF'RGB(0,I*4,0)
'    GLINE 0,I+60*J,400,I+60*J,RGB(0,I*4,I*4) '
 ' NEXT
' NEXT
  GCLS RGB(0,192,0)
  FOR I=-400TO 400 STEP 2
   GLINE I,0,I+400,400,RGB(0,0,255)'RGB(255,255,255)
  NEXT
  GCLS RGB(0,224,224)
  GCLS RGB(0,128,128)
  'GCLS RGB(191,191,191)
  GPAGE OTW_SP,OTW_DP
  GPRIO 1023
 ' GCLS RGB(0,192,128)
' GCLS RGB(0,0,255)
'GCLS 
  GPRIO 1023
  GOTO @_
  XSCREEN 2,512,2
  DISPLAY 1
  CLS
  VISIBLE 1,0,1,0
  LOCATE 0,25
  ?":LEFT CLICK"
  ?":RIGHT CLICK(UNUSED)"
  ?"TOUCH:CURSOR
  BGSCREEN 0,25,15
  BGSCALE 0,19.5/25,19.5/25'1
  GCLS 'RGB(255,0,0)
  BACKCOLOR RGB(0,192,128)
  VAR X,Y
  I=0
  FOR Y=0TO 14
   FOR X=0TO 24
    BGPUT 0,X,Y,I
    INC I
   NEXT
  I=I+7
  NEXT
  BGPAGE OTW_DP
  VAR K$="KEYBOARD"
  OTW_KX=39*8
  OTW_KY=0
  OTW_KX2=40*8
  OTW_KY2=LEN(K$)*8
  ATTR 1
  FOR I=0TO LEN(K$)-1
   COLOR 15,8
   LOCATE 39,I
   ?K$[I];
  NEXT
  COLOR 15,0
  ATTR 0
  DISPLAY 0
  @_
  OTW_INIT=TRUE
  VAR E
  NewControl "DESKTOP" OUT WIN_ROOTCTL,E
  E=SetControlPainter(WIN_ROOTCTL,"DesktopPainter")
  NewTopLevelWindow WIN_ROOTCTL,"DESKTOP",400,240 OUT WIN_ROOTWND,E
  ExtendControl "HELLO",GetWindowControl() OUT TSTCTL,E
' NewTopLevelWindow TSTCTL,"HELLO",164,164 OUT TSTWND,E
' NewTopLevelWindow TSTCTL,"HELLO",64,64 OUT TSTWND2,E
' NewTopLevelWindow TSTCTL,"HELLO",64,64 OUT TSTWND3,E
  E=SetControlPainter(TSTCTL,"HELLOPainter")
  GCLIP 1,0,0,400,239
  VISIBLE 1,1,1,1
  OTW_MOUSEX=(400-16)/2
  OTW_MOUSEY=(240-16)/2
  OTW_MOUSEX#=(400-16)/2
  OTW_MOUSEY#=(240-16)/2
  
  OTW_MOUSELBTN=32OR 256
  OTW_MOUSERBTN=16OR 512
  OTW_LMOUSEDWN=1
  OTW_LMOUSEUP =2
  OTW_RMOUSEDWN=4
  OTW_RMOUSEUP =8
  
  '290
  SPSET OTW_MOUSESP,0
  OTW_SHADOWSP=1
  SPSET OTW_SHADOWSP,0
  OTW_INITSP 0
  OTW_MOVWINSP=2
  SPSET OTW_MOVWINSP,0
  SPHIDE OTW_MOVWINSP
  SPVAR OTW_MOVWINSP,0,1
  OTW_MOVWINCOL=RGB(128,128,128,128)
  OTW_MOVWINCOL=RGB(128,255,255,255)
  SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
  DEC FM,FREEMEM
  OTW_USEMEM=FM
  PrintConsoleln FORMAT$("UsingMemory8192KB/%DKB",FM/1024)+LF$()
  CLS
  LOCATE 0,29
  NewProcess"LAUNCHER","" OUT E,E
 ENDIF
RETURN
END
COMMON DEF HELLOPainter WND,CTL,TYPE,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYPE,A1,A2)
 E=GBEGINWindow(WND)
 IF E THEN RETURN
 GFILLWindow WND,0,0,64,64,RGB(224-224,224,224)'RGB(0,0,0)
 VAR S$="HELLOWORLD",I
 FOR I=0TO LEN(S$)-1
  GPRINTWindowCC WND,6+I*8,1,S$[I],I
 NEXT
 E=GENDWindow(WND)
END
VAR OTW_OLDMOUSEX
VAR OTW_OLDMOUSEY
DEF OTWGetOvMouseNUWID()
 RETURN RGBToShort(GSPOIT(OTW_MOUSEX,OTW_MOUSEY+240))
END
VAR OTW_OLDLMOUSE
VAR OTW_OLDRMOUSE
VAR OTW_FDIFF
VAR OTW_OLDBTN
VAR OTW_OLDBTNF
VAR OLDMOVEMOUSEWINDOW
VAR OTW_SMOOTH_MOVE_WINDOW
COMMON DEF L_OTW
 VAR MOVEMOUSE
 UpdateMouse
 IF OTW_MOUSEX!=OTW_OLDMOUSEX THEN MOVEMOUSE=1
 IF OTW_MOUSEY!=OTW_OLDMOUSEY THEN MOVEMOUSE=1
 VAR NUWID,E
 VAR BTN=UpdateButton()
 IF MOVEMOUSE||BTN THEN
  IF OTW_SMOOTH_MOVE_WINDOW THEN
   IF WIN_DRAGHANDLER_USE THEN
    CALL WIN_DRAGHANDLER$,WIN_DRAGHANDLER_WND,OTW_MOUSEX,OTW_MOUSEY,WIN_DRAGHANDLER_A1,WIN_DRAGHANDLER_A2
 ENDIF
  ENDIF
  NUWID=OTWGetOvMouseNUWID()
 ENDIF
 IF BTN THEN
  'LEFT MOUSE DOWN
  IF BTN AND OTW_LMOUSEDWN THEN
   CAPTURE_WND=0
   VAR OA=WIN_ACTIVENUWID
   WIN_ACTIVENUWID=NUWID
   IF WIN_ACTIVENUWID!=OA THEN
    E=SendChFocusWindow(NUWIDToWND(OA),FALSE,NUWIDToWND(WIN_ACTIVENUWID AND 32767))
    E=SendChFocusWindow(NUWIDToWND(WIN_ACTIVENUWID AND 32767),TRUE,NUWIDToWND(OA))
   ENDIF
   VAR F=MAINCNT
   IF NUWID==OTW_LCLKWND&&F-OTW_LCLKF<=OTW_DBLCLKF&&ABS(OTW_MOUSEY-OTW_DBLCLKY)<OTW_DBLCLKXY&&ABS(OTW_MOUSEX-OTW_DBLCLKX)<OTW_DBLCLKXY THEN
    OTW_LCLKWND=0
    IF NUWID AND WIN_FRAMEFLG THEN
     'TODO:Double Click
     
     E=LMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
     WIN_ACTIVENUWID=NUWID AND 32767
    ELSE
     IF LEN(CTL_HANDLER$[WIN_CTL[NUWID]AND 4095,CTL_LDBLCLKHANDLER])THEN
      E=LDoubleClickWindow(NUWIDToWND(NUWID))
     ELSE
      E=LMouseDownWindow(NUWIDToWND(NUWID))
     ENDIF
    ENDIF
   ELSE
    OTW_LCLKWND=NUWID
    OTW_LCLKF=F
    OTW_DBLCLKX=OTW_MOUSEX
    OTW_DBLCLKY=OTW_MOUSEY
   IF NUWID AND WIN_FRAMEFLG THEN
    E=LMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
    
    WIN_ACTIVENUWID=NUWID AND 32767
   ELSE
    E=LMouseDownWindow(NUWIDToWND(NUWID))
   ENDIF
   ENDIF
  ENDIF
  IF BTN AND OTW_LMOUSEUP THEN
   IF WIN_DRAGHANDLER_USE THEN
    CALL WIN_DRAGHANDLER$,WIN_DRAGHANDLER_WND,OTW_MOUSEX,OTW_MOUSEY,WIN_DRAGHANDLER_A1,WIN_DRAGHANDLER_A2
    E=ClearWindowDragHandler()
   ELSE
    VAR NUWIDRAW=NUWID AND 32767
    IF NUWIDRAW!=(WIN_ACTIVENUWID AND 32767)&&CAPTURE_WND==NUWIDToWND(WIN_ACTIVENUWID)THEN
     IF NUWID AND WIN_FRAMEFLG THEN
      E=LMouseUpWindowOnFrame(NUWIDToWND(WIN_ACTIVENUWID))
      E=LMouseUpWindow(NUWIDToWND(WIN_ACTIVENUWID))
     ELSE
      E=LMouseUpWindow(NUWIDToWND(WIN_ACTIVENUWID))
     ENDIF
    ELSE
     IF NUWID AND WIN_FRAMEFLG THEN
      E=LMouseUpWindowOnFrame(NUWIDToWND(NUWIDRAW))
      E=LMouseUpWindow(NUWIDToWND(NUWIDRAW))
     ELSE
      E=LMouseUpWindow(NUWIDToWND(NUWID))
     ENDIF
    ENDIF
   ENDIF
   CAPTURE_WND=0
  ENDIF
  
  
  '=====R=====
  IF BTN AND OTW_RMOUSEDWN THEN
   CAPTURE_WND=0
   OA=WIN_ACTIVENUWID
   WIN_ACTIVENUWID=NUWID
   IF WIN_ACTIVENUWID!=OA THEN
    E=SendChFocusWindow(NUWIDToWND(OA),FALSE,NUWIDToWND(WIN_ACTIVENUWID AND 32767))
    E=SendChFocusWindow(NUWIDToWND(WIN_ACTIVENUWID AND 32767),TRUE,NUWIDToWND(OA))
   ENDIF
   F=MAINCNT
   IF NUWID==OTW_LCLKWND&&F-OTW_LCLKF<=OTW_DBLCLKF&&ABS(OTW_MOUSEY-OTW_DBLCLKY)<OTW_DBLCLKXY&&ABS(OTW_MOUSEX-OTW_DBLCLKX)<OTW_DBLCLKXY THEN
    OTW_LCLKWND=0
    IF NUWID AND WIN_FRAMEFLG THEN
     'TODO:Double Click
     
     E=RMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
     WIN_ACTIVENUWID=NUWID AND 32767
    ELSE
     IF LEN(CTL_HANDLER$[WIN_CTL[NUWID]AND 4095,CTL_LDBLCLKHANDLER])THEN
      E=RDoubleClickWindow(NUWIDToWND(NUWID))
     ELSE
      E=RMouseDownWindow(NUWIDToWND(NUWID))
     ENDIF
    ENDIF
   ELSE
    OTW_LCLKWND=NUWID
    OTW_LCLKF=F
    OTW_DBLCLKX=OTW_MOUSEX
    OTW_DBLCLKY=OTW_MOUSEY
   IF NUWID AND WIN_FRAMEFLG THEN
    E=RMouseDownWindowOnFrame(NUWIDToWND(NUWID AND 32767))
    
    WIN_ACTIVENUWID=NUWID AND 32767
   ELSE
    E=RMouseDownWindow(NUWIDToWND(NUWID))
   ENDIF
   ENDIF
  ENDIF

  IF BTN AND OTW_RMOUSEUP THEN
    CAPTURE_WND=0
    IF NUWID AND WIN_FRAMEFLG THEN
     E=RMouseUpWindowOnFrame(NUWIDToWND(WIN_ACTIVENUWID))
     E=RMouseUpWindow(NUWIDToWND(WIN_ACTIVENUWID))
    ELSE
     E=RMouseUpWindow(NUWIDToWND(WIN_ACTIVENUWID))
    ENDIF
  ENDIF
  '===========
  
  
  
 ENDIF
 IF MOVEMOUSE THEN
  MoveWindowSP FALSE
  IF CAPTURE_WND THEN
   E=MouseMoveWindow(CAPTURE_WND AND NUWIDMASK)
  ELSE
  IF OLDMOVEMOUSEWINDOW!=NUWID THEN
   IF!(OLDMOVEMOUSEWINDOW AND WIN_FRAMEFLG)THEN
    E=MouseLeaveWindow(NUWIDToWND(OLDMOVEMOUSEWINDOW))
   ELSE
    E=MouseLeaveWindowOnFrame(NUWIDToWND(OLDMOVEMOUSEWINDOW AND 32767))
   ENDIF
  ENDIF
  IF!(NUWID AND WIN_FRAMEFLG)THEN
   E=MouseMoveWindow(NUWID)
  ELSE
   E=MouseMoveWindowOnFrame(NUWID AND 32767)
  ENDIF
  OLDMOVEMOUSEWINDOW=NUWID
  ENDIF
 ENDIF
' IF BUTTON()AND 64THEN DUMP_WND
 OTW_OLDMOUSEX=OTW_MOUSEX
 OTW_OLDMOUSEY=OTW_MOUSEY
 VAR K$=INKEY$()
 IF LEN(K$)THEN
  E=SendKeyWindow(NUWIDToWND(WIN_ACTIVENUWID),ASC(K$))
 ENDIF
 VOID UpdateWindowOnly(WIN_ROOTWND)
'E=UpdateWindow(TSTWND2)
'E=UpdateWindow(TSTWND)
'E=UpdateWindow(TSTWND3)
 OTW_FDIFF=MAINCNT-OTW_FCNT
 IF OTW_FDIFF>1 THEN
  OTW_FPF#=OTW_FPFCNT
  IF!OTW_FPFCNT THEN
   OTW_FPF#=1.0/OTW_FDIFF
   IF OTW_FPF#<0.3THEN OTW_FPF#=0.333
  ENDIF
  OTW_FPFCNT=0
  OTW_FCNT=MAINCNT
 ELSE
  INC OTW_FPFCNT
 ENDIF
 OTW_FDIFF=MAINCNT-OTW_CNT
 IF OTW_FDIFF>60 THEN
  OTW_FPS=OTW_FPSCNT
  OTW_FPSCNT=0
  '?OTW_FPS
  OTW_CNT=MAINCNT
 ELSE
  INC OTW_FPSCNT
 ENDIF
 BTN=BUTTON()AND OTW_USEBTN
 IF BTN||OTW_OLDBTN THEN
  IF MAINCNT-OTW_OLDBTNF||OTW_OLDBTN THEN
   E=SendButtonWindow(NUWIDToWND(WIN_ACTIVENUWID),BTN)
   OTW_OLDBTNF=MAINCNT
   OTW_OLDBTN=BTN
  ENDIF
 ENDIF
' ExitProcess 1
RETURN
END
  '2     3     4
  ' 
  ' 
  '           
  '5          6
  '           
  '           
  '           
  '789
DEF MoveWindowSP F
 IF OTW_MOVWINFLG>=2THEN
  VAR NW=SPVAR(OTW_MOVWINSP,1)
  VAR W=WIN_WIDTH[NW],H=WIN_HEIGHT[NW]
  VAR X=WIN_AX[NW],Y=WIN_AY[NW]
  VAR LTOPH,LTOPW
  VAR RTOPH,RTOPW
  IF OTW_MOVWINFLG==2THEN
   LTOPH=1LTOPW=1
  ENDIF
  IF OTW_MOVWINFLG==3THEN
   LTOPH=1
  ENDIF
  IF OTW_MOVWINFLG==5THEN
   LTOPW=1
  ENDIF
   IF LTOPW THEN
    INC W,X-OTW_MOUSEX
    X=OTW_MOUSEX
    IF W<WIN_MINW[NW]THEN
     W=WIN_MINW[NW]-1
     X=WIN_AX[NW]+WIN_WIDTH[NW]-W
    ENDIF
   ENDIF
   IF LTOPH THEN
    INC H,Y-OTW_MOUSEY
    Y=OTW_MOUSEY
    IF H<WIN_MINH[NW]THEN
     H=WIN_MINH[NW]-1
     Y=WIN_AY[NW]+WIN_HEIGHT[NW]-H
    ENDIF
   ENDIF
  IF OTW_MOVWINFLG==4THEN
   RTOPH=1RTOPW=1
  ENDIF
  IF OTW_MOVWINFLG==6THEN
   RTOPW=1
  ENDIF
   IF RTOPW THEN
    DEC W,X-OTW_MOUSEX+W
    IF W<WIN_MINW[NW]THEN W=WIN_MINW[NW]-1
   ENDIF
   IF RTOPH THEN
    INC H,Y-OTW_MOUSEY
    Y=OTW_MOUSEY
    IF H<WIN_MINH[NW]THEN
     H=WIN_MINH[NW]-1
     Y=WIN_AY[NW]+WIN_HEIGHT[NW]-H
    ENDIF
   ENDIF
  VAR LBOTH,LBOTW
  VAR RBOTH,RBOTW
  IF OTW_MOVWINFLG==7THEN
   LBOTH=1LBOTW=1
  ENDIF
  IF OTW_MOVWINFLG==8THEN
   LBOTH=1
  ENDIF
   IF LBOTW THEN
    INC W,X-OTW_MOUSEX
    X=OTW_MOUSEX
    IF W<WIN_MINW[NW]THEN
     W=WIN_MINW[NW]-1
     X=WIN_AX[NW]+WIN_WIDTH[NW]-W
    ENDIF
   ENDIF
   IF LBOTH THEN
    DEC H,Y-OTW_MOUSEY+H
    IF H<WIN_MINH[NW]THEN H=WIN_MINH[NW]-1
   ENDIF
  IF OTW_MOVWINFLG==9THEN
   RBOTH=1RBOTW=1
  ENDIF
   IF RBOTW THEN
    DEC W,X-OTW_MOUSEX+W
    IF W<WIN_MINW[NW]THEN W=WIN_MINW[NW]-1
   ENDIF
   IF RBOTH THEN
    DEC H,Y-OTW_MOUSEY+H
    IF H<WIN_MINH[NW]THEN H=WIN_MINH[NW]-1
   ENDIF
  SPOFS OTW_MOVWINSP,X,Y
  SPSCALE OTW_MOVWINSP,W+1,H+1'TODO:WH
  IF F THEN
   'TODO:Move->Resizeでおかしくなる
   'TODO:MoveResizeWindow
'   VOID MoveWindow(NUWIDToWND(NW),X,Y)
   VOID MoveResizeWindowF(NUWIDToWND(NW),X,Y,W,H)
  ENDIF
 ENDIF
END
VAR RUNCTL
COMMON DEF I_RUN
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 ExtendControl "RUN",GetWindowControl() OUT RUNCTL,E
 VAR WND
 NewTopLevelWindow RUNCTL,"RUN",64,32 OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 E=SetControlNotificationHandler(RUNCTL,"RunNotificationHandler")
 SetProcessVar WND
 VAR TW
 NewWindow GetButtonControl(),"RUN",0,10,32,10,WND,0OUT TW,E
 NewWindow GetTextBoxControl(),"",0,0,64,8,WND,0OUT TW,E
END
COMMON DEF L_RUN
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END
VAR ABOUTCTL
DIM OTWLOGO[0]
COMMON DEF I_ABOUT
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!ABOUTCTL THEN
  ExtendControl "ABOUT",GetWindowControl() OUT ABOUTCTL,E
  OTWLOGO=NewArray(0)
  LOAD"DAT:OTWLOGORC",OTWLOGO,0
 ENDIF
 VAR WND
 NewTopLevelWindow ABOUTCTL,"OTW",144,64 OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 SetProcessVar WND
 E=SetControlPainter(ABOUTCTL,"AboutPainter")
 E=SetControlNotificationHandler(ABOUTCTL,"ABOUTNotif")
 NewWindow GetButtonControl(),"OK",(144-20)/2,16,20,12,WND,0 OUT E,E
END
COMMON DEF AboutNotif WND,CTL,TYPE,A1,A2
 VOID Deletewindow(WND)
END
COMMON DEF AboutPainter WND,CTL,TYPE,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYPE,A1,A2)
' E=GBeginWindow(WND)
 IF E THEN RETURN
 VAR S$="otya 3D window"
 GPRINTWindow WND,(144-LEN(S$)*8)/2,0,S$,RGB(0,0,0)
 S$="system 5.0"
 GPRINTWindow WND,(144-LEN(S$)*8)/2,8,S$,RGB(0,0,0)
 GLOADWindow WND,1,1,16,16,OTWLOGO,1,0
 S$="Logo designed by"
 GPRINTWindow WND,(144-LEN(S$)*8)/2,30,S$,RGB(0,0,0)
 S$="mintyan"
 GPRINTWindow WND,(144-LEN(S$)*8)/2,38,S$,RGB(0,0,0)
 S$="© 2011-2015 otya"
 GPRINTWindow WND,(144-LEN(S$)*8)/2,46+4,S$,RGB(0,0,0)
 E=GEndWindow(WND)
END
COMMON DEF L_ABOUT
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 1
END
VAR LAUNCHERCTL
DIM LAUNCHERITEM$[0]
DIM LAUNCHERLEN
COMMON DEF LauncherPainter WND,CTL,T,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,T,A1,A2)
 IF GBeginWindow(WND)THEN RETURN
 VAR I
 FOR I=0TO LAUNCHERLEN-1
  GPRINTWindow WND,0,I*8+1,LAUNCHERITEM$[I],RGB(0,0,0)
 NEXT
 E=GEndWindow(WND)
END
COMMON DEF LauncherLMouseUP WND,CTL,T,X,Y
 VAR E=CallBaseControlHandler(WND,CTL,T,X,Y)
 VAR ITEM=Y/8
 IF ITEM>=LAUNCHERLEN||ITEM<0THEN
  RETURN
 ENDIF
 NewProcess LAUNCHERITEM$[ITEM],"" OUT E,E
END
COMMON DEF LauncherResize WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 VOID ResizeWindow(CW,W,H)
END
COMMON DEF LauncherNotif WND,CTL,T,A1,A2
 IF A2==0THEN
  VAR PROC$=GetListBoxSelectedText$(A1)
  VAR E
  NewProcess PROC$,"" OUT E,E
 ENDIF
END
COMMON DEF I_LAUNCHER
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 IF LAUNCHERCTL THEN
  VAR WND,E
  NewTopLevelStyleWindow LAUNCHERCTL,"LAUNCHER",80,64,WINDOWRESIZABLESTYLE() OUT WND,E
  SetProcessVar WND
  NewWindow GetListBoxControl(),"",0,0,80,64,WND,0 OUT WND,E
  AddArrayListBoxItem WND,LAUNCHERITEM$
 ELSE
  LAUNCHERLEN=11
  LAUNCHERITEM$=NewArray$(LAUNCHERLEN)
  LAUNCHERITEM$[0]="WCLOCK"
  LAUNCHERITEM$[1]="RUN"
  LAUNCHERITEM$[2]="ABOUT"
  LAUNCHERITEM$[3]="LAUNCHER"
  LAUNCHERITEM$[4]="PAINT"
  LAUNCHERITEM$[5]="TXTED"
  LAUNCHERITEM$[6]="PRGED"
  LAUNCHERITEM$[7]="OTYFIL"
  LAUNCHERITEM$[8]="OTYDOC"
  LAUNCHERITEM$[9]="MPLAY"
  LAUNCHERITEM$[10]="CLIPBRD"
  ExtendControl "LAUNCHER",GetWindowControl() OUT LAUNCHERCTL,E
'  E=SetControlPainter(LAUNCHERCTL,"LauncherPainter")
'  E=SetControlLMouseUpHandler(LAUNCHERCTL,"LauncherLMouseUP")
  E=SetControlNotifHandler(LAUNCHERCTL,"LauncherNotif")
  E=SetControlResizeHandler(LAUNCHERCTL,"LauncherResize")
  I_LAUNCHER
 ENDIF
END
COMMON DEF L_LAUNCHER
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 1
END

VAR WCLOCKWND
VAR WCLOCKCTL
VAR WCLOCKBC
VAR WCLOCKBC2
VAR WCLOCKTIM
COMMON DEF RunNotificationHandler W,C,T,V,A2
 VAR PRC,E
 NewProcess GetWindowName$(GetChildWindow(GetParentWindow(V))),"" OUT PRC,E
 IF E THEN BEEP
END
COMMON DEF I_WCLOCK
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 ExtendControl "WCLOCK",GetWindowControl() OUT WCLOCKCTL,E
 E=SetControlPainter(WCLOCKCTL,"WCLOCKPainter")
 NewTopLevelWindow WCLOCKCTL,"CLOCK",64,64 OUT WCLOCKWND,E
 WCLOCKTIM=MAINCNT/60
 WCLOCKTIM=WCLOCKTIM*60
 'NewWindow GetButtonControl()
 NewWindow TSTCTL,"TEST",8,8,32,32,WCLOCKWND,0 OUT WCLOCKBC,E
 NewWindow GetTextBoxControl(),"TEST",0,16,48,8,WCLOCKWND,0OUT WCLOCKBC2,E
'NewWindow GetButtonControl(),"TEST",16,16,32,32,WCLOCKWND,0 OUT WCLOCKBC2,E
 E=SetControlNotificationHandler(WCLOCKCTL,"WCLOCKNotif")
 SetProcessVar WCLOCKWND
END
COMMON DEF WCLOCKNotif W,C,T,WND,V
 BEEP 
END
COMMON DEF WCLOCKPainter W,C,T,A,B
 VAR E=CallBaseControlHandler(W,C,T,A,B)
 WCLOCK_RP
END
COMMON DEF L_WCLOCK
 VAR E
 WCLOCKWND=GetProcessVar()
 VAR H,M,S
' E=UpdateWindow(WCLOCKBC)
 E=PeekWindowEvent(WCLOCKWND)
' IF E==RepaintControlEvent()THEN
'  E=UpdateWindow(WCLOCKWND)
'  WCLOCK_RP
'  RETURN
' ENDIF
 E=UpdateWindow(WCLOCKWND)
 IF E THEN ExitProcess 1
 TMREAD OUT H,M,S
 IF S!=GetWindowVar(WCLOCKWND,0)THEN
  WCLOCK_RP
  SetWindowVar WCLOCKWND,0,S
 ENDIF
' IF MAINCNT-WCLOCKTIM>=60 THEN
'  WCLOCKTIM=MAINCNT/60
'  WCLOCKTIM=WCLOCKTIM*60
'  WCLOCK_RP
' ENDIF
' E=UpdateWindow(WCLOCKBC2)
 
END
 DEF WCLOCK_RP
  VAR E
  E=GBeginWindow(WCLOCKWND)
  IF E THEN RETURN
  GCLSWindow WCLOCKWND,WIN_BKGND'255,160,16)
  GPRINTWindowCC WCLOCKWND,0,0,TIME$,1
  GPRINTWindowCC WCLOCKWND,0,8,TIME$,1
  GPRINTWindowCC WCLOCKWND,0,56,TIME$,1
  E=GEndWindow(WCLOCKWND)
 END
DEF DUMP_WND
 DUMP_WND2 WIN_ROOTWND AND NUWIDMASK,""
END
DEF DUMP_WND2 NUW,I$
 IF!NUW THEN RETURN
 ?I$;WIN_NAME$[NUW],NUW,WIN_WID[NUW],CTL_NAME$[WIN_CTL[NUW]AND 4095],WIN_CTL[NUW]AND 4095
' IF CSRY==29 THEN VAR II$INPUT "";II$
 IF LEN(I$) THEN
  VAR NM$=""
  IF WIN_NEXT[NUW] THEN
   NM$=""
  ELSE
   NM$=""
  ENDIF
  IF WIN_NEXT[WIN_PARENT[NUW]]THEN
   NM$=""+NM$
  ELSE
   NM$=" "+NM$
  ENDIF
  DUMP_WND2 WIN_CHILD[NUW],MID$(I$,0,LEN(I$)-1)+NM$
 ELSE
  IF WIN_CHILD[NUW]THEN
   DUMP_WND2 WIN_CHILD[NUW],""
  ELSE
   DUMP_WND2 WIN_CHILD[NUW],""
  ENDIF
 ENDIF
 DUMP_WND2 WIN_NEXT[NUW],I$
END
DEF UpdateButton()
 VAR B=BUTTON()
 VAR RET=0
 IF B AND OTW_MOUSELBTN THEN
  IF!OTW_OLDLMOUSE THEN RET=OTW_LMOUSEDWN
  OTW_OLDLMOUSE=1
 ELSE
  IF OTW_OLDLMOUSE THEN RET=OTW_LMOUSEUP
  OTW_OLDLMOUSE=0
 ENDIF
 IF B AND OTW_MOUSERBTN THEN
  IF!OTW_OLDRMOUSE THEN RET=RET OR OTW_RMOUSEDWN
  OTW_OLDRMOUSE=1
 ELSE
  IF OTW_OLDRMOUSE THEN RET=RET OR OTW_RMOUSEUP
  OTW_OLDRMOUSE=0
 ENDIF
 RETURN RET
END
VAR OTW_MOUSEOLDX,OTW_MOUSEOLDY
VAR OTW_MOUSEOLDST
COMMON DEF UpdateMouse
 VAR S,X,Y
 TOUCH OUT S,X,Y
 IF OTW_MOUSEOLDST&&S THEN
  OTW_MOUSEX=OTW_MOUSEX+X-OTW_MOUSEOLDX
  OTW_MOUSEY=OTW_MOUSEY+Y-OTW_MOUSEOLDY
   IF OTW_MOUSEX<OTW_MOUSECLIPX THEN OTW_MOUSEX=OTW_MOUSECLIPX
   IF OTW_MOUSEY<OTW_MOUSECLIPY THEN OTW_MOUSEY=OTW_MOUSECLIPY
   IF OTW_MOUSEX>=OTW_MOUSECLIPX2 THEN OTW_MOUSEX=OTW_MOUSECLIPX2
   IF OTW_MOUSEY>=OTW_MOUSECLIPY2 THEN OTW_MOUSEY=OTW_MOUSECLIPY2
   SPOFS OTW_MOUSESP,OTW_MOUSEX,OTW_MOUSEY
   OTW_MOUSEX#=OTW_MOUSEX
   OTW_MOUSEY#=OTW_MOUSEY
 ELSE
  IF S&&X>=OTW_KX&&X<OTW_KX2&&Y>=OTW_KY&&Y<OTW_KY2 THEN
   BEEP 
   VAR K$
   XSCREEN 0,512,2
   VISIBLE 1,1,1,1
   
   OTW_SP=OTW_DP
   GPAGE OTW_DP,OTW_DP
   KEY 1,"
  ENDIF
 ENDIF
 OTW_MOUSEOLDX=X
 OTW_MOUSEOLDY=Y
 OTW_MOUSEOLDST=S
 IF!S THEN
  VAR X#,Y#
  STICK OUT X#,Y#
  IF X#!=0 OR Y#!=0 THEN
   OTW_MOUSEX#=OTW_MOUSEX#+X#*(4/OTW_FPF#)'0.2'/2
   OTW_MOUSEY#=OTW_MOUSEY#-Y#*(4/OTW_FPF#)'0.2'/2
   IF OTW_MOUSEX#<OTW_MOUSECLIPX THEN OTW_MOUSEX#=OTW_MOUSECLIPX
   IF OTW_MOUSEY#<OTW_MOUSECLIPY THEN OTW_MOUSEY#=OTW_MOUSECLIPY
   IF OTW_MOUSEX#>=OTW_MOUSECLIPX2 THEN OTW_MOUSEX#=OTW_MOUSECLIPX2-1
   IF OTW_MOUSEY#>=OTW_MOUSECLIPY2 THEN OTW_MOUSEY#=OTW_MOUSECLIPY2
   SPANIM OTW_MOUSESP,"XY",-1,OTW_MOUSEX#,OTW_MOUSEY#
'   SPOFS OTW_MOUSESP,OTW_MOUSEX#,OTW_MOUSEY#
   OTW_MOUSEX=OTW_MOUSEX#
   OTW_MOUSEY=OTW_MOUSEY#
  ENDIF
 ENDIF
 OTW_LASTUPD=MAINCNT
END
COMMON DEF OTWSAVE VER$
 SAVE"PRG1:OTW"+VER$
END
'DEF OTW_LOADMOUSE
' 
'END
COMMON DEF I_CREATEOTW
 ?"OTW Develop Tool"
 VAR K$
 INC K$,"VAR _1CTL"+LF$()
 INC K$,"COMMON DEF I__1"+LF$()
 INC K$, "IF!CHKCALL(_QIsWinRunning_Q)||!IsWinRunning()THEN"+LF$()
 INC K$,"  PrintConsole _QRequire window system_Q+LF$()"+LF$()
 INC K$,"  ExitProcess 1"+LF$()
 INC K$,"  RETURN"+LF$()
 INC K$," ENDIF"+LF$()
 INC K$," VAR WND,E"+LF$()
 INC K$," IF!_1CTL THEN"+LF$()
 INC K$,"  ExtendControl _Q_2_Q,GetWindowControl() OUT _1CTL,E"+LF$()
 INC K$," ENDIF"+LF$()
 INC K$," NewTopLevelWindow _1CTL,_Q_2_Q,_W,_H OUT WND,E"+LF$()
 INC K$,"SetProcessVar WND"+LF$()
 INC K$,"END"+LF$()
 INC K$,"COMMON DEF L__1"+LF$()
 INC K$,"IF UpdateWindow(GetProcessVar())THEN ExitProcess 1"+LF$()
 INC K$,"END
 VAR _1$
 VAR _2$,_W,_H
 VAR _Q$=CHR$(34)
 LINPUT "ProcessName?";_1$
 LINPUT "WindowName?";_2$
 INPUT "Width";_W
 INPUT "Height";_H
 K$=ReplaceStr$(K$,"_1",_1$)
 K$=ReplaceStr$(K$,"_2",_2$)
 K$=ReplaceStr$(K$,"_W",STR$(_W))
 K$=ReplaceStr$(K$,"_H",STR$(_H))
 K$=ReplaceStr$(K$,"_Q",_Q$)
 VAR SLOT=3
 INPUT "InsertSlot";SLOT
 PRGEDIT SLOT
 PRGINS K$
 ExitProcess 0
END
COMMON DEF L_CREATEOTW
END

VAR PAINTCTL
COMMON DEF PaintRepaint WND,CTL,T,A1,A2
 IF CallBaseControlHandler(WND,CTL,T,A1,A2)THEN RETURN
 DIM A[64*64]
 ReadArray GetWindowVar(WND,2),A,0,LEN(A)
 GLOADWindow WND,0,0,64,64,A,1,0
 VAR E=GEndWindow(WND)
END
COMMON DEF PaintLDWN WND,CTL,T,X,Y
 VAR E=CallBaseControlHandler(WND,CTL,T,X,Y)
 SetWindowVar WND,3,1
 SetWindowVar WND,0,X
 SetWindowVar WND,1,Y
 VOID SetCapture(WND)
END
COMMON DEF PaintLUP WND,CTL,T,X,Y
 SetWindowVar WND,3,0
END
COMMON DEF PaintCF WND,CTL,T,F,A2
'IF CallBaseControlHandler(WND,CTL,T,F,A2)THEN 
 IF!F THEN SetWindowVar WND,3,0
END

COMMON DEF PaintMouseMove WND,CTL,T,X,Y
 IF!GetWindowVar(WND,3)THEN RETURN
 VAR OX=GetWindowVar(WND,0)
 VAR OY=GetWindowVar(WND,1)
 VAR E=GBeginWindow(WND)
 GLINEWindow WND,X,Y,OX,OY,RGB(0,0,0)
 GLINEArrayMemory GetWindowVar(WND,2),64,64,X,Y,OX,OY,RGB(0,0,0)
 E=GEndWindow(WND)
 SetWindowVar WND,0,X
 SetWindowVar WND,1,Y
END
COMMON DEF I_PAINT
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR PTR=malloc(64*64)
 IF!PTR THEN BEEP:ExitProcess 1RETURN
 VAR WND,E
 IF!PAINTCTL THEN
  ExtendControl "PAINT",GetWindowControl() OUT PAINTCTL,E
  E=SetControlMouseMoveHandler(PAINTCTL,"PaintMouseMove")
  E=SetControlPainter(PAINTCTL,"PaintRepaint")
  E=SetControlLMouseDownHandler(PAINTCTL,"PaintLDWN")
  E=SetControlLMouseUpHandler(PAINTCTL,"PaintLUP")
  E=SetControlChFocusHandler(PAINTCTL,"PaintCF")
 ENDIF
 NewTopLevelWindow PAINTCTL,"PAINT",64,64 OUT WND,E  SetProcessVar WND
 SetWindowVar WND,2,PTR
END
COMMON DEF L_PAINT
IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
'===Text editor===
VAR TXTEDCTL
VAR TXTBOXEXCTL
VAR TXTBOXEX_LINESIZ
VAR TXTBOXEX_FREE
DIM TXTBOXEX_VAL$[0]
DIM TXTBOXEX_LINE[0]
DIM TXTBOXEX_NEXT[0]
DIM TXTBOXEX_PREV[0]

VAR TXTBOXEX_MAXCTL
VAR TXTBOXEX_CFREE
DIM TXTBOXEX_CLINE[0]
DIM TXTBOXEX_CMODE[0]
DIM TXTBOXEX_CNEXT[0]
DIM TXTBOXEX_CFIRST[0]
DIM TXTBOXEX_CSELLINE1[0]
DIM TXTBOXEX_CSELPOS1[0]
DIM TXTBOXEX_CSELLINE2[0]
DIM TXTBOXEX_CSELPOS2[0]
DIM TXTBOXEX_CISSEL[0]
DIM TXTBOXEX_CISSELING[0]
COMMON DEF GetTextBoxExControl()
 RETURN TXTBOXEXCTL
END
COMMON DEF SetTextBoxExPRGMode WND,FLG
 VAR CTL=GetWindowVar(WND,7)
 SetTextBoxExMode CTL,FLG
END
VAR TextBoxEx_MENU
COMMON DEF INIT_TXTBOXEX
 VAR E
 IF!TXTEDCTL THEN
  NewControl "TextBoxEx" OUT TXTBOXEXCTL,E
  E=SetControlPainter(TXTBOXEXCTL,"TextBoxExPainter")
  E=SetControlKeyHandler(TXTBOXEXCTL,"TextBoxExKey")
  E=SetControlButtonHandler(TXTBOXEXCTL,"TextBoxExButton")
  E=SetControlChFocusHandler(TXTBOXEXCTL,"TextBoxExChFocus")
  E=SetControlCreateHandler(TXTBOXEXCTL,"TextBoxExCreate")
  E=SetControlNotifHandler(TXTBOXEXCTL,"TextBoxExNotif")
  E=SetControlLMouseDownHandler(TXTBOXEXCTL,"TextBoxExLMD")
  E=SetControlLMouseUpHandler(TXTBOXEXCTL,"TextBoxExLMU")
  E=SetControlRMouseDownHandler(TXTBOXEXCTL,"TextBoxExRMD")
  E=SetControlResizeHandler(TXTBOXEXCTL,"TextBoxResize")
  E=SetControlMouseMoveHandler(TXTBOXEXCTL,"TextBoxExMMOVE")
  TXTBOXEX_LINESIZ=10000'1024
  TXTBOXEX_VAL$=NewArray$(TXTBOXEX_LINESIZ)
  TXTBOXEX_LINE=NewArray(TXTBOXEX_LINESIZ)
  TXTBOXEX_NEXT=NewArray(TXTBOXEX_LINESIZ)
  TXTBOXEX_PREV=NewArray(TXTBOXEX_LINESIZ)
  TXTBOXEX_FREE=1
  TXTBOXEX_MAXCTL=100'1024
  TXTBOXEX_CNEXT=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CLINE=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CMODE=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CFIRST=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELLINE1=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELPOS1=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELLINE2=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CSELPOS2=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CISSEL=NewArray(TXTBOXEX_MAXCTL)
  TXTBOXEX_CISSELING=NewArray(TXTBOXEX_MAXCTL)
  VAR I
  FOR I=1TO TXTBOXEX_LINESIZ-2
   TXTBOXEX_NEXT[I]=I+1
  NEXT
  FOR I=1TO TXTBOXEX_MAXCTL-2
   TXTBOXEX_CNEXT[I]=I+1
  NEXT
  TXTBOXEX_CFREE=1
  NewMenu OUT TextBoxEx_MENU,E
  AddMenuItem TextBoxEx_MENU,"Copy",1
  AddMenuItem TextBoxEx_MENU,"Cut",2
  AddMenuItem TextBoxEx_MENU,"Paste",3
  AddMenuItemSeparator TextBoxEx_MENU
  AddMenuItem TextBoxEx_MENU,"Select all",3
 ENDIF
END
DEF TXTED_NewCTL(WND)
 VAR R=TXTBOXEX_CFREE
 IF!R THEN RETURN 0
 TXTBOXEX_CFREE=TXTBOXEX_CNEXT[TXTBOXEX_CFREE]
 TXTBOXEX_CLINE[R]=1
 RETURN TXTBOXEX_CFREE
END
DEF TXTED_NewLINE(V$,P)
 VAR R=TXTBOXEX_FREE
 IF!R THEN RETURN 0
 TXTBOXEX_FREE=TXTBOXEX_NEXT[TXTBOXEX_FREE]
 IF P THEN
  TXTBOXEX_LINE[R]=TXTBOXEX_LINE[P]+1
 ELSE
  TXTBOXEX_LINE[R]=1
 ENDIF
 VAR N
 IF P THEN
  N=TXTBOXEX_NEXT[P]
  TXTBOXEX_NEXT[P]=R
 ENDIF
 TXTBOXEX_VAL$[R]=V$
 TXTBOXEX_NEXT[R]=N
 TXTBOXEX_PREV[R]=P
 IF N THEN
  TXTBOXEX_PREV[N]=R
 ENDIF
 RETURN R
END
DEF TXTED_DeleteLine(L)
 IF!L THEN RETURN 0
 VAR N=TXTBOXEX_NEXT[L]
 VAR P=TXTBOXEX_PREV[L]
 IF N THEN
  TXTBOXEX_PREV[N]=P
 ENDIF
 IF P THEN
  TXTBOXEX_NEXT[P]=N
 ENDIF
 TXTBOXEX_NEXT[L]=TXTBOXEX_FREE
 TXTBOXEX_FREE=L
 IF P THEN RETURN P
 IF N THEN RETURN N
 RETURN 0
END

COMMON DEF TextBoxExMMOVE WND,CTL,T,X,Y
 IF GetCapture()!=WND THEN
  RETURN
 ENDIF
 VAR MF
 IF Y<0&&TXTED_UpCursor(WND)THEN
  MF=TRUE
 ENDIF
 
 VAR H=GetWindowHeight(WND)
 IF Y>H&&TXTED_DownCursor(WND)THEN
  MF=TRUE
 ENDIF
 IF MF THEN
  TextBoxExRepaint WND
  RETURN
 ENDIF
 VAR LINE,POS,OL,OP
 GetWindowVar WND,2 OUT OL
 GetWindowVar WND,3 OUT OP
 VAR LINEOBJ
 TEXTBOXEX_GETLINEPOS WND,X,Y OUT LINE,POS,LINEOBJ
 VAR BOX=GetWindowVar(WND,7)
 SetWindowVar WND,2,LINEOBJ
 SetWindowVar WND,3,POS
 TXTBOXEX_CSELLINE2[BOX]=LINE
 TXTBOXEX_CSELPOS2[BOX]=POS
 TXTBOXEX_CISSEL[BOX]=TRUE
 TXTBOXEX_CISSELING[BOX]=TRUE
 IF LINE==OL&&POS==OP THEN RETURN
 VOID RepaintWindow(WND)
END
COMMON DEF TextBoxExLMU WND,CTL,T,X,Y
 VOID ReleaseCapture(WND)
 VAR BOX=GetWindowVar(WND,7)
 TXTBOXEX_CISSELING[BOX]=FALSE
END
DEF TEXTBOXEX_GETLINEPOS WND,X,Y OUT LINE,POS,V
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
' IF!X||!Y||X>=W||Y>=H THEN RETURN
 V=GetWindowVar(WND,1)
 VAR Y1=1,Y2
 LINE=TXTBOXEX_CLINE[GETWINDOWVar(WND,7)]
 VAR OV
' IF X<33THEN RETURN
 WHILE V
  OV=V
  LINE=LINE+1
  Y2=Y1+8
  IF Y>=Y1&&Y<Y2 THEN
   BREAK
  ENDIF
  INC Y1,8
  V=TXTBOXEX_NEXT[V]
 WEND
 POS=MAX(0,(X-1-32) DIV 8)
 IF!V THEN V=OV
END
COMMON DEF TextBoxExLMD WND,CTL,T,X,Y
 VAR LINE,POS
 VAR OL,OP
 GetWindowVar WND,2 OUT OL
 GetWindowVar WND,3 OUT OP
 VAR LINEOBJ
 TEXTBOXEX_GETLINEPOS WND,X,Y OUT LINE,POS,LINEOBJ
 VAR BOX=GetWindowVar(WND,7)
 TXTBOXEX_CISSEL[BOX]=FALSE
 TXTBOXEX_CISSELING[BOX]=FALSE
 IF OL==LINE&&OP==POS THEN
 ELSE
  SetWindowVar WND,2,LINEOBJ
  SetWindowVar WND,3,POS
  VOID RepaintWindow(WND)
 ENDIF
 TXTBOXEX_CSELLINE1[BOX]=LINE
 TXTBOXEX_CSELPOS1[BOX]=POS
 TXTBOXEX_CSELLINE2[BOX]=LINE
 TXTBOXEX_CSELPOS2[BOX]=POS
 VOID SetCapture(WND)
END
COMMON DEF TextBoxExRMD WND,CTL,T,X,Y
 ShowContextMenu TextBoxEx_MENU,WND
END
DEF TEXTBOXEX_MENU WND,ID
 ON ID GOTO @UNK,@COPY,@CUT,@PASTE
 @UNK
 ?"UNK
 RETURN
 @COPY
 @CUT
'?TEXTBOXEXGETSELECTEDTEXT(WND)
 TextBoxExCopy WND
 RETURN
 @PASTE
 TextBoxExPaste WND
END
COMMON DEF TextBoxExNotif WND,CTL,T,_,POS
 'MENU
 IF _==0 THEN
  TEXTBOXEX_MENU WND,POS
  RETURN
 ENDIF
 VAR BOX=GetWindowVar(WND,7)
 VAR F=GetTextBoxExLine(BOX)
 VAR SA=POS-F
 VAR I
 IF!SA THEN RETURN
 VAR V=GetWindowVar(WND,1)
 IF SA>0THEN
  FOR I=1TO SA
   IF!TXTBOXEX_NEXT[V]THEN BREAK
   V=TXTBOXEX_NEXT[V]
  NEXT
 ELSE
  SA=ABS(SA)
  FOR I=1TO SA
   IF!TXTBOXEX_PREV[V]THEN BREAK
   V=TXTBOXEX_PREV[V]
  NEXT
 ENDIF
 SetTextBoxExLine BOX,POS
 SetWindowVar WND,1,V
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExCreate WND,CTL,T,_,__
 VAR SCR,E
 VAR W=GetWindowWidth(WND),
 NewVScrollBar WND,0 OUT SCR,E
 VAR C=TXTED_NewCTL(WND)
 SetWindowVar WND,7,C
 SetTextBoxExLine C,0
 TXTBOXEX_CFIRST[C]=0
 TXTBOXEX_CISSEL[C]=0
 TXTBOXEX_CISSELING[C]=0
 TXTBOXEX_CSELLINE1[C]=0
 TXTBOXEX_CSELPOS1[C]=0
 TXTBOXEX_CSELLINE2[C]=0
 TXTBOXEX_CSELPOS2[C]=0
END
DEF GetTextBoxExMode(CTL)
 RETURN TXTBOXEX_CMODE[CTL]
END
DEF SetTextBoxExMode CTL,L
 TXTBOXEX_CMODE[CTL]=L
END
DEF GetTextBoxExLine(CTL)
 RETURN TXTBOXEX_CLINE[CTL]
END
DEF SetTextBoxExLine CTL,L
 TXTBOXEX_CLINE[CTL]=L
END
DEF TextBoxResize WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF TextBoxExPainter WND,CTL,T,_,__
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExChFocus WND,CTL,T,_,__
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExRepaint WND
 VAR E=GBeginWindow(WND)
 VAR BOX=GetWindowVar(WND,7)
 VAR SH=GetTextBoxExMode(BOX)
 IF SH THEN
  GCLSWindow WND,RGB(0,0,0)
 ELSE
  GCLSWindow WND,RGB(255,255,255)
 ENDIF
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR L=GetWindowVar(WND,1)
 VAR C=GetWindowVar(WND,2)
 VAR V$=TXTBOXEX_VAL$[C]
 VAR CX=GetWindowVar(WND,3)
 VAR L$=LF$()
 IF LEN(V$)<=CX THEN
  CX=LEN(V$)
  IF LEN(V$)&&V$[LEN(V$)-1]==L$THEN DEC CX
  SetWindowVar WND,3,CX
 ENDIF
 VAR TC=RGB(0,0,0)
 IF SH THEN TC=-1
 VAR Y=1,X=32,PL,LC
 VAR LINE=GetTextBoxExLine(BOX),_
 VAR M0=MAINCNT
 IF TXTBOXEX_CISSEL[BOX]THEN
  VAR SELLINE1=TXTBOXEX_CSELLINE1[BOX]
  VAR SELLINE2=TXTBOXEX_CSELLINE2[BOX]
  VAR SELPOS1=TXTBOXEX_CSELPOS1[BOX]
  VAR SELPOS2=TXTBOXEX_CSELPOS2[BOX]
  IF SELLINE1>SELLINE2 THEN
   SWAP SELLINE1,SELLINE2
   SWAP SELPOS1,SELPOS2
  ENDIF
 ENDIF
 WHILE 1
  INC LINE
  V$=TXTBOXEX_VAL$[L]
  _=(LINE-(LINE DIV 1000000)*1000000) DIV 10000
  IF LINE>=1000000THEN INC _,&H64
  IF !_ THEN _=&H6E
  VAR LS$=CHR$(&HE100+_)
  _=(LINE-((LINE DIV 10000)*10000))DIV 100
  IF LINE>=10000&&_<=&H9THEN INC _,&H64
  IF !_ THEN _=&H6E
  INC LS$,CHR$(&HE100+_)
  _=LINE-((LINE DIV 100)*100)
  IF LINE>=100&&_<=&H9THEN INC _,&H64
  IF !_ THEN _=&H6E
  INC LS$,CHR$(&HE100+_)
  GPRINTWindow WND,1,Y,LS$+CHR$(&HE16F),RGB(198,198,198)
  IF LINE>SELLINE1&&LINE<SELLINE2 THEN
   GFILLWindow WND,X,Y,X+LEN(V$)*8,Y+7,RGB(0,0,255)
  ENDIF
  IF LINE==SELLINE1&&LINE==SELLINE2 THEN
   GFILLWindow WND,X+MIN(LEN(V$),SELPOS1)*8,Y,X+MIN(LEN(V$),SELPOS2)*8,Y+7,RGB(0,0,255)
  ELSEIF LINE==SELLINE1 THEN
   GFILLWindow WND,X+MIN(LEN(V$),SELPOS1)*8,Y,X+LEN(V$)*8,Y+7,RGB(0,0,255)
  ELSEIF LINE==SELLINE2 THEN
   GFILLWindow WND,X,Y,X+MIN(LEN(V$),SELPOS2)*8,Y+7,RGB(0,0,255)
  ENDIF
  IF SH THEN
   TXTED_PRGPRINT WND,X,Y,V$
  ELSE
   GPRINTWindow WND,X,Y,V$,TC
  ENDIF
  PL=L
  IF L==C&&IsActiveWindow(WND)THEN
   GFILLWindow WND,X+CX*8,Y+7,X+7+CX*8,Y+6,TC
  ENDIF
  L=TXTBOXEX_NEXT[L]
  INC Y,8
  IF Y>=H THEN BREAK
  IF!L THEN
   IF!LEN(V$)||V$[LEN(V$)-1]!=L$THEN
'    GPRINTWindow WND,LEN(V$)*8,Y-8,"[EOF]",RGB(80,208,255)
    IF PL==C&&IsActiveWindow(WND)THEN
     GFILLWindow WND,X+CX*8,Y-1,X+7+CX*8,Y-2,TC
    ENDIF
   ELSE
'    GPRINTWindow WND,X,Y,"[EOF]",RGB(80,208,255)
    IF PL==C&&IsFocusWindow(WND)THEN
  '   GFILLWindow WND,CX*8,Y+7,8+CX*8,Y+6,TC
    ENDIF
   ENDIF
   PL=0
   BREAK
  ENDIF
  IF MAINCNT-M0>1THEN UpdateMouse
 WEND
 GBOXWindow WND,0,0,W,H,RGB(0,0,0)
 E=GEndWindow(WND)
 SetWindowVar WND,6,PL
END
DEF TXTED_UpCursor(WND)
  VAR C=GetWindowVar(WND,2)
  IF TXTBOXEX_PREV[C]THEN
   VAR L=TXTBOXEX_PREV[GetWindowVar(WND,1)]
   C=TXTBOXEX_PREV[C]
   IF L==C THEN
     SetWindowVar WND,1,L
    VAR BOX=GetWindowVar(WND,7)
    VAR LINE=GetTextBoxExLine(BOX)-1
    SetTextBoxExLine BOX,LINE
    SetScrollBarPosition GetChildWindow(WND),LINE

   ENDIF
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
DEF TXTED_DownCursor(WND)
  VAR C=GetWindowVar(WND,2)
  IF TXTBOXEX_NEXT[C]THEN
   IF GetWindowVar(WND,6)==C THEN
    VAR L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
    IF L THEN
     SetWindowVar WND,1,L
     VAR BOX=GetWindowVar(WND,7)
     VAR LINE=GetTextBoxExLine(BOX)+1
     SetTextBoxExLine BOX,LINE
     SetScrollBarPosition GetChildWindow(WND),LINE
    ENDIF
   ENDIF
   C=TXTBOXEX_NEXT[C]
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
COMMON DEF TextBoxExButton WND,CTL,T,BTN,_
 VAR BOX=GetWindowVar(WND,7)
 IF TXTBOXEX_CISSELING[BOX]THEN RETURN
 VAR F=GetWindowVar(WND,4),U,R=GetWindowVar(WND,5)
 TXTBOXEX_CISSEL[BOX]=0
 IF!BTN THEN SetWindowVar WND,5,0RETURN
 IF MAINCNT-F<R THEN RETURN

 IF BTN AND 1 THEN
  IF TXTED_UpCursor(WND)THEN
   TextBoxExRepaint WND
  ENDIF
  U=1
 ENDIF
 IF BTN AND 2 THEN
  IF TXTED_DownCursor(WND)THEN
   TextBoxExRepaint WND
  ENDIF
  U=1
 ENDIF
 IF BTN AND 4THEN
  VAR CX=GetWindowVar(WND,3)
  IF CX THEN
   SetWindowVar WND,3,CX-1
   TextBoxExRepaint WND
  ELSE
   IF TXTED_UpCursor(WND)THEN
    VAR C=GetWindowVar(WND,2)
    SetWindowVar WND,3,LEN(TXTBOXEX_VAL$[C])
    TextBoxExRepaint WND
   ENDIF
  ENDIF
  U=1
 ENDIF
 IF BTN AND 8THEN
  CX=GetWindowVar(WND,3)
  C=GetWindowVar(WND,2)
  SetWindowVar WND,3,CX+1
  VAR V$=TXTBOXEX_VAL$[C]
  IF LEN(V$)<=CX||LEN(V$)-1==CX&&V$[CX]==LF$()THEN
   IF TXTED_DownCursor(WND)THEN
    SetWindowVar WND,3,0
    TextBoxExRepaint WND
   ENDIF
  ENDIF
  TextBoxExRepaint WND
  U=1
 ENDIF
 IF U THEN
  IF R==0 THEN
   SetWindowVar WND,5,20
  ELSE
   SetWindowVar WND,5,3
  ENDIF
  SetWindowVar WND,4,MAINCNT
 ENDIF
END
COMMON DEF TextBoxExKey WND,CTL,T,KEY,_
 VAR C=GetWindowVar(WND,2)
 VAR BOX=GetWindowVar(WND,7)
 IF TXTBOXEX_CISSELING[BOX]THEN RETURN
 TXTBOXEX_CISSEL[BOX]=0
 IF!C THEN
  C=TXTED_NewLINE("",0)
  SetWindowVar WND,1,C
  SetWindowVar WND,2,C
  TXTBOXEX_CFIRST[BOX]=C
  IF!C THEN RETURN
 ENDIF
 VAR X=GetWindowVar(WND,3)
 VAR K$=CHR$(KEY)
 IF K$==CR$()THEN K$=LF$()
 IF K$==BS$()THEN
  IF X>0THEN
   TXTBOXEX_VAL$[C]=RemoveStr$(TXTBOXEX_VAL$[C],X-1,1)
   SetWindowVar WND,3,X-1
  ELSE
   VAR P=TXTBOXEX_PREV[C]
   IF P THEN
    VAR L=GetWindowVar(WND,1)
    VAR V$=TXTBOXEX_VAL$[C]
    L=TXTED_DeleteLine(C)
    IF C==TXTBOXEX_CFIRST[BOX]THEN
     TXTBOXEX_CFIRST[BOX]=L
    ENDIF
    SetWindowVar WND,2,L
    TXTBOXEX_VAL$[L]=LEFT$(TXTBOXEX_VAL$[L],LEN(TXTBOXEX_VAL$[L])-1)
    SetWindowVar WND,3,LEN(TXTBOXEX_VAL$[L])
    INC TXTBOXEX_VAL$[L],MID$(V$,X,LEN(V$)-X)
    L=GetWindowVar(WND,1)
    IF L==C THEN
     SetWindowVar WND,1,GetWindowVar(WND,2)
    ENDIF
   ENDIF
  ENDIF
 ELSE
  IF K$==LF$()THEN
   VAR C2=TXTED_NewLine(MID$(TXTBOXEX_VAL$[C],X,LEN(TXTBOXEX_VAL$[C])-X),C)
   IF!C2 THEN RETURN
   SetWindowVar WND,2,C2
   SetWindowVar WND,3,0
   TXTBOXEX_VAL$[C]=MID$(TXTBOXEX_VAL$[C],0,X)+K$
   IF GetWindowVar(WND,6)==C THEN
    L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
    IF L THEN
     VAR LINE=GetTextBoxExLine(BOX)+1
     SetTextBoxExLine BOX,LINE
     VAR SCRBAR=GetChildWindow(WND)
     IF GetScrollBarSize(SCRBAR)<LINE THEN
      SetScrollBarSize SCRBAR,LINE
     ENDIF
     SetScrollBarPosition SCRBAR,LINE
     SetWindowVar WND,1,L
    ENDIF
   ENDIF
  ELSE
'   X=MIN(MAX(LEN(TXTBOXEX_VAL$[C]),-80),X)
'   SetWindowVar WND,3,X
   TXTBOXEX_VAL$[C]=InsertStr$(TXTBOXEX_VAL$[C],X,K$)
   SetWindowVar WND,3,X+1
  ENDIF
 ENDIF
 TextBoxExRepaint WND
END
COMMON DEF TextBoxExSetText WND,TXT$
 VAR BOX=GetWindowVar(WND,7)
 VAR C=GetWindowVar(WND,1),I,J
 IF C THEN
  I=C
  WHILE 1
   TXTBOXEX_VAL$[C]=""
   TXTBOXEX_PREV[C]=0
   IF!TXTBOXEX_NEXT[C]THEN BREAK
   C=TXTBOXEX_NEXT[C]
  WEND
  TXTBOXEX_NEXT[C]=TXTBOXEX_FREE
  TXTBOXEX_FREE=I
  I=0
 ENDIF
 C=0
 VAR OC=0,L=-8-8
 WHILE 1
  INC L
  J=INSTR(I,TXT$,LF$())
  IF LEN(TXT$)==I THEN BREAK
  IF J==-1THEN J=LEN(TXT$)-1
  C=TXTED_NewLINE(MID$(TXT$,I,J-I+1),C)
  IF!OC THEN
   SetWindowVar WND,1,C
   SetWindowVar WND,2,C
   TXTBOXEX_CFIRST[BOX]=C
   OC=1
  ENDIF
  IF!C THEN BREAK
  IF I==LEN(TXT$)-1THEN BREAK
  I=J+1
 WEND
 IF!LEN(TXT$)THEN
  C=TXTED_NewLINE("",C)
  SetWindowVar WND,1,C
  SetWindowVar WND,2,C
  TXTBOXEX_CFIRST[BOX]=C
 ENDIF
 VAR S=L+CEIL((GetWindowHeight(WND)-2)/8)
 IF S<0THEN S=0
 SetScrollBarSize GetChildWindow(WND),S
 SetScrollBarPosition GetChildWindow(WND),0
 SetTextBoxExLine BOX,0
 VOID RepaintWindow(WND)
END
COMMON DEF TextBoxExGetText WND OUT TXT$
 TXT$=""+""
 VAR BOX=GetWindowVar(WND,7)
 VAR C=TXTBOXEX_CFIRST[BOX]
 WHILE C
  PUSH TXT$,TXTBOXEX_VAL$[C]
  C=TXTBOXEX_NEXT[C]
 WEND
END
COMMON DEF TextBoxExCopy WND
 VAR TXT$
 TextBoxExGetSelectedText WND OUT TXT$
 ClearClipboard
 ClipboardSetText TXT$
END
COMMON DEF TextBoxExPaste WND
 IF!ClipboardContainsText()THEN RETURN
 VAR TXT$=ClipboardGetText$()
 TextBoxExSetSelectedText WND,TXT$
END
'TXT$->LINEOBJ
DEF TEXTBOXEX_PARSETXT TXT$ OUT LINEFIRST,LINELAST,LINECOUNT
 VAR I,J
 VAR C=0
 VAR OC=0,L
 VAR LF$=LF$()
 WHILE 1
  INC L
  J=INSTR(I,TXT$,LF$)
  IF LEN(TXT$)==I THEN BREAK
  IF J==-1THEN J=LEN(TXT$)-1
  C=TXTED_NewLINE(MID$(TXT$,I,J-I+1),C)
  IF!OC THEN
   LINEFIRST=C
   OC=TRUE
  ENDIF
  IF!C THEN BREAK
  IF I==LEN(TXT$)-1THEN BREAK
  I=J+1
 WEND
 IF!LEN(TXT$)THEN
  C=TXTED_NewLINE("",C)
  LINEFIRST=C
 ENDIF
 LINELAST=C
 TXTBOXEX_NEXT[C]=0
 LINECOUNT=L
END
'RET:LINE
DEF TEXTBOXEX_REMOVESELECTEDTEXT WND OUT L,CX
 VAR BOX=GetWindowVar(WND,7)
 IF!TXTBOXEX_CISSEL[BOX]THEN
  L=GetWindowVar(WND,2)
  CX=GetWindowVar(WND,3)
  RETURN
 ENDIF
 TXTBOXEX_CISSEL[BOX]=FALSE
 VAR C=TXTBOXEX_CFIRST[BOX]
 VAR SELLINE1=TXTBOXEX_CSELLINE1[BOX]
 VAR SELLINE2=TXTBOXEX_CSELLINE2[BOX]
 VAR SELPOS1=TXTBOXEX_CSELPOS1[BOX]
 VAR SELPOS2=TXTBOXEX_CSELPOS2[BOX]
 IF SELLINE1>SELLINE2 THEN
  SWAP SELLINE1,SELLINE2
  SWAP SELPOS1,SELPOS2
 ENDIF
 VAR LINE
 CX=SELPOS1
 WHILE C
  INC LINE
  IF SELLINE1==LINE THEN
   L=C
  ENDIF
  IF SELLINE1==LINE&&SELLINE2==LINE THEN
   IF SELPOS2<SELPOS1 THEN
    SWAP SELPOS2,SELPOS1
   ENDIF
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   TXTBOXEX_VAL$[C]=RemoveStr$(TXTBOXEX_VAL$[C],SELPOS1,SELPOS2-SELPOS1)
   CX=MIN(CX,LEN(TXTBOXEX_VAL$[C])-1)
   BREAK
  ELSEIF SELLINE1==LINE THEN
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   IF SELPOS1 THEN
    TXTBOXEX_VAL$[C]=LEFT$(TXTBOXEX_VAL$[C],SELPOS1-1)
   ELSE
    TXTBOXEX_VAL$[C]=""
   ENDIF
   CX=MIN(CX,MAX(LEN(TXTBOXEX_VAL$[C])-1,0))
  ELSEIF SELLINE2==LINE THEN
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   TXTBOXEX_VAL$[C]=RIGHT$(TXTBOXEX_VAL$[C],LEN(TXTBOXEX_VAL$[C])-SELPOS2-1)
   BREAK
  ELSEIF SELLINE1<LINE THEN
   C=TXTED_DeleteLine(C)
   CONTINUE
  ENDIF
  C=TXTBOXEX_NEXT[C]
 WEND
END
COMMON DEF TextBoxExSetSelectedText WND,TXT$
 VAR _1,_3,_2,LF$=LF$()
 TEXTBOXEX_PARSETXT TXT$ OUT _1,_2,_3
 IF _1==0THEN RETURN
 VAR T1$=TXTBOXEX_VAL$[_1]
 VAR LASTLF
 IF LEN(T1$)&&T1$[LEN(T1$)-1]==LF$THEN
  LASTLF=TRUE
 ENDIF
 VAR T2$=TXTBOXEX_VAL$[_2]
 VAR LASTLF2
 IF LEN(T2$)&&T2$[LEN(T2$)-1]==LF$THEN
  LASTLF2=TRUE
 ENDIF
 VAR C
 VAR CX
 TEXTBOXEX_REMOVESELECTEDTEXT WND OUT C,CX
 IF LASTLF THEN
  VAR MATSUO$=MID$(TXTBOXEX_VAL$[C],CX,LEN(TXTBOXEX_VAL$[C])-CX)
  TXTBOXEX_VAL$[C]=LEFT$(TXTBOXEX_VAL$[C],CX)+T1$
  IF!LASTLF2 THEN
   TXTBOXEX_VAL$[_2]=TXTBOXEX_VAL$[_2]+MATSUO$
  ELSE
   VOID TXTED_NewLine(MATSUO$,C)
  ENDIF
 ELSE
  TXTBOXEX_VAL$[C]=InsertStr$(TXTBOXEX_VAL$[C],CX,T1$)
 ENDIF
 IF _1==_2 THEN
  VOID TXTED_DeleteLine(_1)
  RETURN
 ENDIF
 _1=TXTBOXEX_NEXT[_1]
 VAR CN=TXTBOXEX_NEXT[C]
 TXTBOXEX_NEXT[C]=_1
 TXTBOXEX_PREV[_1]=C
 TXTBOXEX_NEXT[_2]=CN
 TXTBOXEX_PREV[CN]=_2
 VOID RepaintWindow(WND)
RETURN

END
COMMON DEF TextBoxExGetSelectedText WND OUT TXT$
 TXT$=""+""
 VAR BOX=GetWindowVar(WND,7)
 VAR C=TXTBOXEX_CFIRST[BOX]
 VAR SELLINE1=TXTBOXEX_CSELLINE1[BOX]
 VAR SELLINE2=TXTBOXEX_CSELLINE2[BOX]
 VAR SELPOS1=TXTBOXEX_CSELPOS1[BOX]
 VAR SELPOS2=TXTBOXEX_CSELPOS2[BOX]
 IF SELLINE1>SELLINE2 THEN
  SWAP SELLINE1,SELLINE2
  SWAP SELPOS1,SELPOS2
 ENDIF
 VAR LINE
 WHILE C
  INC LINE
  IF SELLINE1==LINE&&SELLINE2==LINE THEN
   IF SELPOS2<SELPOS1 THEN
    SWAP SELPOS2,SELPOS1
   ENDIF
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   TXT$=MID$(TXTBOXEX_VAL$[C],SELPOS1,SELPOS2-SELPOS1)
   BREAK
  ELSEIF SELLINE1==LINE THEN
   SELPOS1=MIN(SELPOS1,LEN(TXTBOXEX_VAL$[C])-1)
   PUSH TXT$,MID$(TXTBOXEX_VAL$[C],SELPOS1,LEN(TXTBOXEX_VAL$[C])-SELPOS1)
  ELSEIF SELLINE2==LINE THEN
   SELPOS2=MIN(SELPOS2,LEN(TXTBOXEX_VAL$[C])-1)
   PUSH TXT$,MID$(TXTBOXEX_VAL$[C],0,SELPOS2)
   BREAK
  ELSEIF SELLINE1<LINE THEN
   PUSH TXT$,TXTBOXEX_VAL$[C]
  ENDIF
  C=TXTBOXEX_NEXT[C]
 WEND
END
'===syntax highlighting===
'HashSet
VAR RTXTEDTRUE
VAR RTXTEDFALSE
VAR RTXTEDVAR
VAR RTXTEDDIM
VAR RTXTEDFOR
VAR RTXTEDNEXT
VAR RTXTEDBREAK
VAR RTXTEDCONTINUE
VAR RTXTEDREPEAT
VAR RTXTEDUNTIL
VAR RTXTEDWHILE
VAR RTXTEDWEND
VAR RTXTEDDATA
VAR RTXTEDREAD
VAR RTXTEDCOMMON
VAR RTXTEDDEF
VAR RTXTEDOUT
VAR RTXTEDEND
VAR RTXTEDRETURN
VAR RTXTEDIF
VAR RTXTEDTHEN
VAR RTXTEDELSE
VAR RTXTEDENDIF
VAR RTXTEDPRINT
VAR RTXTEDREM
VAR RTXTEDINC
VAR RTXTEDDEC
VAR RTXTEDGOTO
VAR RTXTEDGOSUB
VAR RTXTEDRESTORE
VAR RTXTEDAND
VAR RTXTEDOR
VAR RTXTEDXOR
VAR RTXTEDNOT
VAR RTXTEDMOD
VAR RTXTEDDIV
VAR RTXTEDCALL
COMMON DEF TXTED_PRGPRINT WND,X,Y,P$
 VAR L=LEN(P$)-1,I,A
 VAR _0=ASC("0"),_9=ASC("9"),_Q=34
 VAR _S=ASC("'"),_A=ASC("A"),_Z=ASC("Z")
 VAR _LA=ASC("a"),_LZ=ASC("z"),__=ASC("_")
 VAR _AT=ASC("@"),_AND=ASC("&"),_B=ASC("B")
 VAR _H=ASC("H"),_1=ASC("1"),_F=ASC("F")
 VAR _LF=10
 VAR S
 FOR I=0TO L
  A=ASC(P$[I])
  IF A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__ THEN 
   S=I
   FOR I=I+1 TO L
    A=ASC(P$[I])
    IF A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__ THEN CONTINUE
    IF A>=_0&&A<=_9 THEN CONTINUE
    BREAK
   NEXT
   VAR I$=MID$(P$,S,I-S)
   IF CHKVAR("RTXTED"+I$)THEN
    GPRINTWindow WND,X,Y,I$,RGB(0,198,247)
   ELSE
    GPRINTWindow WND,X,Y,I$,-1'RGB(0,0,0)
   ENDIF
   INC X,LEN(I$)*8
   DEC I
   CONTINUE
  ENDIF
  IF A==_Q THEN
   GPUTCHRWindow WND,X,Y,A,RGB(99,132,247)
   INC X,8
   FOR I=I+1 TO L
    A=ASC(P$[I])
    IF A==_LF THEN GPUTCHRWindow WND,X,Y,A,-1BREAK
    GPUTCHRWindow WND,X,Y,A,RGB(99,132,247)
    INC X,8
    IF A==_Q THEN BREAK
   NEXT
   IF A!=_Q THEN BREAK
   IF I==L THEN BREAK
   CONTINUE
  ENDIF
  IF A==_S THEN
   FOR I=I TO L
    A=ASC(P$[I])
    IF A==_LF THEN GPUTCHRWindow WND,X,Y,A,-1BREAK
    GPUTCHRWindow WND,X,Y,A,RGB(33,247,16)
    INC X,8
   NEXT
   BREAK
  ENDIF
  IF A==_AT THEN
   FOR I=I TO L
    A=ASC(P$[I])
    IF!(A>=_A&&A<=_Z||A>=_LA&&A<=_LZ||A==__||A>=_0&&A<=_9||A==_AT)THEN DEC I:BREAK
    GPUTCHRWindow WND,X,Y,A,RGB(247,167,0)
    INC X,8
   NEXT
   CONTINUE
  ENDIF
  IF A==_AND THEN
   S=ASC(P$[I])
   FOR I=I+1 TO L
    A=ASC(P$[I])
    INC X,8
    IF A==_B THEN
     GPUTCHRWindow WND,X-8,Y,S,RGB(247,69,149)
     GPUTCHRWindow WND,X,Y,A,RGB(247,69,149)
     INC X,8
     S=0
     FOR I=I+1 TO L
      A=ASC(P$[I])
      IF A>_1&&A<=_9 THEN
       GPUTCHRWindow WND,X,Y,A,-1'RGB(0,0,0)
       INC X,8
       S=1
       CONTINUE
      ENDIF
      IF A!=_0&&A!=_1||S THEN DEC I:BREAK
      GPUTCHRWindow WND,X,Y,A,RGB(247,69,149)
      INC X,8
     NEXT
     DEC I
     BREAK
    ENDIF
    IF A==_H THEN
     GPUTCHRWindow WND,X-8,Y,S,RGB(247,69,149)
     GPUTCHRWindow WND,X,Y,A,RGB(247,69,149)
     INC X,8
     FOR I=I+1 TO L
      A=ASC(P$[I])
      IF!(A>=_0&&A<=_9||A>=_A&&A<=_F)THEN DEC I:BREAK
      GPUTCHRWindow WND,X,Y,A,RGB(247,69,149)
      INC X,8
     NEXT
     BREAK
    ENDIF
    GPUTCHRWindow WND,X-8,Y,S,RGB(255,255,255)
    DEC I
    BREAK
   NEXT
   CONTINUE
  ENDIF
  IF A>=_0&&A<=_9 THEN
   GPUTCHRWindow WND,X,Y,A,RGB(247,69,149)
  ELSE
   IF A==_LF THEN GPUTCHRWindow WND,X,Y,A,RGB(0,0,0)',RGB(0,184,255)BREAK
   GPUTCHRWindow WND,X,Y,A,-1'RGV(0,0,0)
  ENDIF
  INC X,8
 NEXT
END
'===End text editor===
COMMON DEF TXTEDNOTIF W,C,T,A1,A2
 IF A2==4THEN
  VOID SaveFileDialog(W,"TXT",1)
 ENDIF
 IF A2==2THEN
  VOID OpenFileDialog(W,"TXT",0)
 ENDIF
 IF A2==1THEN
  TextBoxExSetText GetWindowVar(W,0),LF$()
 ENDIF
END
COMMON DEF TXTEDSTRNOTIF W,C,T,ID,A2$
 ON ID GOTO @OPEN,@SAVE
 RETURN
 @OPEN
 TextBoxExSetText GetWindowVar(W,0),LoadFile$(RIGHT$(A2$,LEN(A2$)-1))
 RETURN
 @SAVE
 VAR T$
 TextBoxExGetText GetWindowVar(W,0) OUT T$
 SaveFile$ RIGHT$(A2$,LEN(A2$)-1),T$
 RETURN
END
COMMON DEF TXTEDRESIZE WND,C,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W>=0THEN
  VOID ResizeWindow(GetChildWindow(WND),W,H)
 ENDIF
END
COMMON DEF I_TXTED
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!TXTEDCTL THEN
  ExtendControl "TXTED",GetWindowControl() OUT TXTEDCTL,E
  E=SetControlNotifHandler(TXTEDCTL,"TXTEDNOTIF")
  E=SetControlStrNotifHandler(TXTEDCTL,"TXTEDSTRNOTIF")
  E=SetControlResizeHandler(TXTEDCTL,"TXTEDRESIZE")
 ENDIF
 NewTopLevelStyleWindow TXTEDCTL,"TXTED",128,64,WindowMenuStyle()OR WindowResizableStyle() OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"New",1
 AddMenuItem MENU,"Open",2
 AddMenuItem MENU,"Save",3
 AddMenuItem MENU,"Save as",4
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 SetProcessVar WND
 VAR TED
 NewWindow GetTextBoxExControl(),"",0,0,128,64,WND,0 OUT TED,E
 TextBoxExSetText TED,LF$()
 SetWindowVar WND,0,TED
 VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
 IF LEN(CMD$)THEN
  TextBoxExSetText GetWindowVar(WND,0),LoadFile$(CMD$)
 ENDIF
'SetTextBoxExPRGMode WND,TRUE
END
COMMON DEF L_TXTED
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR PRGEDCTL
COMMON DEF I_PRGED
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!PRGEDCTL THEN
  ExtendControl "PRGED",GetWindowControl() OUT PRGEDCTL,E
  E=SetControlNotifHandler(PRGEDCTL,"TXTEDNOTIF")
  E=SetControlStrNotifHandler(PRGEDCTL,"TXTEDSTRNOTIF")
  E=SetControlResizeHandler(PRGEDCTL,"TXTEDRESIZE")
 ENDIF
 NewTopLevelStyleWindow PRGEDCTL,"PRGED",128,64,WindowMenuStyle()OR WindowResizableStyle() OUT WND,E
'NewTopLevelMenuWindow PRGEDCTL,"PRGED",128,64 OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"New",1
 AddMenuItem MENU,"Open",2
 AddMenuItem MENU,"Save",3
 AddMenuItem MENU,"Save as",4
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 SetProcessVar WND
 VAR TED
 NewWindow GetTextBoxExControl(),"",0,0,128,64,WND,0 OUT TED,E
 TextBoxExSetText TED,LF$()
 SetWindowVar WND,0,TED
 SetTextBoxExPRGMode TED,TRUE
 VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
  IF LEN(CMD$)THEN
   TextBoxExSetText GetWindowVar(WND,0),LoadFile$(CMD$)
  ENDIF
END
COMMON DEF L_PRGED
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
'===OTYA DOCUMENT EDITOR===
COMMON DEF RichTextBold()
 RETURN 1
END
COMMON DEF RichTextItalic()
 RETURN 2
END
COMMON DEF RichTextStrike()
 RETURN 4
END
COMMON DEF RichTextUnderline()
 RETURN 8
END
COMMON DEF RICHTEXTWindow WND,X,Y,C,STYLE,SIZE,COL
 VAR S2=SIZE DIV 8
 VAR I,X2,BF=0
' INC Y,SIZE MOD 8
 IF SIZE==8THEN'&&(STYLE AND 3)!=3THEN
  X2=X
  @LOOP1
  IF STYLE AND 2THEN
   IF!BF THEN
    GPAGE OTW_SP,OTW_DP
    GCLIP 1
    GFILL 511-8,511-8,511,511,0
    GPUTCHR 511-8,511-8,C,1,1,COL
    GPAGE OTW_SP,OTW_BP
   ENDIF
'  FOR I=0TO 7
'   GCOPY OTW_DP,511-8,511-8+I,511,511-8+I,X+WING_SX+I DIV 4,Y+WING_SY+I,0
'  NEXT
   'こうそくか
   GCOPY OTW_DP,511-8,511-8,511,511-5,X+WING_SX+1,Y+WING_SY,0
   GCOPY OTW_DP,511-8,511-4,511,511,X+WING_SX,Y+WING_SY+4,0
  ELSE
   GPUTCHRSize1Window WND,X,Y,C,S2,COL
  ENDIF
  IF STYLE AND 1 THEN
   INC X
   STYLE=STYLE AND NOT 1
   BF=TRUE
   GOTO @LOOP1
   'GPUTCHRWindow WND,X+1,Y,C,COL
  ENDIF
  X=X2
 ELSE
  GPUTCHRSize1Window WND,X,Y,C,S2,COL
  IF STYLE AND 1 THEN
   GPUTCHRSize1Window WND,X+1,Y,C,S2,COL
  ENDIF
 ENDIF
 IF STYLE AND 4THEN
  GLINEWindow WND,X,Y+SIZE/2-1,X+SIZE,Y+SIZE/2-1,COL
 ENDIF
 IF STYLE AND 8THEN
  GLINEWindow WND,X,Y+SIZE-1,X+SIZE-1,Y+SIZE-1,COL
 ENDIF
END
VAR OTYDOCCTL
VAR OTYDOC_WNDCTL
VAR OTYDOC_FREE
DIM OTYDOC_LINE[0]
DIM OTYDOC_NEXT[0]
DIM OTYDOC_PREV[0]
DIM OTYDOC_VAL$[0]
VAR OTYDOC_LEFT
VAR OTYDOC_CENTER
VAR OTYDOC_RIGHT
DIM OTYDOC_LINESTYLE[0]
'LINE SIZE
DIM OTYDOC_SIZE[0]
VAR OTYDOC_LINESIZ

VAR OTYDOC_WFREE
VAR OTYDOC_WSIZ
DIM OTYDOC_WNEXT[0]
DIM OTYDOC_WPREV[0]
DIM OTYDOC_ShowLine[0]
DIM OTYDOC_CurLine[0]
DIM OTYDOC_WSIZE[0]
DIM OTYDOC_STYLE[0]
DIM OTYDOC_WSIZE2[0]
DIM OTYDOC_STYLE2[0]
DIM OTYDOC_COL[0]
DIM OTYDOC_COL2[0]
DIM OTYDOC_CX[0]

VAR OTYDOC_BEG$
VAR OTYDOC_END$
COMMON DEF INIT_OTYDOC
 VAR E
 IF!OTYDOCCTL THEN
  OTYDOC_BEG$=CHR$(&HB10B)
  OTYDOC_END$=CHR$(&HE0F0)
  NewControl "OTYDoc" OUT OTYDOCCTL,E
  E=SetControlPainter(OTYDOCCTL,"OTYDocPainter")
  E=SetControlKeyHandler(OTYDOCCTL,"OTYDocKey")
  E=SetControlButtonHandler(OTYDOCCTL,"OTYDocButton")
  E=SetControlChFocusHandler(OTYDOCCTL,"OTYDocChFocus")
  E=SetControlCreateHandler(OTYDOCCTL,"OTYDocCreate")
  E=SetControlResizeHandler(OTYDOCCTL,"OTYDocResize")
  E=SetControlLMouseDownHandler(OTYDOCCTL,"OTYDocLMouseUp")
  OTYDOC_LINESIZ=1024
  OTYDOC_VAL$=NewArray$(OTYDOC_LINESIZ)
  OTYDOC_LINE=NewArray(OTYDOC_LINESIZ)
  OTYDOC_NEXT=NewArray(OTYDOC_LINESIZ)
  OTYDOC_PREV=NewArray(OTYDOC_LINESIZ)
  OTYDOC_SIZE=NewArray(OTYDOC_LINESIZ)
  OTYDOC_LINESTYLE=NewArray(OTYDOC_LINESIZ)
  OTYDOC_LEFT=0
  OTYDOC_CENTER=1
  OTYDOC_RIGHT=2
  OTYDOC_FREE=1
  VAR I
  FOR I=1TO OTYDOC_LINESIZ-2
   OTYDOC_NEXT[I]=I+1
  NEXT
  OTYDOC_WSIZ=16
  OTYDOC_WNEXT=NewArray(OTYDOC_WSIZ)
  OTYDOC_WPREV=NewArray(OTYDOC_WSIZ)
  OTYDOC_ShowLine=NewArray(OTYDOC_WSIZ)
  OTYDOC_CurLine=NewArray(OTYDOC_WSIZ)
  OTYDOC_WSIZE=NewArray(OTYDOC_WSIZ)
  OTYDOC_STYLE=NewArray(OTYDOC_WSIZ)
  OTYDOC_WSIZE2=NewArray(OTYDOC_WSIZ)
  OTYDOC_STYLE2=NewArray(OTYDOC_WSIZ)
  OTYDOC_COL=NewArray(OTYDOC_WSIZ)
  OTYDOC_COL2=NewArray(OTYDOC_WSIZ)
  OTYDOC_CX=NewArray(OTYDOC_WSIZ)
  OTYDOC_WFREE=1
  FOR I=1TO OTYDOC_WSIZ-2
   OTYDOC_WNEXT[I]=I+1
  NEXT
 ENDIF
END
DEF OTYDOC_NewLINE(V$,P)
 VAR R=OTYDOC_FREE
 OTYDOC_FREE=OTYDOC_NEXT[OTYDOC_FREE]
 IF P THEN
  OTYDOC_LINE[R]=OTYDOC_LINE[P]+1
 ELSE
  OTYDOC_LINE[R]=1
 ENDIF
 VAR N
 IF P THEN
  N=OTYDOC_NEXT[P]
  OTYDOC_NEXT[P]=R
 ENDIF
 OTYDOC_VAL$[R]=V$
 OTYDOC_NEXT[R]=N
 OTYDOC_PREV[R]=P
 IF N THEN
  OTYDOC_PREV[N]=R
 ENDIF
 OTYDOC_SIZE[R]=8
 RETURN R
END
DEF OTYDOC_DeleteLine(L)
 IF!L THEN RETURN 0
 VAR N=OTYDOC_NEXT[L]
 VAR P=OTYDOC_PREV[L]
 IF N THEN
  OTYDOC_PREV[N]=P
 ENDIF
 IF P THEN
  OTYDOC_NEXT[P]=N
 ENDIF
 OTYDOC_NEXT[L]=OTYDOC_FREE
 OTYDOC_FREE=L
 IF P THEN RETURN P
 IF N THEN RETURN N
 RETURN 0
END
DEF OTYDOC_NewCTL WND
 VAR R=OTYDOC_WFREE
 OTYDOC_WFREE=OTYDOC_WNEXT[OTYDOC_WFREE]
 OTYDOC_SetData WND,R
END
DEF OTYDOC_DeleteCTL WND
 VAR L=OTYDOC_GetData(WND)
 IF!L THEN RETURN
 OTYDOC_SetData WND,0
 OTYDOC_WNEXT[L]=OTYDOC_WFREE
 OTYDOC_WFREE=L
 RETURN
END
'FONT SIZE と LINE SIZE あわせる(かいぎょうよう)
DEF OTYDOC_AdjustLine L
 VAR V$=OTYDOC_VAL$[L]
 '?"OTYDOC_AdjustLine",L,V$
 VAR I
 VAR HASTEXT
 IF LEN(V$)THEN VAR C=-1'ASC(V$[I])
 VAR YSZ=8
 FOR I=0TO LEN(V$)-1
  IF C==-1 THEN C=ASC(V$[I])CONTINUE
  IF C==&HB10BTHEN
   C=ASC(V$[I])
   IF C==0THEN
    INC I
    VAR YSZ2=ASC(V$[I])
    '?"L,YSZ2,YSZ",L,YSZ2,YSZ
    'ひどいいれこ
    'FONTSIZEしていのあと もじがないか うわがきされてたら むこう
    IF YSZ<YSZ2 THEN
     FOR I=I+1 TO LEN(V$)
      IF I<LEN(V$)THEN C=ASC(V$[I])ELSE
       IF HASTEXT THEN
        '?"EEEEEEEEEE"
        BREAK
       ENDIF
       C=0
      ENDIF
      IF C==&HB10C THEN CONTINUE
      IF C==&HB10BTHEN
       IF ASC(V$[I+1])==0THEN YSZ2=0BREAK
       FOR I=I TO LEN(V$)-1
        IF ASC(V$[I])==&HB10C THEN BREAK
       NEXT
       CONTINUE
      ENDIF
      '?CHR$(C),HEX$(C),YSZ2
      YSZ=MAX(YSZ,YSZ2)
      BREAK
     NEXT
    ENDIF
'    YSZ=MAX(YSZ,ASC(V$[I]))
    CONTINUE
   ELSE
    FOR I=I TO LEN(V$)-1
     IF ASC(V$[I])==&HB10C THEN BREAK
    NEXT
    INC I
    IF I<LEN(V$)THEN C=ASC(V$[I])
    CONTINUE
   ENDIF
  ENDIF
  HASTEXT=MAX(C,1)'TRUE
  C=ASC(V$[I])
 NEXT
 OTYDOC_SIZE[L]=YSZ
 IF!HASTEXT THEN YSZ=MAX(YSZ,YSZ2)
'DIALOG V$
'DIALOG STR$(YSZ)
END
'
DEF OTYDOC_GetData(WND)
 RETURN GetWindowVar(WND,0)
END
DEF OTYDOC_SetData WND,L
 SetWindowVar WND,0,L
END
'====EVENT HANDLER====
COMMON DEF OTYDocCreate WND,CTL,TYPE,A1,A2
 VAR SCR,E
 VAR W=GetWindowWidth(WND),
 NewVScrollBar WND,0 OUT SCR,E
END
COMMON DEF OTYDocResize WND,C,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF OTYDocPainter WND,CTL,TYPE,A1,A2
 OTYDOCRepaint WND
END
DEF OTYDOCRepaint WND
 OTYDOCRepaintSEL WND,FALSE,0,0
END
DEF OTYDOCRepaintSEL WND,SEL_FLG,SX,SY
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,RGB(255,255,255)
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 IF!OTYDOC_GetData(WND)THEN OTYDOC_NewCTL WND
 VAR D=OTYDOC_GetData(WND)
 VAR I=OTYDOC_ShowLine[D]
 VAR CL=OTYDOC_CurLine[D]
 VAR CX=OTYDOC_CX[D]
 VAR Y=2,X=2
 VAR ST=0
 VAR SZ=8
 VAR COL=RGB(0,0,0)
 VAR OJ
 VAR ACX=-100,ACY=-100
 WHILE I
  VAR YSZ=OTYDOC_SIZE[I]
'?"YSZ",YSZ
'?YSZ,SZ,Y
  VAR V$=OTYDOC_VAL$[I]
  VAR LINESTYLE=OTYDOC_LINESTYLE[I]
  VAR A
  VAR L=LEN(V$)-1,J,C
  SZ=8
  X=1
  FOR J=0TO L
   C=ASC(V$[J])
   IF C==&Hb10cTHEN CONTINUE
   IF C==&Hb10bTHEN
   IF I==CL THEN
    IF CX==J THEN
     GFILLWindow WND,X,Y+YSZ-SZ,X+1,Y+YSZ-1,RGB(0,0,0)
     OTYDOC_STYLE[D]=ST
     OTYDOC_COL[D]=RGBToShort(COL)
     OTYDOC_WSIZE[D]=SZ
    ENDIF
   ENDIF
    INC J
    C=ASC(V$[J])
    ON C GOTO@FNT,@COL,@STY
    CONTINUE
    @FNT'0
    INC J
    A=ASC(V$[J])
    SZ=A
'    ?"SZ",SZ
    CONTINUE
    @COL'1
    INC J
    A=ASC(V$[J])
    COL=ShortToRGB(A)
    CONTINUE
    @STY'2
    INC J
    A=ASC(V$[J])
    ST=A
    CONTINUE
   ENDIF
   IF  C<128THEN
    RICHTEXTWindow WND,X-SZ DIV 8,Y+YSZ-SZ,C,ST,SZ,COL
   ELSE
    RICHTEXTWindow WND,X,Y+YSZ-SZ,C,ST,SZ,COL
   ENDIF
   IF I==CL THEN
    IF CX==J THEN
     GFILLWindow WND,X,Y+YSZ-SZ,X+1,Y+YSZ-1,RGB(0,0,0)
     OTYDOC_STYLE[D]=ST
     OTYDOC_COL[D]=RGBToShort(COL)
     OTYDOC_WSIZE[D]=SZ
    ENDIF
   ENDIF
'   ?HEX$(COL)
   IF  C<128THEN INC X,SZ*6/8 ELSE INC X,SZ
   IF SEL_FLG THEN
    
   ENDIF
   IF X+SZ>=W THEN
    X=1
    INC Y,YSZ
    IF Y+YSZ>=H THEN BREAK
   ENDIF
  NEXT
  IF I==CL&&CX>L THEN
   GFILLWindow WND,X,Y+YSZ-SZ,X+1,Y+YSZ-1,RGB(0,0,0)
   OTYDOC_STYLE[D]=ST
   OTYDOC_COL[D]=RGBToShort(COL)
   OTYDOC_WSIZE[D]=SZ
  ENDIF
  IF LINESTYLE==OTYDOC_CENTER THEN
   'CENTER
   VAR CENT=(W-2-X)DIV 2
   GCOPYWindow WND,1,Y,X+1,Y+YSZ,CENT,Y,0
   IF CENT>1 THEN
    GFILLWindow WND,1,Y,CENT-1,Y+YSZ,-1
   ENDIF
  ENDIF
  IF LINESTYLE==OTYDOC_RIGHT THEN
   'RIGHT
   VAR MOVE=(W-2-X)
   GCOPYWindow WND,1,Y,X+1,Y+YSZ,MOVE,Y,0
   IF MOVE>1 THEN
    GFILLWindow WND,1,Y,MOVE-1,Y+YSZ,-1
   ENDIF
  ENDIF
  INC Y,YSZ
  IF Y+YSZ>=H THEN BREAK
  I=OTYDOC_NEXT[I]
 WEND
 GBOXWindow WND,0,0,W,H,RGB(0,0,0)
 VAR E=GEndWindow(WND)
END
COMMON DEF OTYDocChFocus WND,CTL,TYPE,A1,A2
END
DEF OTYDOC_CLK X,Y

END
COMMON DEF OTYDocLMouseUp WND,CTL,TYPE,X,Y
 ?X,Y
END
DEF OTYDOC_UpCursor(WND)
  VAR D=GetWindowVar(WND,0)
  VAR C=OTYDOC_CurLine[D]
  IF OTYDOC_PREV[C]THEN
   OTYDOC_CurLine[D]=OTYDOC_PREV[C]
   OTYDOC_CX[D]=MIN(LEN(OTYDOC_VAL$[OTYDOC_CurLine[D]]),OTYDOC_CX[D])
   RETURN 1
'SCROLL
   VAR L=OTYDOC_PREV[GetWindowVar(WND,1)]
   C=OTYDOC_PREV[C]
   IF L==C THEN
     SetWindowVar WND,1,L
   ENDIF
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
DEF OTYDOC_DownCursor(WND)
  VAR D=GetWindowVar(WND,0)
  VAR C=OTYDOC_CurLine[D]
'SCROLL
  IF OTYDOC_NEXT[C]THEN
   OTYDOC_CurLine[D]=OTYDOC_NEXT[C]
   OTYDOC_CX[D]=MIN(LEN(OTYDOC_VAL$[OTYDOC_CurLine[D]]),OTYDOC_CX[D])
   RETURN 1
   IF GetWindowVar(WND,6)==C THEN
    VAR L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
    IF L THEN
     SetWindowVar WND,1,L
    ENDIF
   ENDIF
   C=TXTBOXEX_NEXT[C]
   SetWindowVar WND,2,C
   RETURN 1
  ENDIF
  RETURN 0
END
DEF OTYDOC_DeleteDup2 C
 VAR V$=OTYDOC_VAL$[C]
 VAR CX
 FOR CX=0TO LEN(V$)-1
 VAR S0=0,S1=0,S2=0,OC=CX
 IF ASC(V$[CX])==&HB10BTHEN
  @LOOP21
  VAR A=ASC(V$[CX])
  FOR CX=CX+1 TO LEN(V$)-1
   IF A==&HB10B THEN
    A=ASC(V$[CX])
    IF A==0THEN INC S0:CONTINUE
    IF A==1THEN INC S1:CONTINUE
    IF A==2THEN INC S2:CONTINUE
   ENDIF
   A=ASC(V$[CX])
   IF A==&HB10CTHEN BREAK
  NEXT
  IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN @LOOP21
  '?S0,S1,S2
  IF S2||S1||S0 THEN
   OTYDOC_DeleteDup V$,OC,CX,S0,S1,S2 OUT CX
  ENDIF
 ENDIF
 NEXT
END
DEF OTYDOC_DeleteDup V$,OC,CX,S0,S1,S2 OUT CX2
 VAR I
 VAR A=ASC(V$[OC])
 FOR I=OC+1 TO CX
  IF LEN(V$)<=I THEN BREAK
  IF A==&HB10B THEN
   A=ASC(V$[I])
   IF A==0THEN
    IF S0>1 THEN DEC S0 ELSE CONTINUE
   ENDIF
   IF A==1THEN
    IF S1>1 THEN DEC S1 ELSE CONTINUE
   ENDIF
   IF A==2THEN
    IF S2>1 THEN DEC S2 ELSE CONTINUE
   ENDIF
   DEC I
   WHILE 1
    A=ASC(V$[I])
    V$[I]=""
    DEC CX
    IF A==&HB10C THEN BREAK
   WEND
  ENDIF
  IF LEN(V$)<=I THEN BREAK
  A=ASC(V$[I])
  'IF A==&HB10C THEN BREAK
 NEXT
 CX2=CX
END
COMMON DEF OTYDOCButton WND,CTL,T,BTN,_
 VAR F=GetWindowVar(WND,4),U,R=GetWindowVar(WND,5)
 IF!BTN THEN SetWindowVar WND,5,0RETURN
 IF MAINCNT-F<R THEN RETURN
 IF BTN AND 1 THEN
  IF OTYDOC_UpCursor(WND)THEN
   OTYDOCRepaint WND
  ENDIF
  U=1
 ENDIF
 IF BTN AND 2 THEN
  IF OTYDOC_DownCursor(WND)THEN
   OTYDOCRepaint WND
  ENDIF
  U=1
 ENDIF
 VAR D=GetWindowVar(WND,0)
 IF BTN AND 4THEN
  VAR CX=OTYDOC_CX[D]
  VAR C=OTYDOC_CurLine[D]
  VAR S$=OTYDOC_VAL$[C]
  IF CX<LEN(S$)&&ASC(S$[CX])==&HB10CTHEN
   @LOOP11
   FOR CX=CX TO 0 STEP -1
    IF ASC(S$[CX])==&HB10BTHEN DEC CX:BREAK
   NEXT
   IF CX<0THEN CX=0
   IF ASC(S$[CX])==&HB10CTHEN @LOOP11
   OTYDOC_CX[D]=CX
  ENDIF
  IF CX THEN
   DEC OTYDOC_CX[D]
   DEC CX
   IF CX<LEN(S$)&&ASC(S$[CX])==&HB10CTHEN
   BEEP 
    @LOOP1
    FOR CX=CX TO 0 STEP -1
     IF ASC(S$[CX])==&HB10BTHEN DEC CX:BREAK
    NEXT
    VAR CXMF
    IF CX<0THEN CX=0:CXMF=TRUE
    IF ASC(S$[CX])==&HB10CTHEN @LOOP1
    OTYDOC_CX[D]=CX
    IF CXMF THEN @___
   ENDIF
   OTYDOCRepaint WND
  ELSE
   @___
   IF OTYDOC_UpCursor(WND)THEN
    C=OTYDOC_CurLine[D]
    OTYDOC_CX[D]=LEN(OTYDOC_VAL$[C])
    OTYDOCRepaint WND
   ELSE
    OTYDOCRepaint WND
   ENDIF
  ENDIF
  U=1
 ENDIF
 IF BTN AND 8THEN
  CX=OTYDOC_CX[D]
  C=OTYDOC_CurLine[D]
  VAR V$=OTYDOC_VAL$[C]
  VAR S0,S1,S2,OC=CX
  IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN
   @LOOP21
   VAR A=ASC(V$[CX])
   FOR CX=CX+1 TO LEN(V$)-1
    IF A==&HB10B THEN
     A=ASC(V$[CX])
     IF A==0THEN INC S0:CONTINUE
     IF A==1THEN INC S1:CONTINUE
     IF A==2THEN INC S2:CONTINUE
    ENDIF
    A=ASC(V$[CX])
    IF A==&HB10CTHEN INC CX:BREAK
   NEXT
   IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN @LOOP21
   IF S2||S1||S0 THEN
    '?S0,S1,S2,OC;"-";CX
    OTYDOC_DeleteDup V$,OC,CX,S0,S1,S2 OUT CX
   ENDIF
   OTYDOC_CX[D]=CX
  ENDIF
  INC OTYDOC_CX[D]
  INC CX'TODO:BUG?  IF LEN(V$)<=CX||LEN(V$)-1==CX&&V$[CX]==LF$()THEN

  IF LEN(V$)<=CX THEN'IF LEN(V$)<=CX||LEN(V$)==CX&&V$[CX]==LF$()THEN
   IF LEN(V$)<CX THEN 
   IF OTYDOC_DownCursor(WND)THEN
    OTYDOC_CX[D]=0
   ELSE
    DEC OTYDOC_CX[D]
   ENDIF
   ENDIF
  ELSE
   IF ASC(V$[CX])==&HB10B0THEN
    @LOOP2
    FOR CX=CX TO LEN(V$)-1
     IF ASC(V$[CX])==&HB10CTHEN INC CX:BREAK
    NEXT
    IF CX<LEN(V$)&&ASC(V$[CX])==&HB10BTHEN @LOOP2
    OTYDOC_CX[D]=CX
   ENDIF
  ENDIF
  OTYDOCRepaint WND
  U=1
 ENDIF
 CX=LEN(OTYDOC_VAL$[OTYDOC_CurLine[D]])-1
 VAR I,LLL
 FOR I=0TO CX
  IF I==OTYDOC_CX[D]THEN LLL=CSRX
  S$=OTYDOC_VAL$[OTYDOC_CurLine[D]]
  IF ASC(S$[I])==&HB10BTHEN
   COLOR 2
   ?OTYDOC_VAL$[OTYDOC_CurLine[D]][I];'C]
   INC I
   IF I==OTYDOC_CX[D]THEN LLL=CSRX
   IF ASC(S$[I])==0THEN ?"<SIZE>";
   IF ASC(S$[I])==1THEN ?"<COLOR>";
   IF ASC(S$[I])==2THEN ?"<STYLE>";
   INC I
   IF I==OTYDOC_CX[D]THEN LLL=CSRX
   ?ASC(S$[I]);
   CONTINUE
  ELSEIF ASC(S$[I])==&HB10CTHEN
   COLOR 3
  ELSE COLOR 15 ENDIF
  ?OTYDOC_VAL$[OTYDOC_CurLine[D]][I];'C]
 NEXT
  IF I==OTYDOC_CX[D]THEN LLL=CSRX
 ?
 COLOR 15
 ?" "*(LLL);""
 IF U THEN
  IF R==0 THEN
   SetWindowVar WND,5,20
  ELSE
   SetWindowVar WND,5,3
  ENDIF
  SetWindowVar WND,4,MAINCNT
 ENDIF
END

COMMON DEF OTYDOC_TextCheck(V$,I)
 FOR I=I TO LEN(V$)-1
  VAR A=ASC(V$[I])
  IF A==&HB10B THEN
   FOR I=I TO LEN(V$)-1
    IF ASC(V$[I])==&HB10CTHEN
     BREAK
    ENDIF
   NEXT
   CONTINUE
  ENDIF
  RETURN TRUE
 NEXT
 RETURN FALSE
END
COMMON DEF OTYDocKey WND,CTL,TYPE,KEY,A2
 VAR D=OTYDOC_GetData(WND)
 VAR S=OTYDOC_ShowLine[D]
 VAR C=OTYDOC_CurLine[D]
 VAR X=OTYDOC_CX[D]
 IF!OTYDOC_COL2[D]THEN
  OTYDOC_COL2[D]=RGBToShort(RGB(0,0,0))
 ENDIF
 IF!OTYDOC_COL[D]THEN
  OTYDOC_COL[D]=RGBToShort(RGB(0,0,0))
 ENDIF
 IF!OTYDOC_WSIZE[D]THEN
  OTYDOC_WSIZE[D]=8
 ENDIF
 IF!OTYDOC_WSIZE2[D]THEN
  OTYDOC_WSIZE2[D]=8
 ENDIF
 IF!S THEN
  S=OTYDOC_NewLine("",0)
  OTYDOC_ShowLine[D]=S
  OTYDOC_CurLine[D]=S
  C=S
 ENDIF
  VAR I$=CHR$(KEY)
 IF I$==BS$()THEN
  IF X THEN
   DEC OTYDOC_CX[D]
   DEC X
   VAR S$=OTYDOC_VAL$[C]
   WHILE 1
    IF ASC(S$[X])==&Hb10cTHEN
     FOR X=X TO 0 STEP -1
      IF ASC(S$[X])==&Hb10bTHEN DEC X:BREAK
     NEXT
     IF X<0THEN X=0OTYDOC_CX[D]=X:OTYDOCRepaint WND:RETURN
     OTYDOC_CX[D]=X
     CONTINUE
    ENDIF
    BREAK
   WEND
   IF ASC(S$[X])==&Hb10bTHEN
    DEC X
    DEC OTYDOC_CX[D]
    IF X<0THEN X=0OTYDOC_CX[D]=X:OTYDOCRepaint WND:RETURN

   ENDIF
   RemoveStrB OTYDOC_VAL$[C],X,1
   
   OTYDOC_AdjustLine C
  ELSE
   IF OTYDOC_PREV[C]THEN
    S$=OTYDOC_VAL$[C]
    C=OTYDOC_DeleteLine(C)
    OTYDOC_CurLine[D]=C
    'SCROLL
    OTYDOC_CX[D]=LEN(OTYDOC_VAL$[C])
    OTYDOC_VAL$[C]=OTYDOC_VAL$[C]+S$
   ENDIF
  ENDIF
 ELSE
  IF I$==CR$()THEN
   VAR C2=OTYDOC_NewLine(CHR$(&HB10B)+CHR$(2)+CHR$(OTYDOC_STYLE[D])+CHR$(&HB10C)+CHR$(&HB10B)+CHR$(1)+CHR$(OTYDOC_COL[D])+CHR$(&HB10C)+CHR$(&HB10B)+CHR$(0)+CHR$(OTYDOC_WSIZE[D])+CHR$(&HB10C)+MID$(OTYDOC_VAL$[C],X,LEN(OTYDOC_VAL$[C])-X),C)
   IF!C2 THEN RETURN
   OTYDOC_VAL$[C]=MID$(OTYDOC_VAL$[C],0,X)
'  OTYDOC_DeleteDup2 C
'  OTYDOC_DeleteDup2 C2
   OTYDOC_AdjustLine C
   OTYDOC_SIZE[C2]=OTYDOC_WSIZE[C]
   OTYDOC_AdjustLine C2
   OTYDOC_CurLine[D]=C2
   OTYDOC_CX[D]=LEN(OTYDOC_VAL$[C2])
   IF FALSE THEN 
   SetWindowVar WND,2,C2
   SetWindowVar WND,3,0
'  OTYDOC_VAL$[C]=MID$(TXTBOXEX_VAL$[C],0,X)+K$
   IF GetWindowVar(WND,6)==C THEN
'   L=TXTBOXEX_NEXT[GetWindowVar(WND,1)]
'   IF L THEN
'    SetWindowVar WND,1,L
'   ENDIF
   ENDIF
   ENDIF
  ELSE
  IF OTYDOC_STYLE[D]!=OTYDOC_STYLE2[D]THEN
   VAR TF=OTYDOC_TextCheck(OTYDOC_VAL$[C],X)
   I$=CHR$(&HB10B)+CHR$(2)+CHR$(OTYDOC_STYLE2[D])+CHR$(&HB10C)+I$
   IF TF THEN PUSH I$,CHR$(&HB10B)+CHR$(2)+CHR$(OTYDOC_STYLE[D])+CHR$(&HB10C)
   OTYDOC_STYLE[D]=OTYDOC_STYLE2[D]
   INC OTYDOC_CX[D],4
  ENDIF
  IF OTYDOC_COL[D]!=OTYDOC_COL2[D]THEN
   TF=OTYDOC_TextCheck(OTYDOC_VAL$[C],X)
   I$=CHR$(&HB10B)+CHR$(1)+CHR$(OTYDOC_COL2[D])+CHR$(&HB10C)+I$
   IF TF THEN PUSH I$,CHR$(&HB10B)+CHR$(1)+CHR$(OTYDOC_COL[D])+CHR$(&HB10C)
   OTYDOC_COL[D]=OTYDOC_COL2[D]
   INC OTYDOC_CX[D],4
  ENDIF
  
  IF OTYDOC_WSIZE[D]!=OTYDOC_WSIZE2[D]THEN
   TF=OTYDOC_TextCheck(OTYDOC_VAL$[C],X)
   I$=CHR$(&HB10B)+CHR$(0)+CHR$(OTYDOC_WSIZE2[D])+CHR$(&HB10C)+I$
   IF TF THEN PUSH I$,CHR$(&HB10B)+CHR$(0)+CHR$(OTYDOC_WSIZE[D])+CHR$(&HB10C)
   '?STR$(OTYDOC_WSIZE2[D])
   OTYDOC_WSIZE[D]=OTYDOC_WSIZE2[D]
   INC OTYDOC_CX[D],4
   IF OTYDOC_SIZE[C]<OTYDOC_WSIZE[D]THEN OTYDOC_SIZE[C]=OTYDOC_WSIZE[D]
  ENDIF
  INC OTYDOC_CX[D]
  IF!LEN(OTYDOC_VAL$[C])THEN
   OTYDOC_VAL$[C]=I$
  ELSE
   InsertStrB OTYDOC_VAL$[C],X,I$
  ENDIF
   OTYDOC_AdjustLine C
  ENDIF
 ENDIF
 OTYDOCRepaint WND
 ?OTYDOC_VAL$[C]
 ?" "*MAX(OTYDOC_CX[D],0);""
END
'====EVENT HANDLER====

'RichTextEditor API
COMMON DEF RTESetBold WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR 1
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT 1
 ENDIF
END
COMMON DEF RTESetItalic WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR RichTextItalic()
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT RichTextItalic()
 ENDIF
END
COMMON DEF RTESetStrike WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR RichTextStrike()
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT RichTextStrike()
 ENDIF
END
COMMON DEF RTESetUnderline WND,F
 VAR D=OTYDOC_GetData(WND)
 IF F THEN
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] OR RichTextUnderline()
 ELSE
  OTYDOC_STYLE2[D]=OTYDOC_STYLE2[D] AND NOT RichTextUnderline()
 ENDIF
END
COMMON DEF RTESetTextColor WND,COL
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_COL2[D]=RGBToShort(COL)
END
COMMON DEF RTESetAlignLeft WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_LINESTYLE[OTYDOC_CURLINE[D]]=OTYDOC_LEFT
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetAlignCenter WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_LINESTYLE[OTYDOC_CURLINE[D]]=OTYDOC_CENTER
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetAlignRight WND
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_LINESTYLE[OTYDOC_CURLINE[D]]=OTYDOC_RIGHT
 VOID RepaintWindow(WND)
END
COMMON DEF RTESetFontSize WND,SIZE
 VAR D=OTYDOC_GetData(WND)
 OTYDOC_WSIZE2[D]=SIZE
END
'==================
VAR OTYDOCCOLOR_CTL
COMMON DEF OTYDOC_WNDNOTIF WND,CTL,TYPE,CW,F
 VAR N$=GetWindowName$(CW)
 IF N$=="B"THEN
  RTESetBold GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$=="I"THEN
  RTESetItalic GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$=="S"THEN
  RTESetStrike GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$=="U"THEN
  RTESetUnderline GetWindowVar(WND,0),F
  RETURN
 ENDIF
 IF N$==""THEN
  VAR X=GetWindowX(WND)+GetWindowX(CW),Y=GetWindowY(WND)+GetWindowY(CW)
  OTYDOC_ShowMenu OTYDOCCOLOR_CTL,WND,X,Y,X+GetWindowWidth(CW),Y+GetWindowHeight(CW)
 ENDIF
 IF N$=="OTYDOCCOLOR"THEN
  RTESetTextColor GetWindowVar(WND,0),F
  VOID DeleteWindow(CW)
 ENDIF
 IF N$==""THEN
  VAR BTNL,BTNC,BTNR
  BTNL=GetWindowVar(WND,1)
  BTNC=GetWindowVar(WND,2)
  BTNR=GetWindowVar(WND,3)
  IF CW==BTNL THEN
   CheckButton BTNL
   UnCheckButton BTNR
   UnCheckButton BTNC
   RTESetAlignLeft GetWindowVar(WND,0)
  ENDIF
  IF CW==BTNC THEN
   CheckButton BTNC
   UnCheckButton BTNR
   UnCheckButton BTNL
   RTESetAlignCenter GetWindowVar(WND,0)
  ENDIF
  IF CW==BTNR THEN
   CheckButton BTNR
   UnCheckButton BTNL
   UnCheckButton BTNC
   RTESetAlignRight GetWindowVar(WND,0)
  ENDIF
'  UnCheckButtonsGroup CW
 ENDIF
 IF GetControl(CW)==GetNumUpDownControl()THEN
  RTESetFontSize GetWindowVar(WND,0),GetNumUpDownValue(CW)
 ENDIF
END
COMMON DEF OTYDOC_WNDRESIZE WND,CTL,TYPE,A1,A2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VOID ResizeWindow(GetWindowVar(WND,0),W,H-12)
END
'2PX
'
'
'
'
COMMON DEF OTYDOC_COLORCREATE WND,CTL,TYP,A1,A2
 VAR E
 NewWindow GetButtonControl(),">>>",1,GetWindowHeight(WND)-10,27,10,WND,0 OUT E,E
 SetWindowVar WND,0,-1
END
COMMON DEF OTYDOC_COLORPAINT WND,CTL,TYP,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,RGB(200,200,200)
 GBOXWindow WND,0,0,GetWindowWidth(WND),GetWindowHeight(WND),RGB(0,0,0)
 VAR X,Y,C
 VAR SEL=GetWindowVar(WND,0)
 FOR Y=0TO 3
  FOR X=0TO 3
   VAR RGB
   IF!C THEN
    RGB=RGB(0,0,0)
    GBOXWindow WND,X*8+2*X+2,Y*8+2*Y+2,X*8+7+2*X+2,Y*8+7+2*Y+2,RGB
   ELSE
    RGB=GetConsolePalette(C)
    GFILLWindow WND,X*8+2*X+2,Y*8+2*Y+2,X*8+7+2*X+2,Y*8+7+2*Y+2,RGB
   ENDIF
   IF SEL==C THEN
    GBOXWindow WND,X*8+2*X+1,Y*8+2*Y+1,X*8+7+2*X+3,Y*8+7+2*Y+3,RGB(255,160,16)
   ENDIF
   INC C
  NEXT
 NEXT
 E=GEndWindow(WND)
END
COMMON DEF OTYDOC_ColorNotif WND,CTL,TYP,FLG,FW
 'そのうち まともに
 VOID ActiveWindow(WND)
END
COMMON DEF OTYDOC_ColorChFocus WND,CTL,TYP,FLG,FW
 IF!FLG THEN
  IF GetParentWindow(FW)==WND THEN RETURN
  VAR OWN=GetWindowGroupOwner(WND)
  IF GetWindowVar(WND,0)!=-1THEN
   VOID SendNotifWindow(OWN,WND,GetConsolePalette(GetWindowVar(WND,0)))
   RETURN
  ENDIF
  VOID DeleteWindow(WND)
 ENDIF
END
COMMON DEF OTYDOC_ColorMouseUp WND,CTL,TYP,X,Y
 VAR E=CallBaseControlHandler(WND,CTL,TYP,X,Y)
' IF X MOD 10<2THEN RETURN
' IF Y MOD 10<2THEN RETURN
 VAR COL=(X DIV 10)+(Y DIV 10)*4
 IF COL>15THEN RETURN
 SetWindowVar WND,0,COL
 OTYDOC_COLORPAINT WND,CTL,TYP,0,0
END
COMMON DEF OTYDOC_ShowMenu CTL,WND,X,Y,X2,Y2
 VAR E,MENUWND
 IF CTL==OTYDOCCOLOR_CTL THEN
  NewWindow OTYDOCCOLOR_CTL,"OTYDOCCOLOR",X,Y2,4*8+2*4+1,4*8+2*4+2+8+1,GetRootWND(),WindowFrontFlag()OUT MENUWND,E
  IF E THEN RETURN
 ENDIF
 E=JoinWindowGroup(WND,MENUWND)
 
END
COMMON DEF OTYDOC_LCRPAINT WND,CTL,TYP,_,__
 IF CallBaseControlHandler(WND,CTL,TYP,_,__)THEN RETURN
 VAR T=GetWindowVar(WND,7)
 REPEAT
  ON T GOTO @LEFT,@CENTER,@RIGHT
  @LEFT
   GLINEWindow WND,1,1,8,1,RGB(0,0,0)
   GLINEWindow WND,1,3,6,3,RGB(0,0,0)
   GLINEWindow WND,1,5,8,5,RGB(0,0,0)
   GLINEWindow WND,1,7,6,7,RGB(0,0,0)
  BREAK
  @CENTER
   GLINEWindow WND,1,1,8,1,RGB(0,0,0)
   GLINEWindow WND,2,3,7,3,RGB(0,0,0)
   GLINEWindow WND,1,5,8,5,RGB(0,0,0)
   GLINEWindow WND,2,7,7,7,RGB(0,0,0)
  BREAK
  @RIGHT
   GLINEWindow WND,1,1,8,1,RGB(0,0,0)
   GLINEWindow WND,3,3,8,3,RGB(0,0,0)
   GLINEWindow WND,1,5,8,5,RGB(0,0,0)
   GLINEWindow WND,3,7,8,7,RGB(0,0,0)
  BREAK
 UNTIL FALSE
 VAR E=GEndWindow(WND)
END
COMMON DEF OTYDOC_LCRMouseDown WND,CTL,TYP,_,__
 IF IsCheckedButton(WND)THEN RETURN
 IF CallBaseControlHandler(WND,CTL,TYP,_,__)THEN RETURN
END
VAR OTYDOCLCRBTN_CTL
COMMON DEF I_OTYDOC
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTYDOC_WNDCTL THEN
  INIT_OTYDOC
  ExtendControl "OTYDOC",GetWindowControl() OUT OTYDOC_WNDCTL,E
'  ExtendControl "OTYDOCCOLOR",GetWindowControl() OUT OTYDOCCOLOR_CTL,E
  NewControl "OTYDOCCOLOR" OUT OTYDOCCOLOR_CTL,E
  E=SetControlNotifHandler(OTYDOC_WNDCTL,"OTYDOC_WNDNOTIF")
  E=SetControlPainter(OTYDOCCOLOR_CTL,"OTYDOC_COLORPAINT")
  E=SetControlCreateHandler(OTYDOCCOLOR_CTL,"OTYDOC_COLORCREATE")
  E=SetControlChFocusHandler(OTYDOCCOLOR_CTL,"OTYDOC_ColorChFocus")
  E=SetControlNotifHandler(OTYDOCCOLOR_CTL,"OTYDOC_ColorNotif")
  E=SetControlLMouseDownHandler(OTYDOCCOLOR_CTL,"OTYDOC_ColorMouseUp")
  E=SetControlResizeHandler(OTYDOC_WNDCTL,"OTYDOC_WNDRESIZE")
  ExtendControl "OTYDOCLCRBUTTON",GetToggleButtonControl() OUT OTYDOCLCRBTN_CTL,E
  E=SetControlPainter(OTYDOCLCRBTN_CTL,"OTYDOC_LCRPAINT")
  E=SetControlLMouseDownHandler(OTYDOCLCRBTN_CTL,"OTYDOC_LCRMouseDown")
 ENDIF
 NewTopLevelStyleWindow OTYDOC_WNDCTL,"OTYDOC",256,128,WindowMenuStyle() OR WindowResizableStyle() OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"New",1
 AddMenuItem MENU,"Open",2
 AddMenuItem MENU,"Save",3
 AddMenuItem MENU,"Save as",4
 AddSubMenuItem GetWindowMenu(WND),"File",MENU SetProcessVar WND
 VAR DOC,COL
 NewWindow OTYDOCCTL,"OTYDOC",0,12,256,116,WND,0 OUT DOC,E
 SetWindowVar WND,0,DOC
 NewWindow GetToggleButtonControl(),"B",0,0,11,11,WND,0 OUT E,E
 NewWindow GetToggleButtonControl(),"I",12*1,0,11,11,WND,0 OUT E,E
 NewWindow GetToggleButtonControl(),"S",12*2,0,11,11,WND,0 OUT E,E
 NewWindow GetToggleButtonControl(),"U",12*3,0,11,11,WND,0 OUT E,E
 NewWindow GetButtonControl(),"color",12*4,0,11+32,11,WND,0 OUT E,E
 NewWindow GetButtonControl(),"",12*5+32,0,11,11,WND,0 OUT E,E
 VAR NUM
 VAR X=12*6+32
 NewWindow GetLabelControl(),"size",X,2,31,7,WND,0 OUT E,E
 INC X,32
 NewWindow GetNumUpDownControl(),"0",X,0,11+8*3,11,WND,0 OUT NUM,E
 SetNumUpDownRange NUM,8,96
 INC X,11+8*3+1
 VAR BTNL,BTNC,BTNR
 NewWindow OTYDOCLCRBTN_CTL,"",X,0,11,11,WND,WindowOwnerDrawFlag() OUT BTNL,E
 INC X,12
 NewWindow OTYDOCLCRBTN_CTL,"",X,0,11,11,WND,WindowOwnerDrawFlag() OUT BTNC,E
 INC X,12
 NewWindow OTYDOCLCRBTN_CTL,"",X,0,11,11,WND,WindowOwnerDrawFlag() OUT BTNR,E
 INC X,12
 VAR DRP
 NewWindow GetDropDownListControl(),"",X,0,56,11,WND,0 OUT DRP,E
 VAR LST=GetDropDownListBox(DRP)
 AddListBoxItem LST,"H1"
 AddListBoxItem LST,"H2"
 AddListBoxItem LST,"H3"
 AddListBoxItem LST,"H4"
 AddListBoxItem LST," xxx"
 AddListBoxItem LST,"1. xxx"
 AddListBoxItem LST,"'quote'"
 INC X,56
 SetWindowVar WND,1,BTNL
 SetWindowVar WND,2,BTNC
 SetWindowVar WND,3,BTNR
 SetWindowVar BTNL,7,0
 SetWindowVar BTNC,7,1
 SetWindowVar BTNR,7,2
 'TODO:GROUPのかくちょう
'E=JoinWindowGroup(BTNL,BTNC)
'E=JoinWindowGroup(BTNL,BTNR)
'E=JoinWindowGroup(BTNC,BTNL)
'E=JoinWindowGroup(BTNC,BTNR)
'E=JoinWindowGroup(BTNR,BTNL)
'E=JoinWindowGroup(BTNR,BTNC)
 VOID ActiveWindow(WND)
END
COMMON DEF L_OTYDOC
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
'===OTYA DOCUMENT EDITOR===
VAR OTYFIL_MOPEN
VAR OTYFIL_MCOPY
VAR OTYFIL_MCUT
VAR OTYFIL_MDEL
VAR OTYFIL_MREN
VAR OTYFIL_MABOUT
VAR OTYFIL_MPASTE
DIM OTYFILICOTXT[0]
DIM OTYFILICODAT[0]
DIM OTYFILICON[0]
COMMON DEF RC_OTYFIL
 DIM ICONS[512]
 LOAD"DAT:OTYFILRC",ICONS,0
 OTYFILICOTXT=NewArray(16*16)
 OTYFILICODAT=NewArray(16*16)
 OTYFILICON=NewArray(16*16)
 COPY OTYFILICOTXT,ICONS,0,16*16
 COPY OTYFILICODAT,ICONS,16*16,16*16
 COPY OTYFILICON,ICONS,16*16*2,16*16
END
VAR OTYFILCTL
VAR OTYFILICONCTL
VAR OTYFILABOUTCTL
VAR OTYFILRENCTL
COMMON DEF OTYFILICONCTLPainter W,C,T,_,__
 IF GBeginWindow(W)THEN RETURN
 VAR SEL=GetWindowVar(W,3)
 IF SEL THEN
  GCLSWindow W,RGB(0,0,255)
 ELSE
  GCLSWindow W,WIN_BKGND
 ENDIF
 VAR TYP=GetWindowVar(W,1)
 IF TYP THEN
  IF TYP==2THEN
   GLOADWindow W,0,0,16,16,OTYFILICON,1,0
   RETURN
  ENDIF
  GLOADWindow W,0,0,16,16,OTYFILICODAT,1,0
 ELSE
  GLOADWindow W,0,0,16,16,OTYFILICOTXT,1,0
 ENDIF
 IF GEndWindow(W)THEN RETURN
END
COMMON DEF OTYFILABOUTNOTIF WND,CTL,T,_,__
 VOID DeleteWindow(WND)
END
COMMON DEF OTYFILABOUTCREATE WND,CTL,T,_,__
 VAR W,E
 NewWindow OTYFILICONCTL,"",0,0,15,15,WND,0 OUT W,E
 SetWindowVar W,1,2
 VAR WI=GetWindowWidth(WND)
 VAR S$="OTW Filer"
 NewWindow GetLabelControl(),S$,(WI-LEN(S$)*8)/2,0,LEN(S$)*8,7,WND,0 OUT W,E
 S$="Ver 5.0"
 NewWindow GetLabelControl(),S$,(WI-LEN(S$)*8)/2,8,LEN(S$)*8,7,WND,0 OUT W,E
 S$="© 2011-2015 otya"
 NewWindow GetLabelControl(),S$,(WI-LEN(S$)*8)/2,16,LEN(S$)*8,7,WND,0 OUT W,E
 S$="OK"
 NewWindow GetButtonControl(),S$,(WI-LEN(S$)*8)/2+2,24,LEN(S$)*8+2,12,WND,0 OUT W,E
END
DEF OTYFIL_GETSELECTEDFILE$ WND OUT F$
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR SELECT=GetWindowVar(WND,4)
 F$=""
 IF SELECT<0||KL<SELECT THEN RETURN
 F$=GetString$(ASC(ARY$[SELECT])OR ASC(ARY$[SELECT+1])<<16)
END
DEF OTYFIL_OPEN WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 VAR TYP$
 IF F$[0]==" "THEN
  TYP$="DAT"
 ENDIF
 IF F$[0]=="*"THEN
  TYP$="TXT"
 ENDIF
 F$=MID$(F$,1,99999)
 VAR EXT$=GetFileExtension$(F$)
 VAR PRG$=GetAssociatedProgram$(TYP$,EXT$)
 VAR PRC,E
 NewProcess PRG$,F$ OUT PRC,E
END
DEF OTYFIL_COPY WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 ClearClipboard
 ClipboardSetFile FALSE,F$
END
DEF OTYFIL_CUT WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 ClearClipboard
 ClipboardSetFile TRUE,F$
END
'
'From[HOGEHOGE.TXT]
'To  [FUGAFUGA.TXT]
'       [OK]
COMMON DEF OTYFILRENCREATE WND,CTL,T,A1,A2
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 VAR FROM=LEN("FROM")*8+8
 VAR E,W2,FROMW,TOW
 VAR FROM$=GetWindowName$(WND)
 NewWindow GetLabelControl(),"From",1,1,32,7,WND,0 OUT W2,E
 NewWindow GetLabelControl(),"To",1,11,16,7,WND,0 OUT W2,E
 NewWindow GetTextBoxControl(),FROM$,FROM,0,W-FROM,9,WND,0 OUT FROMW,E
 NewWindow GetTextBoxControl(),"",FROM,11,W-FROM,9,WND,0 OUT TOW,E
 VAR BW=24
 NewWindow GetButtonControl(),"OK",(W-BW) DIV 2,22,BW,10,WND,0 OUT W2,E
 SetWindowName WND,"Rename"
 SetWindowVar WND,0,FROMW
 SetWindowVar WND,1,TOW
 IF FROM$[0]==" "THEN
  SetWindowVar WND,2,1
 ENDIF
END
COMMON DEF OTYFILRENNOTIF WND,CTL,T,A1,A2
 VAR FROMW,TOW
 GetWindowVar WND,0OUT FROMW
 GetWindowVar WND,1OUT TOW
 VAR FROM$=GetWindowName$(FROMW)
 VAR TO$=GetWindowName$(TOW)
 RenameFile FROM$,TO$
 VOID DeleteWindow(WND)
END
DEF OTYFIL_DEL WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 DeleteFile F$
END
DEF OTYFIL_PASTE WND
 IF!ClipboardContainsFile()THEN
  RETURN
 ENDIF
 VAR CUT,F$
 ClipboardGetFile OUT CUT,F$
 ?"PASTE:",F$
END
DEF OTYFIL_REN WND
 VAR F$=OTYFIL_GETSELECTEDFILE$(WND)
 IF F$==""THEN RETURN
 VAR E=NewModalDialogBox(OTYFILRENCTL,F$,40+15*8+4,32,WND)
END
COMMON DEF OTYFILLDBL WND,CTL,T,X,Y
 OTYFILLMouse WND,CTL,T,X,Y
 OTYFIL_OPEN WND
END
VAR OTYFIL_CONTEXTMENU
COMMON DEF OTYFILRMouse WND,CTL,T,X,Y
 ShowContextMenu OTYFIL_CONTEXTMENU,WND
END
COMMON DEF OTYFILLMouse WND,CTL,T,X,Y
 VAR S=GetChildWindow(WND)
 VAR POS=GetScrollBarPosition(S)*2
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 VAR R=WIDTH DIV 42
 VAR BY1=(POS MOD 40)+7
 VAR BY2=(POS MOD 40)-9
 VAR K=(POS DIV 40)*R
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR W=42
 VAR H=40
 K=K+((Y+(POS MOD 40)) DIV H)*R
 K=K+X DIV W
 K=K*2
 IF GetWindowVar(WND,4)!=K THEN
  SetWindowVar WND,4,K
  OTYFILPAINT WND,CTL,T,0,0
 ENDIF
END
COMMON DEF OTYFILDEL WND,CTL,T,A1,A2
 FreeString GetWindowVar(WND,2)
 StrArrayFree GetWindowVar(WND,3)
END
DEF OTYFILGETSCRBARLEN(WND)
 VAR CW=GetChildWindow(WND)
 VAR W=GetWindowWidth(WND)
 VAR OL=W DIV 42
 VAR LEN=LEN(GetString$(GetWindowVar(WND,3)))
 VAR AW=(LEN DIV OL)*10
 RETURN AW
END
COMMON DEF OTYFILRESIZ WND,CTL,T,A1,WH
 VAR W,H
 SplitInt WH OUT W,H
 IF W<0||H<0THEN RETURN
 VAR CW=GetChildWindow(WND)
 SetScrollBarSize CW,OTYFILGETSCRBARLEN(WND)
 VOID MoveResizeWindow(CW,W-GetWindowWidth(CW),0,GetWindowWidth(CW),H)
END
COMMON DEF OTYFILPAINT WND,CTL,T,A1,A2
 IF CallBaseControlHandler(WND,CTL,T,A1,A2)THEN RETURN
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,GetBackColor()
 VAR S=GetChildWindow(WND)
 VAR POS=GetScrollBarPosition(S)*2
 VAR WIDTH=GetWindowWidth(WND)
 VAR HEIGHT=GetWindowHeight(WND)
 VAR R=WIDTH DIV 42
 VAR BY1=(POS MOD 40)+7
 VAR BY2=(POS MOD 40)-9
 VAR X=0,Y=7
 VAR K=((POS DIV 40)*R)*2
 VAR ARY$=GetString$(GetWindowVar(WND,3))
 VAR KL=LEN(ARY$)
 VAR W=42
 VAR H=40
 VAR SELECT=GetWindowVar(WND,4)
 VAR IX=(40-16) DIV 2
 VAR C=RGB(0,0,0)
 WHILE K<KL
  VAR F$=GetString$(ASC(ARY$[K])OR ASC(ARY$[K+1])<<16)
  IF F$[0]==" "THEN
   GLOADWindow WND,X+IX,Y-BY1,16,16,OTYFILICODAT,1,0
  ELSE
   GLOADWindow WND,X+IX,Y-BY1,16,16,OTYFILICOTXT,1,0
  ENDIF
  IF SELECT==K THEN
   GFILLWindow WND,X,Y-BY2,X+39,Y-BY2+23,RGB(0,0,255)
   C=-1
  ENDIF
  VAR L=LEN(F$)-1
  IF L<=5 THEN 
  GPRINTWindow WND,X+(5-L)*4,Y-BY2,MID$(F$,1,5),C
  ELSEIF L>10THEN
   GPRINTWindow WND,X,Y-BY2+8,MID$(F$,6,5),C
   GPRINTWindow WND,X+((5-(L-10))*4),Y-BY2+16,MID$(F$,11,4),C
   GPRINTWindow WND,X,Y-BY2,MID$(F$,1,5),C
  ELSEIF L>5THEN
   GPRINTWindow WND,X+((5-(L-5))*4),Y-BY2+8,MID$(F$,6,5),C
   GPRINTWindow WND,X,Y-BY2,MID$(F$,1,5),C
  ENDIF
  X=X+W
  IF X+W>=WIDTH THEN
   X=0
   IF Y>=HEIGHT THEN BREAK
   Y=Y+H
  ENDIF
  IF SELECT==K THEN
   C=RGB(0,0,0)
  ENDIF
  K=K+2
 WEND
 IF GENDWindow(WND)THEN RETURN
END
COMMON DEF OTYFILNOTIF WND,CTL,T,ID,POS
 IF!ID THEN
  IF POS==OTYFIL_MOPEN THEN
   OTYFIL_OPEN WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MCOPY THEN
   OTYFIL_COPY WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MCUT THEN
   OTYFIL_CUT WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MDEL THEN
   OTYFIL_DEL WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MREN THEN
   OTYFIL_REN WND
   RETURN
  ENDIF
  IF POS==OTYFIL_MPASTE THEN
   OTYFIL_PASTE WND
   RETURN
  ENDIF
  VAR E=NewModalDialogBox(OTYFILABOUTCTL,"ABOUT",128,40,WND)
  RETURN
 ENDIF
 OTYFILPAINT WND,CTL,T,0,0
 RETURN
END
DEF StrArrayGetFiles PTR,DIR$
 DIM FILES$[0]
 GetFiles FILES$,""
 VAR S$=CHR$(0)*(2*LEN(FILES$))
 VAR I,L=LEN(FILES$)-1
 FOR I=0TO L
  VAR A=AllocString(FILES$[I])
  S$[I*2]=CHR$(A)
  S$[I*2+1]=CHR$(A>>16)
 NEXT
 SetString PTR,S$
END
DEF StrArrayFree PTR
 VAR OLD$=GetString$(PTR)
 VAR I,L=LEN(OLD$)-1
 FOR I=0 TO L STEP 2
  VAR J=ASC(OLD$[I])OR ASC(OLD$[I+1])<<16
  FreeString J
 NEXT
END
COMMON DEF I_OTYFIL
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!OTYFILCTL THEN
  ExtendControl "Files",GetWindowControl() OUT OTYFILCTL,E
  E=SetControlNotifHandler(OTYFILCTL,"OTYFILNOTIF")
  E=SetControlPainter(OTYFILCTL,"OTYFILPAINT")
  E=SetControlResizeHandler(OTYFILCTL,"OTYFILRESIZ")
  E=SetControlDeleteHandler(OTYFILCTL,"OTYFILDEL")
  E=SetControlLMouseDownHandler(OTYFILCTL,"OTYFILLMouse")
  E=SetControlRMouseUpHandler(OTYFILCTL,"OTYFILRMouse")
  E=SetControlLDoubleClickHandler(OTYFILCTL,"OTYFILLDBL")
  NewControl "OTYFILICON" OUT OTYFILICONCTL,E
  E=SetControlPainter(OTYFILICONCTL,"OTYFILICONCTLPainter")
  RC_OTYFIL
  ExtendControl "FilesAbout",GetWindowControl() OUT OTYFILABOUTCTL,E
  E=SetControlNotifHandler(OTYFILABOUTCTL,"OTYFILABOUTNOTIF")
  E=SetControlCreateHandler(OTYFILABOUTCTL,"OTYFILABOUTCREATE")
  ExtendControl "Files_Rename",GetWindowControl() OUT OTYFILRENCTL,E
  E=SetControlCreateHandler(OTYFILRENCTL,"OTYFILRENCREATE")
  E=SetControlNotifHandler(OTYFILRENCTL,"OTYFILRENNOTIF")
 ENDIF
 VAR W=42*4+8,H=64,LBL
 NewTopLevelStyleWindow OTYFILCTL,"Files",W,H,WINDOWMENUSTYLE()OR WINDOWRESIZABLESTYLE() OUT WND,E
 VAR MENU
 NewMenu OUT MENU,E
 OTYFIL_MOPEN=1
 OTYFIL_MCOPY=2
 OTYFIL_MCUT=3
 OTYFIL_MDEL=4
 OTYFIL_MREN=5
 OTYFIL_MABOUT=6
 OTYFIL_MPASTE=7
 AddMenuItem MENU,"Open",OTYFIL_MOPEN
'AddMenuItem MENU,"Copy",OTYFIL_MCOPY
'AddMenuItem MENU,"Cut",OTYFIL_MCUT
'AddMenuItem MENU,"Paste",OTYFIL_MPASTE
 AddMenuItem MENU,"Delete",OTYFIL_MDEL
 AddMenuItem MENU,"Rename",OTYFIL_MREN
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 OTYFIL_CONTEXTMENU=MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"About",OTYFIL_MABOUT
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 VAR SCR
 SetProcessVar WND
 SetWindowVar WND,2,AllocString("")
 VAR PTR=AllocString("")
 StrArrayGetFiles PTR,""
 SetWindowVar WND,3,PTR
 NewVScrollBAR WND,OTYFILGETSCRBARLEN(WND) OUT SCR,E
 SetWindowVar WND,4,-1'SELECTED
 OTYFILNOTIF WND,0,0,WND,0
END
COMMON DEF L_OTYFIL
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR MPLAYCTL
VAR MPLAYABOUTCTL
COMMON DEF MPLAYNOTIF WND,CTL,TYP,CW,ID
 VAR N$=GetWindowName$(CW)
 IF N$==""THEN
  BGMPLAY LoadFile$(GetWindowName$(GetWindowVar(WND,0)))
  RETURN
 ENDIF
 IF ID==1THEN
  VOID OpenFileDialog(WND,"TXT",0)
  RETURN
 ENDIF
 IF ID==3THEN
  VOID DeleteWindow(WND)
  RETURN
 ENDIF
 IF ID==4THEN
  VAR E=NewModalDialogBox(MPLAYABOUTCTL,"ABOUT",128,40,WND)
 ENDIF
END
COMMON DEF MPLAYSNOTIF W,C,T,A1,A2$
 SetWindowName GetWindowVar(W,0),RIGHT$(A2$,LEN(A2$)-1)
 VOID RepaintWindow(GetWindowVar(W,0))
END
COMMON DEF I_MPLAY
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!MPLAYCTL THEN
  ExtendControl "MPLAY",GetWindowControl() OUT MPLAYCTL,E
  E=SetControlNotifHandler(MPLAYCTL,"MPLAYNOTIF")
  E=SetControlStrNotifHandler(MPLAYCTL,"MPLAYSNOTIF")
  ExtendControl "MPLAYABOUT",GetWindowControl() OUT MPLAYABOUTCTL,E
 ENDIF
 VAR MENU
 NewTopLevelMenuWindow MPLAYCTL,"MPLAY",128,10 OUT WND,E
 NewMenu OUT MENU,E
 AddMenuItem MENU,"Open",1
 AddMenuItem MENU,"Preset",2
 AddMenuItem MENU,"Exit",3
 AddSubMenuItem GetWindowMenu(WND),"File",MENU
 NewMenu OUT MENU,E
 AddMenuItem MENU,"About",4
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 SetProcessVar WND
 VAR W2
 NewWindow GetButtonControl(),"",0,0,10,10,WND,0 OUT W2,E
 VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
 NewWindow GetLabelControl(),CMD$,12,2,128-12,8,WND,1 OUT W2,E
 SetWindowVar WND,0,W2
END
COMMON DEF L_MPLAY
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
DEF GETBGMLIST()
 DIM BGM$[43]
 COPY BGM$,@BGMNAME
 RETURN BGM$
@BGMNAME
DATA "Kung-Fu POP"
DATA "With stealthy steps"
DATA "Flat out run"
DATA "Nostalgia TECHNO"
DATA "Feel easy"
DATA "Have a good time"
DATA "Relief"
DATA "Exciting days"
DATA "Skipping march"
DATA "Valiant departure"
DATA "Important thing"
DATA "Chasing at 'Ooedo'"
DATA "Funny land"
DATA "Step on the accelerator"
DATA "Experiment"
DATA "New discovery"
DATA "Thinking time"
DATA "Mischievous boy"
DATA "Float"
DATA "Sound of the surf"
DATA "Sound of the surf2"
DATA "Spy movie"
DATA "Calculating"
DATA "Take Off!"
DATA "The evening moon."
DATA "Sensibility"
DATA "Pure water"
DATA "Strategy"
DATA "cure"
DATA "Intense battle"
DATA "Keen competition"
DATA "Heat uuuup!!"
DATA "Rise with force"
DATA "Bright blue"
DATA "Storyteller"
DATA "Return trip"
DATA "High spirits"
DATA "Welcome to the party"
DATA "Funky claps"
DATA "Night surfer"
DATA "Ready to FLY"
DATA "We are heroes"
DATA "Pure water2"
END
'Init common dialogs
VAR CTL_FILDIA
DEF OTW_FileDialog
 VAR E
 ExtendControl "FileDialog",GetWindowControl()OUT CTL_FILDIA,E
 IF E THEN RETURN
 E=SetControlCreateHandler(CTL_FILDIA,"FileDialogCreate")
 E=SetControlNotifHandler(CTL_FILDIA,"FileDialogNotif")
END
COMMON DEF FileDialogNotif WND,C,T,W,__
 VAR ISSAVE=GetWindowVar(WND,1)
 IF ISSAVE&&__==ListBoxChItem()THEN
  SetWindowName GetWindowVar(WND,2),GetListBoxSelectedText$(W)
  VOID RepaintWindow(GetWindowVar(WND,2))
  RETURN
 ENDIF
 IF GetWindowName$(W)=="OK"||GetWindowName$(W)=="L"THEN
  VAR SEL$
  IF ISSAVE THEN
   SEL$=GetWindowName$(GetWindowVar(WND,2))
   IF!LEN(SEL$)THEN RETURN
   IF SEL$[0]!=" "&&SEL$[0]!="*"THEN
    SEL$="*"+SEL$
   ENDIF
  ELSE
   SEL$=GetListBoxSelectedText$(GetWindowVar(WND,0))
   IF!LEN(SEL$)THEN RETURN
  ENDIF
  VAR ID=GetWindowVar(WND,3)
  VOID SendStrNotifWindow(GetWindowGroupOwner(WND),ID,SEL$)
  VOID DeleteWindow(WND)
 ELSE
  IF GetWindowName$(W)=="Cancel"THEN
   VOID DeleteWindow(WND)
  ENDIF
 ENDIF
END
COMMON DEF FileDialogCreate WND,C,T,ID,__
 VAR E,L
 NewWindow GetListBoxControl(),"L",0,0,116,64,WND,0 OUT L,E
 DIM F$[0]
 GetFiles F$,""
 VAR I
 VAR T$=GetWindowName$(WND)
 T$=RIGHT$(T$,LEN(T$)-5)
 T=0
 IF T$=="TXT"THEN T=1
 IF T$=="DAT"THEN T=2
 FOR I=0TO LEN(F$)-1
  IF F$[I][0]==" "&&T==1THEN CONTINUE
  IF F$[I][1]=="*"&&T==2THEN CONTINUE
  AddListBoxItem L,F$[I]
 NEXT
 VAR F=LEFT$(GetWindowName$(WND),4)=="Save"
 SetWindowVar WND,0,L
 SetWindowVar WND,1,F
 NewWindow GetButtonControl(),"OK",119,2,20,12,WND,0 OUT L,E
 NewWindow GetButtonControl(),"Cancel",119,16,50,12,WND,0 OUT L,E
 IF F THEN
  NewWindow GetTextBoxControl(),"",0,65,170,9,WND,0 OUT L,E
  SetWindowVar WND,2,L
  SetChItemListBoxNotif WND,F
 ENDIF
 SetWindowVar WND,3,ID
END
COMMON DEF SaveFileDialog(OWNER,TYPE$,ID)
 IF!CTL_FILDIA THEN
  OTW_FileDialog
 ENDIF
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN TYPE$=""
 VAR TITLE$=TYPE$
 VAR E=NewDialogBoxWithArg(CTL_FILDIA,"Save "+TYPE$,170,74,OWNER,TRUE,ID,0)
 RETURN E
END
COMMON DEF OpenFileDialog(OWNER,TYPE$,ID)
 IF!CTL_FILDIA THEN
  OTW_FileDialog
 ENDIF
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN TYPE$=""
 VAR TITLE$=TYPE$
 VAR E=NewDialogBoxWithArg(CTL_FILDIA,"Open "+TYPE$,170,64,OWNER,TRUE,ID,0)
 RETURN E
END

'=========
DEF OTW_LOADFONT
 'LOAD FONT-1
 VAR C$
 VAR X,Y,I,J
 RESTORE @FONT
 VAR C,_$,K
 DIM PAL[16]
 OTW_CONSOLEPAL=PAL
 FOR I=0TO 15
  READ PAL[I]
 NEXT
 RETURN
 '3.0.X
 OTW_FNT=NewArray2(1024,64)
 OTW_FNTTMP=NewArray(64)
 OTW_FNTPAL=NewArray(2)
 OTW_FNTTBL=NewArray(65536)
 PrintConsoleln "Init font table..."
 FOR I=0TO 127
  OTW_FNTTBL[I]=703
 NEXT
 FOR I=1TO 511
  COPY OTW_FNTTBL,I*128,OTW_FNTTBL,0,128
 NEXT
 OTW_FNTTBL[10]=13
 OTW_LOADFNTTBL
 IF!CHKFILE("DAT:OTW_FONT")THEN
  OTW_GENFONT
 ELSE
  PrintConsoleln "Load DAT:OTW_FONT"
  LOAD"DAT:OTW_FONT",OTW_FNT,0
 ENDIF
 @FONT
 '      AARRGGBB
DATA &H00000000
DATA &HFF000000
DATA &HFF7F0000
DATA &HFFFF0000
DATA &HFF007F00
DATA &HFF00FF00
DATA &HFF7F7F00
DATA &HFFFFFF00
DATA &HFF00007F
DATA &HFF0000FF
DATA &HFF7F007F
DATA &HFFFF00FF
DATA &HFF007F7F
DATA &HFF00FFFF
DATA &HFF7F7F7F
DATA &HFFFFFFFF
END
DEF OTW_GENFONT
 VAR I
 IF!CHKFILE("DAT:FONT")THEN
  SAVE "GRPF:FONT"
  IF RESULT==-1 THEN SAVE "GRPF:FONT"
  '2かいもやめたならしかたない
  IF RESULT!=1 THEN
   FOR I=0TO 63
    READ OTW_FNT[703,I]
   NEXT
   FOR I=1TO 65535
    OTW_FNTTBL[I]=703
   NEXT
   RETURN
  ENDIF
 ENDIF
 LOAD"GRP1:FONT",0
 VAR L
 VAR X,Y,J,K
 GPAGE 0,1
 FOR I=0TO 1023
  X=I*8
  Y=X/512
  Y=Y*8
  X=X MOD 512
  VAR X2=X+7,Y2=Y+7,M=0
  FOR K=Y TO Y2
   FOR J=X TO X2
    IF(GSPOIT(J,K)AND&HFF000000)THEN
     OTW_FNT[I,M]=1
    ENDIF
    INC M
   NEXT
  NEXT
 NEXT
 SAVE"DAT:OTW_FONT",OTW_FNT
 GCLS 
 GPAGE 0,0
@FONT
RETURN
COLOR
DATA 1,1,1,1,1,1,1,0'"FFFFFFF0"
DATA 1,0,1,1,1,0,1,0'"F0FFF0F0"
DATA 1,1,0,1,0,1,1,0'"FF0F0FF0"
DATA 1,1,1,0,1,1,1,0'"FFF0FFF0"
DATA 1,1,0,1,0,1,1,0'"FF0F0FF0"
DATA 1,0,1,1,1,0,1,0'"F0FFF0F0"
DATA 1,1,1,1,1,1,1,0'"FFFFFFF0"
DATA 0,0,0,0,0,0,0,0'"00000000"
DATA "0"
DATA &B00111000'"00FFF000"
DATA &B01000100
DATA &B01001100
DATA &B01010100
DATA &B01100100
DATA &B01000100
DATA &B00111000
DATA &B00000000
DATA "END"
END
DEF OTW_LOADFNTTBL
 RESTORE@RANGE
 VAR I
 WHILE 1
  VAR R1,R2,C1,C2
  READ R1
  IF R1==-1THEN BREAK
  READ C1,R2,C2
  FOR I=R1 TO R2
   OTW_FNTTBL[I]=C1
   INC C1
  NEXT
 WEND
 RESTORE @GRPFTABLE
 WHILE 1
  READ R1
  IF R1==-1THEN BREAK
  READ C1
  OTW_FNTTBL[R1]=C1
 WEND
@RANGE
DATA -1,"A"
@GRPFTABLE

'=REMOVED(DIFF)=

DATA -1
END
VAR TRIANCTL
COMMON DEF DrawSquare WND,X1,Y1,X2,Y2,X3,Y3,X4,Y4,COL
 GTRIWindow WND,X2,Y2,X1,Y1,X4,Y4,COL'RGB(0,255,0)'COL
 GTRIWindow WND,X1,Y1,X4,Y4,X3,Y3,COL
END
COMMON DEF TRIANPAINT WND,CTL,TYP,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 E=GBeginWindow(WND)
' DrawSquare WND,32,0,                                         0,63,                                         63,0,                                         32,63,-1
' DrawSquare WND,8,8,                                         0,63,                                         32,16,                                         32,63,-1
 DrawSquare WND,8,8,0,63,32,16,32,63,-1
 E=GEndWindow(WND)
END
COMMON DEF I_TRIAN
IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!TRIANCTL THEN
  ExtendControl "TRIAN",GetWindowControl() OUT TRIANCTL,E
  E=SetControlPainter(TRIANCTL,"TRIANPAINT")
 ENDIF
 NewTopLevelWindow TRIANCTL,"TRIAN",64,64 OUT WND,E
 SetProcessVar WND
END
COMMON DEF L_TRIAN
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR ODSKCTL
COMMON DEF I_ODSK
IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!ODSKCTL THEN
  ExtendControl "ODSK",GetWindowControl() OUT ODSKCTL,E
 ENDIF
 NewTopLevelStyleWindow ODSKCTL,"Desktop",256,128,WINDOWRESIZABLESTYLE() OUT WIN_ROOTWND2,E
 SetProcessVar WIN_ROOTWND2
END
COMMON DEF L_ODSK
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
DEF PRUN_RMFIRSTSP P$
 VAR I,L=LEN(P$)-1,_$
 FOR I=0TO L
  IF P$[0]!=" "THEN RETURN
  _$=SHIFT(P$)
 NEXT
END
DEF PRUN_ISTHEN(P$)
 VAR I,L=LEN(P$)-1,I$,THEN$="THEN",J=LEN(THEN$)-1
 FOR I=L TO 0STEP -1
  I$=P$[I]
  IF I$==" "THEN CONTINUE
  IF J==-1THEN
   'IF ASC(I$)>= THEN 'ISALPHA
   'TODO AATHENなどのばあいや COMMENT
   RETURN TRUE
  ENDIF
  IF P$[I]==THEN$[J] THEN
   DEC J
   CONTINUE
  ENDIF
  BREAK
 NEXT
 RETURN FALSE
END
DEF PRUN_EDITPRG
 PRGEDIT 2,1
 VAR I,L=PRGSIZE(2)
 VAR H$="INT"+HEX$(RND(&HFFFF),4)
 VAR L$=":"+H$
 VAR H2$=HEX$(RND(&H7FFFFFFF),8)
 VAR Y=CSRY
 FOR I=1TO L
  LOCATE 0,Y
  ?I/L*100;"%";
  PRGEDIT 2,I
  VAR P$=PRGGET$()
  IF LEN(P$)&&ASC(P$[LEN(P$)-1])==10THEN P$=LEFT$(P$,LEN(P$)-1)
  PRUN_RMFIRSTSP P$
  IF LEN(P$)&&!PRUN_ISTHEN(P$)THEN
   PRGEDIT 2,I
   PRGSET P$+L$
  ENDIF
 NEXT
 PRGINS"DEF "+H$
 PRGINS"IF BUTTON()=="+STR$(512+64)+" THEN GOTO"+CHR$(34)+"2:@"+H2$
 PRGINS"END"
 PRGINS "@"+H2$
 PRGINS "END"
END
COMMON DEF PRUNNotificationHandler NDW,C,T,CW,_
 VAR TW=GetWindowVar(NDW,0)
 DIM U[512] 
 DIM V[512] 
 DIM W[512] 
 DIM H[512] 
 DIM A[512] 
 DIM X[512] 
 DIM Y[512] 
 DIM Z[512] 
 DIM DEFNO[512] 
 DIM SV[512,8] 
 VAR I
 DIM GP0[0]
 DIM GP1[0]
 DIM GP2[0]
 DIM GP3[0]
 DIM GP4[0]
 DIM GP5[0]
 GCLIP 1
 GSAVE OTW_SP,GP0,1
 GSAVE OTW_DP,GP1,1

' FOR I=0TO 511
'  VAR J
'  FOR J=0TO 7
'   SV[I,J]=SPVAR(I,J)
'  NEXT
'  IF SV[I,0]THEN
'   SPCHR I OUT U[I],V[I],W[I],H[I],A[I]
'   SPOFS I OUT X[I],Y[I],Z[I]
'  ENDIF
' NEXT
 LOCATE 0,29
 ?"Now loading..."
 LOAD"PRG2:"+GetWindowName$(TW),0
 ?"OK"
 ?"EXEC..."
 PRUN_EDITPRG
 ACLS
 EXEC 2
 ACLS
 'FOR I=0TO 511
 ' IF SV[I,0]THEN
 '  SPSET I,U[I],V[I],W[I],H[I],A[I]
 '  ?SV[I,0],I,U[I],V[I],W[I],H[I],A[I]
 '  SPOFS I,X[I],Y[I],Z[I]
 '  FOR J=0TO 7
 '   SPVAR I,J,SV[I,J]
 '  NEXT
 ' ENDIF
 'NEXT
 VAR NW=GetChildWindow(GetRootWND())AND NUWIDMASK
 
 WHILE NW
  VAR SP=WIN_SP[NW]AND 511
  IF SP THEN
   SPSET WIN_SP[NW] AND 511,WIN_RX[NW],WIN_RY[NW],WIN_AW[NW]+1,WIN_AH[NW]+1,1
   SPOFS WIN_SP[NW] AND 511,WIN_RX[NW],WIN_RY[NW]
  ENDIF
  NW=WIN_NEXT[NW]
 WEND
 GPRIO 1023
 OTW_SPSORT
 GPAGE OTW_SP,OTW_SP
 GLOAD GP0,1,1
 GPAGE OTW_SP,OTW_DP
 GLOAD GP1,1,1
 GCLIP 1,0,0,400,239
 GPAGE OTW_SP,OTW_DP
  '290
  SPSET OTW_MOUSESP,0
  OTW_SHADOWSP=1
  SPSET OTW_SHADOWSP,0
  OTW_INITSP 0
  OTW_MOVWINSP=2
  SPSET OTW_MOVWINSP,0
  SPSCALE OTW_MOVWINSP,1,1
  SPHIDE OTW_MOVWINSP
  SPVAR OTW_MOVWINSP,0,1
  OTW_MOVWINCOL=RGB(128,128,128,128)
  OTW_MOVWINCOL=RGB(128,255,255,255)
  SPCOLOR OTW_MOVWINSP,OTW_MOVWINCOL
END
VAR PRUNCTL
COMMON DEF I_PRUN
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!PRUNCTL THEN
  ExtendControl "PRUN",GetWindowControl() OUT PRUNCTL,E
 ENDIF
 VAR WND
 NewTopLevelStyleWindow PRUNCTL,"PRUN",128,32,WindowResizableStyle() OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 E=SetControlNotificationHandler(PRUNCTL,"PRUNNotificationHandler")
 SetProcessVar WND
 VAR TW
 NewWindow GetButtonControl(),"RUN Program",0,10,32+68,10,WND,0OUT TW,E
 NewWindow GetTextBoxControl(),"",0,0,128,8,WND,0OUT TW,E
 SetWindowVar WND,0,TW
END
COMMON DEF L_PRUN
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END
COMMON DEF LOADERNotificationHandler NDW,C,T,CW,_
 VAR TW=GetWindowVar(NDW,0)
 EXEC"PRG2:"+GetWindowName$(TW)
END
VAR LOADERCTL
COMMON DEF I_LOADER
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!LOADERCTL THEN
  ExtendControl "LOADER",GetWindowControl() OUT LOADERCTL,E
 ENDIF
 VAR WND
 NewTopLevelStyleWindow LOADERCTL,"LOADER",128,32,WindowResizableStyle() OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 E=SetControlNotificationHandler(LOADERCTL,"LOADERNotificationHandler")
 SetProcessVar WND
 VAR TW
 NewWindow GetButtonControl(),"Load",0,10,40,10,WND,0OUT TW,E
 NewWindow GetTextBoxControl(),"",0,0,128,8,WND,0OUT TW,E
 SetWindowVar WND,0,TW
END
COMMON DEF L_LOADER
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END

COMMON DEF TSKBARP WND,C,T,CW,_
 IF GBeginWindow(WND)THEN RETURN
 GCLSWindow WND,GetBackColor()
 VAR W=GetWindowWidth(WND)
 VAR H=GetWindowHeight(WND)
 GLINEWindow WND,0,0,W,0,RGB(0,0,0)
 GLINEWindow WND,0,1,W,1,RGB(255,255,255)
 IF GEndWindow(WND)THEN RETURN
END
VAR TSKBARCTL
DIM TB_TASKLIST$[0]
DIM TB_TASKLIST_WND[0]
COMMON DEF I_TSKBAR
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require OTW"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR E
 IF!TSKBARCTL THEN
  NewControl "TSKBAR" OUT TSKBARCTL,E
  E=SetControlPainter(TSKBARCTL,"TSKBARP")
 ' E=SetControlNotificationHandler(TSKBARCTL,"TSKBARNotificationHandler")
 ENDIF
 VAR WND
 VAR H=16,W=399
 NewWindow TSKBARCTL,"TSKBAR",0,239-H,W,H,GetRootWND(),0 OUT WND,E
 IF E THEN BEEP:ExitProcess 1
 SetProcessVar WND
 VAR TW
 VAR TSKW=84,TC,TSX=24,TCM=5
 TB_TASKLIST$=NewArray$(TCM)
 TB_TASKLIST_WND=NewArray(TCM)
  NewWindow GetToggleButtonControl(),"",1,3,TSX-3,11,WND,0OUT TW,E
 FOR TC=0TO TCM-1
  NewWindow GetToggleButtonControl(),"Task"+STR$(TC),TSKW*TC+TC*2+TSX,3,TSKW,11,WND,WindowHideFlag()OUT TW,E
  SetButtonAlignLeft TW
  TB_TASKLIST_WND[TC]=TW
 NEXT
 SetWindowVar WND,0,TW
END
DEF UPDATE_TSKBAR
 VAR TSKW=84,TC,TSX=24,TCM=5
 VAR RW=GetRootWND()
 VAR CW=GetChildWindow(RW)
 IF GetNextWindow(CW)THEN
  TC=0
  WHILE GetNextWindow(CW)
   IF TCM<=TC THEN BREAK
   SetWindowName TB_TASKLIST_WND[TC],GetWindowName$(CW)
   IF ShowWindow(TB_TASKLIST_WND[TC])THEN BREAK
   CW=GetNextWindow(CW)
   INC TC
  WEND
 ENDIF
END
VAR TSKBAR_TIMER
VAR TSKBAR_CWND
COMMON DEF L_TSKBAR
 IF TSKBAR_TIMER!=MAINCNT THEN
  UPDATE_TSKBAR
'  TSKBAR_CWND=OCW
  TSKBAR_TIMER=MAINCNT DIV 100
 ENDIF
 VAR E=UpdateWindow(GetProcessVar())
 IF E THEN ExitProcess 0
END
VAR CLIPBRDCTL
VAR CLIPBRD_MENU_UPDATE
VAR CLIPBRD_MENU_ABOUT
COMMON DEF CLIPBRDNOTIF WND,CTL,TYP,A1,A2
 IF A2==CLIPBRD_MENU_UPDATE THEN
  VOID RepaintWindow(WND)
 ENDIF
END
DEF SUGOIGPRINTWindow WND,X,Y,W,H,TXT$,COL OUT OX,OY
 W=W DIV 8
 H=H DIV 8
 VAR I,J
 VAR LF$=LF$()
 WHILE 1
  VAR T$=MID$(TXT$,I,W)
  IF!LEN(T$)THEN BREAK
  VAR LFPOS=INSTR(T$,LF$)
  IF LFPOS!=-1THEN
   T$=MID$(T$,0,LFPOS)
   I=I+LFPOS+1
  ELSE
   I=I+W
  ENDIF
  GPRINTWindow WND,X,Y,T$,COL
  J=J+1
  IF H<J THEN BREAK
  Y=Y+8
 WEND
 OX=X
 OY=Y
END
COMMON DEF CLIPBRDPAINTER WND,CTL,TYP,A1,A2
 VAR E=CallBaseControlHandler(WND,CTL,TYP,A1,A2)
 
 IF GBeginWindow(WND)THEN RETURN
 IF ClipboardContainsText()THEN
  GCLSWindow WND,-1
 ELSE
  GCLSWindow WND,GetBackColor()
 ENDIF
 VAR W=GETWINDOWWIDTH(WND)
 VAR H=GETWINDOWHEIGHT(WND)
 VAR X,Y
 IF ClipboardContainsText()THEN
  VAR TXT$=ClipboardGetText$()
  
  SUGOIGPRINTWindow WND,0,Y,W,H-Y,"Text:",RGB(0,0,0) OUT X,Y
  SUGOIGPRINTWindow WND,0,Y,W,H-Y,TXT$,RGB(0,0,0) OUT X,Y
 ELSE
 ENDIF
 IF ClipboardContainsFile()THEN
  VAR CUT,FILE$
  ClipboardGetFile OUT CUT,FILE$
  IF!CUT THEN
   SUGOIGPRINTWindow WND,0,Y,W,H-Y,"File:",RGB(0,0,0) OUT X,Y
  ELSE
   SUGOIGPRINTWindow WND,0,Y,W,H-Y,"File(cut):",RGB(0,0,0) OUT X,Y
  ENDIF
  SUGOIGPRINTWindow WND,0,Y,W,H-Y,FILE$,RGB(0,0,0) OUT X,Y
 ENDIF
 E=GEndWindow(WND)
END
COMMON DEF I_CLIPBRD
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!CLIPBRDCTL THEN
  ExtendControl "ClipBook Viewer",GetWindowControl() OUT CLIPBRDCTL,E
  E=SetControlPainter(CLIPBRDCTL,"CLIPBRDPAINTER")
  E=SetControlNotifHandler(CLIPBRDCTL,"CLIPBRDNOTIF")
 ENDIF
 VAR MENU
 NewTopLevelStyleWindow CLIPBRDCTL,"ClipBook Viewer",128,64,WINDOWRESIZABLESTYLE()OR WINDOWMENUSTYLE() OUT WND,E
 NewMenu OUT MENU,E
 CLIPBRD_MENU_UPDATE=1
 AddMenuItem MENU,"Update",CLIPBRD_MENU_UPDATE
 AddSubMenuItem GetWindowMenu(WND),"View",MENU
 NewMenu OUT MENU,E
 CLIPBRD_MENU_ABOUT=2
 AddMenuItem MENU,"About",CLIPBRD_MENU_ABOUT
 AddSubMenuItem GetWindowMenu(WND),"Help",MENU
 SetProcessVar WND
END
COMMON DEF L_CLIPBRD
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END
VAR EDITORSELCTL
COMMON DEF EDITORSELNOTIF A,B,C,D,E
 IF E==0THEN
  VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
  VAR PRC
  NewProcess GetListBoxSelectedText$(D),CMD$ OUT PRC,E
  VOID DeleteWindow(A)
 ENDIF
END
COMMON DEF I_EDITORSEL
 IF!CHKCALL("IsWinRunning")||!IsWinRunning()THEN
  PrintConsole "Require window system"+LF$()
  ExitProcess 1
  RETURN
 ENDIF
 VAR WND,E
 IF!EDITORSELCTL THEN
  ExtendControl "EditorSelector",GetWindowControl() OUT EDITORSELCTL,E
  E=SetControlNotifHandler(EDITORSELCTL,"EDITORSELNOTIF")
 ENDIF
 NewTopLevelWindow EDITORSELCTL,"EditorSelector",128,40 OUT WND,E
 SetProcessVar WND
 VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
 NewWindow GetLabelControl(),"Open "+CMD$,1,1,128,7,WND,0 OUT E,E
 NewWindow GetListBoxControl(),"",0,9,127,32,WND,0 OUT WND,E
 AddListBoxItem WND,"TXTED"
 AddListBoxItem WND,"PRGED"
END
COMMON DEF L_EDITORSEL
 IF UpdateWindow(GetProcessVar())THEN ExitProcess 1
END

