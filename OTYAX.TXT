OPTION STRICT
OPTION DEFINT
?"
VAR STARTSHELL=0
'SMILETOOLようファイルのばあいTRUEにする
VAR ISSMILETOOL=CHECKSMILETOOL()
DEF CHECKSMILETOOL()
 VAR I
 FOR I=0TO 3
  IF CHKCALL(STR$(I)+":IsSmileTool")THEN
   RETURN FALSE
  ENDIF
 NEXT
 RETURN TRUE
END
COMMON DEF IsSmileTool()
 RETURN ISSMILETOOL
END
'SAVE"OTYAX"
'SAVE"PRG1:OTW
IF!IsSmileTool()THEN
 USE 2
ENDIF
?"
ACLS
VAR OTX_MAXMEM=FREEMEM
COMMON DEF GetMemorySize()
 RETURN OTX_MAXMEM
END
'LOAD"GRPF:BOLD.GRPF",0
'LOAD"GRPF:OTYFNT.GRPF",0
COLOR 14,0
CLS
VAR ISDIR=0
COMMON DEF IsDirectMode()
 RETURN ISDIR
END
VAR LF$=CHR$(10)
VAR CR$=CHR$(13)
VAR BS$=CHR$(8)
VAR HTAB$=CHR$(9)
VAR ESC$=CHR$(&H1B)
VAR INF#=POW(2,1024)
VAR NAN#=INF#/INF#
VAR OTX_NULLSTR$=NewArray$(1)[0]

'GETTER
COMMON DEF NULL$()
 RETURN OTX_NULLSTR$
END
COMMON DEF VOID EXP
END
COMMON DEF LF$()
 RETURN LF$
END
COMMON DEF CR$()
 RETURN CR$
END
COMMON DEF BS$()
 RETURN BS$
END
COMMON DEF HTAB$()
 RETURN HTAB$
END
COMMON DEF INF#()
 RETURN INF#
END
COMMON DEF NAN#()
 RETURN NAN#
END
COMMON DEF NOIMPL MSG$
 ?MSG$
END
@OTYAX
 VAR FIRSTPID=0
 VAR FIRSTNUPID=0
 VAR RUNPID
 VAR RUNPRC=0
 VAR PIDSHIFT=12,NUPIDMASK=4095
?"initializing..."
GOSUB @OTYAXINIT

VAR OTX_RESERVEDMEM=FREEMEM
COMMON DEF GetSystemMemorySize()
 RETURN OTX_MAXMEM-OTX_RESERVEDMEM
END

IF RUNPID THEN ?"FAIL":END
?"OK"
GOSUB @OTYAX_MAIN
?"OK
END
'しょきかルーチン
@OTYAXINIT
 '?"OTYAX 5.0-6
 VAR KILLPRCBTN=64+128+512
 VAR VER$="5.0-19"
 VAR VER=&H50000018
 ?"OTYAX version ";VER$
 GOSUB @OTYAXERRORINIT
 UPDATE
 ?"initializing process..."
 GOSUB @OTYAXPROCESSINIT
 ?"initializing memory manager..."
 OTYAXMEMINIT
 OTYAXSTRINI
 OTX_INIT_SBARRAY
 ?"initializing file system..."
 GOSUB @OTYAXFILEINIT
 ?"initializing console..."
 GOSUB @OTYAXCONINIT
 INIT_LOADMOD
 VAR INITPROC$="OTW"
 VAR SHPROC$="SH"
VAR OTX_MAXMEM2=FREEMEM
 IF BUTTON()AND 8192THEN STARTSHELL=TRUE
 IF STARTSHELL THEN INITPROC$=SHPROC$
 ?"initializing shell..."
 NewProcess "INIT","" OUT RUNPRC,RUNPID
 VAR CON_SBCON
 SetProcessConsole RUNPRC,CON_SBCON OUT RUNPID
 SetConsoleForeColor CON_SBCON,#TGRAY OUT RUNPID
 FIRSTPID=RUNPRC>>PIDSHIFT
 FIRSTNUPID=RUNPRC AND NUPIDMASK
 IF RUNPID THEN
  ?"Process ";INITPROC$;" ";"のきどうにしっぱいしました。:";RUNPID
  NewProcess SHPROC$,"" OUT RUNPRC,RUNPID
  SetProcessConsole RUNPRC,CON_SBCON OUT RUNPID
  FIRSTPID=RUNPRC>>PIDSHIFT
  FIRSTNUPID=RUNPRC AND NUPIDMASK
 ENDIF
RETURN
DEF SAVEVERFILE
 REPEAT
  SAVE"TXT:VERSION","&H"+HEX$(VER)
 UNTIL RESULT==TRUE
 RETURN
END
DEF UPDATE
 IF!CHKFILE("VERSION")THEN
  SAVEVERFILE
  RETURN
 ENDIF
 ?"Check version"
 VAR TXT$=LOAD("TXT:VERSION",0)
 VAR T=VAL(TXT$)
 IF T==0THEN
  ?"Invalid VERSION file"
  SAVEVERFILE
  RETURN
 ENDIF
 IF T>VER THEN
  ?"Updates found!"
  IF CHKFILE("UPDATE")THEN EXEC"PRG1:UPDATE"
 ENDIF
END
DEF FUNCKEY_INIT
 KEY 1,"FILES"
 KEY 2,"LOAD"+CHR$(34)
 KEY 3,"SAVE"+CHR$(34)
 KEY 4,"LIST ERR"+CHR$(13)
 KEY 5,"RUN"
END

@OTYAXERRORINIT
 INIT_ERROR
 VAR SUCCESS=0
 VAR ERROR_ERROR=1
 VAR ERROR_NOTIMPL=2
 RegisterError "SUCCESS
 RegisterError "ERROR_ERROR
 RegisterError "ERROR_NOTIMPL
RETURN
@OTYAXPROCESSINIT
 VAR PROCESS_MAX=128
 DIM PRC_NAME$[PROCESS_MAX]
 DIM PRC_ENTRY$[PROCESS_MAX]
 DIM PRC_ARGS$[PROCESS_MAX]
 DIM PRC_PID[PROCESS_MAX]
 DIM PRC_STDOUT[PROCESS_MAX]
 DIM PRC_STDERR[PROCESS_MAX]
 DIM PRC_STDIN[PROCESS_MAX]
 DIM PRC_NEXT[PROCESS_MAX]
 DIM PRC_PREV[PROCESS_MAX]
 DIM PRC_CHILD[PROCESS_MAX]
 DIM PRC_PARENT[PROCESS_MAX]
 DIM PRC_FLG[PROCESS_MAX]
 DIM PRC_DAT[PROCESS_MAX]
 DIM PRC_PTR[PROCESS_MAX]
 DIM PRC_CWD$[PROCESS_MAX]
 DIM PRC_CON[PROCESS_MAX]
 DIM PRC_STIME[PROCESS_MAX]
 DIM PRC_TIME[PROCESS_MAX]
 'SESSION
 DIM PRC_SES[PROCESS_MAX]
 DIM PRC_SESNXT[PROCESS_MAX]
 DIM PRC_SESPRV[PROCESS_MAX]
 'PROCESS GROUP
 DIM PRC_PGRP[PROCESS_MAX]
 'PROCESS GROUP
 DIM PRC_PGRPNXT[PROCESS_MAX]
 DIM PRC_PGRPPRV[PROCESS_MAX]
 'SIGNAL
 VAR PRC_SIG_MAX=SIGUSR2()+1
 DIM PRC_SIG[PROCESS_MAX]
 DIM PRC_SIGMASK[PROCESS_MAX]
 DIM PRC_SIGHNDLR$[PROCESS_MAX,PRC_SIG_MAX]
 VAR PRC_SIG_TERM$="PRC_SIG_TERM"
 VAR PRC_SIG_IGNORE$="PRC_SIG_IGNORE"
 VAR PRC_SIG_STOP$="PRC_SIG_STOP"
 VAR PRC_SIG_CONT$="PRC_SIG_CONT"
 DIM PRC_SIGTBL$[PRC_SIG_MAX]
 PRC_SIGTBL$[SIGHUP()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGINT()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGQUIT()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGKILL()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGPIPE()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGTERM()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGCHLD()]=PRC_SIG_IGNORE$
 PRC_SIGTBL$[SIGCONT()]=PRC_SIG_CONT$
 PRC_SIGTBL$[SIGSTOP()]=PRC_SIG_STOP$
 PRC_SIGTBL$[SIGTSTP()]=PRC_SIG_STOP$
 PRC_SIGTBL$[SIGUSR1()]=PRC_SIG_TERM$
 PRC_SIGTBL$[SIGUSR2()]=PRC_SIG_TERM$
 VAR PRC_FLG_INIT=1
 VAR PRC_FLG_FUN=2
 VAR PIDCNT=0
 VAR PRC_FREE=1
 VAR PRC_INIT$="PRC_INIT"

 _INITFREEPROC
 DEF _INITFREEPROC
  VAR I
  FOR I=1 TO PROCESS_MAX-2
   PRC_NEXT[I]=I+1
  NEXT
 END
 PRC_PID[0]=&HCAFEBABE
 VAR RUNNUPID=0
 VAR ERROR_NEW_PROC=&H1001
 VAR ERROR_NO_PROC=&H1002
 RegisterError "ERROR_NEW_PROC
 RegisterError "ERROR_NO_PROC
RETURN
COMMON DEF SIGHUP()
 RETURN 1
END
COMMON DEF SIGINT()
 RETURN 2
END
COMMON DEF SIGQUIT()
 RETURN 3
END
COMMON DEF SIGKILL()
 RETURN 4
END
COMMON DEF SIGPIPE()
 RETURN 5
END
COMMON DEF SIGTERM()
 RETURN 6
END
COMMON DEF SIGCHLD()
 RETURN 7
END
COMMON DEF SIGCONT()
 RETURN 8
END
COMMON DEF SIGSTOP()
 RETURN 9
END
COMMON DEF SIGTSTP()
 RETURN 10
END
COMMON DEF SIGUSR1()
 RETURN 11
END
COMMON DEF SIGUSR2()
 RETURN 12
END
@OTYAXFILEINIT
 VAR FIDSHIFT=12,NUFIDMASK=4095
 VAR FILES_MAX=1024
 DIM FILES_PID[FILES_MAX]
 DIM FILES_FID[FILES_MAX]
 DIM FILES_NAME$[FILES_MAX]
 DIM FILES_DAT[FILES_MAX]
 DIM FILES_DATSTR$[FILES_MAX]
 DIM FILES_WRITER$[FILES_MAX]
 DIM FILES_READER$[FILES_MAX]
 DIM FILES_READLN$[FILES_MAX]
 DIM FILES_CLOSE$[FILES_MAX]
 DIM FILES_NEXT[FILES_MAX]
 DIM FILES_POS[FILES_MAX]
 DIM FILES_ISEOF[FILES_MAX]
 VAR ERROR_NOFILE=&H2001
 VAR ERROR_NOPENFILE=&H2002
 VAR ERROR_NOALLOCFILE=&H2003
 VAR ERROR_NOFILECONTENT=&H2004
 VAR ERROR_INVALIDFILENAME=&H2005
 VAR ERROR_PERM=&H2005
 VAR ERROR_ALREADYFILE=&H2006
 VAR ERROR_NOFUNC=&H2007
 VAR ERROR_INVALID=&H2008
 RegisterError "ERROR_NOFILE
 RegisterError "ERROR_NOPENFILE
 RegisterError "ERROR_NOALLOCFILE
 RegisterError "ERROR_NOFILECONTENT
 RegisterError "ERROR_INVALIDFILENAME
 RegisterError "ERROR_PERM
 RegisterError "ERROR_ALREADYFILE
 RegisterError "ERROR_NOFUNC
 RegisterError "ERROR_INVALID
 VAR FILES_FREE=1
 VAR FILES_FIDCNT=0
 VAR FILE_READ_FLAG=1
 VAR FILE_WRITE_FLAG=2
 VAR FILE_APPEND_FLAG=4
 VAR FILE_CREATE_FLAG=8
 _INITFREEFIL
 DEF _INITFREEFIL
  VAR I
  FOR I=1 TO FILES_MAX-2
   FILES_NEXT[I]=I+1
  NEXT
 END
 FILES_FID[0]=&HCAFEBABE

 VAR OTYAX_STDOUT_OPENER$="OUTCONSOLE_OPEN"
 VAR OTYAX_STDIN_OPENER$="INCONSOLE_OPEN"
 VAR ROOTFS
 VAR FS_ERROR_NOTFOUND
 VAR FS_ERROR_NOTSUPPORTED
 VAR FS_ERROR_ACCESS
 VAR FS_ERROR_NOSPACE
 VAR FS_ERROR_CANCEL
 VAR FS_ERROR_INVALIDFS
 VAR FS_ERROR_DUPFS
 VAR FS_ERROR_OUTOFMEM
 VAR FS_ERROR_INVALIDFUNC
 VAR FS_ERROR_RESERVED
 FS_INIT
 OTYFS_INIT
 IF ROOTFS_INIT()THEN
  ?"ERROR on File system"
  PANIC
 ENDIF
 
RETURN
@OTYAXCONINIT
 VAR CON_ERROR_INVALIDCON
 VAR CON_ERROR_INVALIDFUNC
 IF CON_INIT()THEN
  ?"ERROR on console"
  PANIC
 ENDIF
RETURN
'key=value
'#COMMENT
'key2=value2...
'KEYS$=["key","#COMMENT","key2"]
'VALUES$=["value","","value2"]
COMMON DEF LoadConfigFile FILE$ OUT KEYS$,VALUES$
 DIM K$[0],V$[0]
 VAR I,J
 WHILE TRUE
  J=INSTR(I,FILE$,LF$)
  IF J==-1THEN J=MAX(LEN(FILE$)-1,0)
  VAR LINE$=MID$(FILE$,I,J-I)
  IF!LEN(LINE$)THEN @C
  FOR I=I TO J
   VAR I$=FILE$[I]
   IF I$!=" "THEN BREAK
  NEXT
  IF FILE$[I]=="#"THEN
   PUSH K$,MID$(FILE$,I,J-I)
   PUSH V$,""
  ELSE
   VAR OI=I
   FOR I=I TO J
    I$=FILE$[I]
    IF I$==LF$THEN BREAK
    IF I$=="="THEN BREAK
   NEXT
   PUSH K$,MID$(FILE$,OI,I-OI)
   PUSH V$,MID$(FILE$,I+1,J-I-1)
  ENDIF
  @C
  I=J+1
  IF I>=LEN(FILE$)THEN BREAK
 WEND
 KEYS$=K$
 VALUES$=V$
END
COMMON DEF LoadLinkFileOld FILE$ OUT TYPE$,NAME$,CONTENT$
 TYPE$=""
 CONTENT$=""
 VAR I=INSTR(FILE$,"END"+LF$)
 IF I!=0THEN RETURN
 INC I,4
 VAR J=INSTR(I,FILE$,LF$)
 IF J==-1 THEN RETURN
 TYPE$=MID$(FILE$,I,J-I)
 INC J
 I=INSTR(J,FILE$,LF$)
 IF I==-1 THEN RETURN
 NAME$=MID$(FILE$,J,I-J)
'IF LEN(CONTENT$)&&CONTENT$[LEN(CONTENT$)-1]==LF$THEN
' CONTENT$=LEFT$(CONTENT$,LEN(CONTENT$)-1)
'ENDIF
 INC I
 J=INSTR(I,FILE$,LF$)
 IF J==-1 THEN RETURN
 CONTENT$=MID$(FILE$,I,J-I)
END
@OTYAX_MAIN
 IF RUNNUPID THEN
 ''DEBUGCODE
' VAR CX=CSRX,CY=CSRY,FFF=0
' LOCATE 40,0
' ?RUNNUPID;PRC_NAME$[RUNNUPID];
' IF CX>=50 THEN DEC CX:FFF=1
' LOCATE CX,CY
' IF FFF THEN
'  ?CHR$(CHKCHR(CX,CY));
' ENDIF
 ''
  VAR _OMT
  RUNPRC=PRC_PID[RUNNUPID]<<PIDSHIFT OR RUNNUPID
  'INIT  ->PRC_INIT->I_XXX
  'SIGNAL->PRC_SIG
  '      ->L_XXX
  _OMT=MILLISEC
  VAR __R=RUNNUPID
  CALL PRC_ENTRY$[RUNNUPID]
  IF __R==RUNNUPID THEN
   INC PRC_TIME[RUNNUPID],MILLISEC-_OMT
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    __R=RUNNUPID
    RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
    IF!RUNNUPID THEN
     RUNNUPID=PRC_PARENT[__R]
     WHILE 1
      __R=RUNNUPID
      RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
      IF!RUNNUPID THEN
       RUNNUPID=PRC_PARENT[__R]
       IF!RUNNUPID THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
RETURN
DEF PRC_INIT
 PRC_ENTRY$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
 CALL "I_"+PRC_NAME$[RUNNUPID]
END
DEF PRC_SIG
 PRC_ENTRY$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
 VAR S=PRC_SIG[RUNNUPID]
 VAR I
 FOR I=0TO PRC_SIG_MAX-1
  IF S AND (1<<I)THEN
   CALL PRC_SIGHNDLR$[RUNNUPID,I+1],I+1
   PRC_SIG[RUNNUPID]=PRC_SIG[RUNNUPID] AND NOT (1<<I)
  ENDIF
 NEXT
END
DEF PRC_INIT_SIG NUPID
 VAR I
 '※REF COPY
 FOR I=0TO PRC_SIG_MAX-1
  PRC_SIGHNDLR$[NUPID,I]=PRC_SIGTBL$[I]
 NEXT
 PRC_SIG[NUPID]=0
 PRC_SIGMASK[NUPID]=0
END
DEF PRC_SIG_TERM SIGNUM
 ExitProcess SIGNUM
END
DEF PRC_SIG_IGNORE SIGNUM
END
'FIXME
DEF PRC_SIG_STOP SIGNUM
END
'FIXME
DEF PRC_SIG_CONT SIGNUM
END
VAR OTX_CONT_BREAK
COMMON DEF OTX_BREAK
 OTX_CONT_BREAK=TRUE
END
COMMON DEF OTX_CONT
ISDIR=1
OTX_CONT_BREAK=FALSE
@OTYAX_MAIN
 IF OTX_CONT_BREAK THEN RETURN
 IF RUNNUPID THEN
 ''DEBUGCODE
' VAR CX=CSRX,CY=CSRY,FFF=0
' LOCATE 40,0
' ?RUNNUPID;PRC_NAME$[RUNNUPID];
' IF CX>=50 THEN DEC CX:FFF=1
' LOCATE CX,CY
' IF FFF THEN
'  ?CHR$(CHKCHR(CX,CY));
' ENDIF
 ''
  IF PRC_FLG[RUNNUPID] AND PRC_FLG_INIT THEN
   IF!CHKLABEL("@I_"+PRC_NAME$[RUNNUPID])THEN
    IF CHKCALL("I_"+PRC_NAME$[RUNNUPID])THEN
     VAR __R=RUNNUPID
     CALL "I_"+PRC_NAME$[RUNNUPID]
     IF __R==RUNNUPID THEN
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]XOR PRC_FLG_INIT
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]OR PRC_FLG_FUN
      PRC_NAME$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
      IF!CHKCALL(PRC_NAME$[RUNNUPID]) THEN
       ExitProcess 1
       GOTO@OTYAX_MAIN
      ENDIF
     ENDIF
    ELSE
     ExitProcess 1
     GOTO@OTYAX_MAIN
    ENDIF
   ELSE
    GOSUB "@I_"+PRC_NAME$[RUNNUPID]
    PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID] XOR PRC_FLG_INIT
    PRC_NAME$[RUNNUPID]="@L_"+PRC_NAME$[RUNNUPID]
    IF!CHKLABEL(PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
   ENDIF
  ELSE
   IF PRC_FLG[RUNNUPID] AND PRC_FLG_FUN THEN
    CALL PRC_NAME$[RUNNUPID]
   ELSE
    GOSUB PRC_NAME$[RUNNUPID]
   ENDIF
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    __R=RUNNUPID
    RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
    IF!RUNNUPID THEN
     RUNNUPID=PRC_PARENT[__R]
     WHILE 1
      __R=RUNNUPID
      RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
      IF!RUNNUPID THEN
       RUNNUPID=PRC_PARENT[__R]
       IF!RUNNUPID THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
END
'OTYAX UTIL
COMMON DEF NewArray#(LEN)
 DIM ARY#[LEN]
 RETURN ARY#
END
COMMON DEF NewArray%(LEN)
 DIM ARY%[LEN]
 RETURN ARY%
END
COMMON DEF NewArray$(LEN)
 DIM ARY$[LEN]
 RETURN ARY$
END
COMMON DEF NewArray(LEN)
 DIM ARY[LEN]
 RETURN ARY
END
COMMON DEF NewArray2#(LEN,L2)
 DIM ARY#[LEN,L2]
 RETURN ARY#
END
COMMON DEF NewArray2%(LEN,L2)
 DIM ARY%[LEN,L2]
 RETURN ARY%
END
COMMON DEF NewArray2$(LEN,L2)
 DIM ARY$[LEN,L2]
 RETURN ARY$
END
COMMON DEF NewArray2(LEN,L2)
 DIM ARY[LEN,L2]
 RETURN ARY
END

COMMON DEF NewArray3#(LEN,L2,L3)
 DIM ARY#[LEN,L2,L3]
 RETURN ARY#
END
COMMON DEF NewArray3%(LEN,L2,L3)
 DIM ARY%[LEN,L2,L3]
 RETURN ARY%
END
COMMON DEF NewArray3$(LEN,L2,L3)
 DIM ARY$[LEN,L2,L3]
 RETURN ARY$
END
COMMON DEF NewArray3(LEN,L2,L3)
 DIM ARY[LEN,L2,L3]
 RETURN ARY
END

COMMON DEF NewArray4#(LEN,L2,L3,L4)
 DIM ARY#[LEN,L2,L3,L4]
 RETURN ARY#
END
COMMON DEF NewArray4%(LEN,L2,L3,L4)
 DIM ARY%[LEN,L2,L3,L4]
 RETURN ARY%
END
COMMON DEF NewArray4$(LEN,L2,L3,L4)
 DIM ARY$[LEN,L2,L3,L4]
 RETURN ARY$
END
COMMON DEF NewArray4(LEN,L2,L3,L4)
 DIM ARY[LEN,L2,L3,L4]
 RETURN ARY
END
COMMON DEF FindArray(ARY[],V)
 VAR I,L=LEN(ARY)-1
 FOR I=0TO L
  IF ARY[I]==V THEN RETURN I
 NEXT
 RETURN -1
END
COMMON DEF BinarySearch(ARY,TXT)
 IF!LEN(ARY)THEN RETURN-1
 VAR MN,MX=LEN(ARY)-1
 WHILE 1
  IF MX<MN THEN RETURN -1
  VAR I=MN+(MX-MN)DIV 2
  'VAR D=ARY[I]
  IF ARY[I]==TXT THEN RETURN I
  IF ARY[I]>TXT THEN
   'TIISAI
   MX=I-1
  ELSE
   MN=I+1
  ENDIF
 WEND
END
COMMON DEF BinarySearch$(ARY,TXT)
 IF!LEN(ARY)THEN RETURN-1
 VAR MN,MX=LEN(ARY)-1
 WHILE 1
  IF MX<MN THEN RETURN -1
  VAR I=MN+(MX-MN)DIV 2
  VAR D$=ARY[I]
  IF D$==TXT THEN RETURN I
  IF D$>TXT THEN
   'TIISAI
   MX=I-1
  ELSE
   MN=I+1
  ENDIF
 WEND
END
COMMON DEF BinarySearch#(ARY,TXT)
 IF!LEN(ARY)THEN RETURN-1
 VAR MN,MX=LEN(ARY)-1
 WHILE 1
  IF MX<MN THEN RETURN -1
  VAR I=MN+(MX-MN)DIV 2
  VAR D#=ARY[I]
  IF D#==TXT THEN RETURN I
  IF D#>TXT THEN
   'TIISAI
   MX=I-1
  ELSE
   MN=I+1
  ENDIF
 WEND
END
COMMON DEF BinarySearch%(ARY,TXT)
 IF!LEN(ARY)THEN RETURN-1
 VAR MN,MX=LEN(ARY)-1
 WHILE 1
  IF MX<MN THEN RETURN -1
  VAR I=MN+((MX-MN)DIV 2)
  VAR D%=ARY[I]
  IF D%==TXT THEN RETURN I
  IF D%>TXT THEN
   'TIISAI
   MX=I-1
  ELSE
   MN=I+1
  ENDIF
 WEND
END

COMMON DEF ShortToRGB(IN)
 VAR R=IN>>11AND 31
 VAR G=IN>>6AND 31
 VAR B=IN>>1AND 31
 VAR A=(IN AND 1)*255
 RETURN RGB(A,R<<3,G<<3,B<<3)
END
COMMON DEF RGBToShort(IN)
 VAR A=IN>>24
 VAR R=IN>>16AND 255
 VAR G=IN>>8AND 255
 VAR B=IN AND 255
' RETURN !!A<<15OR R>>3<<10OR G>>3<<5OR B>>3
RETURN R>>3<<11OR G>>3<<6OR B>>3<<1OR !!A'==255
END
COMMON DEF SplitInt IN OUT X,Y
 X=IN AND 65535
 Y=IN>>16
END
COMMON DEF JoinInt(X,Y)
 RETURN (X AND 65535)OR Y<<16
END
COMMON DEF _BIN$(IN)
 VAR R$="",S$="01"
 WHILE IN
  R$=S$[IN AND 1]+R$
  IN=IN>>1
 WEND
 RETURN R$
END
COMMON DEF Join$(ARY$,S$)
 VAR I,L=LEN(ARY$)-1
 VAR R$
 FOR I=0TO L
  IF I THEN PUSH R$,S$
  PUSH R$,ARY$[I]
 NEXT
 RETURN R$
END
COMMON DEF InsertStr$(BASE$,POS,INS$)
' RETURN LEFT$(BASE$,POS)+INS$+RIGHT$(BASE$,LEN(BASE$)-POS)
 RETURN SUBST$(BASE$,POS,0,INS$)
END
COMMON DEF InsertStrB BASE$,POS,INS$
 IF POS==LEN(BASE$)THEN
  PUSH BASE$,INS$
  RETURN
 ENDIF
 BASE$[POS]=INS$+BASE$[POS]
END
COMMON DEF RemoveStr$(THIS$,POS,LEN)
 RETURN SUBST$(THIS$,POS,LEN,"")'LEFT$(THIS$,POS)+RIGHT$(THIS$,LEN(THIS$)-POS-LEN)
END
COMMON DEF RemoveStrB THIS$,POS,LEN
 FOR LEN=LEN TO 1 STEP -1
  THIS$[POS]=""
 NEXT
END
COMMON DEF ReplaceStr$(THIS$,STR$,TO$)
 VAR I,L=LEN(STR$)
 WHILE 1
  I=INSTR(I,THIS$,STR$)
  IF I==-1THEN BREAK
  THIS$=SUBST$(THIS$,I,L,TO$)
  INC I,L
 WEND
 RETURN THIS$
END
COMMON DEF GetFileNameWithoutDir$(FILE$)
 IF INSTR(FILE$,"/")==-1THEN RETURN FILE$
 VAR L=LASTINSTR(FILE$,"/")
 RETURN MID$(FILE$,L+1,LEN(FILE$))
END
COMMON DEF GetFileNameWithoutExt$(FILE$)
 FILE$=GetFileNameWithoutDir$(FILE$)
 VAR D=INSTR(FILE$,".")
 IF D==-1THEN RETURN FILE$
 RETURN LEFT$(FILE$,D)
END
COMMON DEF GetFileExtension$(FILE$)
 FILE$=GetFileNameWithoutDir$(FILE$)
 VAR D=INSTR(FILE$,".")
 IF D==-1THEN RETURN ""
 VAR E
 WHILE 1
  E=INSTR(D+1,FILE$,".")
  IF E==-1THEN
   RETURN RIGHT$(FILE$,LEN(FILE$)-(D+1))
  ENDIF
  D=E
 WEND
END
COMMON DEF ArrayFill ARY[],V,OFF,L
 IF!L THEN RETURN
 VAR E=OFF+L,O2=OFF
 VAR L1=1
 ARY[OFF]=V
 COPY ARY,OFF+L1,ARY,OFF,L1
' ?L1,OFF
 WHILE 1
 VAR _=L1
' ?L1,OFF
 IF OFF+L1+1+_*2>E THEN
' STOP
  COPY ARY,OFF+L1+1,ARY,O2,E-(OFF+L1+1)'E-OFF DIV 2
  RETURN
 ENDIF
 COPY ARY,OFF+L1+1,ARY,O2,_*2'L1
' ?"COPY ARY",OFF+L1+1,"ARY",O2,_*2
 INC OFF,L1
 INC L1,L1
 
 WEND
END
COMMON DEF Split(STR$,SP$)
 DIM R$[0]
 VAR I,J,SPL=LEN(SP$)
 WHILE 1
  J=INSTR(I,STR$,SP$)
  IF J==-1THEN
   IF I==LEN(STR$)-1THEN RETURN R$
   PUSH R$,MID$(STR$,I,LEN(STR$)-I)
   RETURN R$
  ENDIF
  PUSH R$,MID$(STR$,I,J-I)
  I=J+SPL
 WEND
END
COMMON DEF ToUpper$(STR$)
 IF!LEN(STR$)THEN RETURN""
 VAR S2$
 COPY S2$,STR$
 ToUpper S2$
 RETURN S2$
END
COMMON DEF ToUpper STR$
 VAR I,L=LEN(STR$)-1
 FOR I=0TO L
  VAR C=ASC(STR$[I])
  IF C>=97&&C<=122 THEN
   STR$[I]=CHR$(C-32)
  ENDIF
 NEXT
END
COMMON DEF ToLower$(STR$)
 IF!LEN(STR$)THEN RETURN""
 VAR S2$
 COPY S2$,STR$
 ToLower S2$
 RETURN S2$
END
COMMON DEF ToLower STR$
 VAR I,L=LEN(STR$)-1
 FOR I=0TO L
  VAR C=ASC(STR$[I])
  IF C>=65&&C<=90 THEN
   STR$[I]=CHR$(C+32)
  ENDIF
 NEXT
END
COMMON DEF LASTINSTR(S1$,S2$)
 VAR I,L=LEN(S2$)
 FOR I=LEN(S1$)-L TO 0 STEP -1
  IF MID$(S1$,I,L)==S2$THEN BREAK
 NEXT
 RETURN I
END
'Memory Library
DIM OTX_STR$[0]
DIM OTX_STRNXT[0]
DIM OTX_STRPRV[0]
VAR OTX_STRFR
DEF OTYAXSTRINI
 OTX_STR$=NewArray$(512)
 OTX_STRNXT=NewArray(512)
 OTX_STRPRV=NewArray(512)
 VAR I
 FOR I=1TO 510
  OTX_STRNXT[I]=I+1
 NEXT
 OTX_STRFR=1
END
COMMON DEF AllocString(STR$)
 IF!OTX_STRFR THEN
  PUSH OTX_STR$,STR$
  PUSH OTX_STRNXT,0
  PUSH OTX_STRPRV,0
  RETURN LEN(OTX_STR$)-1
 ENDIF
 VAR I=OTX_STRFR
 OTX_STR$[I]=STR$
 OTX_STRFR=OTX_STRNXT[I]
 RETURN I
END
COMMON DEF SetString PTR,STR$
 OTX_STR$[PTR]=STR$
END
COMMON DEF GetString$(PTR)
 RETURN OTX_STR$[PTR]
END
'COMMON DEF SetStringArray32 PTR,I,V
' RETURN OTX_STR$[PTR]
'END
COMMON DEF FreeString PTR
 OTX_STR$[PTR]=OTX_NULLSTR$
 OTX_STRNXT[PTR]=OTX_STRFR
 OTX_STRFR=PTR
END
VAR OTX_MEMSIZ
DIM OTX_MEM[0]
DIM OTX_MEM#[0]
DIM OTX_MEM$[0]
VAR OTX_FREESIZ
VAR OTX_FREELEN
DIM OTX_FREE[0]
DIM OTX_FREEADDR[0]
VAR OTX_MEMHEAD
DEF OTYAXMEMINIT
 OTX_MEMSIZ=65536
 OTX_MEM=NewArray(OTX_MEMSIZ)
 OTX_FREESIZ=256
 OTX_FREE=NewArray(OTX_FREESIZ)
 OTX_FREEADDR=NewArray(OTX_FREESIZ)
 OTX_MEMHEAD=&Hdeadbeef
 OTYAXMEMFREEINIT
 RETURN


 
 ?"TEST"
 VAR PTR=malloc(128)
 ?"PTR=malloc(128)";PTR
 VAR PTR2=malloc(128)
 ?"PTR2=malloc(128)";PTR2
 free PTR
 ?"free PTR"
 PTR=malloc(32)
 ?"PTR=malloc(128)";PTR
 VAR PTR3=malloc(32)
 ?"PTR3=malloc(128)";PTR
 VAR PTR4=malloc(128)
 ?"PTR4=malloc(128)";PTR
 OTX_FREEDUMP
END
DEF OTYAXMEMFREEINIT
 OTX_FREELEN=1
 OTX_FREE[0]=OTX_MEMSIZ-1
 OTX_FREEADDR[0]=1
END
DEF OTX_FREEDUMP
 VAR I
 FOR I=0TO OTX_FREELEN-1
  ?OTX_FREEADDR[I];":";OTX_FREE[I]
 NEXT
END
COMMON DEF malloc(SIZE)
 VAR I=OTX_FREELEN/2,A=I
 VAR U=-1
 INC SIZE,3'HEADER SIZE
 WHILE 1
  VAR N=OTX_FREE[I]
  'ちょうどいい
  IF I==SIZE THEN
   U=I
   BREAK
  ENDIF
  IF I<SIZE THEN
   IF!A THEN BREAK
'  IF OTX_FREE[I+A]<=SIZE THEN BREAK
   DEC I,A
   IF I<0THEN I=0
   A=A/2
   CONTINUE
  ENDIF
  IF I>SIZE THEN
   IF!A THEN BREAK
 '  IF OTX_FREE[I-A]<=SIZE THEN BREAK
   INC I,A
   IF I>=OTX_FREELEN THEN I=0
   A=A/2
   CONTINUE
  ENDIF
 WEND
 IF OTX_FREE[I]<SIZE THEN RETURN 0
 VAR ADDR=OTX_FREEADDR[I]
 DEC OTX_FREE[I],SIZE
 IF!OTX_FREE[I]THEN DEC OTX_FREELEN
 INC OTX_FREEADDR[I],SIZE
 RSORT OTX_FREE,OTX_FREEADDR
 OTX_MEM[ADDR]=OTX_MEMHEAD
 OTX_MEM[ADDR+1]=SIZE
 OTX_MEM[ADDR+2]=0'NEXT
 RETURN ADDR+3
END
COMMON DEF free ADDR
 IF!ADDR THEN RETURN
 INC OTX_FREELEN
 IF OTX_FREELEN>=OTX_FREESIZ THEN
  PUSH OTX_FREE,0
  PUSH OTX_FREEADDR,0
 ENDIF
 DEC ADDR,3
 IF ADDR<=0||ADDR>=LEN(OTX_MEM)THEN RETURN
 IF OTX_MEM[ADDR]!=OTX_MEMHEAD THEN RETURN
 OTX_FREE[OTX_FREELEN]=OTX_MEM[ADDR+1]
 OTX_FREEADDR[OTX_FREELEN]=ADDR
 RSORT OTX_FREE,OTX_FREEADDR
END
COMMON DEF GetRawMemory()
 RETURN OTX_MEM
END
COMMON DEF ReadArray PTR,ARRAY[],POS,LEN
 IF PTR<0||PTR+LEN>LEN(OTX_MEM)THEN RETURN
 COPY ARRAY,POS,OTX_MEM,PTR,LEN
END
COMMON DEF WriteArray PTR,ARRAY[],POS,LEN
 IF PTR<0||PTR+LEN>LEN(OTX_MEM)THEN RETURN
 COPY OTX_MEM,PTR,ARRAY,POS,LEN
END
COMMON DEF WriteInt PTR,VALUE
 IF PTR<0||PTR>=LEN(OTX_MEM)THEN RETURN
 OTX_MEM[PTR]=VALUE
END
COMMON DEF ReadInt(PTR)
 IF PTR<0||PTR>=LEN(OTX_MEM)THEN RETURN PTR
 RETURN OTX_MEM[PTR]
END
COMMON DEF LoadDATA NAME$,ARY OUT ERR
 GetSBFile NAME$ OUT NAME$,ERR
 IF ERR THEN RETURN
 IF MID$(NAME$,0,4)!="DAT:"THEN ERR=1RETURN
 LOAD NAME$,ARY,0
 IF RESULT!=TRUE THEN ERR=1:RETURN
END
COMMON DEF SaveDATA PATH$,ARY OUT ERR
 VAR NAME$
 GetSBFile PATH$ OUT NAME$,ERR
 IF ERR THEN
  SaveDATAFile PATH$,ARY OUT ERR
  RETURN
 ENDIF
 IF MID$(NAME$,0,4)!="DAT:"THEN ERR=1RETURN
 SAVE NAME$,ARY
 IF RESULT!=TRUE THEN ERR=1:RETURN
END
COMMON DEF LoadFile NAME$ OUT RESULT$,ERR
 VAR FILE,DAT$
 RESULT$=""
 FileOpen NAME$,FileReadFlag() OUT FILE,ERR
 IF ERR THEN RESULT$=""RETURN
 WHILE 1
  IF IsFileEOF(FILE)THEN BREAK
  FileRead FILE,2048 OUT DAT$,ERR
  PUSH RESULT$,DAT$
 WEND
 FileClose FILE OUT ERR
END
COMMON DEF SaveFile NAME$,T$ OUT ERR
 VAR FILE
 FileOpen NAME$,FileWriteFlag()OR FileCreateFlag() OUT FILE,ERR
 IF ERR THEN RETURN
 FileWrite FILE,T$ OUT ERR
 FileClose FILE OUT ERR
END
COMMON DEF GetSBFileName$(F$)
 IF F$[0]==" "THEN RETURN "DAT:"+MID$(F$,1,999)
 IF F$[0]=="*"THEN RETURN "TXT:"+MID$(F$,1,999)
 IF INSTR(F$,"TXT:")==0THEN RETURN F$
 IF INSTR(F$,"DAT:")==0THEN RETURN F$
 RETURN "TXT:"+F$
END
'COMMON DEF DeleteFile NAME$
' DELETE GetSBFileName$(NAME$)
'END
COMMON DEF RenameFile FROM$,TO$ OUT ERR
 FROM$=GetAbsolutePath$(FROM$)
 IF INSTR(TO$,"/")!=-1THEN
  ERR=ERROR_INVALIDFILENAME
  RETURN
 ENDIF
 FSRename ROOTFS,"",FROM$,TO$ OUT ERR
END
COMMON DEF SetCurrentDir(DIR$)
 PRC_CWD$[RUNNUPID]=GetAbsoluteDir$(DIR$)
 RETURN 0
END
COMMON DEF GetCurrentDir$()
 RETURN PRC_CWD$[RUNNUPID]
END
COMMON DEF CombinePath$(BASE$,PATH$)
 IF MID$(PATH$,0,1)=="/"THEN RETURN PATH$
 IF MID$(BASE$,LEN(BASE$)-1,1)!="/"THEN BASE$=BASE$+"/"
 RETURN BASE$+PATH$
END
COMMON DEF GetAbsolutePath$(PATH$)
 IF MID$(PATH$,0,1)!="/"THEN
  PATH$=CombinePath$(GetCurrentDir$(),PATH$)
 ENDIF
 RETURN PATH$
END
COMMON DEF GetAbsolutePath2$(BASE$,PATH$)
 IF MID$(PATH$,0,1)!="/"THEN
  PATH$=CombinePath$(CombinePath$(GetCurrentDir$(),BASE$),PATH$)
 ENDIF
 RETURN PATH$
END
COMMON DEF GetAbsoluteDir$(PATH$)
 PATH$=GetAbsolutePath$(PATH$)
 IF MID$(PATH$,LEN(PATH$)-1,1)!="/"THEN PATH$=PATH$+"/"
 IF RIGHT$(PATH$,4)=="/../"THEN
  PATH$=LEFT$(PATH$,LEN(PATH$)-4)
  PATH$=MID$(PATH$,0,LASTINSTR(PATH$,"/")+1)
  IF!LEN(PATH$)THEN PATH$="/"'"/../"=>"/"
 ENDIF
 RETURN PATH$
END

COMMON DEF GetFiles DIR$ OUT ARY,ERR
 DIR$=GetAbsoluteDir$(DIR$)
 FSGetFiles ROOTFS,"",DIR$ OUT ARY,ERR
 IF DIR$!="/"THEN PUSH ARY,"/.."
END

COMMON DEF NewDir DIR$ OUT ERR
 DIR$=GetAbsoluteDir$(DIR$)
 FSNewDir ROOTFS,"",DIR$ OUT ERR
END

COMMON DEF Mount DIR$,FS$,DATA$ OUT ERR
 DIR$=GetAbsoluteDir$(DIR$)
 FSMount ROOTFS,"",DIR$,FS$,DATA$ OUT ERR
END

COMMON DEF DeleteFile DIR$ OUT ERR
 DIR$=GetAbsolutePath$(DIR$)
 FSDelete ROOTFS,"",DIR$ OUT ERR
END

COMMON DEF GetFileType PATH$ OUT TYPE$,ERR
 PATH$=GetAbsolutePath$(PATH$)
 FSGetType ROOTFS,"",PATH$ OUT TYPE$,ERR
END

COMMON DEF GetSBFile PATH$ OUT FILE$,ERR
 PATH$=GetAbsolutePath$(PATH$)
 FSGetSBFile ROOTFS,"",PATH$ OUT FILE$,ERR
END

COMMON DEF SaveDATAFile PATH$,ARRAY OUT ERR
 PATH$=GetAbsolutePath$(PATH$)
 FSSaveDATAFile ROOTFS,"",PATH$,ARRAY OUT ERR
END

'ちゅうい:symlinkat(2)のきょどう
COMMON DEF SymlinkFile PATH$,TARGET$ OUT ERR
 PATH$=GetAbsolutePath$(PATH$)
 TARGET$=GetAbsolutePath$(TARGET$)
 FSSymlink ROOTFS,"",PATH$,TARGET$ OUT ERR
END

'symlink(2)のきょどう
COMMON DEF SymlinkRelFile PATH$,TARGET$ OUT ERR
 PATH$=GetAbsolutePath$(PATH$)
 IF INSTR(PATH$,"/")!=-1THEN
  ERR=ERROR_INVALIDFILENAME
  RETURN
 ENDIF
 FSSymlink ROOTFS,"",PATH$,TARGET$ OUT ERR
END

'OTYAX PROCESS API
COMMON DEF NewProcess NAME$,ARGS$ OUT PRC,E
 VAR PID,NUPID
 IF PRC_FREE==0 THEN @ERROR
 IF !CHKCALL("I_"+NAME$) THEN @ERROR2
 IF !CHKCALL("L_"+NAME$) THEN @ERROR2
 INC PIDCNT
 PID=PIDCNT
 NUPID=PRC_FREE
 PRC_PID[NUPID]=PID
 PRC_FREE=PRC_NEXT[PRC_FREE]
 PRC_NAME$[NUPID]=NAME$
 PRC_ENTRY$[NUPID]=PRC_INIT$
 PRC_ARGS$[NUPID]=NAME$+" "+ARGS$
 PRC_PREV[NUPID]=0
 PRC_CHILD[NUPID]=0
 PRC_STIME[NUPID]=MILLISEC
 PRC_TIME[NUPID]=0
 PRC_PARENT[NUPID]=RUNNUPID
 PRC_INIT_SIG NUPID
 'VAR 
 VAR C=PRC_CHILD[RunNUPID]
 PRC_CHILD[RunNUPID]=NUPID
 PRC_NEXT[NUPID]=C
 IF C THEN
  PRC_PREV[C]=NUPID
 ENDIF
 PRC_FLG[NUPID]=PRC_FLG_INIT
 IF RUNNUPID THEN
  'TODO:IMPL
  PRC_STDOUT[NUPID]=DupFile(PRC_STDOUT[RUNNUPID])

  PRC_STDIN[NUPID]=DupFile(PRC_STDIN[RUNNUPID])

  PRC_STDERR[NUPID]=DupFile(PRC_STDERR[RUNNUPID])
  PRC_CWD$[NUPID]=PRC_CWD$[RUNNUPID]
  PRC_CON[NUPID]=PRC_CON[RUNNUPID]
  PRC_SES[NUPID]=PRC_SES[RUNNUPID]
  PRC_PGRP[NUPID]=PRC_PGRP[RUNNUPID]
  IF CheckProcess(PRC_SES[NUPID])THEN
   LINKLIST_INS PRC_SESNXT,PRC_SESPRV,PRC_SES[NUPID]AND NUPIDMASK,NUPID
  ELSE
   PRC_SESNXT[NUPID]=0
   PRC_SESPRV[NUPID]=0
  ENDIF
  IF CheckProcess(PRC_PGRP[NUPID])THEN
   LINKLIST_INS PRC_PGRPNXT,PRC_PGRPPRV,PRC_PGRP[NUPID]AND NUPIDMASK,NUPID
  ELSE
   PRC_PGRPNXT[NUPID]=0
   PRC_PGRPPRV[NUPID]=0
  ENDIF
 ELSE
  OutConsoleOpen OUT PRC_STDOUT[NUPID],E
  InConsoleOpen OUT PRC_STDIN[NUPID],E
  PRC_STDERR[NUPID]=PRC_STDOUT[NUPID]
  PRC_CWD$[NUPID]="/"
  PRC_SES[NUPID]=0
  PRC_SESNXT[NUPID]=0
  PRC_SESPRV[NUPID]=0
  PRC_PGRP[NUPID]=0
  PRC_PGRPNXT[NUPID]=0
  PRC_PGRPPRV[NUPID]=0
 ENDIF
 E=SUCCESS
 PRC=PID<<PIDSHIFT OR NUPID
 RETURN
 @ERROR
 PRC=0
 E=ERROR_NEW_PROC
 RETURN
 @ERROR2
 PRC=0
 E=ERROR_NO_PROC
END
COMMON DEF NewSession PRC OUT SES,ERR
 ERR=0
 SES=0
 IF!CheckProcess(PRC)THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 VAR NP=PRC AND NUPIDMASK
 IF PRC_SES[NP]THEN
  LINKLIST_DEL PRC_SESNXT,PRC_SESPRV,NP
 ENDIF
 IF PRC_PGRP[NP]THEN
  LINKLIST_DEL PRC_PGRPNXT,PRC_PGRPPRV,NP
 ENDIF
 PRC_PGRP[NP]=PRC
 PRC_SES[NP]=PRC
END
COMMON DEF GetSession PRC OUT SES,ERR
 IF!CheckProcess(PRC)THEN
  SES=0
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 ERR=0
 SES=PRC_SES[PRC AND NUPIDMASK]
END
COMMON DEF SetProcessGroup PRC,PGRP OUT RETPGRP,ERR
 RETPGRP=0
 IF!PRC THEN PRC=GetProcess()
 IF!PGRP THEN PGRP=PRC
 IF!CheckProcess(PRC)||!CheckProcess(PGRP)THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 VAR SES1,SES2
 GetSession PRC OUT SES1,ERR
 IF ERR THEN RETURN
 GetSession PGRP OUT SES2,ERR
 IF ERR THEN RETURN
 IF SES1!=SES2 THEN
  ERR=ERROR_PERM
  RETURN
 ENDIF
 VAR NP=PRC AND NUPIDMASK
 VAR NPG=PGRP AND NUPIDMASK
 IF PRC_PGRP[NPG]!=PGRP THEN
  IF CheckProcess(PRC_PGRP[NPG])THEN
   'VAR NPG_PGRP=PRC_PGRP[NPG]AND NUPIDMASK
   LINKLIST_DEL PRC_PGRPNXT,PRC_PGRPPRV,NPG
  ENDIF
  PRC_PGRP[NPG]=PGRP
 ENDIF
 IF PRC_PGRP[NP] THEN
  VAR NP_PGRP=PRC_PGRP[NP]AND NUPIDMASK
  LINKLIST_DEL PRC_PGRPNXT,PRC_PGRPPRV,NPG
 ENDIF
 LINKLIST_INS PRC_PGRPNXT,PRC_PGRPPRV,NPG,NP
 PRC_PGRP[NP]=PGRP
END
'HELPER
DEF LINKLIST_INS NXT[],PRV[],HEAD,INS
 VAR N=NXT[HEAD]
 NXT[INS]=N
 PRV[INS]=HEAD
 NXT[HEAD]=INS
 IF N THEN
  PRV[N]=INS
 ENDIF
END
DEF LINKLIST_DEL NXT[],PRV[],IDX
 VAR N=NXT[IDX]
 VAR P=PRV[IDX]
 IF N THEN
  PRV[N]=P
 ENDIF
 IF P THEN
  NXT[P]=N
 ENDIF
 NXT[IDX]=0
 PRV[IDX]=0
END
COMMON DEF GetProcessGroup PRC OUT PGRP,ERR
 IF!CheckProcess(PRC)THEN
  PGRP=0
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 ERR=0
 PGRP=PRC_PGRP[PRC AND NUPIDMASK]
END
COMMON DEF SetSignalHandler PRC,SIG,HNDLR$OUT ERR
 ERR=0
 IF!PRC THEN PRC=GetProcess()
 IF!CheckProcess(PRC)THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 IF!CHKCALL(HNDLR$)THEN
  ERR=ERROR_NOFUNC
  RETURN
 ENDIF
 IF 0>SIG||SIG>=PRC_SIG_MAX THEN
  ERR=ERROR_INVALID
  RETURN
 ENDIF
 PRC_SIGHNDLR$[PRC AND NUPIDMASK,SIG]=HNDLR$
END
COMMON DEF SetSignalHandlerTerm PRC,SIG OUT ERR
 SetSignalHandler PRC,SIG,PRC_SIG_TERM$ OUT ERR
END
COMMON DEF SetSignalHandlerIgnore PRC,SIG OUT ERR
 SetSignalHandler PRC,SIG,PRC_SIG_IGNORE$ OUT ERR
END
COMMON DEF SetSignalHandlerCont PRC,SIG OUT ERR
 SetSignalHandler PRC,SIG,PRC_SIG_CONT$ OUT ERR
END
COMMON DEF SetSignalHandlerStop PRC,SIG OUT ERR
 SetSignalHandler PRC,SIG,PRC_SIG_STOP$ OUT ERR
END
COMMON DEF SendSignal PRC,SIG OUT ERR
 ERR=0
 IF!PRC THEN PRC=GetProcess()
 IF!CheckProcess(PRC)THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 IF 0>SIG||SIG>=PRC_SIG_MAX THEN
  ERR=ERROR_INVALID
  RETURN
 ENDIF
 VAR NP=PRC AND NUPIDMASK
 VAR F=(1<<(SIG-1)) AND NOT PRC_SIGMASK[NP]
 IF!F THEN RETURN
 PRC_SIG[NP]=PRC_SIG[NP] OR F
 PRC_ENTRY$[NP]="PRC_SIG"
END
COMMON DEF SetProcessVar DAT
 PRC_DAT[RUNNUPID]=DAT
END
COMMON DEF GetProcessVar()
 RETURN PRC_DAT[RUNNUPID]
END
COMMON DEF CheckProcess(PRC)
 RETURN PRC_PID[PRC AND NUPIDMASK]==PRC>>PIDSHIFT
END
DEF CheckProcess2(PID,NUPID)
 RETURN PRC_PID[NUPID]==PID
END
COMMON DEF GetProcessArgs$()
 RETURN PRC_ARGS$[RUNNUPID]
END
COMMON DEF GetSTDIN()
 RETURN PRC_STDIN[RUNNUPID]
END
COMMON DEF GetSTDOUT()
 RETURN PRC_STDOUT[RUNNUPID]
END
COMMON DEF GetSTDERR()
 RETURN PRC_STDERR[RUNNUPID]
END
COMMON DEF SetProcessSTDIN PRC,STDIN
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDIN[PRC AND NUPIDMASK]=STDIN
END
COMMON DEF SetProcessSTDOUT PRC,STDOUT
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDOUT[PRC AND NUPIDMASK]=STDOUT
END
COMMON DEF SetProcessSTDERR PRC,STDERR
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDERR[PRC AND NUPIDMASK]=STDERR
END
COMMON DEF GetProcessSTDIN(PRC)
 IF!CheckProcess(PRC)THEN RETURN 0
 RETURN PRC_STDIN[PRC AND NUPIDMASK]
END
COMMON DEF GetProcessSTDOUT(PRC)
 IF!CheckProcess(PRC)THEN RETURN
 RETURN PRC_STDOUT[PRC AND NUPIDMASK]
END
COMMON DEF GetProcessSTDERR(PRC)
 IF!CheckProcess(PRC)THEN RETURN
 RETURN PRC_STDERR[PRC AND NUPIDMASK]
END
COMMON DEF GetPID()
 RETURN PRC_PID[RUNNUPID]
END
COMMON DEF GetNUPID()
 RETURN RUNNUPID
END
COMMON DEF GetProcess()
 RETURN PRC_PID[RUNNUPID]<<PIDSHIFT OR RUNNUPID
END
COMMON DEF NUPIDToPID(NUPID)
 RETURN PRC_PID[NUPID]
END
COMMON DEF ExitProcess RESULT
 VAR ERR
 KillProcess RUNPRC OUT ERR
END
COMMON DEF KillProcess PRC OUT ERR
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF!NUPID THEN RETURN
 IF !CheckProcess(PRC) THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 VAR PNUPID=PRC_PREV[NUPID]
 VAR NNUPID=PRC_NEXT[NUPID]
 IF PNUPID THEN
  PRC_NEXT[PNUPID]=NNUPID
 ENDIF
 IF NNUPID THEN
  PRC_PREV[NNUPID]=PNUPID
 ENDIF
 IF FIRSTNUPID==NUPID THEN
  FIRSTNUPID=PRC_NEXT[NUPID]
  IF!FIRSTNUPID THEN
   FIRSTNUPID=PRC_CHILD[NUPID]
  ENDIF
 ENDIF
 VAR PANUPID=PRC_PARENT[NUPID]
 IF PRC_CHILD[PANUPID]==NUPID THEN
  PRC_CHILD[PRC_PARENT[NUPID]]=NNUPID
 ENDIF
 VAR CNUPID=PRC_CHILD[NUPID]
 PRC_PID[NUPID]=0
 VAR NXT
 ' ころころしていく
 'こはころさない
 VAR WE
 WHILE CNUPID
  NXT=PRC_NEXT[CNUPID]
  PRC_PARENT[CNUPID]=FIRSTNUPID
  IF !NXT THEN WE=CNUPID:BREAK
  CNUPID=NXT
 WEND
 CNUPID=PRC_CHILD[NUPID]
 IF CNUPID THEN
  IF FIRSTNUPID THEN
   NXT=PRC_CHILD[FIRSTNUPID]
   PRC_CHILD[FIRSTNUPID]=CNUPID
   PRC_NEXT[WE]=NXT
   PRC_PREV[NXT]=WE
  ELSE
   FIRSTNUPID=CNUPID
  ENDIF
 ENDIF
 RUNNUPID=PRC_PARENT[NUPID]
 PRC_NEXT[NUPID]=PRC_FREE
 PRC_FREE=NUPID
 PRC_PREV[NUPID]=0
 PRC_NAME$[NUPID]=NULL$()
 PRC_ENTRY$[NUPID]=NULL$()
 VAR I
 FOR I=0TO PRC_SIG_MAX-1
  PRC_SIGHNDLR$[NUPID,I]=NULL$()
 NEXT
 ERR=SUCCESS
 VOID FileClose(PRC_STDOUT[NUPID])
 VOID FileClose(PRC_STDERR[NUPID])
 VOID FileClose(PRC_STDIN[NUPID])
END
COMMON DEF HasChildProcess(PRC)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN 0
 ENDIF
 RETURN !!PRC_CHILD[NUPID]
END
COMMON DEF GetProcessTime(PRC)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN 0
 ENDIF
 RETURN PRC_TIME[NUPID]
END
COMMON DEF GetProcessElapsedTime(PRC)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN 0
 ENDIF
 RETURN MILLISEC-PRC_STIME[NUPID]
END
COMMON DEF GetParentProcess(PRC)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN 0
 ENDIF
 RETURN PRC_PID[PRC_PARENT[NUPID]]<<PIDSHIFT OR PRC_PARENT[NUPID]
END
COMMON DEF GetProcessPID(PRC)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN 0
 ENDIF
 RETURN PRC_PID[NUPID]
END
COMMON DEF GetProcessName$(PRC)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN ""
 ENDIF
 RETURN PRC_NAME$[NUPID]
END
COMMON DEF GetRootProcess()
 RETURN PRC_PID[FIRSTNUPID]<<PIDSHIFT OR FIRSTNUPID
END
COMMON DEF GetChildProcesses(PRC,ARY[],R)
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF !CheckProcess(PRC) THEN
  RETURN 0
 ENDIF
 VAR L=0
 VAR C=PRC_CHILD[NUPID]
 WHILE C
  IF C==NUPID THEN BREAK
  VAR P=PRC_PID[C]<<PIDSHIFT OR C
  IF LEN(ARY)>L THEN
   ARY[L]=P
  ELSE
   PUSH ARY,P
  ENDIF
  INC L
  IF R&&PRC_CHILD[C] THEN
   C=PRC_CHILD[C]
  ELSE 
   IF PRC_NEXT[C] THEN
    C=PRC_NEXT[C]
   ELSE
    VAR __R=C
    C=PRC_NEXT[PRC_PARENT[C]]
    IF C==NUPID THEN BREAK
    IF!C THEN
     C=PRC_PARENT[__R]
     IF C==NUPID THEN BREAK
     WHILE 1
      __R=C
      C=PRC_NEXT[PRC_PARENT[C]]
      IF C==NUPID THEN BREAK
      IF!C THEN
       C=PRC_PARENT[__R]
       IF C==NUPID THEN BREAK
       IF!C THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 WEND
 RETURN L
END

'COMMAND
COMMON DEF ExecCommand LINE$ OUT PRC,ERR
 IF INSTR(LINE$,"|")==-1THEN
  ExecCommand_ LINE$ OUT PRC,ERR
  RETURN
 ENDIF
 DIM COMMAND$[0]
 COMMAND$=Split(LINE$,"|")
 VAR I
 VAR FIRST
 VAR OLD
 FOR I=0TO LEN(COMMAND$)-1
  ExecCommand_ COMMAND$[I] OUT PRC,ERR
  IF!I THEN
   FIRST=PRC
  ELSE
   VAR PIPEIN,PIPEOUT
   OpenPipeFile PRC,OLD OUT PIPEIN,PIPEOUT,ERR
   SetProcessSTDOUT OLD,PIPEOUT
   SetProcessSTDIN PRC,PIPEIN
  ENDIF
  OLD=PRC
 NEXT
END
DEF ExecCommand_ LINE$ OUT PRC,ERR
'?"TRACE:ExecCommand ";LINE$
 VAR L=LEN(LINE$)-1
 VAR I,C$=""
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 FOR I=0TO L
  C$=MID$(LINE$,I,1)
  IF C$==" " AND S==RDNAME THEN
   ENDNAME=I
   BREAK
  ELSE
   IF C$!=" " AND S==RDSP THEN START=I:S=RDNAME
  ENDIF
 NEXT
 VAR NAME$="",ARG$=""
 IF !ENDNAME THEN
  IF START THEN
    NAME$=MID$(LINE$,START,L-START+1)
   ELSE
    NAME$=LINE$
   ENDIF
   ARG$=""'NAME$
 ELSE
  NAME$=MID$(LINE$,START,ENDNAME-START)
  VAR ARGSTART=ENDNAME+1,STARTARG=1,ARGEND=999
  FOR I=ENDNAME+1 TO L
   IF STARTARG&&LINE$[I]!=" "THEN
    ARGSTART=I
    STARTARG=0
    CONTINUE
   ENDIF
   IF!STARTARG&&LINE$[I]!=" "THEN
    ARGEND=I
   ENDIF
  NEXT
  ARG$=MID$(LINE$,ARGSTART,ARGEND-ARGSTART+1)'ENDNAME+1,L-ENDNAME)
  'ARG$=MID$(LINE$,START,ENDNAME-START+L-ENDNAME+1)
 ENDIF
'?"AAAAA";ARG$;"#
 L=LEN(ARG$)-1
 VAR FILE,ARG2$=ARG$,NXT
 VAR INFILE=1,PIPE=2
 VAR HASPIPE=INSTR(ARG$,"|")!=-1
 FOR I=0TO L
  C$=MID$(ARG2$,I,1)
  IF C$=="|"THEN
   VAR SI=ENDNAME+1+I
   IF!ENDNAME THEN SI=I
   VAR PRC2
   ExecCommand LEFT$(LINE$,SI-1) OUT PRC,ERR
   VAR PIPEFILE=OpenPipeFile()
   SetProcessSTDOUT PRC,PIPEFILE
   ExecCommand MID$(LINE$,SI+1,LEN(LINE$)-SI-1) OUT PRC2,ERR
   ?LEFT$(LINE$,SI-1);",";MID$(LINE$,SI+1,LEN(LINE$)-SI-1);",";PIPEFILE
   SetProcessSTDIN PRC2,PIPEFILE
   SWAP PRC,PRC2
   RETURN
  ENDIF
  IF HASPIPE THEN CONTINUE
  IF C$=="<" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
   DIALOG C$
   FileOpen C$,FileReadFlag() OUT FILE,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PRC,ERR
   SetProcessGroup PRC,PRC OUT ,
   IF ERR THEN RETURN
   SetProcessSTDIN PRC,FILE
   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
  IF C$==">" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
   FileOpen C$,FileWriteFlag()OR FileCreateFlag() OUT FILE,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PRC,ERR
   SetProcessGroup PRC,PRC OUT ,
   IF ERR THEN RETURN
   SetProcessSTDOUT PRC,FILE
'   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
 NEXT
' ?ARG$;"RUN:";NAME$
 NewProcess NAME$,ARG$ OUT PRC,ERR
 SetProcessGroup PRC,PRC OUT ,

END
COMMON DEF GetCommandArgsWithoutName$(ARGS$)
 VAR CMD$,I
 GetCommandArg ARGS$,I OUT CMD$,I
 ARGS$=MID$(ARGS$,I,LEN(ARGS$)-I)
 VAR SP=INSTR(ARGS$," ")
 IF SP==-1THEN RETURN ARGS$
 FOR I=0 TO LEN(ARGS$)-1
  VAR C$=ARGS$[I]
  IF C$!=" "THEN BREAK
 NEXT
 ARGS$=MID$(ARGS$,I,LEN(ARGS$)-I)
 RETURN ARGS$
END
COMMON DEF GetCommandArg ARGS$,I OUT CMD$,INDEX
 IF I==-1 THEN CMD$="":INDEX=-1:RETURN
 VAR L=LEN(ARGS$)-1
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 VAR C$=""
 CMD$=""INDEX=-1
 FOR I=I TO L
  C$=ARGS$[I]
  IF S==RDSP AND C$!=" " THEN
   START=I
   S=RDNAME
   DEC I
  ELSE
   IF S==RDNAME THEN
    IF C$==" " THEN
     INDEX=I
     CMD$=MID$(ARGS$,START,I-START)
     RETURN
    ENDIF
    IF C$=="\"THEN
     INC I
     IF I>L THEN
      C$=""
     ELSE
      C$=ARGS$[I]
     ENDIF
    ENDIF
    PUSH CMD$,C$
   ENDIF
  ENDIF
 NEXT
 IF S==RDNAME THEN
  INDEX=L+1
 ENDIF
END
COMMON DEF CommandArgsToArray ARY$[],EXPAND OUT LEN
 VAR ARGS$=GetProcessArgs$()
 VAR C$=""
 LEN=0
 VAR I
 WHILE 1
  GetCommandArg ARGS$,I OUT C$,I
  IF I==-1 THEN BREAK
  'FLGがTRUEなら はいれつを かくちょう
  IF EXPAND THEN IF LEN<=LEN(ARY$) THEN
   PUSH ARY$,""
  ELSE
   BREAK
  ENDIF
  ARY$[LEN]=C$
  INC LEN
 WEND
END

DEF OpenPipeFile INPRC,OUTPRC OUT INFILE,OUTFILE,ERR
 OUTFILE=0
 AllocPipeFile FALSE OUT INFILE,ERR
 IF ERR THEN RETURN
 AllocPipeFile TRUE OUT OUTFILE,ERR
 IF ERR THEN RETURN
 VAR PTR1=malloc(4)
 VAR PTR2=malloc(4)
 SetFileData OUTFILE,PTR1
 SetFileData INFILE,PTR2
 WriteInt PTR1+0,INPRC
 WriteInt PTR1+1,OUTPRC
 WriteInt PTR1+2,OUTFILE
 WriteInt PTR1+3,INFILE
 
 WriteInt PTR2+0,INPRC
 WriteInt PTR2+1,OUTPRC
 WriteInt PTR2+2,OUTFILE
 WriteInt PTR2+3,INFILE
END
DEF AllocPipeFile WR OUT FILE,E
 AllocFile OUT FILE,E
 IF E THEN RETURN
 IF WR THEN
  E=SetWriter(FILE,"PIPWRITER")
 ELSE
  E=SetReader(FILE,"PIPREADER")
  E=SetReadln(FILE,"TXTREADLN")
 ENDIF
 E=SetClose(FILE,"PIPCLOSE")
 ' E=SetFlush(FILE,"TXTFLUSH")
END
DEF PipClose FILE
 VAR PTR
 GetFileData FILE OUT PTR
 free PTR
END
DEF PipReadln FILE OUT DAT$,ERR
 
END
DEF PipWriter(FILE,DAT$)
 VAR PTR
 GetFileData FILE OUT PTR
 FILE=ReadInt(PTR+3)
 SetFileDataStr FILE,GetFileDataStr$(FILE)+DAT$
 RETURN SUCCESS
END
DEF PipReader FILE,LEN OUT DAT$,ERR
 TxtReader FILE,LEN OUT DAT$,ERR
 SetFileEOF FILE,FALSE
 IF!LEN||LEN(DAT$)THEN
  RETURN SUCCESS
 ENDIF
 'EOF
 'TORIMA
 VAR PTR
 GetFileData FILE OUT PTR
 VAR OUTFILE=ReadInt(PTR+3)
 VAR INPRC=ReadInt(PTR+1)
 IF!CheckProcess(INPRC)||!CheckFile(OUTFILE)||IsFileEOF(OUTFILE)THEN
  SetFileEOF FILE,TRUE
 ELSE
  SetFileEOF FILE,FALSE
 ENDIF
END
COMMON DEF FileReadFlag()
 RETURN FILE_READ_FLAG
END
COMMON DEF FileWriteFlag()
 RETURN FILE_WRITE_FLAG
END
COMMON DEF FileAppendFlag()
 RETURN FILE_APPEND_FLAG
END
COMMON DEF FileCreateFlag()
 RETURN FILE_CREATE_FLAG
END
'OTYAX FILE API
'TXT:FILE を OPEN
COMMON DEF FileOpen NAME$,FLG OUT FILE,E
' IF!CHKFILE("TXT:"+NAME$) THEN E=ERROR_NOFILE:FID=0NUFID=0RETURN
 NAME$=GetAbsolutePath$(NAME$)
 FSOpenFile ROOTFS,"",NAME$,FLG OUT FILE,E
 RETURN
END
DEF TxtClose FILE
 IF GetFileData(FILE)==1THEN SAVE GetFileName$(FILE),GetFileDataStr$(FILE)
END
DEF TxtReadLn FILE OUT DAT$,ERR
 ERR=SUCCESS
 VAR POS
 GetFilePos FILE OUT POS,ERR
 VAR STR$=GetFileDataStr$(FILE)
 IF LEN(STR$)<=POS THEN
  DAT$=""
  ERR=ERROR_NOFILECONTENT
  RETURN
 ENDIF
 VAR LEN=INSTR(POS,STR$,LF$())
 IF LEN==-1THEN
  LEN=LEN(STR$)-POS
 ELSE
  LEN=LEN-POS
 ENDIF
 TxtReader FILE,LEN OUT DAT$,ERR
END
DEF TxtReader FILE,LEN OUT DAT$,ERR
 ERR=SUCCESS
 VAR POS
 GetFilePos FILE OUT POS,ERR
 VAR STR$=GetFileDataStr$(FILE)
 DAT$=MID$(STR$,POS,MIN(LEN,MAX(0,LEN(STR$)-POS)))
 IF!LEN(DAT$)THEN
  SetFileEOF FILE,TRUE
 ELSE
  FileSeekCUR FILE,LEN(DAT$) OUT ERR
 ENDIF
END
DEF TxtWriter(FILE,DAT$)
 SetFileData FILE,1
 SetFileDataStr FILE,GetFileDataStr$(File)+DAT$
 RETURN SUCCESS
END
COMMON DEF FileWrite(FILE,DAT$)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFile(FILE) THEN
  RETURN ERROR_NOPENFILE
 ENDIF
 VAR E=CALL(FILES_WRITER$[NUFID],FILE,DAT$)
 RETURN SUCCESS
END
COMMON DEF FileRead FILE,LEN OUT DAT$,E
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFile(FILE) THEN
  DAT$=""
  E=ERROR_NOPENFILE
  RETURN
 ENDIF
 IF !LEN THEN RETURN
 CALL FILES_READER$[NUFID],FILE,LEN OUT DAT$,E
 E=SUCCESS
END
COMMON DEF FileClose(FILE)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN
  RETURN ERROR_NOPENFILE
 ENDIF
 IF LEN(FILES_CLOSE$[NUFID]) THEN
  CALL FILES_CLOSE$[NUFID],FILE
 ENDIF
 FILES_FID[NUFID]=0
 FILES_NEXT[NUFID]=FILES_FREE
 FILES_FREE=NUFID
 RETURN SUCCESS
END
COMMON DEF IsFileEOF(FILE)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOPENFILE
 RETURN FILES_ISEOF[NUFID]
END
COMMON DEF DupFile(FILE)
 VAR N2=FILE AND NUFIDMASK
 VAR NUFID,E
 AllocFile OUT FILE,E
 IF E THEN RETURN FILE
 FILES_ISEOF[NUFID]=FILES_ISEOF[N2]
 NUFID=FILE AND NUFIDMASK
 FILES_PID[NUFID]=FILES_PID[N2]
 FILES_NAME$[NUFID]=FILES_NAME$[N2]
 FILES_DAT[NUFID]=FILES_DAT[N2]
 FILES_DATSTR$[NUFID]=FILES_DATSTR$[N2]+""
 FILES_WRITER$[NUFID]=FILES_WRITER$[N2]
 FILES_READER$[NUFID]=FILES_READER$[N2]
 FILES_READLN$[NUFID]=FILES_READLN$[N2]
 FILES_CLOSE$[NUFID]=FILES_CLOSE$[N2]
 FILES_POS[NUFID]=FILES_POS[N2]
 FILES_ISEOF[NUFID]=FILES_ISEOF[N2]
 RETURN NUFIDTOFILE(NUFID)
END
DEF AllocFile OUT FILE,E
 IF FILES_FREE==0 THEN
  FILE=0
  E=ERROR_NOALLOCFILE
  RETURN
 ENDIF
 INC FILES_FIDCNT
 VAR NUFID=FILES_FREE
 FILES_FID[NUFID]=FILES_FIDCNT
 FILES_ISEOF[NUFID]=0
 FILES_POS[NUFID]=0
 FILES_DAT[NUFID]=0
 VAR FID=FILES_FIDCNT
 FILES_FREE=FILES_NEXT[FILES_FREE]
 E=SUCCESS
 FILE=NUFID OR FID<<FIDSHIFT
END
COMMON DEF NUFIDToFID(NUFID)
 RETURN FILES_FID[NUFID]
END
COMMON DEF NUFIDToFile(NUFID)
 RETURN NUFID OR FILES_FID[NUFID]<<FIDSHIFT
END
'FIDがせいじょうならTRUE
COMMON DEF CheckFID(FID,NUFID)
 RETURN FILES_FID[NUFID]==FID
END
COMMON DEF CheckFile(FILE)
 RETURN (FILE AND NUFIDMASK)>0&&(FILE AND NUFIDMASK)<LEN(FILES_FID)&&FILES_FID[FILE AND NUFIDMASK]==FILE>>FIDSHIFT
END
DEF SetWriter(FILE,FUNC$)
 IF!CheckFILE(FILE) THEN RETURN ERROR_NOFILE
 FILES_WRITER$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF SetFileData FILE,DAT
 IF!CheckFILE(FILE) THEN RETURN
 FILES_DAT[FILE AND NUFIDMASK]=DAT
END
DEF GetFileData(FILE)
 IF!CheckFILE(FILE) THEN RETURN -1
 RETURN FILES_DAT[FILE AND NUFIDMASK]
END
DEF SetFIDDataStr FID,NUFID,DAT$
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_DATSTR$[NUFID]=DAT$
END
DEF GetFIDDataStr$(FID,NUFID)
 IF !CheckFID(FID,NUFID) THEN RETURN ""
 RETURN FILES_DATSTR$[NUFID]
END
DEF SetFileDataStr FILE,DAT$
 IF!CheckFile(FILE) THEN RETURN
 FILES_DATSTR$[FILE AND NUFIDMASK]=DAT$
END
DEF GetFileDataStr$(FILE)
 IF !CheckFile(FILE) THEN RETURN ""
 RETURN FILES_DATSTR$[FILE AND NUFIDMASK]
END
DEF SetFileName FILE,DAT$
 IF!CheckFile(FILE) THEN RETURN
 FILES_NAME$[FILE AND NUFIDMASK]=DAT$
END
DEF GetFileName$(FILE)
 IF !CheckFile(FILE) THEN RETURN ""
 RETURN FILES_NAME$[FILE AND NUFIDMASK]
END
DEF SetFileEOF FILE,EOF
 IF!CheckFile(FILE) THEN RETURN
 FILES_ISEOF[FILE AND NUFIDMASK]=EOF
END
DEF SetReader(FILE,FUNC$)
 IF !CheckFile(FILE) THEN RETURN ERROR_NOFILE
 FILES_READER$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF SetReadln(FILE,FUNC$)
 IF !CheckFile(FILE) THEN RETURN ERROR_NOFILE
 FILES_READLN$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF SetClose(FILE,FUNC$)
 IF !CheckFile(FILE) THEN RETURN ERROR_NOFILE
 FILES_CLOSE$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF OutConsoleOpen OUT FILE,E
 AllocFile OUT FILE,E
 E=SETWRITER(FILE,"CONSOLEWRITERSTR")
END
DEF InConsoleOpen OUT FILE,E
 AllocFile OUT FILE,E
 E=SETREADER(FILE,"CONSOLEREADERSTR")
END
COMMON DEF FileSeekCUR FILE,LEN OUT ERR
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF !CheckFID(FID,NUFID) THEN ERR=ERROR_NOFILE:RETURN
 FILES_POS[NUFID]=MAX(FILES_POS[NUFID]+LEN,0)
 ERR=SUCCESS
END
COMMON DEF GetFilePos FILE OUT POS,ERR
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF !CheckFID(FID,NUFID) THEN POS=0:ERR=ERROR_NOFILE:RETURN
 POS=FILES_POS[NUFID]
 ERR=ERROR_NOFILE
END
VAR CON_ESC
VAR CON_ESC_SEQ$
VAR CON_ESC_LB
DIM CON_COLOR_TBL[0]
VAR CON_INIT
DEF ConsoleWriterStr(FILE,DAT$)
 RETURN PutConsole(GetConsole(),DAT$)
END
DEF ConsoleWriterStr_(DAT$)
 'VAR 
 IF!SPUSED(0)THEN
  SPSET 0,6,40,1,1
  SPSCALE 0,2,8
  SPCOLOR 0,-1
 ENDIF
 IF !CON_INIT THEN
  CON_INIT=TRUE
  CON_COLOR_TBL=NewArray(16)
  CON_COLOR_TBL[0]=#TBLACK
  CON_COLOR_TBL[1]=#TMAROON
  CON_COLOR_TBL[2]=#TGREEN
  CON_COLOR_TBL[3]=#TOLIVE
  CON_COLOR_TBL[4]=#TNAVY
  CON_COLOR_TBL[5]=#TPURPLE
  CON_COLOR_TBL[6]=#TTEAL
  CON_COLOR_TBL[7]=#TGRAY
  CON_COLOR_TBL[8]=#TBLACK
  CON_COLOR_TBL[9]=#TRED
  CON_COLOR_TBL[10]=#TGREEN
  CON_COLOR_TBL[11]=#TYELLOW
  CON_COLOR_TBL[12]=#TBLUE
  CON_COLOR_TBL[13]=#TMAGENTA
  CON_COLOR_TBL[14]=#TCYAN
  CON_COLOR_TBL[15]=#TWHITE
 ENDIF
 VAR L=LEN(DAT$)-1
 VAR I
 '?DAT$;
 FOR I=0 TO L
  VAR D$=MID$(DAT$,I,1)
  IF CON_ESC THEN
   IF LEN(CON_ESC_SEQ$)==0THEN
    IF D$=="["THEN
     CON_ESC_LB=TRUE
     CONTINUE
    ENDIF
   ENDIF
   IF CON_ESC_LB THEN
    IF D$==";"||(D$>="0"&&D$<="9")THEN
     PUSH CON_ESC_SEQ$,D$
     CONTINUE
    ELSE
     'END
     CON_ESC_LB=FALSE
     CON_ESC=FALSE
     CON_LBESCSEQ CON_ESC_SEQ$,D$
     CON_ESC_SEQ$=""
     CONTINUE
    ENDIF
   ENDIF
   CON_ESC=FALSE
  ENDIF
  IF D$==LF$ THEN
   PRINT
  ELSEIF D$==CR$THEN
   LOCATE 0,
  ELSEIF D$==ESC$THEN
   CON_ESC=TRUE
  ELSEIF D$==BS$THEN
   IF CSRX!=0 THEN
    LOCATE CSRX-1,
   ELSEIF CSRY!=0THEN
    LOCATE 49,CSRY-1
   ENDIF
  ELSEIF D$==HTAB$ THEN
   PRINT "",
  ELSE
   PRINT D$;
  ENDIF
 NEXT
 SPOFS 0,CSRX*8,CSRY*8
 RETURN SUCCESS
END
'n;m;...
DEF CON_LBESCSEQ S$,C$
 VAR I,L=LEN(S$)-1
 VAR C=-1
 WHILE 1
  IF I==-1THEN BREAK
  I=INSTR(S$,";")
  INC C
  VAR NUM$
  IF I==-1THEN
   NUM$=S$
  ELSE
   NUM$=MID$(S$,0,I)
   S$=MID$(S$,I+1,LEN(S$))
  ENDIF
  VAR NUM=VAL(NUM$)
  IF C$=="A"||C$=="F"THEN
   IF LEN(S$)==0THEN NUM=1
   LOCATE ,MAX(CSRY-NUM,0)
   IF C$=="F"THEN LOCATE 0,
  ENDIF
  IF C$=="B"||C$=="E"THEN
   IF LEN(S$)==0THEN NUM=1
   LOCATE ,MIN(CSRY-NUM,29)
   IF C$=="E"THEN LOCATE 0,
  ENDIF
  IF C$=="C"THEN
   IF LEN(S$)==0THEN NUM=1
   LOCATE MAX(CSRX-NUM,0),
  ENDIF
  IF C$=="D"THEN
   IF LEN(S$)==0THEN NUM=1
   LOCATE MIN(CSRX-NUM,39),
  ENDIF
  IF C$=="m"THEN
   'SGR
   IF NUM==0THEN
    'ALL ATTRBUTES OFF
    COLOR CON_COLOR_TBL[7],CON_COLOR_TBL[0]
   ELSEIF NUM>=30&&NUM<=37THEN
    COLOR CON_COLOR_TBL[NUM-30]
   ELSEIF NUM>=40&&NUM<=47THEN
    COLOR ,CON_COLOR_TBL[NUM-40]
   ENDIF
  ENDIF
  IF C$=="H"||C$=="f"THEN
   IF LEN(S$)==0THEN NUM=1
   IF C==0THEN LOCATE ,MIN(MAX(NUM,29),0)
   IF C==1THEN LOCATE MIN(MAX(NUM,39),0),
  ENDIF
 WEND
END
DEF ConsoleReaderStr FILE,LEN OUT DAT$,E
 ReadConsole GetConsole(),LEN OUT DAT$,E
 RETURN
 DAT$=INKEY$()
 IF DAT$==CR$THEN DAT$=LF$
 E=SUCCESS
 IF!LEN(DAT$) THEN
  RETURN
 ENDIF
 VAR K$,I
 FOR I=0TO LEN-2
  K$=INKEY$()
  IF !LEN(K$)THEN RETURN
  IF K$==CR$THEN K$=LF$
  DAT$=DAT$+K$
 NEXT
END
COMMON DEF PRINTCONSOLE STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],STR$)
END
COMMON DEF PRINTCONSOLELN STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],STR$+LF$)
END
COMMON DEF INKEYCONSOLE$(LEN)
 VAR STR$="",E
 FileRead PRC_STDIN[RUNNUPID],LEN OUT STR$,E
 RETURN STR$
END
COMMON DEF LOCATECONSOLE X,Y
 LOCATE X,Y
END
COMMON DEF FORECOLORCONSOLE C
 COLOR C
END
COMMON DEF BACKCOLORCONSOLE C
 COLOR ,C
END
'OTYAX APPS
DEF I_INIT
 VAR P,E
 NewSession GetProcess()OUT,
 E=SetCurrentDir(GetHomeDir$())
 NewProcess INITPROC$,"" OUT P,E
 NewSession P OUT ,
END
DEF L_INIT
 IF!PRC_CHILD[RUNNUPID]THEN
'IF!HasChildProcess(GetProcess())THEN
  ExitProcess 0
 ENDIF
END
VAR SH_CNT=0
VAR SH_SIZ
VAR SH_INPUT
VAR SH_STATE
VAR SH_PRC

VAR SH_STATE_READ
VAR SH_STATE_EXEC
VAR SH_STATE_EXECEXIT
VAR SH_INIT
DEF I_SH
 IF!SH_INIT THEN
  SH_INITAST
  SH_INIT=TRUE
 ENDIF
 DIM ARGS$[0]
 VOID CommandArgsToArray(ARGS$,TRUE)
 SH_STATE_READ=1
 SH_STATE_EXEC=2
 SH_STATE_EXECEXIT=3
 VAR STATE=SH_STATE_READ
 
 IF LEN(ARGS$)>=3&&ARGS$[1]=="-c"THEN
  STATE=SH_STATE_EXECEXIT
 ENDIF

 SetProcessVar AllocSBArray()
 SH_INPUT  =0
 SH_PRC    =1
 SH_STATE  =2
 SH_SIZ    =3
 
 DIM A[SH_SIZ]
 A[SH_INPUT]=AllocString("")
 A[SH_STATE]=STATE
 SetSBArray GetProcessVar(),A
 IF STATE!=SH_STATE_EXECEXIT THEN
  PrintConsoleln "OTYAX shell"
  PrintConsolelN VER$
  SH_PROMPT
 ENDIF
END
DEF SH_EXIT
 IF 0THEN DIM A[0]
 A=GetSBArray(GetProcessVar())
 FreeString A[SH_INPUT]
 FreeSBArray GetProcessVar()
END
DEF SH_PROMPT
 VAR ERR
 SetConsoleForeColor GetConsole(),#TBLUE OUT ERR
 PrintConsole GetCurrentDir$()+"$"
 SetConsoleForeColor GetConsole(),#TGRAY OUT ERR
END
'SHELL AST
DIM SH_AST_TYP[0]
DIM SH_AST_L[0]
DIM SH_AST_R[0]
DIM SH_AST_V[0]
DIM SH_AST_V$[0]
DIM SH_AST_PARENT[0]
VAR SH_AST_FREE
VAR SH_AST_TYP_CMD
VAR SH_AST_TYP_PIPE
VAR SH_AST_TYP_IN
VAR SH_AST_TYP_OUT
VAR SH_AST_TYP_ARG
VAR SH_AST_TYP_ASY
VAR SH_AST_TYP_AND
VAR SH_AST_TYP_SEQ
VAR SH_AST_TYP_OR
DEF SH_INITAST
 SH_AST_TYP     =NewArray(1)
 SH_AST_L       =NewArray(1)
 SH_AST_R       =NewArray(1)
 SH_AST_V$      =NewArray$(1)
 SH_AST_V       =NewArray(1)
 SH_AST_PARENT  =NewArray(1)
 SH_AST_TYP_CMD=1
 SH_AST_TYP_PIPE=2
 SH_AST_TYP_IN=3
 SH_AST_TYP_OUT=4
 SH_AST_TYP_ARG=5
 'PIP < AND,OR < SEQ,ASYNC(SEPARATOR)
 'Asynchronous Lists (&)
 SH_AST_TYP_ASY=6
 'AND Lists (&&)
 SH_AST_TYP_AND=7
 'Sequential Lists (;)
 SH_AST_TYP_SEQ=8
 'OR Lists (||)
 SH_AST_TYP_OR=9
END
DEF SH_NEWCMD(P)
 RETURN SH_NEWAST(SH_AST_TYP_CMD,0,0,0,P)
END
DEF SH_NEWPIPE(P)
 RETURN SH_NEWAST(SH_AST_TYP_PIPE,0,0,0,P)
END
DEF SH_NEWASY(P)
 RETURN SH_NEWAST(SH_AST_TYP_ASY,0,0,0,P)
END
DEF SH_NEWAND(P)
 RETURN SH_NEWAST(SH_AST_TYP_AND,0,0,0,P)
END
DEF SH_NEWSEQ(P)
 RETURN SH_NEWAST(SH_AST_TYP_SEQ,0,0,0,P)
END
DEF SH_NEWOR(P)
 RETURN SH_NEWAST(SH_AST_TYP_OR,0,0,0,P)
END
'ARG V$:STR
DEF SH_NEWARG(V$,P)
 RETURN SH_NEWAST(SH_AST_TYP_ARG,0,0,V$,P)
END
DEF SH_NEWIN(A,P)
 RETURN SH_NEWAST(SH_AST_TYP_IN,A,0,0,P)
END
DEF SH_NEWOUT(A,P)
 RETURN SH_NEWAST(SH_AST_TYP_OUT,A,0,0,P)
END
DEF SH_DELAST AST
 SH_AST_V$[AST]=NULL$()
 SH_AST_L[AST]=SH_AST_FREE
 SH_AST_FREE=AST
END
DEF SH_NEWAST(TYP,L,R,V,P)
 VAR ISSTR=V>0==3
 VAR I
 IF!SH_AST_FREE THEN
  I=LEN(SH_AST_TYP)
  PUSH SH_AST_TYP,0
  PUSH SH_AST_L,0
  PUSH SH_AST_R,0
  PUSH SH_AST_V$,NULL$()
  PUSH SH_AST_V,0
  PUSH SH_AST_PARENT,0
 ELSE
  I=SH_AST_FREE
  SH_AST_FREE=SH_AST_L[SH_AST_FREE]
 ENDIF
 SH_AST_TYP[I]=TYP
 SH_AST_L[I]=L
 SH_AST_R[I]=R
 IF ISSTR THEN
  SH_AST_V$[I]=V
 ELSE
  SH_AST_V[I]=V
 ENDIF
 SH_AST_PARENT[I]=P
 RETURN I
END
DEF SH_PARSEARG IN$,I,P OUT I2,AST
 VAR L=LEN(IN$)-1
 AST=0
 VAR C$=""
 VAR STATE=0
 FOR I2=I TO L
  VAR C=ASC(IN$[I2])
  IF!STATE&&C==32 THEN CONTINUE
  IF C==60 THEN BREAK
  IF C==59 THEN BREAK';
  IF C==38&&"&"==MID$(IN$,I2+1,1) THEN BREAK
  IF C==62 THEN BREAK
  IF C==124THEN BREAK
  IF STATE!=39THEN
   IF C==32 THEN BREAK
   IF C==92 THEN
    IF I2!=L THEN
     I2=I2+1
     C=ASC(IN$[I2])
    ENDIF
   ENDIF
   'SINGLE QUOTE
   IF C==39 THEN
    STATE=39
    CONTINUE
   ENDIF
  ELSE
   IF C==39 THEN
    STATE=1
    CONTINUE
   ENDIF
  ENDIF
  IF!STATE THEN STATE=1
  PUSH C$,CHR$(C)
 NEXT
 IF!STATE THEN
  RETURN
 ENDIF
 IF I2==I THEN
  RETURN
 ENDIF
 IF!AST THEN
  AST=SH_NEWARG(C$,P)
  RETURN
 ENDIF
END
DEF SH_ADDCMD(CMD,CMD2)
 IF!SH_AST_L[CMD]THEN
  SH_AST_L[CMD]=CMD2
  RETURN CMD
 ENDIF
 IF!SH_AST_R[CMD]THEN
  SH_AST_R[CMD]=CMD2
  RETURN CMD
 ENDIF
 VAR C=SH_NEWCMD(CMD)
 SH_AST_L[C]=SH_AST_R[CMD]
 SH_AST_R[C]=CMD2
 SH_AST_R[CMD]=C
 RETURN C'MD2
END
'A parser of Shell Command Language
DEF SH_PARSEWORD IN$,I2 OUT AST,I
 
END
DEF SH_PARSEPROGRAM IN$,I2 OUT AST,I
 
END
DEF SH_PARSECOMPLETE_COMMANDS IN$,I2 OUT AST,I
 
END
DEF SH_PARSECOMPLETE_COMMAND IN$,I2 OUT AST,I
 
END
DEF SH_PARSELIST IN$,I2 OUT AST,I
 
END
DEF SH_PARSEAND_OR IN$,I2 OUT AST,I
 
END
DEF SH_PARSEPIPELINE IN$,I2 OUT AST,I
 
END
DEF SH_PARSEPIPE_SEQUENCE IN$,I2 OUT AST,I
 
END
DEF SH_PARSECOMMAND IN$,I2 OUT AST,I
 
END
DEF SH_PARSECOMPOUND_COMMAND IN$,I2 OUT AST,I
 
END
DEF SH_PARSESUBSHELL IN$,I2 OUT AST,I
 
END
DEF SH_PARSECOMPOUND_LIST IN$,I2 OUT AST,I
 
END
DEF SH_PARSETERM IN$,I2 OUT AST,I
 
END
DEF SH_PARSEFOR_CLAUSE IN$,I2 OUT AST,I
 
END
DEF SH_PARSE(IN$)
 VAR I,L=LEN(IN$)-1
'DIM CMD[0]
 VAR C$=""
 VAR P
 VAR CMD=SH_NEWCMD(P)
 VAR CMD2=CMD
 VAR ROOT=CMD
 FOR I=0TO L
  VAR C=ASC(IN$[I])
  VAR I2,AST
  IF C==59 THEN
   AST=SH_NEWSEM(P)
   SH_AST_L[AST]=CMD
   SH_AST_R[AST]=SH_NEWCMD(P)
   CMD=AST
   CMD2=SH_AST_R[AST]
   ROOT=AST
   CONTINUE
  ENDIF
  IF C==124 THEN
   AST=SH_NEWPIPE(P)
   SH_AST_L[AST]=CMD
   SH_AST_R[AST]=SH_NEWCMD(P)
   CMD=AST
   CMD2=SH_AST_R[AST]
   ROOT=AST
   CONTINUE
  ENDIF
  '"<"
  IF C==60THEN
   SH_PARSEARG IN$,I+1,P OUT I2,AST
   AST=SH_NEWIN(AST,P)
   CMD2=SH_ADDCMD(CMD2,AST)
   I=I2-1
   CONTINUE
  ENDIF
  '>
  IF C==62THEN
   SH_PARSEARG IN$,I+1,P OUT I2,AST
   AST=SH_NEWOUT(AST,P)
   CMD2=SH_ADDCMD(CMD2,AST)
   I=I2-1
   CONTINUE
  ENDIF
  '" "
  IF C==32 THEN
   CONTINUE
  ENDIF
  SH_PARSEARG IN$,I,P OUT I2,AST
  IF AST THEN
   CMD2=SH_ADDCMD(CMD2,AST)
   I=I2-1
   CONTINUE
  ENDIF
 NEXT
 RETURN ROOT
END
DEF SH_ASTTYPE$(AST)
 VAR T=SH_AST_TYP[AST]
 
 IF T==SH_AST_TYP_CMD THEN
  RETURN "CMD"
 ELSEIF T==SH_AST_TYP_PIPE THEN
  RETURN "|"
 ELSEIF T==SH_AST_TYP_IN THEN
  RETURN "<"
 ELSEIF T==SH_AST_TYP_OUT THEN
  RETURN ">"
 ELSEIF T==SH_AST_TYP_ARG THEN
  RETURN "ARG"
 ELSEIF T==SH_AST_TYP_ASY THEN
  RETURN "&"
 ELSEIF T==SH_AST_TYP_AND THEN
  RETURN "&&"
 ELSEIF T==SH_AST_TYP_OR THEN
  RETURN "||"
 ELSEIF T==SH_AST_TYP_SEQ THEN
  RETURN ";"
 ENDIF
END
DEF SH_DEBUGVIEW AST
 ?"(";SH_ASTTYPE$(AST);
 VAR T=SH_AST_TYP[AST]
 
 IF T==SH_AST_TYP_ARG THEN
  ?" ";
  ?SH_AST_V$[AST];
 ENDIF
 IF SH_AST_L[AST]THEN
  ?" ";
  SH_DEBUGVIEW SH_AST_L[AST]
 ENDIF
 IF SH_AST_R[AST]THEN
  ?" ";
  SH_DEBUGVIEW SH_AST_R[AST]
 ENDIF
 ?")";
END
DEF SH_EVALARGS AST,CMD$,STDIN,STDOUT OUT STDIN2,STDOUT2
 STDIN2=STDIN
 STDOUT2=STDOUT
 IF!AST THEN RETURN
 VAR T=SH_AST_TYP[AST]
 IF T==SH_AST_TYP_IN THEN
  STDIN2=SH_AST_L[AST]
  RETURN
 ENDIF
 IF T==SH_AST_TYP_OUT THEN
  STDOUT2=SH_AST_L[AST]
  RETURN
 ENDIF
 IF T==SH_AST_TYP_ARG THEN
  PUSH CMD$,SH_AST_V$[AST]
  RETURN
 ENDIF
 SH_EVALARGS SH_AST_L[AST],CMD$,STDIN2,STDOUT2 OUT STDIN2,STDOUT2
 SH_EVALARGS SH_AST_R[AST],CMD$,STDIN2,STDOUT2 OUT STDIN2,STDOUT2
END
DEF SH_OPENFILES AST OUT F$,ERR
 F$=NULL$()
 ERR=0
 VAR T=SH_AST_TYP[AST]
 IF T==SH_AST_TYP_IN THEN
  VAR A=SH_AST_L[AST]
  IF!A||SH_AST_TYP[A]!=SH_AST_TYP_ARG THEN
   F$=SH_AST_V$[A]
   ERR=-1
   RETURN
  ENDIF
  FileOpen SH_AST_V$[A],FileReadFlag() OUT SH_AST_V[A],ERR
  IF ERR THEN
   F$=SH_AST_V$[A]
   RETURN
  ENDIF
 ENDIF
 IF T==SH_AST_TYP_OUT THEN
  A=SH_AST_L[AST]
  IF!A||SH_AST_TYP[A]!=SH_AST_TYP_ARG THEN
   F$=SH_AST_V$[A]
   ERR=-1
   RETURN
  ENDIF
  FileOpen SH_AST_V$[A],FileWriteFlag()OR FileCreateFlag() OUT SH_AST_V[A],ERR
  IF ERR THEN
   F$=SH_AST_V$[A]
   RETURN
  ENDIF
 ENDIF
 IF SH_AST_L[AST]THEN
  SH_OPENFILES SH_AST_L[AST] OUT F$,ERR
  IF ERR THEN RETURN
 ENDIF
 IF SH_AST_R[AST]THEN
  SH_OPENFILES SH_AST_R[AST] OUT F$,ERR
  IF ERR THEN RETURN
 ENDIF
END
DEF SH_CLOSEFILES AST
 VAR ERR
 VAR T=SH_AST_TYP[AST]
 IF T==SH_AST_TYP_IN||T==SH_AST_TYP_OUT THEN
  VAR A=SH_AST_L[AST]
  IF A&&SH_AST_TYP[A]==SH_AST_TYP_ARG THEN
   ERR=FileClose(SH_AST_V[A])
  ENDIF
  RETURN
 ENDIF
 IF SH_AST_L[AST]THEN
  SH_CLOSEFILES SH_AST_L[AST]
 ENDIF
 IF SH_AST_R[AST]THEN
  SH_CLOSEFILES SH_AST_R[AST]
 ENDIF
END
DEF SH_DELASTS AST
 IF SH_AST_L[AST]THEN
  SH_DELASTS SH_AST_L[AST]
 ENDIF
 IF SH_AST_R[AST]THEN
  SH_DELASTS SH_AST_R[AST]
 ENDIF
 SH_DELAST AST
END
DEF SH_EXEC AST,PGRP_ OUT PRC,PGRP,ERR
 VAR T=SH_AST_TYP[AST]
 PRC=0
 ERR=0
 PGRP=PGRP_
 IF T==SH_AST_TYP_PIPE THEN
  VAR PRC1,PRC2

  SH_EXEC SH_AST_L[AST],PGRP OUT PRC1,PGRP,ERR
  IF ERR THEN RETURN
  IF!PGRP THEN PGRP=PRC1
  SH_EXEC SH_AST_R[AST],PGRP OUT PRC2,PGRP,ERR
  IF ERR THEN RETURN
  VAR PIPEIN,PIPEOUT
  OpenPipeFile PRC2,PRC1 OUT PIPEIN,PIPEOUT,ERR
  IF ERR THEN RETURN
  SetProcessSTDOUT PRC1,PIPEOUT
  SetProcessSTDIN PRC2,PIPEIN
  PRC=PRC2
 ENDIF
 IF T==SH_AST_TYP_CMD THEN
  DIM CMD$[0],STDIN,STDOUT
  SH_EVALARGS AST,CMD$,STDIN,STDOUT OUT STDIN,STDOUT
  VAR I
  VAR ARGS$
  FOR I=1TO LEN(CMD$)-1
   EscapeArg CMD$[I]
   IF I!=1 THEN PUSH ARGS$," "
   PUSH ARGS$,CMD$[I]
  NEXT
  IF!LEN(CMD$)THEN RETURN
  NewProcess CMD$[0],ARGS$ OUT PRC,ERR
  IF!PGRP THEN PGRP=PRC
  SetProcessGroup PRC,PGRP OUT ,
  IF STDOUT THEN
   SetProcessSTDOUT PRC,SH_AST_V[STDOUT]
  ENDIF
  IF STDIN THEN
   SetProcessSTDIN PRC,SH_AST_V[STDIN]
  ENDIF
 ENDIF
END
DEF L_SH
 IF 0THEN DIM A[0]
 A=GetSBArray(GetProcessVar())
 IF A[SH_PRC] THEN
  IF BUTTON()==KILLPRCBTN THEN
   VOID KillProcess(A[SH_PRC])
  ENDIF
  IF!CheckProcess(A[SH_PRC]) THEN
'?"EXIT:";SH_PID[DAT],SH_NUPID[DAT]
  'コマンドが0XDEAD
   @INIT
   SetString A[SH_INPUT],""
   A[SH_PRC]=0
   SH_PROMPT
'   PrintConsole ">"
  ELSE
   RETURN
  ENDIF
  RETURN
 ENDIF
 VAR KEY$=INKEYCONSOLE$(1)
 IF KEY$=="" THEN RETURN
 IF KEY$==BS$() THEN
  IF LEN(GetString$(A[SH_INPUT]))THEN
   PrintConsole BS$()+CHR$(0)+BS$()
   VOID POP(GetString$(A[SH_INPUT]))
  ENDIF
 ELSE
  PrintConsole KEY$
  IF KEY$==LF$() THEN @EXEC_COMMAND
  IF KEY$==CR$() THEN @EXEC_COMMAND
  PUSH GetString$(A[SH_INPUT]),KEY$
 ENDIF
 RETURN
 
 @EXEC_COMMAND
 VAR ERR
 VAR NAME$,I,ARGS$
 GetCommandArg GetString$(A[SH_INPUT]),0 OUT NAME$,I
 TOUPPER NAME$
 IF NAME$=="EXIT"THEN
  ExitProcess SUCCESS
  SetString A[SH_INPUT],""
  RETURN
 ENDIF
 IF NAME$=="BACK"THEN
  SH_BACK GetString$(A[SH_INPUT])
  SetString A[SH_INPUT],""
  SH_PROMPT
  RETURN
 ENDIF
 IF NAME$=="CD"THEN
  SH_CD GetString$(A[SH_INPUT])
  SetString A[SH_INPUT],""
  SH_PROMPT
  RETURN
 ENDIF
 VAR CMD=SH_PARSE(GetString$(A[SH_INPUT]))
'SH_DEBUGVIEW CMD
'?

 VAR F$
 SH_OPENFILES CMD OUT F$,ERR
 IF ERR THEN
  PrintConsoleln "sh:"+F$+":error "+GetErrorName$(ERR)
  GOTO @INIT
 ENDIF
 VAR PGRP
 SH_EXEC CMD,0 OUT A[SH_PRC],PGRP,ERR
 'ExecCommand GetString$(A[SH_INPUT]) OUT A[SH_PRC],ERR
 IF ERR THEN
  PrintConsoleln "sh:error "+GetErrorName$(ERR)
  GOTO @INIT
 ENDIF
' ?"RUN:";RUNNUPID
END
RETURN

DEF SH_BACK A$
 VAR NAME$,I,ARGS$,PRC,ERR
 GetCommandArg A$,I OUT NAME$,I
 GetCommandArg A$,I OUT NAME$,I
 IF I==-1THEN
  PrintConsole "USAGE:BACK ARGS..."+LF$
  RETURN
 ENDIF
' GetCommandArg A$,I OUT ARGS$,I
 ARGS$=MID$(A$,I,LEN(A$)-1)
 NewProcess NAME$,ARGS$ OUT PRC,ERR
END
DEF SH_CD A$
 VAR NAME$,I,ARGS$,PRC,ERR
 GetCommandArg A$,I OUT NAME$,I
 GetCommandArg A$,I OUT NAME$,I
 IF I==-1THEN
  PrintConsole "USAGE:CD ARGS..."+LF$
  RETURN
 ENDIF
 ERR=SetCurrentDir(NAME$)
END
'I_AM_CAT
DEF I_CAT
 VAR FILE,ERR,CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN ExitProcess I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN
  FILE=GetSTDIN()
 ELSE
  FileOpen CMD$,FileReadFlag() OUT FILE,ERR
 ENDIF
 IF ERR THEN
  PrintConsoleln "cat:error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 SetProcessVar FILE
END
DEF L_CAT
 VAR FILE=GetProcessVar()
 IF !FILE THEN
  ExitProcess SUCCESS
  RETURN
 ENDIF
 VAR DAT$,ERR
 FileRead FILE,2048 OUT DAT$,ERR
 IF ERR THEN
  IF FILE!=GetSTDIN()THEN
   ERR=FileClose(FILE)
  ENDIF
  ExitProcess SUCCESS
  RETURN
 ENDIF
 IF LEN(DAT$)==0THEN
  IF IsFileEOF(FILE)THEN
   IF FILE!=GetSTDIN()THEN
    ERR=FileClose(FILE)
   ENDIF
   ExitProcess SUCCESS
   RETURN
  ENDIF
  RETURN
 ENDIF
' IF LEN(DAT$)==0THEN
'  ERR=FileClose(FILE)
'  ExitProcess SUCCESS
'  RETURN
' ENDIF
 PrintConsole DAT$
END
DEF I_PTREE
END
DEF L_PTREE
 PrintConsoleln "NAME	ID	PID	TIME	ELAPSED"
 DUMP_PS
 ExitProcess 0
END

COMMON DEF DUMP_PS
 DUMP_PS2 FIRSTNUPID,""
END
DEF DUMP_PS2 NUP,I$
 IF!NUP THEN RETURN
 VAR BUF$
 IF PRC_PARENT[NUP]THEN IF PRC_NEXT[NUP] THEN BUF$=I$+"" ELSE BUF$=I$+""
' ?I$;PRC_NAME$[NUP],NUP,"PID",PRC_PID[NUP]
 PrintConsoleln BUF$+PRC_NAME$[NUP]+HTAB$+STR$(NUP)+HTAB$+STR$(PRC_PID[NUP])+HTAB$+STR$(PRC_TIME[NUP])+HTAB$+STR$(MILLISEC-PRC_STIME[NUP])
' IF CSRY==29 THEN VAR II$INPUT "";II$
 IF LEN(I$) THEN
  VAR NM$=""
  IF PRC_NEXT[NUP] THEN
   NM$=""
  ELSE
   NM$=""
  ENDIF
  NM$=" "
  IF PRC_NEXT[PRC_PARENT[NUP]]THEN
   NM$=""+NM$
  ELSE
   IF PRC_NEXT[NUP] THEN
    NM$=" "
   ELSE
    NM$=" "+NM$
   ENDIF
  ENDIF
  DUMP_PS2 PRC_CHILD[NUP],MID$(I$,0,LEN(I$)-1)+NM$
 ELSE
  IF PRC_CHILD[NUP]&&PRC_NEXT[PRC_CHILD[NUP]]THEN
   DUMP_PS2 PRC_CHILD[NUP]," "'"
  ELSE
   DUMP_PS2 PRC_CHILD[NUP]," "'"
  ENDIF
 ENDIF
 DUMP_PS2 PRC_NEXT[NUP],I$
END
DEF I_PS
 PrintConsoleln FORMAT$("% 6S% 8S% 8S% 8S% 6S% 6S","PID","NAME","TIME","ELAPSED","SID","PGID")
END
DEF PS_PRINT P
 VAR SES,PGRP
 GetSession P OUT SES,
 GetProcessGroup P OUT PGRP,
 PrintConsoleln FORMAT$("% 6D% 8S% 8D% 8D% 6D% 6D",GetProcessPID(P),GetProcessName$(P),GetProcessTime(P),GetProcessElapsedTime(P),GetProcessPID(SES),GetProcessPID(PGRP))
END
DEF L_PS
 DIM PS[0]
 VAR L=GetChildProcesses(GetRootProcess(),PS,TRUE)
 VAR I
 PS_PRINT GetRootProcess()
 FOR I=0TO L-1
  PS_PRINT PS[I]
 NEXT
 ExitProcess SUCCESS
END
DEF I_BEEP
END
DEF L_BEEP
 IF !RND(1024) THEN BEEP RND(3)+88
END

VAR DIFF_LOCK
VAR DIFF_PHASE
DIM DIFF_A$[0]
DIM DIFF_B$[0]
DIM DIFF_V[0]
DIM DIFF_TREE[0]
DIM DIFF_SES[0]
VAR DIFF_OI
VAR DIFF_NI
DEF I_DIFF
 IF DIFF_LOCK THEN RETURN
 VAR CMD$,A$,B$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT A$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT B$,I
 IF I==-1THEN @USAGE
 VAR F$,E
 LoadFile A$ OUT F$,E
 IF E THEN @ERR
 DIFF_A$=SPLIT(F$,LF$())
 LoadFile B$ OUT F$,E
 IF E THEN @ERR
 DIFF_B$=SPLIT(F$,LF$())
 DIFF_PHASE=0
 RETURN
 @USAGE
 PrintConsoleln "USAGE: DIFF ORIGIN NEW"
 ExitProcess -1
 RETURN
 @ERR
 PrintConsoleln "diff:error "+GetErrorName$(E)
 ExitProcess -1
END
VAR DIFF_D,DIFF_K,DIFF_TAIL
VAR DIFF_I
DEF L_DIFF
 IF!DIFF_LOCK THEN DIFF_LOCK=GetPID()
 IF DIFF_LOCK!=GetPID()THEN RETURN
 VAR OL=LEN(DIFF_A$),NL=LEN(DIFF_B$)
 VAR DELETE=0
 VAR COMMON_=1
 VAR ADD=2
 VAR D=DIFF_D,K=DIFF_K
 VAR OFFSET=OL
 WHILE 1
  ON DIFF_PHASE GOTO @INIT,@DIFF,@SES,@DUMP,@END
  BREAK
  @INIT
   DIFF_V=NewArray((OL+NL+1)*2)
   VAR VI
   FOR VI=1TO LEN(DIFF_V)-1 STEP 2
    DIFF_V[VI]=-1
   NEXT
   DIFF_TREE=NewArray(0)
   DIFF_PHASE=1
   DIFF_D=0
   DIFF_K=0
   DIFF_TAIL=-1
  BREAK
  @DIFF
' FOR D=0TO OL+NL
   FOR K=-D TO D STEP 2
    IF K<-OL||NL<K THEN CONTINUE
     VAR V_K=(K+OFFSET)*2
     VAR V_KP1=(V_K+2)
     VAR V_KM1=(V_K-2)
     IF D THEN
      IF K==-D||K==-OL||(K!=D&&K!=NL&&DIFF_V[V_KM1]+1<DIFF_V[V_KP1])THEN
       DIFF_V[V_K]=DIFF_V[V_KP1]
       DIFF_V[V_K+1]=LEN(DIFF_TREE)
       PUSH DIFF_TREE,DELETE
       PUSH DIFF_TREE,DIFF_V[V_KP1+1]
      ELSE
       DIFF_V[V_K]=DIFF_V[V_KM1]+1
       DIFF_V[V_K+1]=LEN(DIFF_TREE)
       PUSH DIFF_TREE,ADD
       PUSH DIFF_TREE,DIFF_V[V_KM1+1]
      ENDIF
     ENDIF
     VAR V_K_Y=DIFF_V[V_K]
     WHILE V_K_Y-K<OL&&V_K_Y<NL&&DIFF_A$[V_K_Y-K]==DIFF_B$[V_K_Y]
      VAR OT=DIFF_V[V_K+1]
      DIFF_V[V_K+1]=LEN(DIFF_TREE)
      PUSH DIFF_TREE,COMMON_
      PUSH DIFF_TREE,OT
      INC V_K_Y
      INC DIFF_V[V_K]
     WEND
     IF V_K_Y-K>=OL&&V_K_Y>=NL THEN
      DIFF_TAIL=DIFF_V[V_K+1]
      GOTO @EXIT
     ENDIF
   NEXT
  IF DIFF_D>=OL+NL THEN @EXIT
  INC DIFF_D
  BREAK
' NEXT
  @EXIT
  DIFF_PHASE=2
  BREAK
  @SES
  DIFF_SES=NewArray(0)
  VAR I=DIFF_TAIL
  WHILE I!=-1
   PUSH DIFF_SES,DIFF_TREE[I]
   I=DIFF_TREE[I+1]
  WEND
  DIFF_PHASE=3
  DIFF_I=LEN(DIFF_SES)-1
  DIFF_OI=0
  DIFF_NI=0
  BREAK
  @DUMP
  VAR MX=MAX(0,DIFF_I-128)
  FOR I=DIFF_I TO MX STEP -1
   WHILE 1
   ON DIFF_SES[I] GOTO @DEL,@COM,@ADD
    PrintConsole "?"
    BREAK
    @DEL
     PrintConsole "-"
     IF LEN(DIFF_A$)>DIFF_OI THEN
      PrintConsoleln DIFF_A$[DIFF_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_OI
    BREAK
    @COM
     PrintConsole " "
     IF LEN(DIFF_A$)>DIFF_OI THEN
      PrintConsoleln DIFF_A$[DIFF_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_OI
     INC DIFF_NI
    BREAK
    @ADD
     PrintConsole "+"
     IF LEN(DIFF_B$)>DIFF_NI THEN
      PrintConsoleln DIFF_B$[DIFF_NI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_NI
    BREAK
    WEND
   NEXT
   DIFF_I=I
   IF DIFF_I==-1 THEN DIFF_PHASE=4
  BREAK
  @END
  ExitProcess 0
  BREAK
 WEND
END

COMMON DEF I_FREEMEM
END
COMMON DEF L_FREEMEM
 IF GetProcessVar()==FREEMEM THEN RETURN
 SetProcessVar FREEMEM
 VAR OX,OY,ERR,W,H,F,B
 GetConsoleCursor GetConsole() OUT OX,OY,ERR
 GetConsoleSize   GetConsole() OUT  W, H,ERR
 GetConsoleForeColor GetConsole() OUT F,ERR
 GetConsoleBackColor GetConsole() OUT B,ERR
 SetConsoleCursor GetConsole(),W-1-LEN(STR$(FREEMEM)),0 OUT ERR
 SetConsoleForeColor GetConsole(),1OUT ERR
 SetConsoleBackColor GetConsole(),15OUT ERR
 PrintConsole STR$(FREEMEM)
 SetConsoleForeColor GetConsole(),F OUT ERR
 SetConsoleBackColor GetConsole(),B OUT ERR
 SetConsoleCursor GetConsole(),OX,OY OUT ERR
END

COMMON DEF EXITMORE
 VAR PTR=GetProcessVar()
 VAR CONIN=ReadInt(PTR+1)
 VOID FileClose(CONIN)
 FREE PTR
 ExitProcess 0
END
COMMON DEF I_MORE
 VAR CONIN,E
 VAR PTR=malloc(3)
 WriteInt PTR,0
 WriteInt PTR+1,CONIN
 SetProcessVar PTR
 VAR I,RT
 FOR I=0TO 28
  RT=DOMORE()
  IF RT==1THEN EXITMORE:RETURN
  IF RT==2 THEN WriteInt PTR,1:BREAK
 NEXT
 WriteInt PTR+3,I
END
COMMON DEF L_MORE
 VAR PTR=GetProcessVar()
 VAR STATE=ReadInt(PTR)
 VAR CONIN=ReadInt(PTR+1)
 VAR COUNT=ReadInt(PTR+3)
 VAR KEY$,ERR
 ReadConsole GetConsole(),1 OUT KEY$,ERR
 IF KEY$=="q"||KEY$=="Q"THEN
  EXITMORE
  RETURN
 ENDIF
 IF INSTR(KEY$,LF$())!=-1||STATE THEN
  VAR RT=DOMORE()
  IF RT==1THEN EXITMORE:RETURN
  IF RT==2THEN
   WriteInt PTR,1
  ELSE
   IF COUNT+1<=28THEN
    WriteInt PTR+3,COUNT+1
    WriteInt PTR,1
   ELSE
    WriteInt PTR,0
   ENDIF
  ENDIF
 ENDIF
END
COMMON DEF DOMORE()
 VAR FILE=GetSTDIN()
 IF !FILE THEN ExitProcess SUCCESS:RETURN 1
 VAR DAT$,ERR
 VAR LINEW=50
 FileRead FILE,LINEW OUT DAT$,ERR
 IF LEN(DAT$)==0THEN
  IF IsFileEOF(FILE)THEN
   RETURN 1
  ELSE
   RETURN 2
  ENDIF
 ENDIF
' IF LEN(DAT$)==0THEN
'  ERR=FileClose(FILE)
'  ExitProcess SUCCESS
'  RETURN 1
' ENDIF
 VAR LFPOS=INSTR(DAT$,LF$)
 IF LFPOS==0THEN
  VOID FileSeekCUR(FILE,-48)
  PrintConsoleln ""
  RETURN 0
 ENDIF
 LINEW=LEN(DAT$)
 VAR LEN=LINEW
 IF LFPOS!=-1THEN LEN=MIN(LFPOS+1,LINEW)
 IF LEN-LINEW THEN
  VOID FileSeekCUR(FILE,LEN-LINEW)
 ENDIF
 PrintConsole LEFT$(DAT$,LEN)
 IF LFPOS==-1&&LEN(DAT$)==LINEW THEN PrintConsoleln ""
 IF LFPOS==-1&&LEN<LINEW THEN RETURN 2
 RETURN 0
END
COMMON DEF I_ECHO
END
COMMON DEF L_ECHO
 VAR FILE,ERR,CMD$,I
 PrintConsoleln GetCommandArgsWithoutName$(GetProcessArgs$())
 ExitProcess 0
END
COMMON DEF I_LS
END
COMMON DEF L_LS
 VAR CMD$,DIR$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT DIR$,I
 
 DIM ARY$[0]
 VAR ERR
 VAR MM=MILLISEC
 GetFiles DIR$ OUT ARY$,ERR
 IF ERR THEN
  PrintConsoleln"ls:error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 VAR OLD,OLDB
 GetConsoleForeColor GetConsole() OUT OLD,ERR
 GetConsoleBackColor GetConsole() OUT OLDB,ERR
 SetConsoleBackColor GetConsole(),0 OUT ERR
 FOR I=0TO LEN(ARY$)-1
  IF ARY$[I][0]=="/"THEN
   SetConsoleForeColor GetConsole(),#TGREEN OUT ERR
'  PrintConsole ESC$+"["+STR$(32)+"m"
  ELSE
   SetConsoleForeColor GetConsole(),#TGRAY OUT ERR
'  PrintConsole ESC$+"["+STR$(0)+"m"
  ENDIF
  PrintConsoleln MID$(ARY$[I],1,LEN(ARY$[I]))
 NEXT
'PrintConsole ESC$+"["+STR$(0)+"m"
 SetConsoleForeColor GetConsole(),OLD OUT ERR
 SetConsoleBackColor GetConsole(),OLDB OUT ERR
 ExitProcess 0
END
COMMON DEF I_FIND
 SetProcessVar AllocString("")
END
COMMON DEF L_FIND
 IF!CheckFile(GetSTDIN())||IsFileEOF(GetSTDIN())THEN
  ExitProcess 0
  RETURN
 ENDIF
 VAR C$=INKEYCONSOLE$(1)
 VAR PTR=GetProcessVar()
 IF LEN(C$)THEN
  IF C$==LF$()THEN
   VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
   VAR LINE$=GetString$(PTR)
   IF INSTR(LINE$,CMD$)!=-1THEN
    PrintConsoleln LINE$
   ENDIF
   SetString PTR,""
  ELSE
   SetString PTR,GetString$(PTR)+C$
  ENDIF
 ENDIF
END

COMMON DEF I_MKDIR
END
COMMON DEF L_MKDIR
 VAR CMD$,DIR$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT DIR$,I
 IF I==-1 THEN
  PrintConsoleln "usage "+CMD$+" directory"
  ExitProcess 1
  RETURN
 ENDIF
 VAR ERR=NewDir(DIR$)
 IF ERR THEN
  PrintConsoleln "mkdir:error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 ExitProcess 0
END
COMMON DEF I_MOUNT
END
COMMON DEF L_MOUNT
 VAR CMD$,FS$,DATA$,PATH$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT FS$,I
 IF I==-1 THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT DATA$,I
 IF I==-1 THEN
  @USAGE
  PrintConsoleln "usage "+CMD$+" filesystem [data] path"
  ExitProcess 1
  RETURN
 ENDIF
 GetCommandArg GetProcessArgs$(),I OUT PATH$,I
 IF PATH$==""THEN SWAP PATH$,DATA$
 VAR ERR=Mount(PATH$,FS$,DATA$)
 IF ERR THEN
  PrintConsoleln "mount:error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 ExitProcess 0
END

COMMON DEF I_RM
END
COMMON DEF L_RM
 DIM ARGS$[0]
 VAR LEN
 CommandArgsToArray ARGS$,TRUE OUT LEN
 IF LEN(ARGS$)==0 THEN
  @USAGE
  PrintConsoleln "usage "+ARGS$[0]+" [-d] file..."
  ExitProcess 1
  RETURN
 ENDIF
 VAR ERR,I
 FOR I=1 TO LEN(ARGS$)-1
  PrintConsoleln "remove:"+ARGS$[I]
  DeleteFile ARGS$[I]OUT ERR
  IF ERR THEN
   PrintConsoleln "rm:error "+GetErrorName$(ERR)
   ExitProcess 1
   RETURN
  ENDIF
 NEXT
 ExitProcess 0
END
COMMON DEF I_REN
END
COMMON DEF L_REN
 VAR CMD$,DIR$,NEW$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT DIR$,I
 GetCommandArg GetProcessArgs$(),I OUT NEW$,I
 IF I==-1 THEN
  PrintConsoleln "usage "+CMD$+" path newname"
  ExitProcess 1
  RETURN
 ENDIF
 VAR ERR=RenameFile(DIR$,NEW$)
 IF ERR THEN
  PrintConsoleln "ren:error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 ExitProcess 0
END
COMMON DEF I_ACT
END
COMMON DEF L_ACT
 VAR CMD$,DIR$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT DIR$,I
 IF I==-1 THEN
  PrintConsoleln "usage "+CMD$+" path"
  ExitProcess 1
  RETURN
 ENDIF
 VAR ERR,F$
 GetSBFile(DIR$) OUT F$,ERR
 IF ERR THEN
  PrintConsoleln "ren:error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 PrintConsoleln FORMAT$("%S=%S",DIR$,F$)
 ExitProcess 0
END
COMMON DEF I_ESCTEST
END
COMMON DEF L_ESCTEST
 VAR I
 FOR I=30 TO 37
  PrintConsoleln FORMAT$("%S[%DmHOGE",CHR$(&H1B),I)
 NEXT
 FOR I=40 TO 47
  PrintConsoleln FORMAT$("%S[%DmHOGE",CHR$(&H1B),I)
 NEXT
 PrintConsoleln FORMAT$("%S[%DmHOGE",CHR$(&H1B),40)
 ExitProcess 0
END
COMMON DEF I_FADE
END
COMMON DEF L_FADE
 VAR CMD$,I,A$,R$,G$,B$
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT A$,I
 GetCommandArg GetProcessArgs$(),I OUT R$,I
 GetCommandArg GetProcessArgs$(),I OUT G$,I
 GetCommandArg GetProcessArgs$(),I OUT B$,I
 IF I==-1 THEN
  PrintConsoleln "usage "+CMD$+" A R G B"
  ExitProcess 1
  RETURN
 ENDIF
 FADE RGB(VAL(A$),VAL(R$),VAL(G$),VAL(B$))
 ExitProcess 0
END


'OTYFS LIBRARY
VAR OFS_MAGIC_OTYF
VAR OFS_MAGIC_SDIR
VAR OFS_MAGIC_SFIL
VAR OFS_MAGIC_SDEV
DEF OFS_STRTOBIN(S$)
 RETURN ASC(S$[0])<<24OR ASC(S$[1])<<16OR ASC(S$[2])<<8OR ASC(S$[3])
END
VAR OFS_ROOT$
VAR OFS_ROOTFOBJID
VAR OFS_CURPRJFOBJID
VAR OFS_PRJLSTFOBJID
VAR OFS_PERM_READ
VAR OFS_PERM_WRITE
VAR OFS_PERM_RW
VAR OFS_RAND_Y
VAR OFS_ERROR_PERM
VAR OFS_ERROR_ALREADY
VAR OFS_ERROR_NOTFOUND
VAR OFS_ERROR_SYMLINK
VAR OFS_DIR_RESERVE_DEF
VAR OFS_CHILDTYPE_DIR
VAR OFS_CHILDTYPE_FILE
VAR OFS_CHILDTYPE_MOUNT
VAR OFS_CHILDTYPE_SYMLINK
DEF OFS_CONV_ERR(ERR)
 IF !ERR THEN RETURN 0
 IF ERR==OFS_ERROR_PERM THEN RETURN ERROR_PERM
 IF ERR==OFS_ERROR_ALREADY THEN RETURN ERROR_ALREADYFILE
 IF ERR==OFS_ERROR_NOTFOUND THEN RETURN ERROR_NOFILE
 RETURN ERROR_ERROR
END
DEF OTYFS_INIT
 OFS_DIR_RESERVE_DEF=16
 OFS_ERROR_PERM=2
 OFS_ERROR_ALREADY=ERROR_ALREADYFILE'3
 OFS_ERROR_NOTFOUND=4
 OFS_ERROR_SYMLINK=5
 OFS_MAGIC_OTYF=OFS_STRTOBIN("OTYF")
 OFS_MAGIC_SDIR=OFS_STRTOBIN("SDIR")
 OFS_MAGIC_SFIL=OFS_STRTOBIN("SFIL")
 OFS_MAGIC_SDEV=OFS_STRTOBIN("SDEV")
 OFS_ROOT$="DAT:@00000001.FS"
 OFS_ROOTFOBJID=1
 OFS_CURPRJFOBJID=2
 OFS_PRJLSTFOBJID=3
 OFS_PERM_READ=1
 OFS_PERM_WRITE=2
 OFS_PERM_RW=3

 OFS_CHILDTYPE_DIR=0
 OFS_CHILDTYPE_FILE=1
 OFS_CHILDTYPE_MOUNT=2
 OFS_CHILDTYPE_SYMLINK=3

 RANDOMIZE 0
 OFS_RAND_Y=RND(&H7FFFFFFF)
 OFS_CACHE_INIT
 IF!CHKFILE(OFS_ROOT$)THEN
  'ROOT FILE
  VAR RW=OFS_PERM_READ OR OFS_PERM_WRITE
  IF OFS_NEWDIR("",OFS_ROOTFOBJID,RW)THEN
   ?"FAILURE:INIT OTYFS"
   RETURN
  ENDIF
 ENDIF
' DIM ARY$[0],I,ERR
' OFS_FILES "/",ARY$OUT ERR
' IF ERR THEN ?ERR:RETURN
' ?"LIST OF /
' FOR I=0TO LEN(ARY$)-1
'  ?ARY$[I]
' NEXT
' ARY$=NewArray$(0)
' OFS_FILES "/home" OUT ARY$,ERR
' IF ERR THEN ?ERR:RETURN
' ?"LIST OF /home
' FOR I=0TO LEN(ARY$)-1
'  ?ARY$[I]
' NEXT
 VAR FS,ERR
 NewFileSystem("OFS") OUT FS,ERR
 IF ERR THEN RETURN
 ERR=FSSetFileListHandler(FS,"OFS_FILELIST")
 IF ERR THEN RETURN
 ERR=FSSetOpenFileHandler(FS,"OFS_OPEN")
 IF ERR THEN RETURN
 ERR=FSSetNewDirHandler(FS,"OFS_NEWDIRHANDLER")
 IF ERR THEN RETURN
 ERR=FSSetMountHandler(FS,"OFS_MOUNT")
 IF ERR THEN RETURN
 ERR=FSSetDeleteHandler(FS,"OFS_DELFILEHANDLER")
 IF ERR THEN RETURN
 ERR=FSSetGetFileSystemHandler(FS,"OFS_GETFS")
 IF ERR THEN RETURN
 ERR=FSSetRenameHandler(FS,"OFS_RENHNDLR")
 IF ERR THEN RETURN
 ERR=FSSetGetTypeHandler(FS,"OFS_GETTYPEHNDLR")
 IF ERR THEN RETURN
 ERR=FSSetGetSBFileHandler(FS,"OFS_GETSBFILEHNDLR")
 IF ERR THEN RETURN
 ERR=FSSetSaveDATAFileHandler(FS,"OFS_SAVEDATHNDLR")
 IF ERR THEN RETURN
 ERR=FSSetSymlinkHandler(FS,"OFS_SYMLINKHNDLR")
 IF ERR THEN RETURN
END
DEF OFS_FILELIST FS,DATA$,PATH$,FILELIST$[] OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$,OBJ
 OFS_GETFS_OBJ FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,OBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=PATH$ THEN
  FSGetFilesH OUTFS,OUTDATA$,OUTPATH$,FILELIST$ OUT ERR
  RETURN
 ENDIF
 IF 0 THEN DIM D[0]
 OFS_LOAD DATA$,OBJ OUT D,ERR
 IF ERR THEN RETURN
 ERR=OFS_FILES_L_DIR(D,FILELIST$)
END
DEF OFS_OPEN FS,DATA$,PATH$,FLG OUT FILE,ERR
 FILE=0
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,0,L+1)
 VAR FILENAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR DIROBJ

 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,DIRNAME$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=DIRNAME$ THEN
  FSOpenFile OUTFS,OUTDATA$,OUTPATH$+FILENAME$,FLG OUT FILE,ERR
  RETURN
 ENDIF

 IF ERR THEN RETURN
 VAR SBFILE$,ISDAT,PERM,D
 VAR SYM$
 OFS_OPENFILEINFO DATA$,DIROBJ,FILENAME$ OUT SBFILE$,ISDAT,PERM,D,D,D,SYM$,ERR
 IF LEN(SYM$) THEN
  FileOpen SYM$,FLG OUT FILE,ERR
  RETURN
 ENDIF
 IF (FLG AND FileCreateFlag())&&ERR==OFS_ERROR_NOTFOUND THEN
 ELSEIF ERR THEN
  RETURN
 ENDIF
 AllocFile OUT FILE,ERR
 IF ERR THEN RETURN
 VAR F$=""
 VAR PROJ$=DATA$
 VAR PROJ=LEN(PROJ$)
 IF PROJ THEN
  SBFILE$=PROJ$+SBFILE$
 ENDIF
 IF FLG AND FileWriteFlag()THEN
 ELSEIF LEN(SBFILE$)!=PROJ&&CHKFILE("TXT:"+SBFILE$) THEN
  F$=LOAD("TXT:"+SBFILE$,0)
 ENDIF
 SetFileDataStr FILE,F$
 SetFileNAME FILE,HEX$(DIROBJ,8)+SBFILE$+":"+FILENAME$
 ERR=SetWriter(FILE,"TXTWRITER")
 ERR=SetReader(FILE,"TXTREADER")
 ERR=SetReadln(FILE,"TXTREADLN")
 ERR=SetClose(FILE,"OFS_TXTCLOSE")
 IF FLG AND FileAppendFlag()THEN
  FileSeekCUR FILE,LEN(F$) OUT ERR
 ENDIF
' ERR=SetFlush(FID,NUFID,"TXTFLUSH")
END
DEF OFS_TxtClose FILE
 IF GetFileData(FILE)==0 THEN RETURN
 VAR FDAT$=GetFileName$(FILE)
 '"XXXXXXXX[PROJ/]SBFILE:/path/to"
 VAR SBFILE$=MID$(FDAT$,8,INSTR(FDAT$,":")-8)
 VAR NAME$=MID$(FDAT$,8+LEN(SBFILE$)+1,LEN(FDAT$))
 VAR DIROBJ=VAL("&H"+MID$(FDAT$,0,8))
 VAR PROJ=INSTR(SBFILE$,"/")
 IF PROJ!=-1 THEN
  VAR FILENAME$=MID$(SBFILE$,PROJ+1,&H7FFFFFFF)
  VAR PROJ$=LEFT$(SBFILE$,PROJ+1)
 ELSE
  FILENAME$=SBFILE$
 ENDIF
 IF FILENAME$!=""THEN
  SAVE "TXT:"+SBFILE$,GetFileDataStr$(FILE)
  RETURN
 ENDIF
 VAR _
 OFS_GEN_FOBJFILE_TXT PROJ$ OUT SBFILE$,_
 SAVE SBFILE$,GetFileDataStr$(FILE)
 IF RESULT!=1 THEN RETURN
 'TXT:@HOGE=>@HOGE
 SBFILE$=MID$(SBFILE$,4,LEN(SBFILE$))
 IF LEN(PROJ$)THEN
  SBFILE$=MID$(SBFILE$,LEN(PROJ$),&H7FFFFFFF)
 ENDIF
 VAR ERR=OFS_ADDFILE(PROJ$,DIROBJ,FALSE,NAME$,SBFILE$,OFS_PERM_RW)
END
DEF OFS_MOUNT FS,DATA$,PATH$,MOUNTFS$,MOUNTDATA$ OUT ERR
 PATH$=LEFT$(PATH$,LEN(PATH$)-1)
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  FSMount OUTFS,OUTDATA$,OUTPATH$+DIRNAME$+"/",MOUNTFS$,MOUNTDATA$ OUT ERR
  RETURN
 ENDIF
 IF ERR THEN RETURN
 VAR RW=OFS_PERM_READ OR OFS_PERM_WRITE
 ERR=OFS_ADDMOUNT(DATA$,DIROBJ,DIRNAME$,MOUNTFS$,MOUNTDATA$,RW)
 IF ERR THEN RETURN
END
DEF OFS_SYMLINKHNDLR FS,DATA$,PATH$,TARGET$ OUT ERR
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,0,L+1)
 VAR FILENAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR DIROBJ

 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,DIRNAME$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=DIRNAME$ THEN
  FSSymlink OUTFS,OUTDATA$,OUTPATH$+FILENAME$,TARGET$ OUT ERR
  RETURN
 ENDIF
 IF ERR THEN RETURN
 VAR RW=OFS_PERM_READ OR OFS_PERM_WRITE
 ERR=OFS_ADDSYMLINK(DATA$,DIROBJ,FILENAME$,TARGET$,RW)
 IF ERR THEN RETURN
END
VAR OFS_CACHESIZE
VAR OFS_CACHECOUNT
DIM OFS_CACHE_HTABLEKEY[0]
DIM OFS_CACHE_HTABLEVAL[0]
DEF OFS_CACHE_INIT
 OFS_CACHESIZE=257
 OFS_CACHECOUNT=0
 OFS_CACHE_HTABLEKEY=NewArray(OFS_CACHESIZE)
 OFS_CACHE_HTABLEVAL=NewArray(OFS_CACHESIZE)
END
DEF OFS_SEARCH_CACHE(KEY)
 VAR K2=(KEY AND &H7FFFFFFF) MOD OFS_CACHESIZE
 REPEAT
  VAR K=OFS_CACHE_HTABLEKEY[K2]
  IF K==KEY THEN
   RETURN OFS_CACHE_HTABLEVAL[K2]
  ENDIF
  K2=(K2+1) MOD OFS_CACHESIZE'REHASH
 UNTIL!K
 RETURN -1
END
DEF OFS___CACHE(KEY)
 VAR K2=(KEY AND &H7FFFFFFF) MOD OFS_CACHESIZE
 WHILE 1
  VAR KD=OFS_CACHE_HTABLEKEY[K2]
  IF!KD THEN
   OFS_CACHECOUNT=OFS_CACHECOUNT+1
   RETURN K2
  ENDIF
  IF KD==K2 THEN
   RETURN -2
  ENDIF
' ENDIF
 WEND
END
DEF OFS_ADD_CACHE2 KEY,V,I
 OFS_CACHECOUNT=OFS_CACHECOUNT+1
 OFS_CACHE_HTABLEKEY[I]=KEY
 OFS_CACHE_HTABLEVAL[I]=V
END
DEF OFS_ADD_CACHE_ARY KEY,V[]
 IF OFS_CACHECOUNT>=OFS_CACHESIZE THEN
  RETURN
 ENDIF
 VAR K2=(KEY AND &H7FFFFFFF) MOD OFS_CACHESIZE
 WHILE 1
  VAR KD=OFS_CACHE_HTABLEKEY[K2]
  IF!KD THEN
   OFS_CACHECOUNT=OFS_CACHECOUNT+1
   OFS_CACHE_HTABLEKEY[K2]=KEY
   VAR ARY=AllocSBArray()
   SetSBArray ARY,V
   OFS_CACHE_HTABLEVAL[K2]=ARY
   RETURN
  ENDIF
  IF KD==K2 THEN
   SetSBArray OFS_CACHE_HTABLEVAL[K2],V
   RETURN
  ENDIF
  K2=(K2+1) MOD OFS_CACHESIZE'REHASH
 WEND
END

DEF OFS_ADD_CACHE KEY,V
 IF OFS_CACHECOUNT>=OFS_CACHESIZE THEN
  RETURN
 ENDIF
 VAR K2=(KEY AND &H7FFFFFFF) MOD OFS_CACHESIZE
 WHILE 1
  VAR KD=OFS_CACHE_HTABLEKEY[K2]
  IF!KD THEN
   OFS_CACHECOUNT=OFS_CACHECOUNT+1
   OFS_CACHE_HTABLEKEY[K2]=KEY
   OFS_CACHE_HTABLEVAL[K2]=V
   RETURN
  ENDIF
  IF KD==K2 THEN
   OFS_CACHE_HTABLEVAL[K2]=V
   RETURN
  ENDIF
  K2=(K2+1) MOD OFS_CACHESIZE'REHASH
 WEND
END

DEF OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 VAR ISEXTERN=LEN(PROJ$)
 IF!ISEXTERN THEN
  VAR I=OFS_SEARCH_CACHE(DIROBJ)
  IF I!=-1THEN
   VAR ARY=I'OFS_SEARCH_CACHE(DIROBJ)
   FDATA=GetSBArray(ARY)
   ERR=0
   RETURN
  ENDIF
 ENDIF
 DIM FDATA_[0]
 IF ISEXTERN THEN
  IF!IsSmileTool()THEN
   ERR=ERROR_PERM
   FDATA=FDATA_
   RETURN
  ENDIF
  VAR DIROBJ$="DAT:"+PROJ$+"@"+HEX$(DIROBJ,8)+".FS"
 ELSE
  DIROBJ$="DAT:@"+HEX$(DIROBJ,8)+".FS"
 ENDIF
 LOAD DIROBJ$,FDATA_,0
 FDATA=FDATA_
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN ERR=1
 IF!(FDATA[2] AND OFS_PERM_READ) THEN ERR=OFS_ERROR_PERM:RETURN
 IF!ISEXTERN THEN
  OFS_ADD_CACHE_ARY DIROBJ,FDATA
 ENDIF
 ERR=0
END
DEF OFS_GETFS FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 VAR DIROBJ
 OFS_GETFS_OBJ FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
END
DEF OFS_GETFS_OBJ FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 'TODO:EXI
 OUTPATH$=PATH$
 ERR=0
 OUTFS=FS
 OUTDATA$=DATA$
 DIROBJ=OFS_ROOTFOBJID
 VAR I=1
 VAR CD$

 WHILE 1
  VAR I2=INSTR(I,PATH$,"/")
  IF I2==-1THEN RETURN
  CD$=MID$(PATH$,I,I2-I)
  IF!LEN(CD$)THEN
   RETURN
  ENDIF
  I=I2+1
  IF 0 THEN DIM FDATA[0]
  OFS_LOAD DATA$,DIROBJ OUT FDATA,ERR
  IF ERR THEN RETURN
  VAR TYPE=FDATA[7]
  ON TYPE GOTO @LINEAR
  @LINEAR
  VAR FI=OFS_SEARCH_L(FDATA,CD$)
  IF FI==0 THEN ERR=FS_ERROR_NOTFOUND:RETURN
  DIROBJ=FDATA[FI+1]
  IF!DIROBJ THEN
   INC FI,FDATA[FI+2]+2+1
   TYPE=FDATA[FI]
   INC FI
   IF TYPE==OFS_CHILDTYPE_MOUNT THEN
    BREAK
   ENDIF
   IF TYPE==OFS_CHILDTYPE_SYMLINK THEN
    INC FI,1+3'PERM+DATETIME
    OFS_READ_STR2 FDATA,FI OUT OUTPATH$,FI
    VAR NXT$=MID$(PATH$,I,&H7FFFFFFF)
    OUTPATH$=GetAbsolutePath2$(MID$(PATH$,0,I2-LEN(CD$)),OUTPATH$)
    IF LEN(NXT$)THEN
     OUTPATH$=CombinePath$(OUTPATH$,NXT$)
    ENDIF
    OUTFS=GetRootFileSystem()
    RETURN
   ENDIF
   ERR=FS_ERROR_NOTFOUND
   RETURN
  ENDIF
 WEND
 INC FI,1+3'PERM+DATETIME
 VAR OUTFS$
 OFS_READ_STR2 FDATA,FI OUT OUTFS$,FI
 OFS_READ_STR2 FDATA,FI OUT OUTDATA$,FI
 OUTFS=FindFileSystem(OUTFS$)
 OUTPATH$=MID$(PATH$,I-1,LEN(PATH$))
END
DEF OFS_NEWDIRHANDLER FS,DATA$,PATH$ OUT ERR
 '"/A/B/"->"/A/B"
 
 PATH$=LEFT$(PATH$,LEN(PATH$)-1)
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  FSNewDir OUTFS,OUTDATA$,OUTPATH$+DIRNAME$+"/" OUT ERR
  RETURN
 ENDIF
 VAR RW=OFS_PERM_READ OR OFS_PERM_WRITE
 ERR=OFS_ADDOBJ_NEWDIR(DATA$,DIROBJ,DIRNAME$,RW)
 IF ERR THEN RETURN
END
DEF OFS_DELFILEHANDLER FS,DATA$,PATH$ OUT ERR
 VAR HASSLASH
 IF RIGHT$(PATH$,1)=="/"THEN
  PATH$=LEFT$(PATH$,LEN(PATH$)-1)
  HASSLASH=TRUE
 ENDIF
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  IF HASSLASH THEN INC DIRNAME$,"/"
  FSDelete OUTFS,OUTDATA$,OUTPATH$+DIRNAME$ OUT ERR
  RETURN
 ENDIF
 OFS_DELFILE DATA$,DIROBJ,DIRNAME$ OUT ERR
END
DEF OFS_RENHNDLR FS,DATA$,PATH$,NEW$ OUT ERR
 VAR HASSLASH
 IF RIGHT$(PATH$,1)=="/"THEN
  PATH$=LEFT$(PATH$,LEN(PATH$)-1)
  HASSLASH=TRUE
 ENDIF
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  IF HASSLASH THEN INC DIRNAME$,"/"
  FSRename OUTFS,OUTDATA$,OUTPATH$+DIRNAME$,NEW$ OUT ERR
  RETURN
 ENDIF
 OFS_RENAME DATA$,DIROBJ,DIRNAME$,NEW$ OUT ERR
END

DEF OFS_DELFILE PROJ$,DIROBJ,NAME$ OUT ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN RETURN
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR
 @LINEAR
 VAR FI=OFS_SEARCH_L(FDATA,NAME$)
 IF FI==0 THEN ERR=FS_ERROR_NOTFOUND:RETURN
 DEC FDATA[6]
 VAR RLEN=FDATA[FI]+1+2+1
 COPY FDATA,FI,FDATA,FI+RLEN,LEN(FDATA)-FI-RLEN
 VAR I
 FOR I=0TO RLEN-1
  POP FDATA OUT FI
 NEXT
 ERR=0
 IF OFS_SAVE2(PROJ$,DIROBJ,FDATA)THEN ERR=FS_ERROR_CANCEL
END
DEF OFS_RENAME PROJ$,DIROBJ,NAME$,NEW$ OUT ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN RETURN
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR
 @LINEAR
 VAR FI=OFS_SEARCH_L(FDATA,NAME$)
 IF FI==0 THEN ERR=FS_ERROR_NOTFOUND:RETURN
 VAR RLEN=FDATA[FI]+1+2+1
 VAR DIFF=LEN(NEW$)-LEN(NAME$)
 IF DIFF==0 THEN
  OFS_WRITE_STR FDATA,FI+2,NEW$
 ELSE
  INC FDATA[FI],DIFF
  VAR I,J
  VAR LEN=LEN(FDATA)
  DIM FD2[LEN(FDATA)+DIFF]
  COPY FD2,FDATA,0,MIN(LEN(FDATA)+DIFF,LEN(FDATA))
  'overlap COPYできない?
  SWAP FD2,FDATA
  COPY FDATA,FI+3+LEN(NAME$)+DIFF,FD2,FI+3+LEN(NAME$),LEN-(FI+3+LEN(NAME$))

  OFS_WRITE_STR FDATA,FI+2,NEW$
 ENDIF
 ERR=0
 IF OFS_SAVE2(PROJ$,DIROBJ,FDATA)THEN ERR=FS_ERROR_CANCEL
END
COMMON DEF OFS_GETTYPEHNDLR FS,DATA$,PATH$ OUT TYPE$,ERR
 VAR HASSLASH
 IF PATH$=="/"THEN
  ERR=0
  TYPE$="/"
  RETURN
 ENDIF
 IF RIGHT$(PATH$,1)=="/"THEN
  PATH$=LEFT$(PATH$,LEN(PATH$)-1)
  HASSLASH=TRUE
 ENDIF
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  IF HASSLASH THEN INC DIRNAME$,"/"
  FSGetType OUTFS,OUTDATA$,OUTPATH$+DIRNAME$ OUT TYPE$,ERR
  RETURN
 ENDIF
 OFS_GETFILETYPE DATA$,DIROBJ,DIRNAME$ OUT TYPE$,ERR
 IF ERR==OFS_ERROR_SYMLINK THEN
  GetFileType TYPE$ OUT TYPE$,ERR
 ENDIF
END
COMMON DEF OFS_GETSBFILEHNDLR FS,DATA$,PATH$ OUT FILE$,ERR
 VAR HASSLASH
 IF RIGHT$(PATH$,1)=="/"THEN
  PATH$=LEFT$(PATH$,LEN(PATH$)-1)
  HASSLASH=TRUE
 ENDIF
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  IF HASSLASH THEN INC DIRNAME$,"/"
  FSGetSBFile OUTFS,OUTDATA$,OUTPATH$+DIRNAME$ OUT FILE$,ERR
  RETURN
 ENDIF
 VAR SBFILE$,ISDAT,PERM,D
 VAR SYM$
 OFS_OPENFILEINFO DATA$,DIROBJ,DIRNAME$ OUT SBFILE$,ISDAT,PERM,D,D,D,SYM$,ERR
 IF LEN(SYM$)THEN
  GetSBFile SYM$ OUT FILE$,ERR
  RETURN
 ENDIF
 IF ISDAT THEN
  FILE$="DAT:"+DATA$+SBFILE$
 ELSE
  FILE$="TXT:"+DATA$+SBFILE$
 ENDIF
END
COMMON DEF OFS_SAVEDATHNDLR FS,DATA$,PATH$,ARY OUT ERR
 VAR HASSLASH
 IF RIGHT$(PATH$,1)=="/"THEN
  PATH$=LEFT$(PATH$,LEN(PATH$)-1)
  HASSLASH=TRUE
 ENDIF
 VAR L=LASTINSTR(PATH$,"/")
 VAR DIRNAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR P2$=LEFT$(PATH$,L+1)
 VAR FILENAME$=MID$(PATH$,L+1,LEN(PATH$))
 VAR DIROBJ
 VAR OUTFS,OUTDATA$,OUTPATH$
 OFS_GETFS_OBJ FS,DATA$,P2$ OUT OUTFS,OUTDATA$,OUTPATH$,DIROBJ,ERR
 IF ERR THEN RETURN
 IF OUTPATH$!=P2$ THEN
  IF HASSLASH THEN INC DIRNAME$,"/"
  FSSaveDATAFile OUTFS,OUTDATA$,OUTPATH$+DIRNAME$,ARY OUT ERR
  RETURN
 ENDIF
 VAR SBFILE$,_
 OFS_GEN_FOBJFILE_DAT DATA$ OUT SBFILE$,_
 SAVE SBFILE$,ARY
 IF RESULT==-1 THEN
  ERR=FS_ERROR_CANCEL
  RETURN
 ELSEIF RESULT==FALSE THEN
  ERR=ERROR_ERROR
  RETURN
 ELSE
  ERR=0
 ENDIF
 SBFILE$=MID$(SBFILE$,4+LEN(DATA$),&H7FFFFFFF)
 ERR=OFS_ADDFILE(DATA$,DIROBJ,TRUE,FILENAME$,SBFILE$,OFS_PERM_RW)
 ERR=OFS_CONV_ERR(ERR)
END
'SYMLINK
DEF OFS_GETFILETYPE PROJ$,DIROBJ,NAME$ OUT TYPE$,ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN TYPE$=""RETURN
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR
 TYPE$=""
 ERR=1
 RETURN
 @LINEAR
 VAR FI=OFS_SEARCH_L(FDATA,NAME$)
 IF FI==0 THEN
  ERR=FS_ERROR_NOTFOUND
  TYPE$=""
  RETURN
 ENDIF
 IF FDATA[FI+1]!=0THEN
  TYPE$="/"
  ERR=0
  RETURN
 ENDIF
 VAR SLEN=FDATA[FI+2]
 TYPE=FDATA[FI+3+SLEN]
 IF TYPE==OFS_CHILDTYPE_FILE THEN
  IF FDATA[FI+3+SLEN+1]THEN
   TYPE$=" "
   ERR=0
   RETURN
  ELSE
   TYPE$="*"
   ERR=0
   RETURN
  ENDIF
 ELSEIF TYPE==OFS_CHILDTYPE_MOUNT THEN
  TYPE$="/"
  ERR=0
  RETURN
 ELSEIF TYPE==OFS_CHILDTYPE_SYMLINK THEN
  OFS_READ_STR2 FDATA,FI+3+SLEN+5 OUT TYPE$,FI
  ERR=OFS_ERROR_SYMLINK
  RETURN
 ENDIF
 ERR=1
 TYPE$=""
 RETURN
END
DEF OFS_FILES_L_DIR(DIR[],OUT$)
 VAR I,L=LEN(DIR)-1
 FOR I=8TO L
  VAR RLEN=DIR[I]+1
  I=I+1
  VAR FOBJ=DIR[I]'unused
  I=I+1
  VAR LEN=DIR[I],J,L2=I+LEN
  
  VAR K=0,NAME$=""
  FOR J=I+1 TO L2
   INC NAME$,CHR$(DIR[J])
  NEXT
  IF FOBJ THEN
   PUSH OUT$,"/"+NAME$
  ELSE
   VAR TYPE=DIR[J]
   IF TYPE==OFS_CHILDTYPE_FILE THEN
    VAR ISDAT=DIR[J+1]
    IF ISDAT THEN 
     PUSH OUT$," "+NAME$
    ELSE
     PUSH OUT$,"*"+NAME$
    ENDIF
   ELSEIF TYPE==OFS_CHILDTYPE_MOUNT THEN
    PUSH OUT$,"/"+NAME$
   ELSEIF TYPE==OFS_CHILDTYPE_SYMLINK THEN
    VAR TAR$
    OFS_READ_STR2 DIR,J+5 OUT TAR$,
    VAR TYPE$
    VAR ERR
    GetFileType TAR$ OUT TYPE$,ERR
    IF ERR THEN
     PUSH OUT$,"?"+NAME$
    ELSE
     PUSH OUT$,TYPE$+NAME$
    ENDIF
   ELSE
    PUSH OUT$,"!broken file"
   ENDIF
  ENDIF
  
  I=I+RLEN
 NEXT
 RETURN FALSE
END
DEF OFS_FILES_L_DIR_FILE(DIR[],OUT$[],FILES$[])
 VAR I,L=LEN(DIR)-1
 FOR I=8TO L
  VAR RLEN=DIR[I]+1
  I=I+1
  VAR FOBJ=DIR[I]'unused
  I=I+1
  VAR LEN=DIR[I],J,L2=I+LEN
  
  VAR K=0,NAME$=""
  IF LEN(DIR)<=L2 THEN RETURN 1
  FOR J=I+1 TO L2
   INC NAME$,CHR$(DIR[J])
  NEXT
  IF FOBJ THEN
   PUSH OUT$,"DAT:@"+HEX$(FOBJ,8)+".FS"
   PUSH FILES$,NAME$
  ELSE
   VAR TYPE=DIR[L2+1]
   IF TYPE==OFS_CHILDTYPE_FILE THEN
    VAR ISDAT=DIR[L2+2]
    VAR _,SB$
    OFS_READ_STR2 DIR,L2+7 OUT SB$,_
    
    IF ISDAT THEN
     SB$="DAT:"+SB$
    ELSE 
     SB$="TXT:"+SB$
    ENDIF

    PUSH OUT$,SB$
    PUSH FILES$,NAME$
   ENDIF
  ENDIF
  
  I=I+RLEN
 NEXT
 RETURN FALSE
END
DEF OFS_DEVICE_FILES_PROJECT PROJECT$,PATH$ OUT A$,ERR
 DIM F$[0]
 FILES F$
 A$=F$
 ERR=0
END
DEF OFS_READ_DEVICE DIROBJ OUT DEVNAME$,DEVARG$,ERR
 VAR DIROBJ$="DAT:@"+HEX$(DIROBJ,8)+".FS"
'VAR OBJ$="DAT@:"+HEX$(OBJ,8)+".FS"
 DIM FDATA[0]
 LOAD DIROBJ$,FDATA,0
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDEV THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_READ) THEN ERR=OFS_ERROR_PERM:RETURN
 OFS_READ_STR FDATA,6 OUT DEVNAME$
 OFS_READ_STR FDATA,6+LEN(DEVNAME$)+1OUT DEVARG$
 ERR=FALSE
 RETURN
 @ERR
 ERR=TRUE
END
'RANDOMIZEで らんすう が おかしく なる かのうせい が ある
DEF OFS_RAND()
 OFS_RAND_Y=OFS_RAND_Y XOR (OFS_RAND_Y<<13)
 OFS_RAND_Y=OFS_RAND_Y XOR (OFS_RAND_Y>>17)
 OFS_RAND_Y=OFS_RAND_Y XOR (OFS_RAND_Y<<5)
 RETURN OFS_RAND_Y
END
DEF OFS_GEN_FOBJFILE_TXT PROJ$ OUT FILE$,ID
 @LOOP
 ID=OFS_RAND()
 IF LEN(PROJ$)THEN
  FILE$="TXT:"+PROJ$+"@"+HEX$(ID,8)+".FS"
 ELSE
  FILE$="TXT:@"+HEX$(ID,8)+".FS"
 ENDIF
 IF CHKFILE(FILE$)THEN
  'らんすうに もんだいが ないかぎり おこりにくい
  GOTO @LOOP
 ENDIF
 RETURN FILE$
END
DEF OFS_GEN_FOBJFILE PROJ$ OUT FILE$,ID
 @LOOP
 ID=OFS_RAND()
 IF LEN(PROJ$)THEN
  FILE$="DAT:"+PROJ$+"@"+HEX$(ID,8)+".FS"
 ELSE
  FILE$="DAT:@"+HEX$(ID,8)+".FS"
 ENDIF
 IF CHKFILE(FILE$)THEN
  'らんすうに もんだいが ないかぎり おこりにくい
  GOTO @LOOP
 ENDIF
 RETURN FILE$
END
DEF OFS_GEN_FOBJFILE_DAT PROJ$ OUT FILE$,ID
 @LOOP
 ID=OFS_RAND()
 IF LEN(PROJ$)THEN
  FILE$="DAT:"+PROJ$+"@"+HEX$(ID,8)+".FD"
 ELSE
  FILE$="DAT:@"+HEX$(ID,8)+".FD"
 ENDIF
 IF CHKFILE(FILE$)THEN
  'らんすうに もんだいが ないかぎり おこりにくい
  GOTO @LOOP
 ENDIF
 RETURN FILE$
END
DEF OFS_SAVE2(PROJ$,ID,DAT[])
 IF LEN(PROJ$)THEN
  IF!IsSmileTool()THEN
   RETURN ERROR_PERM
  ENDIF
  SAVE "DAT:"+PROJ$+"@"+HEX$(ID,8)+".FS",DAT
  IF RESULT!=1THEN RETURN TRUE
  RETURN FALSE
 ENDIF
 VAR ARY=OFS_SEARCH_CACHE(ID)
 IF ARY>0THEN
  SetSBArray ARY,DAT
 ELSE
  OFS_ADD_CACHE_ARY ID,DAT
 ENDIF
 SAVE "DAT:@"+HEX$(ID,8)+".FS",DAT
 IF RESULT!=1THEN RETURN TRUE
 RETURN FALSE
END
DEF OFS_WRITE_STR_EXPAND ARY[],S$
 PUSH ARY,LEN(S$)
 VAR J
 FOR J=0 TO LEN(S$)-1
  PUSH ARY,ASC(S$[J])
 NEXT
END
DEF OFS_WRITE_STR ARY[],I,S$
 ARY[I]=LEN(S$)
 VAR J
 FOR J=0 TO LEN(S$)-1
  I=I+1
  ARY[I]=ASC(S$[J])
 NEXT
END
DEF OFS_READ_STR ARY[],I OUT S$
 VAR L=I+1+ARY[I]-1
 S$=""
 FOR I=I+1 TO L
  INC S$,CHR$(ARY[I])
 NEXT
END
DEF OFS_READ_STR2 ARY[],I OUT S$,J
 VAR L=I+1+ARY[I]-1
 S$=""
 FOR I=I+1 TO L
  INC S$,CHR$(ARY[I])
 NEXT
 J=I
END
DEF OFS_SEARCH_L_DIR(DIR[],NAME$)
 VAR I,L=LEN(DIR)-1
 VAR LNAME=LEN(NAME$)
 FOR I=8TO L
  VAR RLEN=DIR[I]+1
  I=I+1
  VAR FOBJ=DIR[I]
  I=I+1
  VAR LEN=DIR[I],J,L2=I+LEN
  IF LNAME!=LEN||!FOBJ THEN
   I=I+RLEN
   CONTINUE
  ENDIF
  VAR K=0
  FOR J=I+1 TO L2
   IF ASC(NAME$[K])!=DIR[J]THEN
    GOTO @MISMATCH
    BREAK
   ENDIF
   K=K+1
  NEXT
  RETURN FOBJ
  @MISMATCH
  I=I+RLEN
 NEXT
 RETURN FALSE
END
DEF OFS_SEARCH_L(DIR[],NAME$)
 VAR I,L=LEN(DIR)-1
 VAR LNAME=LEN(NAME$)
 FOR I=8TO L
  VAR SI=I
  VAR RLEN=DIR[I]+1
  I=I+1
  VAR FOBJ=DIR[I]
  I=I+1
  VAR LEN=DIR[I],J,L2=I+LEN
  IF LNAME!=LEN THEN
   I=I+RLEN
   CONTINUE
  ENDIF
  VAR K=0
  FOR J=I+1 TO L2
   IF ASC(NAME$[K])!=DIR[J]THEN
    GOTO @MISMATCH
    BREAK
   ENDIF
   K=K+1
  NEXT
  RETURN SI
  @MISMATCH
  I=I+RLEN
 NEXT
 RETURN FALSE
END
DEF OFS_ADDOBJ_NEWDIR(PROJ$,DIROBJ,NAME$,PERM)
 VAR ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN RETURN ERR
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_WRITE) THEN RETURN OFS_ERROR_PERM

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 IF OFS_SEARCH_L_DIR(FDATA,NAME$)THEN
  RETURN OFS_ERROR_ALREADY
 ENDIF
 VAR FILE$,OBJ
 OFS_GEN_FOBJFILE PROJ$ OUT FILE$,OBJ
 ERR=OFS_NEWDIR(PROJ$,OBJ,PERM)
 IF ERR THEN RETURN ERR
 
 VAR LN=LEN(NAME$)
 VAR RESERVE=MAX(LN,OFS_DIR_RESERVE_DEF)
 PUSH FDATA,RESERVE
 PUSH FDATA,OBJ
 OFS_WRITE_STR_EXPAND FDATA,NAME$
 VAR I
 FOR I=LEN(NAME$)-1TO RESERVE-1
  PUSH FDATA,0
 NEXT
 IF OFS_SAVE2(PROJ$,DIROBJ,FDATA)THEN RETURN TRUE
 RETURN FALSE
 @ERR
 RETURN TRUE
END
DEF OFS_ADDFILE(PROJ$,DIROBJ,ISDAT,NAME$,SBFILE$,PERM)
 VAR ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN @ERR
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_WRITE) THEN RETURN OFS_ERROR_PERM

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 IF OFS_SEARCH_L_DIR(FDATA,NAME$)THEN
  RETURN OFS_ERROR_ALREADY
 ENDIF
OFS_WRITE_FILEDATA_EXPAND FDATA,NAME$,ISDAT,PERM,SBFILE$
 IF OFS_SAVE2(PROJ$,DIROBJ,FDATA)THEN RETURN TRUE
 RETURN FALSE
 @ERR
 RETURN TRUE
END
DEF OFS_OPENFILEINFO PROJ$,DIROBJ,FILENAME$ OUT SBFILE$,ISDAT,PERM,D1,D2,D3,SYM$,ERR
 SYM$=""
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN @ERR
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_WRITE) THEN
  ERR=OFS_ERROR_PERM
  GOTO @ERR2
 ENDIF

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 VAR FI=OFS_SEARCH_L(FDATA,FILENAME$)
 IF !FI THEN
  ERR=OFS_ERROR_NOTFOUND
  GOTO @ERR2
 ENDIF
 VAR SIZE=FDATA[FI]
 INC FI
 VAR OBJ=FDATA[FI]
 INC FI
 INC FI,FDATA[FI]+1
 VAR JTYPE=FDATA[FI]
 VAR ISSYM=JTYPE==OFS_CHILDTYPE_SYMLINK
 IF JTYPE!=OFS_CHILDTYPE_FILE&&!ISSYM THEN @ERR
 INC FI
 IF!ISSYM THEN
  'TYP-PERM,DTTM,TARGET$
  ISDAT=FDATA[FI]
  INC FI
 ENDIF
 PERM=FDATA[FI]
 INC FI
 D1=FDATA[FI]
 INC FI
 D2=FDATA[FI]
 INC FI
 D3=FDATA[FI]
 INC FI
 IF ISSYM THEN
  OFS_READ_STR2 FDATA,FI OUT SYM$,FI
  SBFILE$=""
  ISDAT=-1
 ELSE
  OFS_READ_STR2 FDATA,FI OUT SBFILE$,FI
 ENDIF
 ERR=0
 RETURN
 @ERR
 ERR=1
 @ERR2
 SBFILE$=""
 ISDAT=-1
 PERM=-1
 D1=-1
 D2=-1
 D3=-1
 RETURN
 
END
DEF OFS_WRITE_FILEDATA_EXPAND FDATA,NAME$,ISDAT,PERM,SBFILE$
 VAR LN=(LEN(NAME$))+(LEN(SBFILE$))+1+1+1+3
 PUSH FDATA,LN
 PUSH FDATA,0
 OFS_WRITE_STR_EXPAND FDATA,NAME$
 PUSH FDATA,OFS_CHILDTYPE_FILE
 PUSH FDATA,ISDAT
 PUSH FDATA,PERM
 OFS_WRITE_DATETIME_EXPAND FDATA
 OFS_WRITE_STR_EXPAND FDATA,SBFILE$
END
DEF OFS_ADDMOUNT(PROJ$,DIROBJ,NAME$,FS$,DATA$,PERM)
 VAR ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN @ERR
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_WRITE) THEN RETURN OFS_ERROR_PERM

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 IF OFS_SEARCH_L_DIR(FDATA,NAME$)THEN
  RETURN OFS_ERROR_ALREADY
 ENDIF
 OFS_WRITE_MOUNTDATA_EXPAND FDATA,NAME$,FS$,DATA$,PERM
 IF OFS_SAVE2(PROJ$,DIROBJ,FDATA)THEN RETURN TRUE
 RETURN FALSE
 @ERR
 RETURN TRUE
END
DEF OFS_WRITE_MOUNTDATA_EXPAND FDATA,NAME$,FS$,DATA$,PERM
 VAR LN=(LEN(NAME$))+LEN(FS$)+1+(LEN(DATA$)+1)+1+3
 PUSH FDATA,LN
 PUSH FDATA,0
 OFS_WRITE_STR_EXPAND FDATA,NAME$
 PUSH FDATA,OFS_CHILDTYPE_MOUNT
 PUSH FDATA,PERM
 OFS_WRITE_DATETIME_EXPAND FDATA
 OFS_WRITE_STR_EXPAND FDATA,FS$
 OFS_WRITE_STR_EXPAND FDATA,DATA$
END
'IWAZUMOGANA
'DATA$:LINK
DEF OFS_ADDSYMLINK(PROJ$,DIROBJ,NAME$,TARGET$,PERM)
 VAR ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,DIROBJ OUT FDATA,ERR
 IF ERR THEN @ERR
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_WRITE) THEN RETURN OFS_ERROR_PERM

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 IF OFS_SEARCH_L_DIR(FDATA,NAME$)THEN
  RETURN OFS_ERROR_ALREADY
 ENDIF
 OFS_WRITE_SYMLINKDATA_EXPAND FDATA,NAME$,TARGET$,PERM
 IF OFS_SAVE2(PROJ$,DIROBJ,FDATA)THEN RETURN TRUE
 RETURN FALSE
 @ERR
 RETURN TRUE
END
DEF OFS_WRITE_SYMLINKDATA_EXPAND FDATA,NAME$,TARGET$,PERM
 VAR LN=(LEN(NAME$))+LEN(TARGET$)+1+1+3
 PUSH FDATA,LN
 PUSH FDATA,0
 OFS_WRITE_STR_EXPAND FDATA,NAME$
 PUSH FDATA,OFS_CHILDTYPE_SYMLINK
 PUSH FDATA,PERM
 OFS_WRITE_DATETIME_EXPAND FDATA
 OFS_WRITE_STR_EXPAND FDATA,TARGET$
 'TYP-PERM,DTTM,TARGET$
END
'DEF OFS_NEWFILE(PATH$,
'File format
'0:"OTYF"
'1:"SDIR"
'2:PPERMISSION
'3-5:DATETIME
'6:FILE COUNT
'7:CONTAINER TYPE(0=LINEAR SEARCH)
'8-:FILES
'FILE OBJECT FORMAT
'0:SIZE
'1:OBJECT ID
'2:LEN(NAME$)
'3-:NAME$
'(FILE)
'3+LEN(NAME$):FILE TYPE(0=DIR,1=FILE,2=MOUNT)
'FILEのばあい
'0:ISDAT
'1:PERM
'2-4:DATETIME
'5:LEN(FILENAME$)
'6:FILENAME$
'(MOUNTED DEVICE)
'0:PERM
'1-3:DATETIME
'4:FILESYSTEM$
'5+LEN:DATA$

DEF OFS_NEWDIR(PROJ$,FOBJID,PERM)
 DIM FDATA[2+1+3+1+1]
 FDATA[0]=OFS_MAGIC_OTYF
 FDATA[1]=OFS_MAGIC_SDIR
 FDATA[2]=PERM
 OFS_WRITE_DATETIME FDATA,3
 FDATA[6]=0'FILECOUNT
 FDATA[7]=0'LINEAR
 IF OFS_SAVE2(PROJ$,FOBJID,FDATA)THEN RETURN TRUE
 RETURN FALSE
END
DEF OFS_WRITE_DATETIME ARY[],I
 VAR Y,M,D
 DTREAD OUT Y,M,D
 VAR H,MI,S
 TMREAD OUT H,MI,S
 ARY[I]=Y<<16+M<<8+D
 ARY[I+1]=H<<24+MI<<16+S<<8
 ARY[I+2]=0
END
DEF OFS_WRITE_DATETIME_EXPAND ARY[]
 VAR Y,M,D
 DTREAD OUT Y,M,D
 VAR H,MI,S
 TMREAD OUT H,MI,S
 PUSH ARY,Y<<16+M<<8+D
 PUSH ARY,H<<24+MI<<16+S<<8
 PUSH ARY,0
END

'Mark & sweep GC
DIM OFSGC_DIR_KEY[0]
DIM OFSGC_DIR_VAL[0]
DIM OFSGC_TXT_KEY[0]
DIM OFSGC_TXT_VAL[0]
DIM OFSGC_DAT_KEY[0]
DIM OFSGC_DAT_VAL[0]

DEF OFS_GC PROJ$
 DIM DIR_KEY#[0]
 DIM DIR_VAL[0]
 DIM TXT_KEY#[0]
 DIM TXT_VAL[0]
 DIM DAT_KEY#[0]
 DIM DAT_VAL[0]
 DIM TXT$[0]
 DIM DAT$[0]
 FILES "TXT:"+PROJ$,TXT$
 FILES "DAT:"+PROJ$,DAT$
 VAR I
 VAR SIZ=LEN("*@FFFFFFFF.FS")
 FOR I=0TO LEN(TXT$)-1
  VAR I$=TXT$[I]
  IF LEN(I$)==SIZ&&INSTR(I$,".FS")==LEN(I$)-3THEN
   PUSH TXT_KEY#,VAL("&H"+MID$(I$,2,LEN(I$)-5))
   PUSH TXT_VAL,FALSE
  ENDIF
 NEXT
 FOR I=0TO LEN(DAT$)-1
  I$=DAT$[I]
  IF LEN(I$)==SIZ&&INSTR(I$,".FS")+3==LEN(I$)THEN
   PUSH DIR_KEY#,VAL("&H"+MID$(I$,2,LEN(I$)-5))
   PUSH DIR_VAL,FALSE
  ENDIF
  IF LEN(I$)==SIZ&&INSTR(I$,".FD")+3==LEN(I$)THEN
   PUSH DAT_KEY#,VAL("&H"+MID$(I$,2,LEN(I$)-5))
   PUSH DAT_VAL,FALSE
  ENDIF
 NEXT
 SORT TXT_KEY#'TXT_VAL
 SORT DIR_KEY#'DIR_VAL
 SORT DAT_KEY#'DAT_VAL
 OFSGC_DIR_KEY=DIR_KEY#
 OFSGC_DIR_VAL=DIR_VAL
 OFSGC_TXT_KEY=TXT_KEY#
 OFSGC_TXT_VAL=TXT_VAL
 OFSGC_DAT_KEY=DAT_KEY#
 OFSGC_DAT_VAL=DAT_VAL
 
 OFSGC_DIR_VAL[BinarySearch#(OFSGC_DIR_KEY,OFS_ROOTFOBJID)]=TRUE
 PrintConsoleln "===mark==="
 OFS_GC_MARK PROJ$,OFS_ROOTFOBJID,"/"
 PrintConsoleln "===sweep==="
 OFS_GC_SWEEP PROJ$
END
DEF OFS_GC_SWEEP PROJ$
 VAR I
 FOR I=0TO LEN(OFSGC_DIR_KEY)-1
  VAR ID=OFSGC_DIR_KEY[I]
  VAR MARKED=OFSGC_DIR_VAL[I]
  VAR ERR
  IF MARKED THEN CONTINUE
  IF 0 THEN DIM FDATA[0]
  OFS_LOAD PROJ$,ID OUT FDATA,ERR
  IF!ERR THEN
  DIM OUTA$[0]
  DIM FILES$[0]
  IF!OFS_FILES_L_DIR_FILE(FDATA,OUTA$,FILES$)THEN
  VAR J
  PrintConsoleln "entries DIR:"+HEX$(ID,8)
  FOR J=0TO LEN(OUTA$)-1
   VAR OUT$=OUTA$[J]
   PrintConsoleln FORMAT$("%S %S",OUT$,FILES$[J])
  NEXT
  ELSE
   PrintConsoleln"(broken directory)"
  ENDIF
  ELSE
   PrintConsoleln"(broken directory)"
  ENDIF
  VAR SB$="DAT:"+PROJ$+"@"+HEX$(ID,8)+".FS"
  PrintConsoleln"sweep DIR:"+HEX$(ID,8)
  DELETE SB$
 NEXT
 FOR I=0TO LEN(OFSGC_TXT_KEY)-1
  ID=OFSGC_TXT_KEY[I]
  MARKED=OFSGC_TXT_VAL[I]
  IF MARKED THEN CONTINUE
  PrintConsoleln "content TXT:"+PROJ$+"@"+HEX$(ID,8)+".FS"
  VAR TXT$
  SB$="TXT:@"+HEX$(ID,8)+".FS"
  TXT$=LOAD(SB$,0)
  PrintConsole MID$(TXT$,0,1024)
  PrintConsoleln"sweep "+SB$
  DELETE SB$
 NEXT
 FOR I=0TO LEN(OFSGC_DAT_KEY)-1
  ID=OFSGC_DAT_KEY[I]
  MARKED=OFSGC_DAT_VAL[I]
  IF MARKED THEN CONTINUE
  SB$="DAT:"+PROJ$+"@"+HEX$(ID,8)+".FD"
  PrintConsoleln"sweep "+SB$
  DELETE SB$
 NEXT
END
DEF OFS_GC_MARK PROJ$,OBJ,DIR$
 PrintConsoleln "mark:"+DIR$
 VAR ERR
 IF 0 THEN DIM FDATA[0]
 OFS_LOAD PROJ$,OBJ OUT FDATA,ERR
 IF ERR THEN RETURN
 DIM OUTA$[0]
 DIM FILES$[0]
 ERR=OFS_FILES_L_DIR_FILE(FDATA,OUTA$,FILES$)
 IF ERR THEN PrintConsoleln"#broken directory"
 VAR I
 FOR I=0TO LEN(OUTA$)-1
  VAR OUT$=OUTA$[I]
  PrintConsoleln FORMAT$("%S %S",OUT$,FILES$[I])
  VAR ISDAT=INSTR(OUT$,"DAT:")==0
  VAR ISDIR=ISDAT&&INSTR(OUT$,".FS")+3==LEN(OUT$)
  VAR ID=VAL("&H"+MID$(OUT$,5,LEN(OUT$)-4-4))
  VAR J
  'MARK
  IF ISDIR THEN
   J=BinarySearch#(OFSGC_DIR_KEY,ID)
   'NAZO
   IF J==-1THEN J=FindArray(OFSGC_DIR_KEY,ID)
   IF J==-1THEN CONTINUE
   IF OFSGC_DIR_VAL[J]THEN CONTINUE
   OFSGC_DIR_VAL[J]=TRUE
   OFS_GC_MARK PROJ$,ID,CombinePath$(DIR$,FILES$[I])
  ELSEIF ISDAT THEN
   J=BinarySearch#(OFSGC_DAT_KEY,ID)
   IF J==-1THEN J=FindArray(OFSGC_DAT_KEY,ID)
   IF J==-1THEN CONTINUE
   IF OFSGC_DAT_VAL[J]THEN CONTINUE
   OFSGC_DAT_VAL[J]=TRUE
  ELSE
   J=BinarySearch#(OFSGC_TXT_KEY,ID)
   IF J==-1THEN J=FindArray(OFSGC_TXT_KEY,ID)
   IF J==-1THEN CONTINUE
   IF OFSGC_TXT_VAL[J]THEN CONTINUE
   OFSGC_TXT_VAL[J]=TRUE
  ENDIF
 NEXT
 PrintConsoleln "leave:"+DIR$
END
COMMON DEF I_OFSGC
 VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
 IF LEN(CMD$)&&RIGHT$(CMD$,1)!="/"THEN
  CMD$=CMD$+"/"
 ENDIF
 OFS_GC CMD$
 ExitProcess 0
END
COMMON DEF L_OFSGC
 ExitProcess 0
END
DIM FS_NAME$[0]
DIM FS_HFILELIST$[0]
DIM FS_HOPEN$[0]
DIM FS_HMOUNT$[0]
DIM FS_HGETFS$[0]
DIM FS_HNEWDIR$[0]
DIM FS_HDEL$[0]
DIM FS_HRENAME$[0]
DIM FS_HGETTYPE$[0]
DIM FS_HGETSBFILE$[0]
DIM FS_HSAVEDAT$[0]
DIM FS_HSYMLINK$[0]
DEF FS_INIT
 FS_NAME$=NewArray$(1)
 FS_HFILELIST$=NewArray$(1)
 FS_HOPEN$=NewArray$(1)
 FS_HMOUNT$=NewArray$(1)
 FS_HGETFS$=NewArray$(1)
 FS_HNEWDIR$=NewArray$(1)
 FS_HDEL$=NewArray$(1)
 FS_HRENAME$=NewArray$(1)
 FS_HGETTYPE$=NewArray$(1)
 FS_HGETSBFILE$=NewArray$(1)
 FS_HSAVEDAT$=NewArray$(1)
 FS_HSYMLINK$=NewArray$(1)
 FS_ERROR_NOTFOUND=&H6001
 RegisterError "FS_ERROR_NOTFOUND
 FS_ERROR_NOTSUPPORTED=&H6002
 RegisterError "FS_ERROR_NOTSUPPORTED
 FS_ERROR_ACCESS=&H6003
 RegisterError "FS_ERROR_ACCESS
 FS_ERROR_NOSPACE=&H6004
 RegisterError "FS_ERROR_NOSPACE
 FS_ERROR_CANCEL=&H6005
 RegisterError "FS_ERROR_CANCEL
 FS_ERROR_INVALIDFS=&H6006
 RegisterError "FS_ERROR_INVALIDFS
 FS_ERROR_DUPFS=&H6007
 RegisterError "FS_ERROR_DUPFS
 FS_ERROR_OUTOFMEM=&H6008
 RegisterError "FS_ERROR_OUTOFMEM
 FS_ERROR_INVALIDFUNC=&H6009
 RegisterError "FS_ERROR_INVALIDFUNC
 FS_ERROR_RESERVED=&H600A
 RegisterError "FS_ERROR_RESERVED
END
'SmileBASIC File System
DIM SB_RESERVEDFILE$[0]
DEF FS_INIT_SBFS
 @RESERVED
 DATA "COM1","COM2","COM3","COM4"'"COM5"
 DATA "LPT1","LPT2","LPT3","LPT4"
 DATA "CON" ,"NUL" ,"PRN" ,"AUX"
 SB_RESERVEDFILE$=NewArray$(12)
 COPY SB_RESERVEDFILE$,@RESERVED
 SORT SB_RESERVEDFILE$
 VAR FS,ERR
 NewFileSystem("SBFS") OUT FS,ERR
 IF ERR THEN RETURN
 ERR=FSSetFileListHandler(FS,"SBFS_FILELIST")
 IF ERR THEN RETURN
 ERR=FSSetOpenFileHandler(FS,"SBFS_OPEN")
 IF ERR THEN RETURN
 ERR=FSSetDeleteHandler(FS,"SBFS_DELFILE")
 IF ERR THEN RETURN
 ERR=FSSetRenameHandler(FS,"SBFS_RENAME")
 IF ERR THEN RETURN
 ERR=FSSetGetTypeHandler(FS,"SBFS_GETTYPE")
 IF ERR THEN RETURN
 ERR=FSSetGetSBFileHandler(FS,"SBFS_GETSBFILE")
 IF ERR THEN RETURN
 ERR=FSSetSaveDATAFileHandler(FS,"SBFS_SAVEDAT")
 IF ERR THEN RETURN
END
COMMON DEF GetRootFileSystem()
 RETURN ROOTFS
END
DEF ROOTFS_INIT OUT ERR
 ERR=0
 VAR FS=FindFileSystem("OFS")
 IF!FS THEN ERR=FS_ERROR_INVALIDFS:RETURN
 ROOTFS=FS
 RETURN
END
DEF SBFS_CONVPROJECTS F$
 VAR I,L=LEN(F$)-1
 FOR I=0TO L
  VAR E$=F$[I]
  IF LEN(E$)==1THEN
   F$[I]="/[DEFAULT]"
   CONTINUE
  ENDIF
  E$[0]="/"+E$[0]
  E$[LEN(F$[I])-1]=""
 NEXT
 
END
DEF SBFS_FILELIST FS,DATA$,PATH$,FILELIST$[] OUT ERR
 IF PATH$!="/" THEN
  IF DATA$=="//"THEN'LIST
   IF PATH$[LEN(PATH$)-1]=="/"THEN
    PATH$=LEFT$(PATH$,LEN(PATH$)-1)
   ENDIF
   VAR D=LASTINSTR(PATH$,"/")
   IF D==-1THEN ERR=1RETURN'?????
   IF D==0 THEN
    PATH$=MID$(PATH$,1,&H7FFFFFFF)
    ToUpper PATH$
    IF BinarySearch(SB_RESERVEDFILE$,PATH$)!=-1THEN
     ERR=FS_ERROR_RESERVED
     RETURN
    ENDIF
    PUSH FILELIST$,"/TXT"
    PUSH FILELIST$,"/DAT"
    ERR=0
    RETURN
   ENDIF
   VAR D$=MID$(PATH$,1,D-1)
   ToUpper D$
   IF BinarySearch(SB_RESERVEDFILE$,D$)!=-1THEN
    ERR=FS_ERROR_RESERVED
    RETURN
   ENDIF
   VAR D2$=MID$(PATH$,D+1,&H7FFFFFFF)
   IF D2$=="TXT"THEN
    ERR=0
    IF D$=="[DEFAULT]"THEN D$="/"
    FILES "TXT:"+D$,FILELIST$
    RETURN
   ENDIF
   IF D2$=="DAT"THEN
    ERR=0
    FILES "DAT:"+D$,FILELIST$
    RETURN
   ENDIF
  ENDIF
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 FILES DATA$,FILELIST$
 IF DATA$=="//"THEN'LIST
  SBFS_CONVPROJECTS FILELIST$
 ENDIF
 ERR=0
END
DEF SBFS_ISWRITABLE(DATA$)
 IF DATA$!="TXT:"&&DATA$!="DAT:"&&DATA$!=""THEN
  RETURN 0
 ENDIF
 RETURN 1
END
DEF SBFS_PARSE_PROJECTS PATH$ OUT PROJ$,TYPE$,FILE$,ERR
 PROJ$=""
 TYPE$=""
 FILE$=""
 ERR=ERROR_PERM
 IF!IsSmileTool()THEN RETURN
 IF 0THEN DIM PATHA$[0]
 PATHA$=Split(PATH$,"/")
 IF LEN(PATHA$)!=4THEN
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 PROJ$=PATHA$[1]
 IF PROJ$=="[DEFAULT]"THEN PROJ$=""
 TYPE$=PATHA$[2]'TXT|DAT
 FILE$=PATHA$[3]
 IF TYPE$!="TXT"&&TYPE$!="DAT"THEN
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 ToUpper FILE$
 IF BinarySearch(SB_RESERVEDFILE$,FILE$)!=-1THEN
  ERR=FS_ERROR_RESERVED
  RETURN
 ENDIF
 ERR=0
END

DEF SBFS_OPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 IF DATA$=="//"THEN
  FILE=0
  VAR PROJ$,TYPE$,FILE$
  SBFS_PARSE_PROJECTS PATH$ OUT PROJ$,TYPE$,FILE$,ERR
  IF ERR THEN RETURN
  PATH$=TYPE$+":"+PROJ$+"/"+FILE$
  DATA$=""
 ENDIF
 IF OPTION AND FileWriteFlag()&&!SBFS_ISWRITABLE(DATA$)THEN
  ERR=ERROR_PERM
  FILE=0
  RETURN
 ENDIF
 IF MID$(PATH$,0,1)=="/"THEN PATH$=RIGHT$(PATH$,LEN(PATH$)-1)
 AllocFile OUT FILE,ERR
 IF ERR THEN RETURN
 VAR F$=""
 PATH$=DATA$+PATH$
 IF MID$(PATH$,0,4)=="DAT:"THEN
  DIM A[0]
  LOAD PATH$,A,0
  VAR I,L=2*LEN(A)-1,J
  F$=CHR$(0)*(LEN(A)*2)
  FOR I=0TO L STEP 2
   F$[I]=CHR$(A[J] AND 65535)
   F$[I+1]=CHR$(A[J]>>16)
   J=J+1
  NEXT
 ELSEIF OPTION AND FileWriteFlag()THEN
 ELSEIF CHKFILE(PATH$) THEN
  F$=LOAD(PATH$,0)
 ENDIF
 SetFileDataStr FILE,F$
 SetFileNAME FILE,PATH$
 ERR=SetWriter(FILE,"TXTWRITER")
 ERR=SetReader(FILE,"TXTREADER")
 ERR=SetReadln(FILE,"TXTREADLN")
 ERR=SetClose(FILE,"TXTCLOSE")
 IF OPTION AND FileAppendFlag()THEN
  FileSeekCUR FILE,LEN(F$) OUT ERR
 ENDIF
' ERR=SetFlush(FID,NUFID,"TXTFLUSH")
END
DEF SBFS_DELFILE FS,DATA$,PATH$ OUT ERR
 IF DATA$=="//"THEN
  VAR PROJ$,TYPE$,FILE$
  SBFS_PARSE_PROJECTS PATH$ OUT PROJ$,TYPE$,FILE$,ERR
  IF ERR THEN RETURN
  PATH$="/"+TYPE$+":"+PROJ$+"/"+FILE$
  DATA$=""
 ENDIF
 IF!SBFS_ISWRITABLE(DATA$)THEN
  ERR=ERROR_PERM
  RETURN
 ENDIF
 VAR P$=DATA$+MID$(PATH$,1,LEN(PATH$))
 IF!CHKFILE(P$)THEN
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 DELETE P$
 ERR=0
END
DEF SBFS_RENAME FS,DATA$,PATH$,TO$ OUT ERR
 IF DATA$=="//"THEN
  VAR PROJ$,TYPE$,FILE$
  SBFS_PARSE_PROJECTS PATH$ OUT PROJ$,TYPE$,FILE$,ERR
  IF ERR THEN RETURN
  PATH$="/"+TYPE$+":"+PROJ$+"/"+FILE$
  DATA$=""
 ENDIF
 IF!SBFS_ISWRITABLE(DATA$)THEN
  ERR=ERROR_PERM
  RETURN
 ENDIF
 VAR P$=DATA$+MID$(PATH$,1,LEN(PATH$))
 IF!CHKFILE(P$)THEN
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 RENAME P$,DATA$+TO$
 ERR=0
END

DEF SBFS_GETTYPE FS,DATA$,PATH$ OUT TYPE$,ERR
 IF DATA$=="//"THEN
   IF PATH$[LEN(PATH$)-1]=="/"THEN
    PATH$=LEFT$(PATH$,LEN(PATH$)-1)
   ENDIF
   VAR D=LASTINSTR(PATH$,"/")
   IF D==-1THEN ERR=1RETURN'?????
   IF D==0 THEN
    TYPE$=""
    ERR=FS_ERROR_NOTFOUND
    RETURN
   ENDIF
   VAR D$=MID$(PATH$,1,D-1)
   VAR D2=LASTINSTR(D$,"/")
   VAR D2$=MID$(D$,D2+1,&H7FFFFFFF)
   
   IF D2$=="TXT"THEN
    ERR=0
    TYPE$="*"
    RETURN
   ENDIF
   IF D2$=="DAT"THEN
    ERR=0
    TYPE$=" "
    RETURN
   ENDIF
   TYPE$=""
   ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 VAR P$=DATA$+MID$(PATH$,1,LEN(PATH$))
 IF!CHKFILE(P$)THEN
  TYPE$=""
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 IF MID$(P$,0,4)=="TXT:"THEN
  ERR=0
  TYPE$="*"
  RETURN
 ENDIF
 IF MID$(P$,0,4)=="DAT:"THEN
  ERR=0
  TYPE$=" "
  RETURN
 ENDIF
 TYPE$=""
 ERR=FS_ERROR_NOTFOUND
END
DEF SBFS_GETSBFILE FS,DATA$,PATH$ OUT FILE$,ERR
 IF DATA$=="//"THEN
  VAR PROJ$,TYPE$
  SBFS_PARSE_PROJECTS PATH$ OUT PROJ$,TYPE$,FILE$,ERR
  IF ERR THEN RETURN
  FILE$=TYPE$+":"+PROJ$+"/"+FILE$
  RETURN
 ENDIF
 VAR P$=DATA$+MID$(PATH$,1,LEN(PATH$))
 IF!CHKFILE(P$)THEN
  FILE$=""
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 FILE$=P$
 ERR=0
END
DEF SBFS_SAVEDAT FS,DATA$,PATH$,ARRAY OUT ERR
 IF DATA$=="//"THEN
  VAR PROJ$,TYPE$,FILE$
  SBFS_PARSE_PROJECTS PATH$ OUT PROJ$,TYPE$,FILE$,ERR
  IF ERR THEN RETURN
  FILE$="/"+TYPE$+":"+PROJ$+"/"+FILE$
  DATA$=""
 ENDIF
 IF!SBFS_ISWRITABLE(DATA$)THEN
  ERR=ERROR_PERM
  RETURN
 ENDIF
 VAR P$=DATA$+MID$(PATH$,1,LEN(PATH$))
 SAVE P$,ARRAY
 IF RESULT==-1 THEN
  ERR=FS_ERROR_CANCEL
 ELSEIF RESULT==FALSE THEN
  ERR=ERROR_ERROR
 ELSE
  ERR=0
 ENDIF
END
'END SmileBASIC File System

COMMON DEF NewFileSystem NAME$ OUT FS,ERR
 PUSH FS_NAME$,NAME$
 PUSH FS_HFILELIST$,"FS_DEFFILELIST"
 PUSH FS_HOPEN$,"FS_DEFOPEN"
 PUSH FS_HMOUNT$,"FS_DEFMOUNT"
 PUSH FS_HGETFS$,"FS_DEFGETFS"
 PUSH FS_HNEWDIR$,"FS_NEWDIR"
 PUSH FS_HDEL$,"FS_DEL"
 PUSH FS_HRENAME$,"FS_DEFRENAME"
 PUSH FS_HGETTYPE$,"FS_DEFGETTYPE"
 PUSH FS_HGETSBFILE$,"FS_DEFGETSBFILE"
 PUSH FS_HSAVEDAT$,"FS_DEFSAVEDAT"
 PUSH FS_HSYMLINK$,"FS_DEFSYMLINK"
 ERR=0
 FS=LEN(FS_NAME$)-1
END
DEF FindFileSystemLinear(NAME$)
 VAR I,J=LEN(FS_NAME$)-1
 FOR I=0 TO J
  IF FS_NAME$[I]==NAME$THEN RETURN I
 NEXT
 RETURN 0
END
COMMON DEF FindFileSystem(NAME$)
 VAR R=FindFileSystemLinear(NAME$)
 IF R THEN RETURN R
 IF CHKCALL("FS_INIT_"+NAME$) THEN
  CALL "FS_INIT_"+NAME$
  RETURN FindFileSystemLinear(NAME$)
 ENDIF
 RETURN 0
END
COMMON DEF CheckFS(FS)
 RETURN 0<FS&&LEN(FS_NAME$)>FS
END
COMMON DEF FSSetFileListHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HFILELIST$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetOpenFileHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HOPEN$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetMountHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HMOUNT$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetGetFileSystemHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HGETFS$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetNewDirHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HNEWDIR$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetDeleteHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HDEL$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetRenameHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HRENAME$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetGetTypeHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HGETTYPE$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetGetSBFileHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HGETSBFILE$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetSaveDATAFileHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HSAVEDAT$[FS]=FUNC$
 RETURN 0
END
COMMON DEF FSSetSymlinkHandler(FS,FUNC$)
 IF!CheckFS(FS)THEN RETURN FS_ERROR_INVALIDFS
 IF!CHKCALL(FUNC$) THEN RETURN FS_ERROR_INVALIDFUNC
 FS_HSYMLINK$[FS]=FUNC$
 RETURN 0
END
DEF FS_DEFFILELIST FS,DATA$,PATH$,FILELIST$[] OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSGetFilesH OUTFS,OUTDATA$,OUTPATH$,FILELIST$ OUT ERR
  RETURN
 ENDIF
 ERR=0
END
DEF FS_DEFOPEN FS,DATA$,PATH$,FLG OUT FILE,ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSOpenFile OUTFS,OUTDATA$,OUTPATH$,FLG OUT FILE,ERR
  RETURN
 ENDIF
 FILE=0
 ERR=ERROR_NOPENFILE
END
DEF FS_DEFMOUNT FS,DATA$,PATH$,MOUNTFS$,MOUNTDATA$ OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSMount OUTFS,OUTDATA$,OUTPATH$,MOUNTFS$,MOUNTDATA$ OUT ERR
  RETURN
 ENDIF
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEFGETFS FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 'TODO:EXI
 ERR=0
 OUTFS=FS
 OUTDATA$=DATA$
 OUTPATH$=PATH$
END
DEF FS_NEWDIR FS,DATA$,PATH$ OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSNewDir OUTFS,OUTDATA$,OUTPATH$ OUT ERR
  RETURN
 ENDIF
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEL FS,DATA$,PATH$ OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSDelete OUTFS,OUTDATA$,OUTPATH$ OUT ERR
  RETURN
 ENDIF
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEFRENAME FS,DATA$,PATH$,NAME$ OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSRename OUTFS,OUTDATA$,OUTPATH$,NAME$ OUT ERR
  RETURN
 ENDIF
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEFGETTYPE FS,DATA$,PATH$ OUT TYPE$,ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSGetType OUTFS,OUTDATA$,OUTPATH$ OUT TYPE$,ERR
  RETURN
 ENDIF
 TYPE$=""
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEFGETSBFILE FS,DATA$,PATH$ OUT FILE$,ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSGetSBFile OUTFS,OUTDATA$,OUTPATH$ OUT FILE$,ERR
  RETURN
 ENDIF
 FILE$=""
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEFSAVEDAT FS,DATA$,PATH$,ARRAY OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSSaveDATAFile OUTFS,OUTDATA$,OUTPATH$,ARRAY OUT ERR
  RETURN
 ENDIF
 ERR=FS_ERROR_NOTSUPPORTED
END
DEF FS_DEFSYMLINK FS,DATA$,PATH$,TARGET$ OUT ERR
 VAR OUTFS,OUTDATA$,OUTPATH$
 FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF OUTPATH$!=PATH$THEN
  FSSymlink OUTFS,OUTDATA$,OUTPATH$,TARGET$ OUT ERR
  RETURN
 ENDIF
 ERR=FS_ERROR_NOTSUPPORTED
END

COMMON DEF FSGetFiles FS,DATA$,PATH$ OUT FILES$,ERR
 IF!CheckFS(FS)THEN ERR=FS_ERROR_INVALIDFS:RETURN
 DIM F$[0]
 FILES$=F$
 CALL FS_HFILELIST$[FS],FS,DATA$,PATH$,FILES$ OUT ERR
END
COMMON DEF FSGetFilesH FS,DATA$,PATH$,FILES$ OUT ERR
 IF!CheckFS(FS)THEN ERR=FS_ERROR_INVALIDFS:RETURN
 CALL FS_HFILELIST$[FS],FS,DATA$,PATH$,FILES$ OUT ERR
END
COMMON DEF FSNewDir FS,DATA$,PATH$ OUT ERR
 IF!CheckFS(FS)THEN ERR=FS_ERROR_INVALIDFS:RETURN
 CALL FS_HNEWDIR$[FS],FS,DATA$,PATH$ OUT ERR
END
COMMON DEF FSOpenFile FS,DATA$,PATH$,FLG OUT FILE,ERR
 IF!CheckFS(FS)THEN
  ERR=FS_ERROR_INVALIDFS
  FILE=0
  RETURN
 ENDIF
 CALL FS_HOPEN$[FS],FS,DATA$,PATH$,FLG OUT FILE,ERR
END
COMMON DEF FSMount FS,DATA$,PATH$,FS$,DT$ OUT ERR
 IF!CheckFS(FS)THEN ERR=FS_ERROR_INVALIDFS:RETURN
 CALL FS_HMOUNT$[FS],FS,DATA$,PATH$,FS$,DT$ OUT ERR
END
COMMON DEF FSDelete FS,DATA$,PATH$ OUT ERR
 IF!CheckFS(FS)THEN ERR=FS_ERROR_INVALIDFS:RETURN
 CALL FS_HDEL$[FS],FS,DATA$,PATH$ OUT ERR
END
COMMON DEF FSRename FS,DATA$,PATH$,TO$ OUT ERR
 IF!CheckFS(FS)THEN ERR=FS_ERROR_INVALIDFS:RETURN
 CALL FS_HRENAME$[FS],FS,DATA$,PATH$,TO$ OUT ERR
END
COMMON DEF FSGetFileSystem FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
 IF!CheckFS(FS)THEN
  OUTFS=0
  OUTDATA$=""
  OUTPATH$=""
  ERR=FS_ERROR_INVALIDFS
  RETURN
 ENDIF
 CALL FS_HGETFS$[FS],FS,DATA$,PATH$ OUT OUTFS,OUTDATA$,OUTPATH$,ERR
END
COMMON DEF FSGetType FS,DATA$,PATH$ OUT TYPE$,ERR
 IF!CheckFS(FS)THEN
  TYPE$=""
  ERR=FS_ERROR_INVALIDFS
  RETURN
 ENDIF
 CALL FS_HGETTYPE$[FS],FS,DATA$,PATH$ OUT TYPE$,ERR
END
COMMON DEF FSGetSBFile FS,DATA$,PATH$ OUT FILE$,ERR
 IF!CheckFS(FS)THEN
  FILE$=""
  ERR=FS_ERROR_INVALIDFS
  RETURN
 ENDIF
 CALL FS_HGETSBFILE$[FS],FS,DATA$,PATH$ OUT FILE$,ERR
END
COMMON DEF FSSaveDATAFile FS,DATA$,PATH$,ARRAY OUT ERR
 IF!CheckFS(FS)THEN
  ERR=FS_ERROR_INVALIDFS
  RETURN
 ENDIF
 CALL FS_HSAVEDAT$[FS],FS,DATA$,PATH$,ARRAY OUT ERR
END
COMMON DEF FSSymlink FS,DATA$,PATH$,TARGET$ OUT ERR
 IF!CheckFS(FS)THEN
  ERR=FS_ERROR_INVALIDFS
  RETURN
 ENDIF
 CALL FS_HSYMLINK$[FS],FS,DATA$,PATH$,TARGET$ OUT ERR
END


DIM NULLARRAY[0]
DIM SBARY[0]
VAR SBARYMAX
VAR SBARYFREE
DEF OTX_INIT_SBARRAY
 SBARYMAX=1024'256
 SBARY=NewArray(SBARYMAX)
 VAR I
 FOR I=0TO SBARYMAX-2
  SBARY[I]=I+1
 NEXT
 SBARY[SBARYMAX-1]=-1
 SBARYFREE=1
 NULLARRAY=NewArray(0)
END
COMMON DEF AllocSBArray()
 VAR A=SBARYFREE
 IF A==-1THEN RETURN -1
 SBARYFREE=SBARY[A]
 RETURN A
END
COMMON DEF FreeSBArray A
 SBARY[A]=SBARYFREE
 SBARYFREE=A
 VAR("_"+HEX$(A))=NULLARRAY
END
COMMON DEF GetSBArray(A)
 RETURN VAR("_"+HEX$(A))
END
COMMON DEF SetSBArray A,ARY
 VAR("_"+HEX$(A))=ARY
END
DIM _0[0],_1[0],_2[0],_3[0],_4[0],_5[0],_6[0],_7[0],_8[0],_9[0],_A[0],_B[0],_C[0],_D[0],_E[0],_F[0],_10[0],_11[0],_12[0],_13[0],_14[0],_15[0],_16[0],_17[0],_18[0],_19[0],_1A[0],_1B[0],_1C[0],_1D[0],_1E[0],_1F[0],_20[0],_21[0],_22[0],_23[0],_24[0],_25[0],_26[0],_27[0],_28[0],_29[0],_2A[0],_2B[0],_2C[0],_2D[0],_2E[0],_2F[0],_30[0],_31[0],_32[0],_33[0],_34[0],_35[0],_36[0],_37[0],_38[0],_39[0],_3A[0],_3B[0],_3C[0],_3D[0],_3E[0],_3F[0],_40[0],_41[0],_42[0],_43[0],_44[0],_45[0],_46[0],_47[0],_48[0],_49[0],_4A[0],_4B[0],_4C[0],_4D[0],_4E[0],_4F[0],_50[0],_51[0],_52[0],_53[0],_54[0],_55[0],_56[0],_57[0],_58[0],_59[0],_5A[0],_5B[0],_5C[0],_5D[0],_5E[0],_5F[0],_60[0],_61[0],_62[0],_63[0],_64[0],_65[0],_66[0],_67[0],_68[0],_69[0],_6A[0],_6B[0],_6C[0],_6D[0],_6E[0],_6F[0],_70[0],_71[0],_72[0],_73[0],_74[0],_75[0],_76[0],_77[0],_78[0],_79[0],_7A[0],_7B[0],_7C[0],_7D[0],_7E[0],_7F[0],_80[0],_81[0],_82[0],_83[0],_84[0],_85[0],_86[0],_87[0],_88[0],_89[0],_8A[0],_8B[0],_8C[0],_8D[0],_8E[0],_8F[0],_90[0],_91[0],_92[0],_93[0],_94[0],_95[0],_96[0],_97[0],_98[0],_99[0],_9A[0],_9B[0],_9C[0],_9D[0],_9E[0],_9F[0],_A0[0],_A1[0],_A2[0],_A3[0],_A4[0],_A5[0],_A6[0],_A7[0],_A8[0],_A9[0],_AA[0],_AB[0],_AC[0],_AD[0],_AE[0],_AF[0],_B0[0],_B1[0],_B2[0],_B3[0],_B4[0],_B5[0],_B6[0],_B7[0],_B8[0],_B9[0],_BA[0],_BB[0],_BC[0],_BD[0],_BE[0],_BF[0],_C0[0],_C1[0],_C2[0],_C3[0],_C4[0],_C5[0],_C6[0],_C7[0],_C8[0],_C9[0],_CA[0],_CB[0],_CC[0],_CD[0],_CE[0],_CF[0],_D0[0],_D1[0],_D2[0],_D3[0],_D4[0],_D5[0],_D6[0],_D7[0],_D8[0],_D9[0],_DA[0],_DB[0],_DC[0],_DD[0],_DE[0],_DF[0],_E0[0],_E1[0],_E2[0],_E3[0],_E4[0],_E5[0],_E6[0],_E7[0],_E8[0],_E9[0],_EA[0],_EB[0],_EC[0],_ED[0],_EE[0],_EF[0],_F0[0],_F1[0],_F2[0],_F3[0],_F4[0],_F5[0],_F6[0],_F7[0],_F8[0],_F9[0],_FA[0],_FB[0],_FC[0],_FD[0],_FE[0],_FF[0],_100[0],_101[0],_102[0],_103[0],_104[0],_105[0],_106[0],_107[0],_108[0],_109[0],_10A[0],_10B[0],_10C[0],_10D[0],_10E[0],_10F[0],_110[0],_111[0],_112[0],_113[0],_114[0],_115[0],_116[0],_117[0],_118[0],_119[0],_11A[0],_11B[0],_11C[0],_11D[0],_11E[0],_11F[0],_120[0],_121[0],_122[0],_123[0],_124[0],_125[0],_126[0],_127[0],_128[0],_129[0],_12A[0],_12B[0],_12C[0],_12D[0],_12E[0],_12F[0],_130[0],_131[0],_132[0],_133[0],_134[0],_135[0],_136[0],_137[0],_138[0],_139[0],_13A[0],_13B[0],_13C[0],_13D[0],_13E[0],_13F[0],_140[0],_141[0],_142[0],_143[0],_144[0],_145[0],_146[0],_147[0],_148[0],_149[0],_14A[0],_14B[0],_14C[0],_14D[0],_14E[0],_14F[0],_150[0],_151[0],_152[0],_153[0],_154[0],_155[0],_156[0],_157[0],_158[0],_159[0],_15A[0],_15B[0],_15C[0],_15D[0],_15E[0],_15F[0],_160[0],_161[0],_162[0],_163[0],_164[0],_165[0],_166[0],_167[0],_168[0],_169[0],_16A[0],_16B[0],_16C[0],_16D[0],_16E[0],_16F[0],_170[0],_171[0],_172[0],_173[0],_174[0],_175[0],_176[0],_177[0],_178[0],_179[0],_17A[0],_17B[0],_17C[0],_17D[0],_17E[0],_17F[0],_180[0],_181[0],_182[0],_183[0],_184[0],_185[0],_186[0],_187[0],_188[0],_189[0],_18A[0],_18B[0],_18C[0],_18D[0],_18E[0],_18F[0],_190[0],_191[0],_192[0],_193[0],_194[0],_195[0],_196[0],_197[0],_198[0],_199[0],_19A[0],_19B[0],_19C[0],_19D[0],_19E[0],_19F[0],_1A0[0],_1A1[0],_1A2[0],_1A3[0],_1A4[0],_1A5[0],_1A6[0],_1A7[0],_1A8[0],_1A9[0],_1AA[0],_1AB[0],_1AC[0],_1AD[0],_1AE[0],_1AF[0],_1B0[0],_1B1[0],_1B2[0],_1B3[0],_1B4[0],_1B5[0],_1B6[0],_1B7[0],_1B8[0],_1B9[0],_1BA[0],_1BB[0],_1BC[0],_1BD[0],_1BE[0],_1BF[0],_1C0[0],_1C1[0],_1C2[0],_1C3[0],_1C4[0],_1C5[0],_1C6[0],_1C7[0],_1C8[0],_1C9[0],_1CA[0],_1CB[0],_1CC[0],_1CD[0],_1CE[0],_1CF[0],_1D0[0],_1D1[0],_1D2[0],_1D3[0],_1D4[0],_1D5[0],_1D6[0],_1D7[0],_1D8[0],_1D9[0],_1DA[0],_1DB[0],_1DC[0],_1DD[0],_1DE[0],_1DF[0],_1E0[0],_1E1[0],_1E2[0],_1E3[0],_1E4[0],_1E5[0],_1E6[0],_1E7[0],_1E8[0],_1E9[0],_1EA[0],_1EB[0],_1EC[0],_1ED[0],_1EE[0],_1EF[0],_1F0[0],_1F1[0],_1F2[0],_1F3[0],_1F4[0],_1F5[0],_1F6[0],_1F7[0],_1F8[0],_1F9[0],_1FA[0],_1FB[0],_1FC[0],_1FD[0],_1FE[0],_1FF[0],_200[0],_201[0],_202[0],_203[0],_204[0],_205[0],_206[0],_207[0],_208[0],_209[0],_20A[0],_20B[0],_20C[0],_20D[0],_20E[0],_20F[0],_210[0],_211[0],_212[0],_213[0],_214[0],_215[0],_216[0],_217[0],_218[0],_219[0],_21A[0],_21B[0],_21C[0],_21D[0],_21E[0],_21F[0],_220[0],_221[0],_222[0],_223[0],_224[0],_225[0],_226[0],_227[0],_228[0],_229[0],_22A[0],_22B[0],_22C[0],_22D[0],_22E[0],_22F[0],_230[0],_231[0],_232[0],_233[0],_234[0],_235[0],_236[0],_237[0],_238[0],_239[0],_23A[0],_23B[0],_23C[0],_23D[0],_23E[0],_23F[0],_240[0],_241[0],_242[0],_243[0],_244[0],_245[0],_246[0],_247[0],_248[0],_249[0],_24A[0],_24B[0],_24C[0],_24D[0],_24E[0],_24F[0],_250[0],_251[0],_252[0],_253[0],_254[0],_255[0],_256[0],_257[0],_258[0],_259[0],_25A[0],_25B[0],_25C[0],_25D[0],_25E[0],_25F[0],_260[0],_261[0],_262[0],_263[0],_264[0],_265[0],_266[0],_267[0],_268[0],_269[0],_26A[0],_26B[0],_26C[0],_26D[0],_26E[0],_26F[0],_270[0],_271[0],_272[0],_273[0],_274[0],_275[0],_276[0],_277[0],_278[0],_279[0],_27A[0],_27B[0],_27C[0],_27D[0],_27E[0],_27F[0],_280[0],_281[0],_282[0],_283[0],_284[0],_285[0],_286[0],_287[0],_288[0],_289[0],_28A[0],_28B[0],_28C[0],_28D[0],_28E[0],_28F[0],_290[0],_291[0],_292[0],_293[0],_294[0],_295[0],_296[0],_297[0],_298[0],_299[0],_29A[0],_29B[0],_29C[0],_29D[0],_29E[0],_29F[0],_2A0[0],_2A1[0],_2A2[0],_2A3[0],_2A4[0],_2A5[0],_2A6[0],_2A7[0],_2A8[0],_2A9[0],_2AA[0],_2AB[0],_2AC[0],_2AD[0],_2AE[0],_2AF[0],_2B0[0],_2B1[0],_2B2[0],_2B3[0],_2B4[0],_2B5[0],_2B6[0],_2B7[0],_2B8[0],_2B9[0],_2BA[0],_2BB[0],_2BC[0],_2BD[0],_2BE[0],_2BF[0],_2C0[0],_2C1[0],_2C2[0],_2C3[0],_2C4[0],_2C5[0],_2C6[0],_2C7[0],_2C8[0],_2C9[0],_2CA[0],_2CB[0],_2CC[0],_2CD[0],_2CE[0],_2CF[0],_2D0[0],_2D1[0],_2D2[0],_2D3[0],_2D4[0],_2D5[0],_2D6[0],_2D7[0],_2D8[0],_2D9[0],_2DA[0],_2DB[0],_2DC[0],_2DD[0],_2DE[0],_2DF[0],_2E0[0],_2E1[0],_2E2[0],_2E3[0],_2E4[0],_2E5[0],_2E6[0],_2E7[0],_2E8[0],_2E9[0],_2EA[0],_2EB[0],_2EC[0],_2ED[0],_2EE[0],_2EF[0],_2F0[0],_2F1[0],_2F2[0],_2F3[0],_2F4[0],_2F5[0],_2F6[0],_2F7[0],_2F8[0],_2F9[0],_2FA[0],_2FB[0],_2FC[0],_2FD[0],_2FE[0],_2FF[0],_300[0],_301[0],_302[0],_303[0],_304[0],_305[0],_306[0],_307[0],_308[0],_309[0],_30A[0],_30B[0],_30C[0],_30D[0],_30E[0],_30F[0],_310[0],_311[0],_312[0],_313[0],_314[0],_315[0],_316[0],_317[0],_318[0],_319[0],_31A[0],_31B[0],_31C[0],_31D[0],_31E[0],_31F[0],_320[0],_321[0],_322[0],_323[0],_324[0],_325[0],_326[0],_327[0],_328[0],_329[0],_32A[0],_32B[0],_32C[0],_32D[0],_32E[0],_32F[0],_330[0],_331[0],_332[0],_333[0],_334[0],_335[0],_336[0],_337[0],_338[0],_339[0],_33A[0],_33B[0],_33C[0],_33D[0],_33E[0],_33F[0],_340[0],_341[0],_342[0],_343[0],_344[0],_345[0],_346[0],_347[0],_348[0],_349[0],_34A[0],_34B[0],_34C[0],_34D[0],_34E[0],_34F[0],_350[0],_351[0],_352[0],_353[0],_354[0],_355[0],_356[0],_357[0],_358[0],_359[0],_35A[0],_35B[0],_35C[0],_35D[0],_35E[0],_35F[0],_360[0],_361[0],_362[0],_363[0],_364[0],_365[0],_366[0],_367[0],_368[0],_369[0],_36A[0],_36B[0],_36C[0],_36D[0],_36E[0],_36F[0],_370[0],_371[0],_372[0],_373[0],_374[0],_375[0],_376[0],_377[0],_378[0],_379[0],_37A[0],_37B[0],_37C[0],_37D[0],_37E[0],_37F[0],_380[0],_381[0],_382[0],_383[0],_384[0],_385[0],_386[0],_387[0],_388[0],_389[0],_38A[0],_38B[0],_38C[0],_38D[0],_38E[0],_38F[0],_390[0],_391[0],_392[0],_393[0],_394[0],_395[0],_396[0],_397[0],_398[0],_399[0],_39A[0],_39B[0],_39C[0],_39D[0],_39E[0],_39F[0],_3A0[0],_3A1[0],_3A2[0],_3A3[0],_3A4[0],_3A5[0],_3A6[0],_3A7[0],_3A8[0],_3A9[0],_3AA[0],_3AB[0],_3AC[0],_3AD[0],_3AE[0],_3AF[0],_3B0[0],_3B1[0],_3B2[0],_3B3[0],_3B4[0],_3B5[0],_3B6[0],_3B7[0],_3B8[0],_3B9[0],_3BA[0],_3BB[0],_3BC[0],_3BD[0],_3BE[0],_3BF[0],_3C0[0],_3C1[0],_3C2[0],_3C3[0],_3C4[0],_3C5[0],_3C6[0],_3C7[0],_3C8[0],_3C9[0],_3CA[0],_3CB[0],_3CC[0],_3CD[0],_3CE[0],_3CF[0],_3D0[0],_3D1[0],_3D2[0],_3D3[0],_3D4[0],_3D5[0],_3D6[0],_3D7[0],_3D8[0],_3D9[0],_3DA[0],_3DB[0],_3DC[0],_3DD[0],_3DE[0],_3DF[0],_3E0[0],_3E1[0],_3E2[0],_3E3[0],_3E4[0],_3E5[0],_3E6[0],_3E7[0],_3E8[0],_3E9[0],_3EA[0],_3EB[0],_3EC[0],_3ED[0],_3EE[0],_3EF[0],_3F0[0],_3F1[0],_3F2[0],_3F3[0],_3F4[0],_3F5[0],_3F6[0],_3F7[0],_3F8[0],_3F9[0],_3FA[0],_3FB[0],_3FC[0],_3FD[0],_3FE[0],_3FF[0],_400[0]
DIM CON_FREE[0]
DIM CON_VAR[0]
DIM CON_VAR$[0]
DIM CON_GETSIZE$[0]
DIM CON_PUT$[0]
DIM CON_RD$[0]
DIM CON_SETFORE$[0]
DIM CON_SETBACK$[0]
DIM CON_GETFORE$[0]
DIM CON_GETBACK$[0]
DIM CON_SETCUR$[0]
DIM CON_GETCUR$[0]
DIM CON_ID[0]
VAR CON_IDCNT
VAR CON_IDMASK
VAR CON_IDSHIFT
DEF CON_INIT OUT ERR
 CON_FREE=NewArray(0)
 CON_VAR=NewArray(1)
 CON_VAR$=NewArray$(1)
 CON_GETSIZE$=NewArray$(1)
 CON_PUT$=NewArray$(1)
 CON_RD$=NewArray$(1)
 CON_SETFORE$=NewArray$(1)
 CON_GETFORE$=NewArray$(1)
 CON_SETBACK$=NewArray$(1)
 CON_GETBACK$=NewArray$(1)
 CON_SETCUR$=NewArray$(1)
 CON_GETCUR$=NewArray$(1)
 CON_ID=NewArray(1)
 CON_ID[0]=-2
 CON_ERROR_INVALIDCON=&H7001
 CON_ERROR_INVALIDFUNC=&H7002
 CON_IDMASK=&HFFFF
 CON_IDSHIFT=16
 
 NewConsole OUT CON_SBCON,ERR:IF ERR THEN @E
 SetGetConsoleSizeHandler CON_SBCON,"SBCON_GETSIZE"OUT ERR
 IF ERR THEN @E
 SetReadConsoleHandler CON_SBCON,"SBCON_RD"OUT ERR
 IF ERR THEN @E
 SetPutConsoleHandler CON_SBCON,"SBCON_PUT"OUT ERR
 IF ERR THEN @E
 SetSetConsoleForeHandler CON_SBCON,"SBCON_SETFORE"OUT ERR
 IF ERR THEN @E
 SetGetConsoleForeHandler CON_SBCON,"SBCON_GETFORE"OUT ERR
 IF ERR THEN @E
 SetSetConsoleBackHandler CON_SBCON,"SBCON_SETBACK"OUT ERR
 IF ERR THEN @E
 SetGetConsoleBackHandler CON_SBCON,"SBCON_GETBACK"OUT ERR
 IF ERR THEN @E
 SetSetConsoleCursorHandler CON_SBCON,"SBCON_SETCURS"OUT ERR
 IF ERR THEN @E
 SetGetConsoleCursorHandler CON_SBCON,"SBCON_GETCURS"OUT ERR
 IF ERR THEN @E
 
 RETURN
 @E
 RETURN
END
DEF SBCON_GETSIZE CON OUT W,H,ERR
 ERR=0
 W=50
 H=30
END
DEF SBCON_RD CON,LEN OUT RES$,ERR
 RES$=""
 ERR=0
 WHILE LEN
  VAR K$=INKEY$()
  IF K$==""THEN BREAK
  IF K$==CR$THEN
   PUSH RES$,LF$
   CONTINUE
  ELSE
   PUSH RES$,K$
  ENDIF
  LEN=LEN-1
 WEND
END
DEF SBCON_PUT CON,BUF$ OUT ERR
 ERR=ConsoleWriterStr_(BUF$)
END
DEF SBCON_GETCURS CON OUT X,Y,ERR
 X=CSRX
 Y=CSRY
 ERR=0
END
VAR SBCON_FORE
VAR SBCON_BACK
DEF SBCON_SETCURS(CON,X,Y)
 IF X<0||Y<0||X>=50||Y>=30THEN RETURN 1
 LOCATE X,Y
 RETURN 0
END
DEF SBCON_SETFORE(CON,C)
 IF C<0||C>15 THEN RETURN 1
 COLOR C
 SBCON_FORE=C
 RETURN 0
END
DEF SBCON_SETBACK(CON,C)
 IF C<0||C>15 THEN RETURN 1
 COLOR ,C
 SBCON_BACK=C
 RETURN 0
END
DEF SBCON_GETFORE CON OUT C,ERR
 C=SBCON_FORE
 ERR=0
END
DEF SBCON_GETBACK CON OUT C,ERR
 C=SBCON_BACK
 ERR=0
END
COMMON DEF NewConsole OUT CON,ERR
 ERR=0
 VAR NC
 CON_IDCNT=CON_IDCNT+1AND CON_IDMASK
 IF LEN(CON_FREE)THEN
  NC=POP(CON_FREE)
  CON_GETSIZE$[NC]="CON_DEFGETSIZE"
  CON_PUT$[NC]="CON_DEFPUT"
  CON_RD$[NC]="CON_DEFRD"
  CON_SETFORE$[NC]=""
  CON_GETFORE$[NC]=""
  CON_SETBACK$[NC]=""
  CON_GETBACK$[NC]=""
  CON_SETCUR$[NC]=""
  CON_GETCUR$[NC]=""
  CON_VAR$[NC]=""
  CON_VAR[NC]=0
  CON_ID[NC]=CON_IDCNT
 ELSE
  NC=LEN(CON_GETSIZE$)
  PUSH CON_GETSIZE$,"CON_DEFGETSIZE"
  PUSH CON_PUT$,"CON_DEFPUT"
  PUSH CON_RD$,"CON_DEFRD"
  PUSH CON_SETFORE$,""
  PUSH CON_GETFORE$,""
  PUSH CON_SETBACK$,""
  PUSH CON_GETBACK$,""
  PUSH CON_SETCUR$,""
  PUSH CON_GETCUR$,""
  PUSH CON_VAR$,""
  PUSH CON_VAR,0
  PUSH CON_ID,CON_IDCNT
 ENDIF
 CON=CON_IDCNT OR (NC<<CON_IDSHIFT)
END
COMMON DEF DupConsole CON OUT ERR,CON2
 IF!CheckConsole(CON)THEN
  CON2=0
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 NewConsole OUT CON2,ERR
 IF ERR THEN RETURN
 VAR NC1=CON>>CON_IDSHIFT
 VAR NC=CON2>>CON_IDSHIFT
 CON_GETSIZE$[NC]=CON_GETSIZE$[NC1]
 CON_PUT$[NC]=CON_PUT$[NC1]
 CON_RD$[NC]=CON_RD$[NC1]
 CON_SETFORE$=CON_SETFORE$
 CON_GETFORE$=CON_GETFORE$
 CON_SETBACK$=CON_SETBACK$
 CON_GETBACK$=CON_GETFORE$
 CON_SETCUR$=CON_SETCUR$
 CON_GETCUR$=CON_GETCUR$
 CON_VAR$[NC]=CON_VAR$[NC1]
 CON_VAR[NC]=CON_VAR[NC1]
END
COMMON DEF CheckConsole(CON)
 RETURN (CON>>CON_IDSHIFT)>0&&(CON>>CON_IDSHIFT)<LEN(CON_ID)&&(CON AND CON_IDMASK)==CON_ID[CON>>CON_IDSHIFT]
END
COMMON DEF DeleteConsole CON OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 VAR C=CON>>CON_IDSHIFT
 PUSH CON_FREE,C
 CON_VAR$[C]=""
 ERR=0
END
COMMON DEF SetGetConsoleSizeHandler(CON,FUNC$)
 IF!CHKCALL(FUNC$)THEN
  RETURN CON_ERROR_INVALIDFUNC
 ENDIF
 IF!CheckConsole(CON)THEN
  RETURN CON_ERROR_INVALIDCON
 ENDIF
 CON_GETSIZE$[CON>>CON_IDSHIFT]=FUNC$
 RETURN 0
END
COMMON DEF SetPutConsoleHandler(CON,FUNC$)
 IF!CHKCALL(FUNC$)THEN
  RETURN CON_ERROR_INVALIDFUNC
 ENDIF
 IF!CheckConsole(CON)THEN
  RETURN CON_ERROR_INVALIDCON
 ENDIF
 CON_PUT$[CON>>CON_IDSHIFT]=FUNC$
 RETURN 0
END
COMMON DEF SetReadConsoleHandler(CON,FUNC$)
 IF!CHKCALL(FUNC$)THEN
  RETURN CON_ERROR_INVALIDFUNC
 ENDIF
 IF!CheckConsole(CON)THEN
  RETURN CON_ERROR_INVALIDCON
 ENDIF
 CON_RD$[CON>>CON_IDSHIFT]=FUNC$
 RETURN 0
END
DEF CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF!CHKCALL(FUNC$)THEN
  ERR=CON_ERROR_INVALIDFUNC
 ENDIF
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
 ENDIF
 ERR=0
END
COMMON DEF SetGetConsoleCursorHandler CON,FUNC$ OUT ERR
 CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF ERR THEN RETURN
 CON_GETCUR$[CON>>CON_IDSHIFT]=FUNC$
END
COMMON DEF SetSetConsoleCursorHandler CON,FUNC$ OUT ERR
 CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF ERR THEN RETURN
 CON_SETCUR$[CON>>CON_IDSHIFT]=FUNC$
END
COMMON DEF SetGetConsoleForeHandler CON,FUNC$ OUT ERR
 CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF ERR THEN RETURN
 CON_GETFORE$[CON>>CON_IDSHIFT]=FUNC$
END
COMMON DEF SetSetConsoleForeHandler CON,FUNC$ OUT ERR
 CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF ERR THEN RETURN
 CON_SETFORE$[CON>>CON_IDSHIFT]=FUNC$
END
COMMON DEF SetGetConsoleBackHandler CON,FUNC$ OUT ERR
 CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF ERR THEN RETURN
 CON_GETBACK$[CON>>CON_IDSHIFT]=FUNC$
END
COMMON DEF SetSetConsoleBackHandler CON,FUNC$ OUT ERR
 CheckConsoleAndFunc CON,FUNC$ OUT ERR
 IF ERR THEN RETURN
 CON_SETBACK$[CON>>CON_IDSHIFT]=FUNC$
END
COMMON DEF SetConsoleVar CON,V OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 ERR=0
 CON_VAR[CON>>CON_IDSHIFT]=V
END
COMMON DEF SetConsoleVar$ CON,V$ OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 ERR=0
 CON_VAR$[CON>>CON_IDSHIFT]=V$
END
COMMON DEF GetConsoleVar CON OUT V,ERR
 IF!CheckConsole(CON)THEN
  V=-1
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 ERR=0
 V=CON_VAR[CON>>CON_IDSHIFT]
END
COMMON DEF GetConsoleVar$ CON OUT V$,ERR
 IF!CheckConsole(CON)THEN
  V$=""
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 ERR=0
 V$=CON_VAR$[CON>>CON_IDSHIFT]
END
COMMON DEF SetProcessConsole PRC,CON OUT ERR
 IF!CheckProcess(PRC)THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 ERR=0
 VAR NP=PRC AND NUPIDMASK
 PRC_CON[NP]=CON
END
COMMON DEF GetProcessConsole PRC OUT CON,ERR
 IF!CheckProcess(PRC)THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 VAR NP=PRC AND NUPIDMASK
 CON=PRC_CON[NP]
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 ERR=0
END
COMMON DEF SetConsole CON
 VAR ERR
 SetProcessConsole GetProcess(),CON OUT ERR
END
COMMON DEF GetConsole OUT CON
 VAR ERR
 GetProcessConsole GetProcess() OUT CON,ERR
END
COMMON DEF PutConsole CON,BUF$ OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 CALL CON_PUT$[CON>>CON_IDSHIFT],CON,BUF$ OUT ERR
END
COMMON DEF ReadConsole CON,LEN OUT BUF$,ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  BUF$=""
  RETURN
 ENDIF
 CALL CON_RD$[CON>>CON_IDSHIFT],CON,LEN OUT BUF$,ERR
END
COMMON DEF GetConsoleSize CON OUT W,H,ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  W=-1
  H=-1
  RETURN
 ENDIF
 CALL CON_GETSIZE$[CON>>CON_IDSHIFT],CON OUT W,H,ERR
END
COMMON DEF GetConsoleCursor CON OUT X,Y,ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  X=-1
  Y=-1
  RETURN
 ENDIF
 CALL CON_GETCUR$[CON>>CON_IDSHIFT],CON OUT X,Y,ERR
END
COMMON DEF SetConsoleCursor CON,X,Y OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 CALL CON_SETCUR$[CON>>CON_IDSHIFT],CON,X,Y OUT ERR
END
COMMON DEF GetConsoleForeColor CON OUT C,ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  C=-1
  RETURN
 ENDIF
 CALL CON_GETFORE$[CON>>CON_IDSHIFT],CON OUT C,ERR
END
COMMON DEF SetConsoleForeColor CON,C OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  RETURN
 ENDIF
 CALL CON_SETFORE$[CON>>CON_IDSHIFT],CON,C OUT ERR
END
COMMON DEF GetConsoleBackColor CON OUT C,ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  C=-1
  RETURN
 ENDIF
 CALL CON_GETBACK$[CON>>CON_IDSHIFT],CON OUT C,ERR
END
COMMON DEF SetConsoleBackColor CON,C OUT ERR
 IF!CheckConsole(CON)THEN
  ERR=CON_ERROR_INVALIDCON
  C=-1
  RETURN
 ENDIF
 CALL CON_SETBACK$[CON>>CON_IDSHIFT],CON,C OUT ERR
END

COMMON DEF GetHomeDir$()
 RETURN "/home/user/"
END

COMMON DEF EscapeArg$(ARG$)
 ARG$=ARG$+""
 EscapeArg ARG$
 RETURN ARG$
END
COMMON DEF EscapeArg ARG$
 VAR I,L=LEN(ARG$)-1
 FOR I=0TO L
  VAR I$=ARG$[I]
  IF I$==" "THEN
   ARG$[I]="\ "
   INC I
   INC L
  ENDIF
 NEXT
END
OPTION DEFINT
OPTION STRICT
VAR LOADMOD_SLOT
VAR LOADMOD_TKN_NUM
VAR LOADMOD_TKN_IDEN
VAR LOADMOD_TYP_ARY
VAR LOADMOD_TYP_INT
VAR LOADMOD_TYP_DBL
VAR LOADMOD_TYP_STR
DIM LOADMOD_VAR$[0]
DIM LOADMOD_VAR_TYP[0]
DIM LOADMOD_VAR_DAT[0]
DIM LOADMOD_VARTMP$[0]
DIM LOADMOD_VARTMP#[0]
DIM LOADMOD_LIST$[0]
DIM LOADMOD_LIST_ENTRY$[0]
DEF LOADMOD_ADDVAR V$,ISARY
 PUSH LOADMOD_VAR$,V$
 VAR TYP
 IF ISARY THEN
  TYP=LOADMOD_TYP_ARY
 ELSE
  VAR P$=MID$(V$,LEN(V$)-1,1)
  TYP=LOADMOD_TYP_INT
  IF P$=="$"THEN
   TYP=LOADMOD_TYP_STR
  ELSEIF P$=="%"THEN
   TYP=LOADMOD_TYP_INT
  ELSEIF P$=="#"THEN
   TYP=LOADMOD_TYP_DBL
  ENDIF
 ENDIF
 PUSH LOADMOD_VAR_TYP,TYP
 PUSH LOADMOD_VAR_DAT,0
END
VAR LOADMOD_LINECOUNT
COMMON DEF INIT_LOADMOD
 LOADMOD_TYP_ARY=1
 LOADMOD_TYP_INT=2
 LOADMOD_TYP_DBL=3
 LOADMOD_TYP_STR=4
 LOADMOD_TKN_NUM=2
 LOADMOD_TKN_IDEN=1
 LOADMOD_SLOT=1
 ?"initializing module system..."
 IF!IsSmileTool()THEN
  PRGEDIT LOADMOD_SLOT,1
  
  PRGDEL -1
  PRGINS "OPTION DEFINT"
  PRGINS "OPTION STRICT"
 ENDIF
 LOADMOD_LINECOUNT=3
 LOADMOD_VAR$=NewArray$(0)
 LOADMOD_VAR_TYP=NewArray(0)
 LOADMOD_VAR_DAT=NewArray(LEN(LOADMOD_VAR$))
 LOADMOD_LIST$=NewArray$(0)
 LOADMOD_LIST_ENTRY$=NewArray$(0)
END
COMMON DEF I_LOADMOD
 IF IsSmileTool()THEN
  ExitProcess 1
 ENDIF
 VAR ERR,CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN ExitProcess I:RETURN
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 VAR EF=FALSE
 IF MID$(CMD$,0,1)=="-"THEN
  IF CMD$=="-e"THEN
   EF=TRUE
  ELSE
   GOTO @USAGE
  ENDIF
  GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 ENDIF
 IF I==-1THEN @USAGE
'LOADMOD_LIST$
 VAR PATH$=GetAbsolutePath$(CMD$)
 VAR FI=FindArray(LOADMOD_LIST$,PATH$)
 IF FI!=-1THEN
  VAR PRG$=LOADMOD_LIST_ENTRY$[FI]
  GOTO @OK
 ENDIF
 VAR F$
 LoadFile CMD$ OUT F$,ERR
 IF ERR THEN
  PrintConsoleln"Couldn't open file."
  ExitProcess 1
  RETURN
 ENDIF
 PRGEDIT LOADMOD_SLOT,-1
 PRGINS F$,1
 PUSH LOADMOD_LIST$,PATH$
' PrintConsoleln"Parsing program..."
 VAR OLD=LEN(LOADMOD_VAR$)
 LOADMOD_SAVEVAR
 PRGEDIT LOADMOD_SLOT,LOADMOD_LINECOUNT
PRG$=LOADMOD_PARSEPROGRAM$()
 PUSH LOADMOD_LIST_ENTRY$,PRG$
 USE LOADMOD_SLOT
 LOADMOD_INITARY OLD
 LOADMOD_RESTOREVAR OLD-1
 LOADMOD_FREEVAR OLD-1
' PrintConsoleln"Saving variables..."
' PrintConsoleln"Done."
 @OK
 IF EF&&LEN(PRG$) THEN
  VAR PRC
  NewProcess PRG$,"" OUT PRC,ERR
  IF !ERR THEN
   SetProcessVar PRC
  ELSE
   ExitProcess ERR
  ENDIF
  RETURN
 ENDIF
 ExitProcess 0
 RETURN
 @USAGE
 PrintConsoleln"loadmod -e file"
 PrintConsoleln"-e:Execute loaded module"
 ExitProcess 1
 RETURN 
END
DEF LOADMOD_INITARY I
 VAR L=LEN(LOADMOD_VAR$)-1
 VAR S$=STR$(LOADMOD_SLOT)+":"
 DIM NUL[0]
 FOR I=I TO L
  VAR V$=S$+LOADMOD_VAR$[I]
  VAR TYP=LOADMOD_VAR_TYP[I]
  IF TYP==LOADMOD_TYP_ARY THEN
   VAR(V$)=NUL
  ENDIF
 NEXT
END
DEF LOADMOD_FREEVAR L
 VAR I
 FOR I=0TO L
  VAR TYP=LOADMOD_VAR_TYP[I]
  IF TYP==LOADMOD_TYP_ARY THEN
   FreeSBArray LOADMOD_VAR_DAT[I]
  ENDIF
 NEXT
END
DEF LOADMOD_RESTOREVAR L
 VAR S$=STR$(LOADMOD_SLOT)+":"
 VAR I
 FOR I=0TO L
  VAR V$=S$+LOADMOD_VAR$[I]
  VAR TYP=LOADMOD_VAR_TYP[I]
  VAR DAT=LOADMOD_VAR_DAT[I]
  
  IF TYP==LOADMOD_TYP_INT THEN
   VAR(V$)=DAT
   '?V$;"<=";DAT
  ELSEIF TYP==LOADMOD_TYP_ARY THEN
   VAR(V$)=GetSBArray(DAT)
  ELSEIF TYP==LOADMOD_TYP_STR THEN
   VAR(V$)=LOADMOD_VARTMP$[DAT]
  ELSEIF TYP==LOADMOD_TYP_DBL THEN
   VAR(V$)=LOADMOD_VARTMP#[DAT]
  ENDIF
 NEXT
END
DEF LOADMOD_SAVEVAR
' LOADMOD_VAR_DAT=NewArray(LEN(LOADMOD_VAR$))
 LOADMOD_VARTMP$=NewArray$(0)
 LOADMOD_VARTMP#=NewArray#(0)
 VAR S$=STR$(LOADMOD_SLOT)+":"
 VAR I,L=LEN(LOADMOD_VAR$)-1
 FOR I=0TO L
  VAR V$=S$+LOADMOD_VAR$[I]
  VAR TYP=LOADMOD_VAR_TYP[I]
  IF TYP==LOADMOD_TYP_INT THEN
   VAR DAT=VAR(V$)
   '?V$;"=>";DAT
  ELSEIF TYP==LOADMOD_TYP_ARY THEN
   DAT=AllocSBArray()
   SetSBArray DAT,VAR(V$)
  ELSEIF TYP==LOADMOD_TYP_STR THEN
   DAT=LEN(LOADMOD_VARTMP$)
   PUSH LOADMOD_VARTMP$,VAR(V$)
  ELSEIF TYP==LOADMOD_TYP_DBL THEN
   DAT=LEN(LOADMOD_VARTMP#)
   PUSH LOADMOD_VARTMP#,VAR(V$)
  ENDIF
  LOADMOD_VAR_DAT[I]=DAT
 NEXT
END
DEF LOADMOD_PARSEPROGRAM$()
' LOADMOD_VAR$=NewArray$(0)
' LOADMOD_VAR_TYP=NewArray(0)
' PRGEDIT LOADMOD_SLOT,1
 VAR R$
 VAR FINDEND
 WHILE 1
  VAR L$=PRGGET$()
  IF!LEN(L$)THEN BREAK
  INC LOADMOD_LINECOUNT
  VAR J=LOADMOD_SKIPSPACE(L$)
  VAR K=INSTR(J,L$," ")-1
  IF K==-2THEN K=&H7FFFFFF0

  VAR L2$=MID$(L$,J,K-J+1)
  IF LEN(L2$)&&ASC(L2$[LEN(L2$)-1])==10THEN
   VAR _$=POP(L2$)
  ENDIF
  IF FINDEND&&L2$=="END"THEN
   FINDEND=FALSE
   CONTINUE
  ENDIF
  IF L2$=="COMMON"THEN
   FINDEND=TRUE
   IF LEN(R$)THEN CONTINUE
   LOADMOD_TOKEN L$,K+1 OUT L2$,J,K
   IF L2$!="DEF"THEN CONTINUE
   LOADMOD_TOKEN L$,J OUT L2$,J,K
   IF MID$(L2$,0,2)=="I_"THEN
    R$=MID$(L2$,2,&H7FFFFFFF)
   ENDIF
   CONTINUE
  ENDIF

  IF L2$=="DEF"THEN
   FINDEND=TRUE
   CONTINUE
  ENDIF
  IF FINDEND THEN CONTINUE
  IF L2$=="VAR"||L2$=="DIM"THEN
   LOADMOD_PARSEVARDEF L$
  ENDIF
 WEND
 RETURN R$
END

DEF LOADMOD_SKIPSPACE(S$)
 VAR I,L=LEN(S$)-1
 FOR I=0TO L
  IF S$[I]!=" "THEN RETURN I
 NEXT
 RETURN I
END
DEF LOADMOD_PARSEEXPR L$,I OUT I2
 VAR TKN$,_
 LOADMOD_TOKEN L$,I OUT TKN$,I,_
 I2=I
END
VAR LOADMOD_ERR
DEF LOADMOD_PARSEVARDEF2 L$,I OUT I2
 VAR NAME$,TKN$,_
 LOADMOD_TOKEN L$,I OUT NAME$,I,_
 IF _!=LOADMOD_TKN_IDEN THEN
  PrintConsoleln "loadmod:syntax error(var)"
  LOADMOD_ERR=TRUE
  I2=I
  RETURN
 ENDIF
 LOADMOD_TOKEN L$,I OUT TKN$,I,_
 VAR ISARY
 IF TKN$=="["THEN
  WHILE 1
   LOADMOD_PARSEEXPR L$,I OUT I
   LOADMOD_TOKEN L$,I OUT TKN$,I,_
   IF TKN$==","THEN CONTINUE
   IF TKN$=="]"THEN BREAK
   PrintConsoleln "loadmod:syntax error(var)"
   LOADMOD_ERR=TRUE
   BREAK
  WEND
  ISARY=TRUE
 ELSEIF TKN$=="="THEN
  LOADMOD_PARSEEXPR L$,I OUT I
  LOADMOD_TOKEN L$,I OUT TKN$,I,_
 ENDIF
 LOADMOD_ADDVAR NAME$,ISARY
 I2=I
 IF TKN$==","THEN
  LOADMOD_PARSEVARDEF2 L$,I OUT I2
 ENDIF
END
DEF LOADMOD_PARSEVARDEF L$
 VAR I,TKN$,_
 WHILE I<LEN(L$)
  LOADMOD_TOKEN L$,I OUT TKN$,I,_
  IF TKN$==CHR$(10)THEN BREAK
  IF TKN$=="VAR"||TKN$=="DIM"THEN
   LOADMOD_PARSEVARDEF2 L$,I OUT I
  ENDIF
 WEND
END
COMMON DEF LOADMOD_TOKEN S$,I OUT TKN$,J,TYP
 VAR L=LEN(S$)-1
 FOR I=I TO L
  VAR C$=S$[I]
  VAR C=ASC(C$)
  IF C==32THEN CONTINUE
  IF (C>=65&&C<=90)||(C>=97&&C<=122)||C==95THEN
   VAR SI=I
   FOR I=I TO L
    C$=S$[I]
    C=ASC(C$)
    IF!((C>=65&&C<=90)||(C>=97&&C<=122)||(C>=48&&C<=57)||C==95)THEN
     'DEC I
     BREAK
    ENDIF
   NEXT
   IF C$=="$"THEN I=I+1
   IF C$=="#"THEN I=I+1
   IF C$=="%"THEN I=I+1
   TKN$=MID$(S$,SI,I-SI)
   J=I
   TYP=LOADMOD_TKN_IDEN
   RETURN
  ENDIF
  IF C>=48&&C<=57THEN
   SI=I
   FOR I=I TO L
    C$=S$[I]
    C=ASC(C$)
    IF!(C>=48&&C<=57)THEN
     'DEC I
     BREAK
    ENDIF
   NEXT
   TKN$=MID$(S$,SI,I-SI)
   J=I
   TYP=LOADMOD_TKN_NUM
   RETURN
  ENDIF
  INC I
  BREAK
 NEXT
 TKN$=C$
 TYP=ASC(C$)
 J=I
END
COMMON DEF L_LOADMOD
 IF!CheckProcess(GetProcessVar())THEN
  ExitProcess 0
 ENDIF
END
COMMON DEF I_LSMOD
 VAR I
 PrintConsoleln FORMAT$("% 20S ENTRY POINT","FILE")
 FOR I=0TO LEN(LOADMOD_LIST$)-1
  PrintConsoleln FORMAT$("% 20S %S",LOADMOD_LIST$[I],LOADMOD_LIST_ENTRY$[I])
 NEXT
 ExitProcess 0
END
COMMON DEF L_LSMOD
END
COMMON DEF LoadModule PATH$ OUT ENTRYPOINT$,ERR
 IF IsSmileTool()THEN
  ENTRYPOINT$=""
  ERR=1
  RETURN
 ENDIF
 PATH$=GetAbsolutePath$(PATH$)
 VAR FI=FindArray(LOADMOD_LIST$,PATH$)
 IF FI!=-1THEN
  VAR PRG$=LOADMOD_LIST_ENTRY$[FI]
  GOTO @OK
 ENDIF
 VAR F$
 ENTRYPOINT$=""
 LoadFile PATH$ OUT F$,ERR
 IF ERR THEN
  RETURN
 ENDIF
 PRGEDIT LOADMOD_SLOT,-1
 PRGINS F$,1
 PUSH LOADMOD_LIST$,PATH$
 VAR OLD=LEN(LOADMOD_VAR$)
 LOADMOD_SAVEVAR
 PRGEDIT LOADMOD_SLOT,LOADMOD_LINECOUNT
 PRG$=LOADMOD_PARSEPROGRAM$()
 PUSH LOADMOD_LIST_ENTRY$,PRG$
 USE LOADMOD_SLOT
 LOADMOD_INITARY OLD
 LOADMOD_RESTOREVAR OLD-1
 LOADMOD_FREEVAR OLD-1
 @OK
 ENTRYPOINT$=PRG$
END
COMMON DEF ExecModule PATH$,ARGS$ OUT PRC,ERR
 VAR ENTRYPOINT$
 LoadModule PATH$ OUT ENTRYPOINT$,ERR
 IF ERR THEN RETURN
 NewProcess ENTRYPOINT$,ARGS$ OUT PRC,ERR
 RETURN
END


'internal function
'KEY:CODE
DIM ERROR_NAME$[0]
DIM ERROR_CODE[0]
'KEY:NAME
DIM ERROR_NAME2$[0]
DIM ERROR_CODE2[0]
VAR ERROR_UPDATE
DEF INIT_ERROR
 ERROR_NAME$=NewArray$(0)
 ERROR_CODE=NewArray#(0)
 ERROR_NAME2$=NewArray$(0)
 ERROR_CODE2=NewArray(0)
 ERROR_UPDATE=FALSE
END
DEF RegisterError NAME$
 RegisterErrorNV NAME$,VAR(NAME$)
END
DEF RegisterErrorNV N$,V
 PUSH ERROR_NAME$,N$
 PUSH ERROR_CODE,V
 PUSH ERROR_NAME2$,N$
 PUSH ERROR_CODE2,V
 ERROR_UPDATE=TRUE
END
DEF ERROR_SORT
 SORT ERROR_CODE,ERROR_NAME$
 SORT ERROR_NAME2$,ERROR_CODE2
END
COMMON DEF GetErrorCode(ERR$)
 IF ERROR_UPDATE THEN ERROR_SORT
 VAR I=BinarySearch(ERROR_NAME2$,ERR$)
 IF I==-1THEN RETURN -1
 RETURN ERROR_CODE2[I]
END
COMMON DEF GetErrorName$(ERR)
 IF ERROR_UPDATE THEN ERROR_SORT
 VAR I=BinarySearch(ERROR_CODE,ERR)
 IF I==-1THEN RETURN "INVALID_ERROR#"+STR$(I)
 RETURN ERROR_NAME$[I]
END

DIM DEVFS_LIST1$[0]
DIM DEVFS_LIST2$[0]
DIM DEVFS_HNDLR$[0]
DEF DEVFS_ADD ISDAT,FILE$,HNDLR$
 IF ISDAT THEN
  PUSH DEVFS_LIST1$," "+FILE$
 ELSE
  PUSH DEVFS_LIST1$,"*"+FILE$
 ENDIF
 PUSH DEVFS_HNDLR$,HNDLR$
 PUSH DEVFS_LIST2$,FILE$
 SORT DEVFS_LIST2$,DEVFS_LIST1$,DEVFS_HNDLR$
END
DEF FS_INIT_DEVFS
 VAR FS,ERR
 NewFileSystem("DEVFS") OUT FS,ERR
 IF ERR THEN RETURN
 ERR=FSSetFileListHandler(FS,"DEVFS_FILELIST")
 IF ERR THEN RETURN
 ERR=FSSetGetTypeHandler(FS,"DEVFS_GETTYPE")
 IF ERR THEN RETURN
 ERR=FSSetOpenFileHandler(FS,"DEVFS_OPEN")
 IF ERR THEN RETURN
 DEVFS_LIST1$=NewArray$(0)
 DEVFS_LIST2$=NewArray$(0)
 DEVFS_HNDLR$=NewArray$(0)
 DEVFS_ADD FALSE,"null","DEVFS_NULL"
 DEVFS_ADD FALSE,"stdout","DEVFS_STDOUT"
 DEVFS_ADD FALSE,"stdin","DEVFS_STDIN"
 DEVFS_ADD FALSE,"stderr","DEVFS_STDERR"
 DEVFS_ADD FALSE,"zero","DEVFS_ZERO"
END
DEF DEVFS_FILELIST FS,DATA$,PATH$,FILELIST$[] OUT ERR
 IF PATH$!="/"THEN
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 COPY FILELIST$,DEVFS_LIST1$
 ERR=0
END
DEF DEVFS_OPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 VAR I=BinarySearch(DEVFS_LIST2$,MID$(PATH$,1,&H7FFFFFFF))
 IF I==-1THEN
  ERR=FS_ERROR_NOTFOUND
  FILE=0
  RETURN
 ENDIF
 VAR H$=DEVFS_HNDLR$[I]+"OPEN"
 IF!CHKCALL(H$)THEN
  ERR=FS_ERROR_NOTSUPPORTED
 ENDIF
 CALL H$,FS,DATA$,PATH$,OPTION OUT FILE,ERR
END
DEF DEVFS_NULLOPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 AllocFile OUT FILE,ERR
 SetFileEOF FILE,TRUE
 ERR=SetWriter(FILE,"NULWRITER")
 ERR=SetReader(FILE,"NULREADER")
 ERR=SetReadln(FILE,"NULREADLN")
 ERR=SetClose(FILE,"NULCLOSE")
END
DEF DEVFS_ZEROOPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 AllocFile OUT FILE,ERR
 ERR=SetWriter(FILE,"ZEROWRITER")
 ERR=SetReader(FILE,"ZEROREADER")
 ERR=SetReadln(FILE,"ZEROREADLN")
 ERR=SetClose(FILE, "ZEROCLOSE")
END
DEF DEVFS_STDINOPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 FILE=DupFile(GetSTDIN())
 ERR=0
END
DEF DEVFS_STDOUTOPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 FILE=DupFile(GetSTDOUT())
 ERR=0
END
DEF DEVFS_STDERROPEN FS,DATA$,PATH$,OPTION OUT FILE,ERR
 FILE=DupFile(GetSTDERR())
 ERR=0
END
DEF NulClose FILE
END
DEF NulReadLn FILE OUT DAT$,ERR
 DAT$=""
 ERR=SUCCESS
END
DEF NulReader FILE,LEN OUT DAT$,ERR
 DAT$=""
 ERR=SUCCESS
END
DEF NulWriter(FILE,DAT$)
 RETURN SUCCESS
END
DEF ZeroClose FILE
END
DEF ZeroReadLn FILE OUT DAT$,ERR
 DAT$=""
 ERR=SUCCESS
END
DEF ZeroReader FILE,LEN OUT DAT$,ERR
 DAT$=CHR$(0)*LEN
 ERR=SUCCESS
END
DEF ZeroWriter(FILE,DAT$)
 RETURN SUCCESS
END
DEF DEVFS_GETTYPE FS,DATA$,PATH$ OUT TYPE$,ERR
 VAR I=BinarySearch(DEVFS_LIST2$,MID$(PATH$,1,&H7FFFFFFF))
 IF I==-1THEN
  TYPE$=""
  ERR=FS_ERROR_NOTFOUND
  RETURN
 ENDIF
 TYPE$=DEVFS_LIST1$[I][0]
 ERR=0
END
COMMON DEF I_INSTALL
 VAR ERR
 NewDir "/home" OUT ERR
 NewDir "/home/user" OUT ERR
 NewDir "/usr" OUT ERR
 NewDir "/usr/share" OUT ERR
 NewDir "/etc" OUT ERR
 NewDir "/SYS" OUT ERR
 Mount "/TXT","SBFS","TXT:" OUT ERR
 Mount "/DAT","SBFS","DAT:" OUT ERR
 Mount "/PROJECTS","SBFS","//" OUT ERR
 Mount "/SYS/TXT","SBFS","TXT:SYS/" OUT ERR
 Mount "/SYS/DAT","SBFS","DAT:SYS/" OUT ERR
 Mount "/dev","DEVFS","" OUT ERR
 ExitProcess 0
END
COMMON DEF L_INSTALL
 ExitProcess 0
END
COMMON DEF I_SYMLINK
END
COMMON DEF L_SYMLINK
 VAR CMD$,PATH$,TARGET$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT TARGET$,I
 GetCommandArg GetProcessArgs$(),I OUT PATH$,I
 IF I==-1 THEN
  PrintConsoleln "usage "+CMD$+" target path"
  ExitProcess 1
  RETURN
 ENDIF
 VAR ERR=SymlinkFile(PATH$,TARGET$)
 IF ERR THEN
  PrintConsoleln CMD$+":error "+GetErrorName$(ERR)
  ExitProcess 1
  RETURN
 ENDIF
 ExitProcess 0
END
VAR DIFF2_LOCK
VAR DIFF2_PHASE
DIM DIFF2_A[0]
DIM DIFF2_B[0]
DIM DIFF2_A2$
DIM DIFF2_B2$
DIM DIFF2_V[0]
DIM DIFF2_TREE[0]
DIM DIFF2_SES[0]
VAR DIFF2_OI
VAR DIFF2_NI
COMMON DEF DIFF2_Split(STR$,SP$)
 DIM R[0]
 VAR I,J,SPL=LEN(SP$)
 WHILE 1
  J=INSTR(I,STR$,SP$)
  IF J==-1THEN
   IF I==LEN(STR$)-1THEN RETURN R
   PUSH R,I
   PUSH R,LEN(STR$)-I
   RETURN R
  ENDIF
  PUSH R,I
  PUSH R,J-I
  I=J+SPL
 WEND
END
DEF I_DIFF2
 IF DIFF2_LOCK THEN RETURN
 VAR CMD$,A$,B$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT A$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT B$,I
 IF I==-1THEN @USAGE
 VAR F$,E
 LoadFile A$ OUT F$,E
 IF E THEN @ERR
 DIFF2_A=DIFF2_SPLIT(F$,LF$())
 DIFF2_A2$=F$
 LoadFile B$ OUT F$,E
 IF E THEN @ERR
 DIFF2_B=DIFF2_SPLIT(F$,LF$())
 DIFF2_B2$=F$
 DIFF2_PHASE=0
 RETURN
 @USAGE
 PrintConsoleln "USAGE: DIFF ORIGIN NEW"
 ExitProcess -1
 RETURN
 @ERR
 PrintConsoleln "diff:error "+GetErrorName$(E)
 ExitProcess -1
END
VAR DIFF2_D,DIFF2_K,DIFF2_TAIL
VAR DIFF2_I
DEF L_DIFF2
 IF!DIFF2_LOCK THEN DIFF2_LOCK=GetPID()
 IF DIFF2_LOCK!=GetPID()THEN RETURN
 VAR OL=LEN(DIFF2_A) DIV 2,NL=LEN(DIFF2_B) DIV 2
 VAR DELETE=0
 VAR COMMON_=1
 VAR ADD=2
 VAR D=DIFF2_D,K=DIFF2_K
 VAR OFFSET=OL
 WHILE 1
  ON DIFF2_PHASE GOTO @INIT,@DIFF,@SES,@DUMP,@END
  BREAK
  @INIT
   DIFF2_V=NewArray((OL+NL+1)*2)
   VAR VI
   FOR VI=1TO LEN(DIFF2_V)-1 STEP 2
    DIFF2_V[VI]=-1
   NEXT
   DIFF2_TREE=NewArray(0)
   DIFF2_PHASE=1
   DIFF2_D=0
   DIFF2_K=0
   DIFF2_TAIL=-1
  BREAK
  @DIFF
' FOR D=0TO OL+NL
   FOR K=-D TO D STEP 2
    IF K<-OL||NL<K THEN CONTINUE
     VAR V_K=(K+OFFSET)*2
     VAR V_KP1=(V_K+2)
     VAR V_KM1=(V_K-2)
     IF D THEN
      IF K==-D||K==-OL||(K!=D&&K!=NL&&DIFF2_V[V_KM1]+1<DIFF2_V[V_KP1])THEN
       DIFF2_V[V_K]=DIFF2_V[V_KP1]
       DIFF2_V[V_K+1]=LEN(DIFF2_TREE)
       PUSH DIFF2_TREE,DELETE
       PUSH DIFF2_TREE,DIFF2_V[V_KP1+1]
      ELSE
       DIFF2_V[V_K]=DIFF2_V[V_KM1]+1
       DIFF2_V[V_K+1]=LEN(DIFF2_TREE)
       PUSH DIFF2_TREE,ADD
       PUSH DIFF2_TREE,DIFF2_V[V_KM1+1]
      ENDIF
     ENDIF
     VAR V_K_Y=DIFF2_V[V_K]
     WHILE V_K_Y-K<OL&&V_K_Y<NL&&MID$(DIFF2_A2$,DIFF2_A[(V_K_Y-K)*2],DIFF2_A[(V_K_Y-K)*2+1])==MID$(DIFF2_B2$,DIFF2_B[V_K_Y*2],DIFF2_B[V_K_Y*2+1])
      VAR OT=DIFF2_V[V_K+1]
      DIFF2_V[V_K+1]=LEN(DIFF2_TREE)
      PUSH DIFF2_TREE,COMMON_
      PUSH DIFF2_TREE,OT
      INC V_K_Y
      INC DIFF2_V[V_K]
     WEND
     IF V_K_Y-K>=OL&&V_K_Y>=NL THEN
      DIFF2_TAIL=DIFF2_V[V_K+1]
      GOTO @EXIT
     ENDIF
   NEXT
  IF DIFF2_D>=OL+NL THEN @EXIT
  INC DIFF2_D
  BREAK
' NEXT
  @EXIT
  DIFF2_PHASE=2
  BREAK
  @SES
  DIFF2_SES=NewArray(0)
  VAR I=DIFF2_TAIL
  WHILE I!=-1
   PUSH DIFF2_SES,DIFF2_TREE[I]
   I=DIFF2_TREE[I+1]
  WEND
  DIFF2_PHASE=3
  DIFF2_I=LEN(DIFF2_SES)-1
  DIFF2_OI=0
  DIFF2_NI=0
  BREAK
  @DUMP
  VAR MX=MAX(0,DIFF2_I-128)
  FOR I=DIFF2_I TO MX STEP -1
   WHILE 1
   ON DIFF2_SES[I] GOTO @DEL,@COM,@ADD
    PrintConsole "?"
    BREAK
    @DEL
     PrintConsole "-"
     IF LEN(DIFF2_A) DIV 2>DIFF2_OI THEN
      PrintConsoleln MID$(DIFF2_A2$,DIFF2_A[DIFF2_OI*2],DIFF2_A[DIFF2_OI*2+1])
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF2_OI
    BREAK
    @COM
     PrintConsole " "
     IF LEN(DIFF2_A) DIV 2>DIFF2_OI THEN
      PrintConsoleln MID$(DIFF2_A2$,DIFF2_A[DIFF2_OI*2],DIFF2_A[DIFF2_OI*2+1])'DIFF2_A$[DIFF2_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF2_OI
     INC DIFF2_NI
    BREAK
    @ADD
     PrintConsole "+"
     IF LEN(DIFF2_B) DIV 2>DIFF2_NI THEN
      PrintConsoleln MID$(DIFF2_B2$,DIFF2_B[DIFF2_NI*2],DIFF2_B[DIFF2_NI*2+1])'DIFF2_B$[DIFF2_NI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF2_NI
    BREAK
    WEND
   NEXT
   DIFF2_I=I
   IF DIFF2_I==-1 THEN DIFF2_PHASE=4
  BREAK
  @END
  ExitProcess 0
  BREAK
 WEND
END

