SAVE"OTYAX
ACLS
OPTION STRICT
OPTION DEFINT
VAR LF$=CHR$(10)
VAR CR$=CHR$(13)
VAR BS$=CHR$(8)
VAR HTAB$=CHR$(9)
@OTYAX
 VAR FIRSTPID=0
 VAR FIRSTNUPID=0
 VAR RUNPID
GOSUB @OTYAXINIT
IF RUNPID THEN ?"FAIL":END
GOSUB @OTYAX_MAIN
?"OK
END
'しょきかルーチン
@OTYAXINIT
 ?"OTYAX 5.0-5
 VAR VER$="5.0-5"
 GOSUB @OTYAXERRORINIT
 GOSUB @OTYAXPROCESSINIT
 GOSUB @OTYAXFILEINIT
 NewProcess "SH","" OUT FIRSTPID,FIRSTNUPID,RUNPID
 IF RUNPID THEN ?"Process ";"SH";" ";"のきどうにしっぱいしました。:";RUNPID
RETURN

@OTYAXERRORINIT
 VAR SUCCESS=0
 VAR ERROR_ERROR=1
 VAR ERROR_NOIMPL=2
RETURN
@OTYAXPROCESSINIT
 VAR PROCESS_MAX=128
 DIM PRC_NAME$[PROCESS_MAX]
 DIM PRC_ARGS$[PROCESS_MAX]
 DIM PRC_PID[PROCESS_MAX]
 DIM PRC_STDOUT[PROCESS_MAX]
 DIM PRC_NSTDOUT[PROCESS_MAX]
 DIM PRC_STDERR[PROCESS_MAX]
 DIM PRC_NSTDERR[PROCESS_MAX]
 DIM PRC_STDIN[PROCESS_MAX]
 DIM PRC_NSTDIN[PROCESS_MAX]
 DIM PRC_NEXT[PROCESS_MAX]
 DIM PRC_PREV[PROCESS_MAX]
 DIM PRC_CHILD[PROCESS_MAX]
 DIM PRC_PARENT[PROCESS_MAX]
 DIM PRC_FLG[PROCESS_MAX]
 DIM PRC_DAT[PROCESS_MAX]
 VAR PRC_FLG_INIT=1
 VAR PIDCNT=0
 VAR PRC_FREE=1
 _INITFREEPRIC
 DEF _INITFREEPRIC
  VAR I
  FOR I=1 TO PROCESS_MAX-2
   PRC_NEXT[I]=I+1
  NEXT
 END
 VAR RUNNUPID=0
 VAR ERROR_NEW_PROC=1
 VAR ERROR_NO_PROC=2
RETURN
@OTYAXFILEINIT
 VAR FILES_MAX=1024
 DIM FILES_PID[FILES_MAX]
 DIM FILES_FID[FILES_MAX]
 DIM FILES_NAME$[FILES_MAX]
 DIM FILES_DAT[FILES_MAX]
 DIM FILES_DATSTR$[FILES_MAX]
 DIM FILES_WRITER$[FILES_MAX]
 DIM FILES_READER$[FILES_MAX]
 DIM FILES_CLOSE$[FILES_MAX]
 DIM FILES_NEXT[FILES_MAX]
 DIM FILES_POS[FILES_MAX]
 VAR ERROR_NOFILE=201
 VAR ERROR_NOPENFILE=202
 VAR ERROR_NOALLOCFILE=203
 VAR FILES_FREE=1
 VAR FILES_FIDCNT=0
 _INITFREEFIL
 DEF _INITFREEFIL
  VAR I
  FOR I=1 TO FILES_MAX-2
   FILES_NEXT[I]=I+1
  NEXT
 END
 VAR OTYAX_STDOUT_OPENER$="OUTCONSOLE_OPEN"
 VAR OTYAX_STDIN_OPENER$="INCONSOLE_OPEN"
RETURN
@OTYAX_MAIN
 IF RUNNUPID THEN
 ''DEBUGCODE
 VAR CX=CSRX,CY=CSRY
 LOCATE 40,0
 ?RUNNUPID;PRC_NAME$[RUNNUPID];
 LOCATE CX,CY
 ''
  IF PRC_FLG[RUNNUPID] AND PRC_FLG_INIT THEN
   IF!CHKLABEL("@I_"+PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
   GOSUB "@I_"+PRC_NAME$[RUNNUPID]
   PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID] XOR PRC_FLG_INIT
   PRC_NAME$[RUNNUPID]="@L_"+PRC_NAME$[RUNNUPID]
   IF!CHKLABEL(PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
  ELSE
   GOSUB PRC_NAME$[RUNNUPID]
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    RUNNUPID=PRC_PARENT[RUNNUPID]
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
RETURN
'OTYAX PROCESS API
DEF NewProcess NAME$,ARGS$ OUT PID,NUPID,E
 IF PRC_FREE==0 THEN @ERROR
' IF !CHKLABEL("@I_"+NAME$) THEN @ERROR
' IF !CHKLABEL("@L_"+NAME$) THEN @ERROR
 INC PIDCNT
 PID=PIDCNT
 NUPID=PRC_FREE
 PRC_PID[NUPID]=PID
 PRC_FREE=PRC_NEXT[PRC_FREE]
 PRC_NAME$[NUPID]=NAME$
 PRC_ARGS$[NUPID]=ARGS$
 PRC_PREV[NUPID]=0
 PRC_CHILD[NUPID]=0
 PRC_PARENT[NUPID]=RUNNUPID
 'VAR 
 VAR C=PRC_CHILD[RunNUPID]
 PRC_CHILD[RunNUPID]=NUPID
 PRC_NEXT[NUPID]=C
 IF C THEN
  PRC_PREV[C]=NUPID
 ENDIF
 PRC_FLG[NUPID]=PRC_FLG_INIT
 IF RUNNUPID THEN
  'TODO:IMPL
  PRC_STDOUT[NUPID]=PRC_STDOUT[RUNNUPID]
  PRC_NSTDOUT[NUPID]=PRC_NSTDOUT[RUNNUPID]

  PRC_STDIN[NUPID]=PRC_STDIN[RUNNUPID]
  PRC_NSTDIN[NUPID]=PRC_NSTDIN[RUNNUPID]

  PRC_STDERR[NUPID]=PRC_STDERR[RUNNUPID]
  PRC_NSTDERR[NUPID]=PRC_NSTDERR[RUNNUPID]
 ELSE
  OutConsoleOpen OUT PRC_STDOUT[NUPID],PRC_NSTDOUT[NUPID],E
  InConsoleOpen OUT PRC_STDIN[NUPID],PRC_NSTDIN[NUPID],E
  PRC_STDERR[NUPID]=PRC_STDOUT[NUPID]
  PRC_NSTDERR[NUPID]=PRC_NSTDOUT[NUPID]
 ENDIF
 E=SUCCESS
 RETURN
 @ERROR
 PID=0
 NUPID=0
 E=ERROR_NEW_PROC
END
DEF SetProcessData DAT
 PRC_DAT[RUNNUPID]=DAT
END
DEF GetProcessData()
 RETURN PRC_DAT[RUNNUPID]
END
DEF CheckProcess(PID,NUPID)
 RETURN PRC_PID[NUPID]==PID
END
DEF GetProcessArgs$()
 RETURN PRC_ARGS$[RUNNUPID]
END
DEF GetSTDIN OUT FID,NUFID
 FID=PRC_STDIN[RUNNUPID]
 NUFID=PRC_NSTDIN[RUNNUPID]
END
DEF GetPID()
 RETURN PRC_PID[RUNNUPID]
END
DEF NUPIDToPID(NUPID)
 RETURN PRC_PID[NUPID]
END
DEF ExitProcess RESULT
 VAR ERR
 KillProcess NUPIDToPID(RUNNUPID),RUNNUPID OUT ERR
END
DEF KillProcess PID,NUPID OUT ERR
 IF!NUPID THEN RETURN
 IF !CheckProcess(PID,NUPID) THEN ERR=ERROR_NO_PROC:RETURN
 VAR PNUPID=PRC_PREV[NUPID]
 VAR NNUPID=PRC_NEXT[NUPID]
 IF PNUPID THEN
  PRC_NEXT[PNUPID]=NNUPID
 ENDIF
 IF PNUPID THEN
  PRC_PREV[NNUPID]=PNUPID
 ENDIF
 IF !PNUPID THEN
  PRC_CHILD[PRC_PARENT[NUPID]]=NNUPID
 ENDIF
 IF FIRSTNUPID==RUNNUPID THEN
  FIRSTNUPID=PRC_NEXT[RUNNUPID]
  IF!FIRSTNUPID THEN
   FIRSTNUPID=PRC_CHILD[RUNNUPID]
  ENDIF
 ENDIF
 IF!PNUPID AND!NNUPID THEN
  PRC_CHILD[PRC_PARENT[NUPID]]=0
 ENDIF
 VAR PANUPID=PRC_PARENT[NUPID]
 IF PANUPID==NUPID THEN
  PRC_CHILD[PRC_PARENT[NUPID]]=NNUPID
  ?NNUPID
 ENDIF
 VAR CNUPID=PRC_CHILD[NUPID]
 PRC_PID[NUPID]=0
 VAR NXT
 'こをころしていく
 WHILE CNUPID
  NXT=PRC_NEXT[CNUPID]
  ?CNUPID,
  KillProcess NUPIDToPID(CNUPID),CNUPID OUT ERR
  IF ERR THEN BREAK
  IF !CNUPID THEN BREAK
  CNUPID=NXT
 WEND
 RUNNUPID=PRC_PARENT[NUPID]
 PRC_NEXT[NUPID]=PRC_FREE
 PRC_FREE=NUPID
 PRC_NAME$[NUPID]=""
 ERR=SUCCESS
END

'COMMAND
DEF ExecCommand LINE$ OUT PID,NUPID,ERR
 VAR L=LEN(LINE$)-1
 VAR I,C$=""
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 FOR I=0TO L
  C$=MID$(LINE$,I,1)
  IF C$==" " AND S==RDNAME THEN
   ENDNAME=I
   BREAK
  ELSE
   IF C$!=" " AND S==RDSP THEN START=I:S=RDNAME
  ENDIF
 NEXT
 VAR NAME$="",ARG$=""
 IF !ENDNAME THEN
  IF START THEN
    NAME$=MID$(LINE$,START,L-START+1)
   ELSE
    NAME$=LINE$
   ENDIF
   ARG$=NAME$
 ELSE
  NAME$=MID$(LINE$,START,ENDNAME-START)
'  ARG$=MID$(LINE$,ENDNAME+1,L-ENDNAME)
  ARG$=MID$(LINE$,START,ENDNAME-START+L-ENDNAME+1)
 ENDIF
 L=LEN(ARG$)-1
 VAR FID,NUFID,ARG2$=ARG$,NXT
 VAR INFILE=1,PIPE=2
 FOR I=0TO L
  C$=MID$(ARG2$,I,1)
  IF C$=="<" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
   DIALOG C$
   FileOpen C$ OUT FID,NUFID,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PID,NUPID,ERR
   IF ERR THEN RETURN
   PRC_STDIN[NUPID]=FID
   PRC_NSTDIN[NUPID]=NUFID
   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
 NEXT
 NewProcess NAME$,ARG$ OUT PID,NUPID,ERR
END
DEF GetCommandArg ARGS$,I OUT CMD$,INDEX
 IF I==-1 THEN CMD$="":INDEX=-1:RETURN
 VAR L=LEN(ARGS$)-1
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 VAR C$=""
 CMD$=""INDEX=-1
 FOR I=I TO L
  C$=MID$(ARGS$,I,1)
  IF S==RDSP AND C$!=" " THEN
   START=I
   S=RDNAME
  ELSE
   IF S==RDNAME AND C$==" " THEN
    INDEX=I
    CMD$=MID$(ARGS$,START,I-START)
    RETURN
   ENDIF
  ENDIF
 NEXT
 IF S==RDNAME THEN
  CMD$=MID$(ARGS$,START,L-START+1)
  INDEX=L+1
 ENDIF
END
DEF CommandArgsToArray ARY$[],EXPAND OUT LEN
 VAR ARGS$=GetCommandArgs$()
 VAR C$=""
 LEN=0
 VAR I
 WHILE 1
  GetCommandArg I OUT C$,I
  IF I==-1 THEN BREAK
  'FLGがTRUEなら はいれつを かくちょう
  IF EXPAND THEN IF LEN>LEN(ARY$) THEN
   PUSH ARY$,""
  ELSE
   BREAK
  ENDIF
  ARY$[LEN]=C$
  INC LEN
 WEND
END

'OTYAX FILE API
'TXT:FILE を OPEN
DEF FileOpen NAME$ OUT FID,NUFID,E
 IF!CHKFILE("TXT:"+NAME$) THEN E=ERROR_NOFILE:FID=0NUFID=0RETURN
 AllocFile OUT FID,NUFID,E
 IF E THEN RETURN
 VAR F$=""
 F$=LOAD("TXT:"+NAME$)
 SetFIDDataStr FID,NUFID,F$
 SetFIDNAME FID,NUFID,NAME$
 E=SetWriter(FID,NUFID,"TXTWRITER")
 E=SetReader(FID,NUFID,"TXTREADER")
 E=SetClose(FID,NUFID,"TXTCLOSE")
' E=SetFlush(FID,NUFID,"TXTFLUSH")
 RETURN
END
DEF TxtClose NUFID
 SAVE "TXT:"+GetFIDName$(NUFIDToFID(NUFID),NUFID),GetFIDDataStr$(NUFIDToFID(NUFID),NUFID)
END
DEF TxtReader NUFID,LEN OUT DAT$,ERR
 ERR=SUCCESS
 VAR FID=NUFIDToFID(NUFID)
 VAR POS
 GetFilePos FID,NUFID OUT POS,ERR
 DAT$=MID$(GetFIDDataStr$(FID,NUFID),POS,POS+LEN)
 FileSeekCUR FID,NUFID,LEN OUT ERR
END
DEF TxtWriter(NUFID,DAT$)
 VAR FID=NUFIDToFID(NUFID)
 SetFIDDataStr FID,NUFID,GetFIDDataStr(FID,DAT$)
 RETURN SUCCESS
END
DEF FileWrite(FID,NUFID,DAT$)
 IF FILES_FID[NUFID]!=FID THEN
  RETURN ERROR_NOPENFILE
 ENDIF
 VAR E=CALL(FILES_WRITER$[NUFID],NUFID,DAT$)
 RETURN SUCCESS
END
DEF FileRead FID,NUFID,LEN OUT DAT$,E
 IF!CheckFID(FID,NUFID) THEN
  E=ERROR_NOPENFILE
  RETURN
 ENDIF
 IF !LEN THEN RETURN
 CALL FILES_READER$[NUFID],NUFID,LEN OUT DAT$,E
 E=SUCCESS
END
DEF FileClose(FID,NUFID)
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOPENFILE
 IF LEN(FILES_CLOSE$[NUFID]) THEN CALL FILES_CLOSE$[NUFID],NUFID
 FILES_NEXT[NUFID]=FILES_FREE
 FILES_FREE=NUFID
 RETURN SUCCESS
END
DEF AllocFile OUT FID,NUFID,E
 IF FILES_FREE==0 THEN
  E=ERROR_NOALLOCFILE
  RETURN
 ENDIF
 INC FILES_FIDCNT
 NUFID=FILES_FREE
 FILES_FID[NUFID]=FILES_FIDCNT
 FID=FILES_FIDCNT
 FILES_FREE=FILES_NEXT[FILES_FREE]
 E=SUCCESS
END
DEF NUFIDToFID(NUFID)
 RETURN FILES_FID[NUFID]
END
'FIDがせいじょうならTRUE
DEF CheckFID(FID,NUFID)
 RETURN FILES_FID[NUFID]==FID
END
DEF SetWriter(FID,NUFID,FUNC$)
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOFILE
 FILES_WRITER$[NUFID]=FUNC$
 RETURN SUCCESS
END
DEF SetFIDData FID,NUFID,DAT
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_DAT[NUFID]=DAT
END
DEF GetFIDData(FID,NUFID)
 IF!CheckFID(FID,NUFID) THEN RETURN -1
 RETURN FILES_DAT[NUFID]
END
DEF SetFIDDataStr FID,NUFID,DAT$
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_DATSTR$[NUFID]=DAT$
END
DEF GetFIDDataStr$(FID,NUFID)
 IF !CheckFID(FID,NUFID) THEN RETURN ""
 RETURN FILES_DATSTR$[NUFID]
END
DEF SetFIDName FID,NUFID,DAT$
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_NAME$[NUFID]=DAT$
END
DEF GetFIDName$(FID,NUFID)
 IF !CheckFID(FID,NUFID) THEN RETURN ""
 RETURN FILES_NAME$[NUFID]
END
DEF SetReader(FID,NUFID,FUNC$)
 IF !CheckFID(FID,NUFID) THEN RETURN ERROR_NOFILE
 FILES_READER$[NUFID]=FUNC$
 RETURN SUCCESS
END
DEF SetClose(FID,NUFID,FUNC$)
 IF !CheckFID(FID,NUFID) THEN RETURN ERROR_NOFILE
 FILES_CLOSE$[NUFID]=FUNC$
 RETURN SUCCESS
END
DEF OutConsoleOpen OUT FID,NUFID,E
 AllocFile OUT FID,NUFID,E
 E=SETWRITER(FID,NUFID,"CONSOLEWRITERSTR")
END
DEF InConsoleOpen OUT FID,NUFID,E
 AllocFile OUT FID,NUFID,E
 E=SETREADER(FID,NUFID,"CONSOLEREADERSTR")
END
DEF FileSeekCUR FID,NUFID,LEN OUT ERR
  IF !CheckFID(FID,NUFID) THEN ERR=ERROR_NOFILE:RETURN
 FILES_POS[NUFID]=FILES_POS[NUFID]+LEN
 ERR=SUCCESS
END
DEF GetFilePos FID,NUFID OUT POS,ERR
 IF !CheckFID(FID,NUFID) THEN POS=0:ERR=ERROR_NOFILE:RETURN
 POS=FILES_POS[NUFID]
 ERR=ERROR_NOFILE
END
DEF ConsoleWriterStr(NUFID,DAT$)
 'VAR 
 VAR L=LEN(DAT$)-1
 VAR I
 '?DAT$;
 FOR I=0 TO L
  VAR D$=MID$(DAT$,I,1)
  IF D$==HTAB$ THEN
   PRINT "",
  ELSE
   PRINT D$;
  ENDIF
 NEXT
 RETURN SUCCESS
END
DEF ConsoleReaderStr NUFID,LEN OUT DAT$,E
 DAT$=INKEY$()
 IF DAT$==CR$THEN DAT$=LF$
 E=SUCCESS
 IF!LEN(DAT$) THEN
  RETURN
 ENDIF
 VAR K$,I
 FOR I=0TO LEN-2
  K$=INKEY$()
  IF !LEN(K$)THEN RETURN
  IF K$==CR$THEN K$=LF$
  DAT$=DAT$+K$
 NEXT
END
DEF PRINTCONSOLE STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],PRC_NSTDOUT[RUNNUPID],STR$)
END
DEF INKEYCONSOLE$(LEN)
 VAR STR$="",E
 FileRead PRC_STDIN[RUNNUPID],PRC_NSTDIN[RUNNUPID],LEN OUT STR$,E
 RETURN STR$
END
DEF LOCATECONSOLE X,Y
 LOCATE X,Y
END
DEF FORECOLORCONSOLE C
 COLOR C
END
DEF BACKCOLORCONSOLE C
 COLOR ,C
END
'OTYAX APPS
@I_SH
 PrintConsole "OTYAX SH"+LF$
 PrintConsole VER$
 PrintConsole FORMAT$("PID:%D%S",GetPID(),LF$)
 IF!CHKVAR("SH_CNT") THEN
  VAR SH_CNT=0
 ELSE
  IF SH_CNT==0 THEN
   DIM SH_INPUT$[12]
   DIM SH_NUPID[12]
   DIM SH_PID[12]
  ENDIF
  INC SH_CNT
  ?SH_CNT
 ENDIF
 SetProcessData(SH_CNT)
 PrintConsole STR$(SH_CNT)+">"
RETURN
@L_SH
L_SH
DEF L_SH
 VAR DAT=GetProcessData()
 IF SH_PID[DAT] THEN
  IF!CheckProcess(SH_PID[DAT],SH_NUPID[DAT]) THEN
?"EXIT:";SH_PID[DAT],SH_NUPID[DAT]
  'コマンドが0XDEAD
   SH_INPUT$[DAT]=""
   SH_PID[DAT]=0
   SH_NUPID[DAT]=0
 PrintConsole STR$(DAT)+">"
'   PrintConsole ">"
  ELSE
   RETURN
  ENDIF
  RETURN
 ENDIF
 VAR KEY$=INKEYCONSOLE$(1)
 IF KEY$=="" THEN RETURN
 PrintConsole KEY$
 IF KEY$==LF$ THEN @EXEC_COMMAND
 IF KEY$==CR$ THEN @EXEC_COMMAND
 SH_INPUT$[DAT]=SH_INPUT$[DAT]+KEY$
 RETURN
 
 @EXEC_COMMAND
 VAR ERR
 VAR NAME$,I,ARGS$
 DIALOG SH_INPUT$[DAT]
 GetCommandArg SH_INPUT$[DAT],0 OUT NAME$,I
 IF NAME$=="EXIT"THEN
  ExitProcess SUCCESS
  SH_INPUT$[DAT]=""
  RETURN
 ENDIF
 IF NAME$=="BACK"THEN
  SH_BACK SH_INPUT$[DAT]
  SH_INPUT$[DAT]=""
  PrintConsole ">"
  RETURN
 ENDIF
 ExecCommand SH_INPUT$[DAT] OUT SH_PID[DAT],SH_NUPID[DAT],ERR
 ?"RUN:";RUNNUPID
END
RETURN

DEF SH_BACK A$
 VAR NAME$,I,ARGS$,PID,NUPID,ERR
 GetCommandArg A$,I OUT NAME$,I
 GetCommandArg A$,I OUT NAME$,I
 IF I==-1THEN
  PrintConsole "USAGE:BACK ARGS..."+LF$
  RETURN
 ENDIF
 GetCommandArg A$,I OUT ARGS$,I
 ?NAME$,ARGS$
 NewProcess NAME$,ARGS$ OUT PID,NUPID,ERR
 ?ERR
END
'I_AM_CAT
@I_CAT
I_CAT
DEF I_CAT
 VAR FID,NUFID,ERR,CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN ExitProcess I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN
  GetSTDIN OUT FID,NUFID
 ELSE
  FileOpen CMD$ OUT FID,NUFID,ERR
 ENDIF
 IF ERR THEN RETURN
 SetProcessData NUFID
END
RETURN
@L_CAT
L_CAT
DEF L_CAT
 VAR NUFID=GetProcessData()
 IF !NUFID THEN ExitProcess SUCCESS:RETURN
 VAR FID=NUFIDToFID(NUFID)
 VAR DAT$,ERR
 FileRead FID,NUFID,2048 OUT DAT$,ERR
 IF LEN(DAT$)==0THEN
  ERR=FileClose(FID,NUFID)
  ExitProcess SUCCESS
  RETURN
 ENDIF
 PrintConsole DAT$
END
RETURN
@I_PTREE
RETURN
@L_PTREE
DEF DUMP_PS
 DUMP_PS2 FIRSTNUPID,""
END
DEF DUMP_PS2 NUP,I$
 IF!NUP THEN RETURN
 ?I$;PRC_NAME$[NUP]
' IF CSRY==29 THEN VAR II$INPUT "";II$
 DUMP_PS2 PRC_NEXT[NUP],I$
 IF LEN(I$) THEN
  VAR NM$=""
  IF PRC_NEXT[NUP] THEN
   NM$=""
  ELSE
   NM$=""
  ENDIF
  IF PRC_NEXT[PRC_PARENT[NUP]]THEN
   NM$=""+NM$
  ELSE
   NM$=" "+NM$
  ENDIF
  DUMP_PS2 PRC_CHILD[NUP],MID$(I$,0,LEN(I$)-1)+NM$
 ELSE
  IF PRC_CHILD[NUP]THEN
   DUMP_PS2 PRC_CHILD[NUP],""
  ELSE
   DUMP_PS2 PRC_CHILD[NUP],""
  ENDIF
 ENDIF
END
 DUMP_PS
 ExitProcess 0
RETURN
@I_PS
 PrintConsole FORMAT$("%SPID%SNUPID%SCOMMAND%S%S",HTAB$,HTAB$,HTAB$,HTAB$,LF$)
RETURN
@L_PS
 ExitProcess SUCCESS
RETURN
@I_BEEP
RETURN
@L_BEEP
 IF !RND(1024) THEN BEEP RND(3)+88
RETURN
