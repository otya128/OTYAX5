?"
VAR STARTSHELL
'SAVE"OTYAX"
'SAVE"PRG1:OTW
USE 1+1
ACLS
OPTION STRICT
OPTION DEFINT
VAR ISDIR=0
COMMON DEF IsDirectMode()
 RETURN ISDIR
END
VAR LF$=CHR$(10)
VAR CR$=CHR$(13)
VAR BS$=CHR$(8)
VAR HTAB$=CHR$(9)
VAR INF#=POW(2,1024)
VAR NAN#=INF#/INF#
'GETTER
COMMON DEF VOID EXP
END
COMMON DEF LF$()
 RETURN LF$
END
COMMON DEF CR$()
 RETURN CR$
END
COMMON DEF BS$()
 RETURN BS$
END
COMMON DEF HTAB$()
 RETURN HTAB$
END
COMMON DEF INF#()
 RETURN INF#
END
COMMON DEF NAN#()
 RETURN NAN#
END
COMMON DEF NOIMPL MSG$
 ?MSG$
END
@OTYAX
 VAR FIRSTPID=0
 VAR FIRSTNUPID=0
 VAR RUNPID
 VAR RUNPRC=0
 VAR PIDSHIFT=12,NUPIDMASK=4095
GOSUB @OTYAXINIT
IF RUNPID THEN ?"FAIL":END
GOSUB @OTYAX_MAIN
?"OK
END
'しょきかルーチン
@OTYAXINIT
 '?"OTYAX 5.0-6
 VAR VER$="5.0-6"
 GOSUB @OTYAXERRORINIT
 GOSUB @OTYAXPROCESSINIT
 GOSUB @OTYAXFILEINIT
 OTYAXMEMINIT
 OTYAXSTRINI
 VAR INITPROC$="OTW"
 VAR SHPROC$="SH"
 IF BUTTON()AND 8192THEN STARTSHELL=TRUE
 IF STARTSHELL THEN INITPROC$=SHPROC$
 NewProcess INITPROC$,"" OUT RUNPRC,RUNPID
 FIRSTPID=RUNPRC>>PIDSHIFT
 FIRSTNUPID=RUNPRC AND NUPIDMASK
 IF RUNPID THEN
  ?"Process ";INITPROC$;" ";"のきどうにしっぱいしました。:";RUNPID
  NewProcess SHPROC$,"" OUT RUNPRC,RUNPID
  FIRSTPID=RUNPRC>>PIDSHIFT
  FIRSTNUPID=RUNPRC AND NUPIDMASK
 ENDIF
RETURN

@OTYAXERRORINIT
 VAR SUCCESS=0
 VAR ERROR_ERROR=1
 VAR ERROR_NOIMPL=2
RETURN
@OTYAXPROCESSINIT
 VAR PROCESS_MAX=128
 DIM PRC_NAME$[PROCESS_MAX]
 DIM PRC_ARGS$[PROCESS_MAX]
 DIM PRC_PID[PROCESS_MAX]
 DIM PRC_STDOUT[PROCESS_MAX]
 DIM PRC_STDERR[PROCESS_MAX]
 DIM PRC_STDIN[PROCESS_MAX]
 DIM PRC_NEXT[PROCESS_MAX]
 DIM PRC_PREV[PROCESS_MAX]
 DIM PRC_CHILD[PROCESS_MAX]
 DIM PRC_PARENT[PROCESS_MAX]
 DIM PRC_FLG[PROCESS_MAX]
 DIM PRC_DAT[PROCESS_MAX]
 DIM PRC_PTR[PROCESS_MAX]
 VAR PRC_FLG_INIT=1
 VAR PRC_FLG_FUN=2
 VAR PIDCNT=0
 VAR PRC_FREE=1
 _INITFREEPROC
 DEF _INITFREEPROC
  VAR I
  FOR I=1 TO PROCESS_MAX-2
   PRC_NEXT[I]=I+1
  NEXT
 END
 VAR RUNNUPID=0
 VAR ERROR_NEW_PROC=1
 VAR ERROR_NO_PROC=2
RETURN
@OTYAXFILEINIT
 VAR FIDSHIFT=12,NUFIDMASK=4095
 VAR FILES_MAX=1024
 DIM FILES_PID[FILES_MAX]
 DIM FILES_FID[FILES_MAX]
 DIM FILES_NAME$[FILES_MAX]
 DIM FILES_DAT[FILES_MAX]
 DIM FILES_DATSTR$[FILES_MAX]
 DIM FILES_WRITER$[FILES_MAX]
 DIM FILES_READER$[FILES_MAX]
 DIM FILES_CLOSE$[FILES_MAX]
 DIM FILES_NEXT[FILES_MAX]
 DIM FILES_POS[FILES_MAX]
 DIM FILES_ISEOF[FILES_MAX]
 VAR ERROR_NOFILE=201
 VAR ERROR_NOPENFILE=202
 VAR ERROR_NOALLOCFILE=203
 VAR FILES_FREE=1
 VAR FILES_FIDCNT=0
 _INITFREEFIL
 DEF _INITFREEFIL
  VAR I
  FOR I=1 TO FILES_MAX-2
   FILES_NEXT[I]=I+1
  NEXT
 END
 VAR OTYAX_STDOUT_OPENER$="OUTCONSOLE_OPEN"
 VAR OTYAX_STDIN_OPENER$="INCONSOLE_OPEN"
RETURN

COMMON DEF LoadLinkFile FILE$ OUT TYPE$,NAME$,CONTENT$
 TYPE$=""
 CONTENT$=""
 VAR I=INSTR(FILE$,"END"+LF$)
 IF I!=0THEN RETURN
 INC I,4
 VAR J=INSTR(I,FILE$,LF$)
 IF J==-1 THEN RETURN
 TYPE$=MID$(FILE$,I,J-I)
 INC J
 I=INSTR(J,FILE$,LF$)
 IF I==-1 THEN RETURN
 NAME$=MID$(FILE$,J,I-J)
'IF LEN(CONTENT$)&&CONTENT$[LEN(CONTENT$)-1]==LF$THEN
' CONTENT$=LEFT$(CONTENT$,LEN(CONTENT$)-1)
'ENDIF
 INC I
 J=INSTR(I,FILE$,LF$)
 IF J==-1 THEN RETURN
 CONTENT$=MID$(FILE$,I,J-I)
END
@OTYAX_MAIN
 IF RUNNUPID THEN
 ''DEBUGCODE
' VAR CX=CSRX,CY=CSRY,FFF=0
' LOCATE 40,0
' ?RUNNUPID;PRC_NAME$[RUNNUPID];
' IF CX>=50 THEN DEC CX:FFF=1
' LOCATE CX,CY
' IF FFF THEN
'  ?CHR$(CHKCHR(CX,CY));
' ENDIF
 ''
  RUNPRC=PRC_PID[RUNNUPID]<<PIDSHIFT OR RUNNUPID
  IF PRC_FLG[RUNNUPID] AND PRC_FLG_INIT THEN
   IF!CHKLABEL("@I_"+PRC_NAME$[RUNNUPID])THEN
    IF CHKCALL("I_"+PRC_NAME$[RUNNUPID])THEN
     VAR __R=RUNNUPID
     CALL "I_"+PRC_NAME$[RUNNUPID]
     IF __R==RUNNUPID THEN
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]XOR PRC_FLG_INIT
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]OR PRC_FLG_FUN
      PRC_NAME$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
      IF!CHKCALL(PRC_NAME$[RUNNUPID]) THEN
       ExitProcess 1
       GOTO@OTYAX_MAIN
      ENDIF
     ENDIF
    ELSE
     ExitProcess 1
     GOTO@OTYAX_MAIN
    ENDIF
   ELSE
    GOSUB "@I_"+PRC_NAME$[RUNNUPID]
    PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID] XOR PRC_FLG_INIT
    PRC_NAME$[RUNNUPID]="@L_"+PRC_NAME$[RUNNUPID]
    IF!CHKLABEL(PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
   ENDIF
  ELSE
   IF PRC_FLG[RUNNUPID] AND PRC_FLG_FUN THEN
    CALL PRC_NAME$[RUNNUPID]
   ELSE
    GOSUB PRC_NAME$[RUNNUPID]
   ENDIF
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    __R=RUNNUPID
    RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
    IF!RUNNUPID THEN
     RUNNUPID=PRC_PARENT[__R]
     WHILE 1
      __R=RUNNUPID
      RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
      IF!RUNNUPID THEN
       RUNNUPID=PRC_PARENT[__R]
       IF!RUNNUPID THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
RETURN
COMMON DEF OTX_CONT
ISDIR=1
@OTYAX_MAIN
 IF RUNNUPID THEN
 ''DEBUGCODE
' VAR CX=CSRX,CY=CSRY,FFF=0
' LOCATE 40,0
' ?RUNNUPID;PRC_NAME$[RUNNUPID];
' IF CX>=50 THEN DEC CX:FFF=1
' LOCATE CX,CY
' IF FFF THEN
'  ?CHR$(CHKCHR(CX,CY));
' ENDIF
 ''
  IF PRC_FLG[RUNNUPID] AND PRC_FLG_INIT THEN
   IF!CHKLABEL("@I_"+PRC_NAME$[RUNNUPID])THEN
    IF CHKCALL("I_"+PRC_NAME$[RUNNUPID])THEN
     VAR __R=RUNNUPID
     CALL "I_"+PRC_NAME$[RUNNUPID]
     IF __R==RUNNUPID THEN
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]XOR PRC_FLG_INIT
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]OR PRC_FLG_FUN
      PRC_NAME$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
      IF!CHKCALL(PRC_NAME$[RUNNUPID]) THEN
       ExitProcess 1
       GOTO@OTYAX_MAIN
      ENDIF
     ENDIF
    ELSE
     ExitProcess 1
     GOTO@OTYAX_MAIN
    ENDIF
   ELSE
    GOSUB "@I_"+PRC_NAME$[RUNNUPID]
    PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID] XOR PRC_FLG_INIT
    PRC_NAME$[RUNNUPID]="@L_"+PRC_NAME$[RUNNUPID]
    IF!CHKLABEL(PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
   ENDIF
  ELSE
   IF PRC_FLG[RUNNUPID] AND PRC_FLG_FUN THEN
    CALL PRC_NAME$[RUNNUPID]
   ELSE
    GOSUB PRC_NAME$[RUNNUPID]
   ENDIF
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    __R=RUNNUPID
    RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
    IF!RUNNUPID THEN
     RUNNUPID=PRC_PARENT[__R]
     WHILE 1
      __R=RUNNUPID
      RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
      IF!RUNNUPID THEN
       RUNNUPID=PRC_PARENT[__R]
       IF!RUNNUPID THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
END
'OTYAX UTIL
COMMON DEF NewArray#(LEN)
 DIM ARY#[LEN]
 RETURN ARY#
END
COMMON DEF NewArray%(LEN)
 DIM ARY%[LEN]
 RETURN ARY%
END
COMMON DEF NewArray$(LEN)
 DIM ARY$[LEN]
 RETURN ARY$
END
COMMON DEF NewArray(LEN)
 DIM ARY[LEN]
 RETURN ARY
END
COMMON DEF NewArray2#(LEN,L2)
 DIM ARY#[LEN,L2]
 RETURN ARY#
END
COMMON DEF NewArray2%(LEN,L2)
 DIM ARY%[LEN,L2]
 RETURN ARY%
END
COMMON DEF NewArray2$(LEN,L2)
 DIM ARY$[LEN,L2]
 RETURN ARY$
END
COMMON DEF NewArray2(LEN,L2)
 DIM ARY[LEN,L2]
 RETURN ARY
END

COMMON DEF NewArray3#(LEN,L2,L3)
 DIM ARY#[LEN,L2,L3]
 RETURN ARY#
END
COMMON DEF NewArray3%(LEN,L2,L3)
 DIM ARY%[LEN,L2,L3]
 RETURN ARY%
END
COMMON DEF NewArray3$(LEN,L2,L3)
 DIM ARY$[LEN,L2,L3]
 RETURN ARY$
END
COMMON DEF NewArray3(LEN,L2,L3)
 DIM ARY[LEN,L2,L3]
 RETURN ARY
END

COMMON DEF NewArray4#(LEN,L2,L3,L4)
 DIM ARY#[LEN,L2,L3,L4]
 RETURN ARY#
END
COMMON DEF NewArray4%(LEN,L2,L3,L4)
 DIM ARY%[LEN,L2,L3,L4]
 RETURN ARY%
END
COMMON DEF NewArray4$(LEN,L2,L3,L4)
 DIM ARY$[LEN,L2,L3,L4]
 RETURN ARY$
END
COMMON DEF NewArray4(LEN,L2,L3,L4)
 DIM ARY[LEN,L2,L3,L4]
 RETURN ARY
END
COMMON DEF FindArray(ARY[],V)
 VAR I,L=LEN(ARY)-1
 FOR I=0TO L
  IF ARY[I]==V THEN RETURN I
 NEXT
 RETURN -1
END
COMMON DEF ShortToRGB(IN)
 VAR R=IN>>11AND 31
 VAR G=IN>>6AND 31
 VAR B=IN>>1AND 31
 VAR A=(IN AND 1)*255
 RETURN RGB(A,R<<3,G<<3,B<<3)
END
COMMON DEF RGBToShort(IN)
 VAR A=IN>>24
 VAR R=IN>>16AND 255
 VAR G=IN>>8AND 255
 VAR B=IN AND 255
' RETURN !!A<<15OR R>>3<<10OR G>>3<<5OR B>>3
RETURN R>>3<<11OR G>>3<<6OR B>>3<<1OR !!A'==255
END
COMMON DEF SplitInt IN OUT X,Y
 X=IN AND 65535
 Y=IN>>16
END
COMMON DEF JoinInt(X,Y)
 RETURN (X AND 65535)OR Y<<16
END
COMMON DEF BIN$(IN)
 VAR R$="",S$="01"
 WHILE IN
  R$=S$[IN AND 1]+R$
  IN=IN>>1
 WEND
 RETURN R$
END
COMMON DEF InsertStr$(BASE$,POS,INS$)
 RETURN LEFT$(BASE$,POS)+INS$+RIGHT$(BASE$,LEN(BASE$)-POS)
END
COMMON DEF InsertStrB BASE$,POS,INS$
 IF POS==LEN(BASE$)THEN
  PUSH BASE$,INS$
  RETURN
 ENDIF
 BASE$[POS]=INS$+BASE$[POS]
END
COMMON DEF RemoveStr$(THIS$,POS,LEN)
 RETURN LEFT$(THIS$,POS)+RIGHT$(THIS$,LEN(THIS$)-POS-LEN)
END
COMMON DEF RemoveStrB THIS$,POS,LEN
 FOR LEN=LEN TO 1 STEP -1
  THIS$[POS]=""
 NEXT
END
COMMON DEF ReplaceStr$(THIS$,STR$,TO$)
 VAR I,L=LEN(STR$)
 WHILE 1
  I=INSTR(I,THIS$,STR$)
  IF I==-1THEN BREAK
  THIS$=SUBST$(THIS$,I,L,TO$)
  INC I,L
 WEND
 RETURN THIS$
END
COMMON DEF ArrayFill ARY[],V,OFF,L
 IF!L THEN RETURN
 VAR E=OFF+L,O2=OFF
 VAR L1=1
 ARY[OFF]=V
 COPY ARY,OFF+L1,ARY,OFF,L1
' ?L1,OFF
 WHILE 1
 VAR _=L1
' ?L1,OFF
 IF OFF+L1+1+_*2>E THEN
' STOP
  COPY ARY,OFF+L1+1,ARY,O2,E-(OFF+L1+1)'E-OFF DIV 2
  RETURN
 ENDIF
 COPY ARY,OFF+L1+1,ARY,O2,_*2'L1
' ?"COPY ARY",OFF+L1+1,"ARY",O2,_*2
 INC OFF,L1
 INC L1,L1
 
 WEND
END
COMMON DEF Split(STR$,SP$)
 DIM R$[0]
 VAR I,J,SPL=LEN(SP$)
 WHILE 1
  J=INSTR(I,STR$,SP$)
  IF J==-1THEN
   IF I==LEN(STR$)-1THEN RETURN R$
   PUSH R$,MID$(STR$,I,LEN(STR$)-I)
   RETURN R$
  ENDIF
  PUSH R$,MID$(STR$,I,J-I)
  I=J+SPL
 WEND
END
'Memory Library
DIM OTX_STR$[0]
DIM OTX_STRNXT[0]
DIM OTX_STRPRV[0]
VAR OTX_STRFR
DEF OTYAXSTRINI
 OTX_STR$=NewArray$(512)
 OTX_STRNXT=NewArray(512)
 OTX_STRPRV=NewArray(512)
 VAR I
 FOR I=1TO 510
  OTX_STRNXT[I]=I+1
 NEXT
 OTX_STRFR=1
END
COMMON DEF AllocString(STR$)
 IF!OTX_STRFR THEN RETURN
 VAR I=OTX_STRFR
 OTX_STR$[I]=STR$
 OTX_STRFR=OTX_STRNXT[I]
 RETURN I
END
COMMON DEF SetString PTR,STR$
 OTX_STR$[PTR]=STR$
END
COMMON DEF GetString$(PTR)
 RETURN OTX_STR$[PTR]
END
'COMMON DEF SetStringArray32 PTR,I,V
' RETURN OTX_STR$[PTR]
'END
COMMON DEF FreeString PTR
 OTX_STRNXT[PTR]=OTX_STRFR
 OTX_STRFR=PTR
END
VAR OTX_MEMSIZ
DIM OTX_MEM[0]
DIM OTX_MEM#[0]
DIM OTX_MEM$[0]
VAR OTX_FREESIZ
VAR OTX_FREELEN
DIM OTX_FREE[0]
DIM OTX_FREEADDR[0]
VAR OTX_MEMHEAD
DEF OTYAXMEMINIT
 OTX_MEMSIZ=65536
 OTX_MEM=NewArray(OTX_MEMSIZ)
 OTX_FREESIZ=256
 OTX_FREE=NewArray(OTX_FREESIZ)
 OTX_FREEADDR=NewArray(OTX_FREESIZ)
 OTX_MEMHEAD=&Hdeadbeef
 OTYAXMEMFREEINIT
 RETURN


 
 ?"TEST"
 VAR PTR=malloc(128)
 ?"PTR=malloc(128)";PTR
 VAR PTR2=malloc(128)
 ?"PTR2=malloc(128)";PTR2
 free PTR
 ?"free PTR"
 PTR=malloc(32)
 ?"PTR=malloc(128)";PTR
 VAR PTR3=malloc(32)
 ?"PTR3=malloc(128)";PTR
 VAR PTR4=malloc(128)
 ?"PTR4=malloc(128)";PTR
 OTX_FREEDUMP
END
DEF OTYAXMEMFREEINIT
 OTX_FREELEN=1
 OTX_FREE[0]=OTX_MEMSIZ-1
 OTX_FREEADDR[0]=1
END
DEF OTX_FREEDUMP
 VAR I
 FOR I=0TO OTX_FREELEN-1
  ?OTX_FREEADDR[I];":";OTX_FREE[I]
 NEXT
END
COMMON DEF malloc(SIZE)
 VAR I=OTX_FREELEN/2,A=I
 VAR U=-1
 INC SIZE,3'HEADER SIZE
 WHILE 1
  VAR N=OTX_FREE[I]
  'ちょうどいい
  IF I==SIZE THEN
   U=I
   BREAK
  ENDIF
  IF I<SIZE THEN
   IF!A THEN BREAK
'  IF OTX_FREE[I+A]<=SIZE THEN BREAK
   DEC I,A
   A=A/2
   CONTINUE
  ENDIF
  IF I>SIZE THEN
   IF!A THEN BREAK
 '  IF OTX_FREE[I-A]<=SIZE THEN BREAK
   INC I,A
   A=A/2
   CONTINUE
  ENDIF
 WEND
 IF OTX_FREE[I]<SIZE THEN RETURN 0
 VAR ADDR=OTX_FREEADDR[I]
 DEC OTX_FREE[I],SIZE
 IF!OTX_FREE[I]THEN DEC OTX_FREELEN
 INC OTX_FREEADDR[I],SIZE
 RSORT OTX_FREE,OTX_FREEADDR
 OTX_MEM[ADDR]=OTX_MEMHEAD
 OTX_MEM[ADDR+1]=SIZE
 OTX_MEM[ADDR+2]=0'NEXT
 RETURN ADDR+3
END
COMMON DEF free ADDR
 INC OTX_FREELEN
 IF OTX_FREELEN>=OTX_FREESIZ THEN
  PUSH OTX_FREE,0
  PUSH OTX_FREEADDR,0
 ENDIF
 DEC ADDR,3
 IF ADDR<=0||ADDR>=LEN(OTX_MEM)THEN RETURN
 IF OTX_MEM[ADDR]!=OTX_MEMHEAD THEN RETURN
 OTX_FREE[OTX_FREELEN]=OTX_MEM[ADDR+1]
 OTX_FREEADDR[OTX_FREELEN]=ADDR
 RSORT OTX_FREE,OTX_FREEADDR
END
COMMON DEF GetRawMemory()
 RETURN OTX_MEM
END
COMMON DEF ReadArray PTR,ARRAY[],POS,LEN
 IF PTR<0||PTR+LEN>LEN(OTX_MEM)THEN RETURN
 COPY ARRAY,POS,OTX_MEM,PTR,LEN
END
COMMON DEF WriteArray PTR,ARRAY[],POS,LEN
 IF PTR<0||PTR+LEN>LEN(OTX_MEM)THEN RETURN
 COPY OTX_MEM,PTR,ARRAY,POS,LEN
END
COMMON DEF WriteInt PTR,VALUE
 IF PTR<0||PTR>=LEN(OTX_MEM)THEN RETURN
 OTX_MEM[PTR]=VALUE
END
COMMON DEF ReadInt(PTR)
 IF PTR<0||PTR>=LEN(OTX_MEM)THEN RETURN PTR
 RETURN OTX_MEM[PTR]
END
COMMON DEF LoadFile$(NAME$)
 RETURN LOAD("TXT:"+NAME$,0)
END
COMMON DEF GetFiles ARY,DIR$
 IF LEN(DIR$)THEN
  FILES DIR$,ARY
 ELSE
  FILES ARY
 ENDIF
END
'OTYAX PROCESS API
COMMON DEF NewProcess NAME$,ARGS$ OUT PRC,E
 VAR PID,NUPID
 IF PRC_FREE==0 THEN @ERROR
 IF !CHKCALL("I_"+NAME$) THEN @ERROR2
 IF !CHKCALL("L_"+NAME$) THEN @ERROR2
 INC PIDCNT
 PID=PIDCNT
 NUPID=PRC_FREE
 PRC_PID[NUPID]=PID
 PRC_FREE=PRC_NEXT[PRC_FREE]
 PRC_NAME$[NUPID]=NAME$
 PRC_ARGS$[NUPID]=NAME$+" "+ARGS$
 PRC_PREV[NUPID]=0
 PRC_CHILD[NUPID]=0
 PRC_PARENT[NUPID]=RUNNUPID
 'VAR 
 VAR C=PRC_CHILD[RunNUPID]
 PRC_CHILD[RunNUPID]=NUPID
 PRC_NEXT[NUPID]=C
 IF C THEN
  PRC_PREV[C]=NUPID
 ENDIF
 PRC_FLG[NUPID]=PRC_FLG_INIT
 IF RUNNUPID THEN
  'TODO:IMPL
  PRC_STDOUT[NUPID]=PRC_STDOUT[RUNNUPID]

  PRC_STDIN[NUPID]=PRC_STDIN[RUNNUPID]

  PRC_STDERR[NUPID]=PRC_STDERR[RUNNUPID]
 ELSE
  OutConsoleOpen OUT PRC_STDOUT[NUPID],E
  InConsoleOpen OUT PRC_STDIN[NUPID],E
  PRC_STDERR[NUPID]=PRC_STDOUT[NUPID]
 ENDIF
 E=SUCCESS
 PRC=PID<<PIDSHIFT OR NUPID
 RETURN
 @ERROR
 PRC=0
 E=ERROR_NEW_PROC
 RETURN
 @ERROR2
 PRC=0
 E=ERROR_NO_PROC
END
COMMON DEF SetProcessVar DAT
 PRC_DAT[RUNNUPID]=DAT
END
COMMON DEF GetProcessVar()
 RETURN PRC_DAT[RUNNUPID]
END
COMMON DEF CheckProcess(PRC)
 RETURN PRC_PID[PRC AND NUPIDMASK]==PRC>>PIDSHIFT
END
DEF CheckProcess2(PID,NUPID)
 RETURN PRC_PID[NUPID]==PID
END
COMMON DEF GetProcessArgs$()
 RETURN PRC_ARGS$[RUNNUPID]
END
COMMON DEF GetSTDIN()
 RETURN PRC_STDIN[RUNNUPID]
END
COMMON DEF GetSTDOUT()
 RETURN PRC_STDOUT[RUNNUPID]
END
COMMON DEF GetSTDERR()
 RETURN PRC_STDERR[RUNNUPID]
END
COMMON DEF SetProcessSTDIN PRC,STDIN
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDIN[PRC AND NUPIDMASK]=STDIN
END
COMMON DEF SetProcessSTDOUT PRC,STDOUT
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDOUT[PRC AND NUPIDMASK]=STDOUT
END
COMMON DEF SetProcessSTDERR PRC,STDERR
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDERR[PRC AND NUPIDMASK]=STDERR
END
COMMON DEF GetProcessSTDIN(PRC)
 IF!CheckProcess(PRC)THEN RETURN 0
 RETURN PRC_STDIN[PRC AND NUPIDMASK]
END
COMMON DEF GetProcessSTDOUT(PRC)
 IF!CheckProcess(PRC)THEN RETURN
 RETURN PRC_STDOUT[PRC AND NUPIDMASK]
END
COMMON DEF GetProcessSTDERR(PRC)
 IF!CheckProcess(PRC)THEN RETURN
 RETURN PRC_STDERR[PRC AND NUPIDMASK]
END
COMMON DEF GetPID()
 RETURN PRC_PID[RUNNUPID]
END
COMMON DEF GetNUPID()
 RETURN RUNNUPID
END
COMMON DEF NUPIDToPID(NUPID)
 RETURN PRC_PID[NUPID]
END
COMMON DEF ExitProcess RESULT
 VAR ERR
 KillProcess RUNPRC OUT ERR
END
COMMON DEF KillProcess PRC OUT ERR
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF!NUPID THEN RETURN
 IF !CheckProcess(PRC) THEN ERR=ERROR_NO_PROC:RETURN
 VAR PNUPID=PRC_PREV[NUPID]
 VAR NNUPID=PRC_NEXT[NUPID]
 IF PNUPID THEN
  PRC_NEXT[PNUPID]=NNUPID
 ENDIF
 IF PNUPID THEN
  PRC_PREV[NNUPID]=PNUPID
 ENDIF
 IF FIRSTNUPID==NUPID THEN
  FIRSTNUPID=PRC_NEXT[NUPID]
  IF!FIRSTNUPID THEN
   FIRSTNUPID=PRC_CHILD[NUPID]
  ENDIF
 ENDIF
 VAR PANUPID=PRC_PARENT[NUPID]
 IF PRC_CHILD[PANUPID]==NUPID THEN
  PRC_CHILD[PRC_PARENT[NUPID]]=NNUPID
 ENDIF
 VAR CNUPID=PRC_CHILD[NUPID]
 PRC_PID[NUPID]=0
 VAR NXT
 ' ころころしていく
 'こはころさない
 VAR WE
 WHILE CNUPID
  NXT=PRC_NEXT[CNUPID]
  PRC_PARENT[CNUPID]=FIRSTNUPID
  IF !CNUPID THEN WE=CNUPID:BREAK
  CNUPID=NXT
 WEND
 CNUPID=PRC_CHILD[NUPID]
 IF CNUPID THEN
  IF FIRSTNUPID THEN
   NXT=PRC_CHILD[FIRSTNUPID]
   PRC_CHILD[FIRSTNUPID]=CNUPID
   PRC_NEXT[WE]=NXT
  ELSE
   FIRSTNUPID=CNUPID
  ENDIF
 ENDIF
 RUNNUPID=PRC_PARENT[NUPID]
 PRC_NEXT[NUPID]=PRC_FREE
 PRC_FREE=NUPID
 PRC_NAME$[NUPID]=""
 ERR=SUCCESS
 VOID FileClose(PRC_STDOUT[NUPID])
 VOID FileClose(PRC_STDERR[NUPID])
 VOID FileClose(PRC_STDIN[NUPID])
END

'COMMAND
COMMON DEF ExecCommand LINE$ OUT PRC,ERR
 VAR L=LEN(LINE$)-1
 VAR I,C$=""
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 FOR I=0TO L
  C$=MID$(LINE$,I,1)
  IF C$==" " AND S==RDNAME THEN
   ENDNAME=I
   BREAK
  ELSE
   IF C$!=" " AND S==RDSP THEN START=I:S=RDNAME
  ENDIF
 NEXT
 VAR NAME$="",ARG$=""
 IF !ENDNAME THEN
  IF START THEN
    NAME$=MID$(LINE$,START,L-START+1)
   ELSE
    NAME$=LINE$
   ENDIF
   ARG$=""'NAME$
 ELSE
  NAME$=MID$(LINE$,START,ENDNAME-START)
  ARG$=MID$(LINE$,ENDNAME+1,L-ENDNAME)
  'ARG$=MID$(LINE$,START,ENDNAME-START+L-ENDNAME+1)
 ENDIF
 L=LEN(ARG$)-1
 VAR FILE,ARG2$=ARG$,NXT
 VAR INFILE=1,PIPE=2
 VAR HASPIPE=INSTR(ARG$,"|")!=-1
 FOR I=0TO L
  C$=MID$(ARG2$,I,1)
  IF C$=="|"THEN
   VAR SI=ENDNAME+1+I
   IF!ENDNAME THEN SI=I
   VAR PRC2
   ExecCommand LEFT$(LINE$,SI-1) OUT PRC,ERR
   ExecCommand MID$(LINE$,SI+1,LEN(LINE$)-SI-1) OUT PRC2,ERR
   VAR PIPEFILE=OpenPipeFile()
   ?PIPEFILE
   SetProcessSTDOUT PRC,PIPEFILE
   SetProcessSTDIN PRC2,PIPEFILE
   SWAP PRC,PRC2
   RETURN
  ENDIF
  IF HASPIPE THEN CONTINUE
  IF C$=="<" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
   DIALOG C$
   FileOpen C$ OUT FILE,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PRC,ERR
   IF ERR THEN RETURN
   SetProcessSTDIN PRC,FILE
   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
  IF C$==">" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
'   DIALOG C$
   FileOpen C$ OUT FILE,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PRC,ERR
   IF ERR THEN RETURN
   SetProcessSTDOUT PRC,FILE
'   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
 NEXT
 NewProcess NAME$,ARG$ OUT PRC,ERR
END
COMMON DEF GetCommandArgsWithoutName$(ARGS$)
 VAR CMD$,I
 GetCommandArg ARGS$,I OUT CMD$,I
 ARGS$=MID$(ARGS$,I,LEN(ARGS$)-I)
 VAR SP=INSTR(ARGS$," ")
 IF SP==-1THEN RETURN ARGS$
 FOR I=0 TO LEN(ARGS$)-1
  VAR C$=ARGS$[I]
  IF C$!=" "THEN BREAK
 NEXT
 ARGS$=MID$(ARGS$,I,LEN(ARGS$)-I)
 RETURN ARGS$
END
COMMON DEF GetCommandArg ARGS$,I OUT CMD$,INDEX
 IF I==-1 THEN CMD$="":INDEX=-1:RETURN
 VAR L=LEN(ARGS$)-1
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 VAR C$=""
 CMD$=""INDEX=-1
 FOR I=I TO L
  C$=MID$(ARGS$,I,1)
  IF S==RDSP AND C$!=" " THEN
   START=I
   S=RDNAME
  ELSE
   IF S==RDNAME AND C$==" " THEN
    INDEX=I
    CMD$=MID$(ARGS$,START,I-START)
    RETURN
   ENDIF
  ENDIF
 NEXT
 IF S==RDNAME THEN
  CMD$=MID$(ARGS$,START,L-START+1)
  INDEX=L+1
 ENDIF
END
COMMON DEF CommandArgsToArray ARY$[],EXPAND OUT LEN
 VAR ARGS$=GetCommandArgs$()
 VAR C$=""
 LEN=0
 VAR I
 WHILE 1
  GetCommandArg I OUT C$,I
  IF I==-1 THEN BREAK
  'FLGがTRUEなら はいれつを かくちょう
  IF EXPAND THEN IF LEN>LEN(ARY$) THEN
   PUSH ARY$,""
  ELSE
   BREAK
  ENDIF
  ARY$[LEN]=C$
  INC LEN
 WEND
END

DEF OpenPipeFile()
 VAR FID,NUFID,E
 AllocFile OUT FID,NUFID,E
 IF E THEN RETURN 0
 E=SetWriter(FID,NUFID,"TXTWRITER")
 E=SetReader(FID,NUFID,"TXTREADER")
' E=SetFlush(FID,NUFID,"TXTFLUSH")
 RETURN FID<<FIDSHIFT OR NUFID
END
'OTYAX FILE API
'TXT:FILE を OPEN
COMMON DEF FileOpen NAME$ OUT FILE,E
' IF!CHKFILE("TXT:"+NAME$) THEN E=ERROR_NOFILE:FID=0NUFID=0RETURN
 VAR FID,NUFID
 AllocFile OUT FID,NUFID,E
 IF E THEN RETURN
 VAR F$=""
 IF CHKFILE("TXT:"+NAME$) THEN
  F$=LOAD("TXT:"+NAME$)
 ENDIF
 SetFIDDataStr FID,NUFID,F$
 SetFIDNAME FID,NUFID,NAME$
 E=SetWriter(FID,NUFID,"TXTWRITER")
 E=SetReader(FID,NUFID,"TXTREADER")
 E=SetClose(FID,NUFID,"TXTCLOSE")
' E=SetFlush(FID,NUFID,"TXTFLUSH")
 FILE=FID<<FIDSHIFT OR NUFID
 RETURN
END
DEF TxtClose NUFID
 SAVE "TXT:"+GetFIDName$(NUFIDToFID(NUFID),NUFID),GetFIDDataStr$(NUFIDToFID(NUFID),NUFID)
END
DEF TxtReader NUFID,LEN OUT DAT$,ERR
 ERR=SUCCESS
 VAR FID=NUFIDToFID(NUFID)
 VAR POS
 VAR FILE=FID<<FIDSHIFT OR NUFID
 GetFilePos FILE OUT POS,ERR
 VAR STR$=GetFIDDataStr$(FID,NUFID)
 DAT$=MID$(STR$,POS,MIN(LEN,MAX(0,LEN(STR$)-POS)))
 IF!LEN(DAT$)THEN
  FILES_ISEOF[NUFID]=TRUE
 ELSE
  FileSeekCUR FILE,LEN(DAT$) OUT ERR
 ENDIF
END
DEF TxtWriter(NUFID,DAT$)
 VAR FID=NUFIDToFID(NUFID)
 SetFIDDataStr FID,NUFID,GetFIDDataStr$(FID,NUFID)+DAT$
 RETURN SUCCESS
END
COMMON DEF FileWrite(FILE,DAT$)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF FILES_FID[NUFID]!=FID THEN
  RETURN ERROR_NOPENFILE
 ENDIF
 VAR E=CALL(FILES_WRITER$[NUFID],NUFID,DAT$)
 RETURN SUCCESS
END
COMMON DEF FileRead FILE,LEN OUT DAT$,E
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN
  DAT$=""
  E=ERROR_NOPENFILE
  RETURN
 ENDIF
 IF !LEN THEN RETURN
 CALL FILES_READER$[NUFID],NUFID,LEN OUT DAT$,E
 E=SUCCESS
END
COMMON DEF FileClose(FILE)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOPENFILE
 IF LEN(FILES_CLOSE$[NUFID]) THEN CALL FILES_CLOSE$[NUFID],NUFID
 FILES_NEXT[NUFID]=FILES_FREE
 FILES_FREE=NUFID
 RETURN SUCCESS
END
COMMON DEF IsFileEOF(FILE)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOPENFILE
 RETURN FILES_ISEOF[NUFID]
END
DEF AllocFile OUT FID,NUFID,E
 IF FILES_FREE==0 THEN
  E=ERROR_NOALLOCFILE
  RETURN
 ENDIF
 INC FILES_FIDCNT
 NUFID=FILES_FREE
 FILES_FID[NUFID]=FILES_FIDCNT
 FILES_ISEOF[NUFID]=0
 FID=FILES_FIDCNT
 FILES_FREE=FILES_NEXT[FILES_FREE]
 E=SUCCESS
END
COMMON DEF NUFIDToFID(NUFID)
 RETURN FILES_FID[NUFID]
END
'FIDがせいじょうならTRUE
COMMON DEF CheckFID(FID,NUFID)
 RETURN FILES_FID[NUFID]==FID
END
COMMON DEF CheckFile(FILE)
 RETURN FILES_FID[FILE AND NUFIDMASK]==FILE>>FIDSHIFT
END
DEF SetWriter(FID,NUFID,FUNC$)
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOFILE
 FILES_WRITER$[NUFID]=FUNC$
 RETURN SUCCESS
END
DEF SetFIDData FID,NUFID,DAT
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_DAT[NUFID]=DAT
END
DEF GetFIDData(FID,NUFID)
 IF!CheckFID(FID,NUFID) THEN RETURN -1
 RETURN FILES_DAT[NUFID]
END
DEF SetFIDDataStr FID,NUFID,DAT$
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_DATSTR$[NUFID]=DAT$
END
DEF GetFIDDataStr$(FID,NUFID)
 IF !CheckFID(FID,NUFID) THEN RETURN ""
 RETURN FILES_DATSTR$[NUFID]
END
DEF SetFIDName FID,NUFID,DAT$
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_NAME$[NUFID]=DAT$
END
DEF GetFIDName$(FID,NUFID)
 IF !CheckFID(FID,NUFID) THEN RETURN ""
 RETURN FILES_NAME$[NUFID]
END
DEF SetReader(FID,NUFID,FUNC$)
 IF !CheckFID(FID,NUFID) THEN RETURN ERROR_NOFILE
 FILES_READER$[NUFID]=FUNC$
 RETURN SUCCESS
END
DEF SetClose(FID,NUFID,FUNC$)
 IF !CheckFID(FID,NUFID) THEN RETURN ERROR_NOFILE
 FILES_CLOSE$[NUFID]=FUNC$
 RETURN SUCCESS
END
DEF OutConsoleOpen OUT FILE,E
 VAR FID,NUFID
 AllocFile OUT FID,NUFID,E
 E=SETWRITER(FID,NUFID,"CONSOLEWRITERSTR")
 FILE=FID<<FIDSHIFT OR NUFID
END
DEF InConsoleOpen OUT FILE,E
 VAR FID,NUFID
 AllocFile OUT FID,NUFID,E
 E=SETREADER(FID,NUFID,"CONSOLEREADERSTR")
 FILE=FID<<FIDSHIFT OR NUFID
END
COMMON DEF FileSeekCUR FILE,LEN OUT ERR
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF !CheckFID(FID,NUFID) THEN ERR=ERROR_NOFILE:RETURN
 FILES_POS[NUFID]=FILES_POS[NUFID]+LEN
 ERR=SUCCESS
END
COMMON DEF GetFilePos FILE OUT POS,ERR
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF !CheckFID(FID,NUFID) THEN POS=0:ERR=ERROR_NOFILE:RETURN
 POS=FILES_POS[NUFID]
 ERR=ERROR_NOFILE
END
DEF ConsoleWriterStr(NUFID,DAT$)
 'VAR 
 VAR L=LEN(DAT$)-1
 VAR I
 '?DAT$;
 FOR I=0 TO L
  VAR D$=MID$(DAT$,I,1)
  IF D$==HTAB$ THEN
   PRINT "",
  ELSE
   PRINT D$;
  ENDIF
 NEXT
 RETURN SUCCESS
END
DEF ConsoleReaderStr NUFID,LEN OUT DAT$,E
 DAT$=INKEY$()
 IF DAT$==CR$THEN DAT$=LF$
 E=SUCCESS
 IF!LEN(DAT$) THEN
  RETURN
 ENDIF
 VAR K$,I
 FOR I=0TO LEN-2
  K$=INKEY$()
  IF !LEN(K$)THEN RETURN
  IF K$==CR$THEN K$=LF$
  DAT$=DAT$+K$
 NEXT
END
COMMON DEF PRINTCONSOLE STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],STR$)
END
COMMON DEF PRINTCONSOLELN STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],STR$+LF$)
END
COMMON DEF INKEYCONSOLE$(LEN)
 VAR STR$="",E
 FileRead PRC_STDIN[RUNNUPID],LEN OUT STR$,E
 RETURN STR$
END
COMMON DEF LOCATECONSOLE X,Y
 LOCATE X,Y
END
COMMON DEF FORECOLORCONSOLE C
 COLOR C
END
COMMON DEF BACKCOLORCONSOLE C
 COLOR ,C
END
'OTYAX APPS
DIM SH_INPUT$[12]
DIM SH_PRC[12]
VAR SH_CNT=0
DEF I_SH
 PrintConsole "OTYAX SH"+LF$
 PrintConsole VER$

 IF SH_CNT==0 THEN
  SH_INPUT$=NewArray$(12)
  SH_PRC=NewArray(12)
 ENDIF
 INC SH_CNT
 SetProcessVar(SH_CNT)
 PrintConsole ">"
END
DEF L_SH
 VAR DAT=GetProcessVar()
 IF SH_PRC[DAT] THEN
  IF!CheckProcess(SH_PRC[DAT]) THEN
'?"EXIT:";SH_PID[DAT],SH_NUPID[DAT]
  'コマンドが0XDEAD
   @INIT
   SH_INPUT$[DAT]=""
   SH_PRC[DAT]=0
   PrintConsole STR$(DAT)+">"
'   PrintConsole ">"
  ELSE
   RETURN
  ENDIF
  RETURN
 ENDIF
 VAR KEY$=INKEYCONSOLE$(1)
 IF KEY$=="" THEN RETURN
 PrintConsole KEY$
 IF KEY$==LF$ THEN @EXEC_COMMAND
 IF KEY$==CR$ THEN @EXEC_COMMAND
 SH_INPUT$[DAT]=SH_INPUT$[DAT]+KEY$
 RETURN
 
 @EXEC_COMMAND
 VAR ERR
 VAR NAME$,I,ARGS$
 GetCommandArg SH_INPUT$[DAT],0 OUT NAME$,I
 IF NAME$=="EXIT"THEN
  ExitProcess SUCCESS
  SH_INPUT$[DAT]=""
  RETURN
 ENDIF
 IF NAME$=="BACK"THEN
  SH_BACK SH_INPUT$[DAT]
  SH_INPUT$[DAT]=""
  PrintConsole ">"
  RETURN
 ENDIF
 ExecCommand SH_INPUT$[DAT] OUT SH_PRC[DAT],ERR
 IF ERR==ERROR_NO_PROC THEN
  PrintConsole NAME$+"がみつかりません"+LF$()
  GOTO @INIT
 ENDIF
' ?"RUN:";RUNNUPID
END
RETURN

DEF SH_BACK A$
 VAR NAME$,I,ARGS$,PID,NUPID,ERR
 GetCommandArg A$,I OUT NAME$,I
 GetCommandArg A$,I OUT NAME$,I
 IF I==-1THEN
  PrintConsole "USAGE:BACK ARGS..."+LF$
  RETURN
 ENDIF
' GetCommandArg A$,I OUT ARGS$,I
 ARGS$=MID$(A$,I,LEN(A$)-1)
 ?ARGS$
 STOP
 NewProcess NAME$,ARGS$ OUT PID,NUPID,ERR
END
'I_AM_CAT
DEF I_CAT
 VAR FILE,ERR,CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN ExitProcess I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN
  FILE=GetSTDIN()
 ELSE
  FileOpen CMD$ OUT FILE,ERR
 ENDIF
 IF ERR THEN RETURN
 SetProcessVar FILE
END
DEF L_CAT
 VAR FILE=GetProcessVar()
 IF !FILE THEN ExitProcess SUCCESS:RETURN
 VAR DAT$,ERR
 FileRead FILE,2048 OUT DAT$,ERR
 IF LEN(DAT$)==0THEN
  IF IsFileEOF(FILE)THEN
   ERR=FileClose(FILE)
   ExitProcess SUCCESS
   RETURN
  ENDIF
 ENDIF
' IF LEN(DAT$)==0THEN
'  ERR=FileClose(FILE)
'  ExitProcess SUCCESS
'  RETURN
' ENDIF
 PrintConsole DAT$
END
DEF I_PTREE
END
DEF L_PTREE
 DUMP_PS
 ExitProcess 0
END

DEF DUMP_PS
 DUMP_PS2 FIRSTNUPID,""
END
DEF DUMP_PS2 NUP,I$
 IF!NUP THEN RETURN
 ?I$;PRC_NAME$[NUP],NUP,"PID",PRC_PID[NUP]
' IF CSRY==29 THEN VAR II$INPUT "";II$
 IF LEN(I$) THEN
  VAR NM$=""
  IF PRC_NEXT[NUP] THEN
   NM$=""
  ELSE
   NM$=""
  ENDIF
  IF PRC_NEXT[PRC_PARENT[NUP]]THEN
   NM$=""+NM$
  ELSE
   NM$=" "+NM$
  ENDIF
  DUMP_PS2 PRC_CHILD[NUP],MID$(I$,0,LEN(I$)-1)+NM$
 ELSE
  IF PRC_CHILD[NUP]THEN
   DUMP_PS2 PRC_CHILD[NUP],""
  ELSE
   DUMP_PS2 PRC_CHILD[NUP],""
  ENDIF
 ENDIF
 DUMP_PS2 PRC_NEXT[NUP],I$
END
DEF I_PS
 PrintConsole FORMAT$("%SPID%SNUPID%SCOMMAND%S%S",HTAB$,HTAB$,HTAB$,HTAB$,LF$)
END
DEF L_PS
 ExitProcess SUCCESS
END
DEF I_BEEP
END
DEF L_BEEP
 IF !RND(1024) THEN BEEP RND(3)+88
END

VAR DIFF_LOCK
VAR DIFF_PHASE
DIM DIFF_A$[0]
DIM DIFF_B$[0]
DIM DIFF_V[0]
DIM DIFF_TREE[0]
DIM DIFF_SES[0]
VAR DIFF_OI
VAR DIFF_NI
DEF I_DIFF
 IF DIFF_LOCK THEN RETURN
 VAR CMD$,A$,B$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT A$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT B$,I
 IF I==-1THEN @USAGE
 VAR F$=LoadFile$(A$)
 DIFF_A$=SPLIT(F$,LF$())
 F$=LoadFile$(B$)
 DIFF_B$=SPLIT(F$,LF$())
 DIFF_PHASE=0
 RETURN
 @USAGE
 PrintConsoleln "USAGE: DIFF ORIGIN NEW"
 ExitProcess -1
END
VAR DIFF_D,DIFF_K,DIFF_TAIL
VAR DIFF_I
DEF L_DIFF
 IF!DIFF_LOCK THEN DIFF_LOCK=GetPID()
 IF DIFF_LOCK!=GetPID()THEN RETURN
 VAR OL=LEN(DIFF_A$),NL=LEN(DIFF_B$)
 VAR DELETE=0
 VAR COMMON_=1
 VAR ADD=2
 VAR D=DIFF_D,K=DIFF_K
 VAR OFFSET=OL
 WHILE 1
  ON DIFF_PHASE GOTO @INIT,@DIFF,@SES,@DUMP,@END
  BREAK
  @INIT
   DIFF_V=NewArray((OL+NL+1)*2)
   VAR VI
   FOR VI=1TO LEN(DIFF_V)-1 STEP 2
    DIFF_V[VI]=-1
   NEXT
   DIFF_TREE=NewArray(0)
   DIFF_PHASE=1
   DIFF_D=0
   DIFF_K=0
   DIFF_TAIL=-1
  BREAK
  @DIFF
' FOR D=0TO OL+NL
   FOR K=-D TO D STEP 2
    IF K<-OL||NL<K THEN CONTINUE
     VAR V_K=(K+OFFSET)*2
     VAR V_KP1=(V_K+2)
     VAR V_KM1=(V_K-2)
     IF D THEN
      IF K==-D||K==-OL||(K!=D&&K!=NL&&DIFF_V[V_KM1]+1<DIFF_V[V_KP1])THEN
       DIFF_V[V_K]=DIFF_V[V_KP1]
       DIFF_V[V_K+1]=LEN(DIFF_TREE)
       PUSH DIFF_TREE,DELETE
       PUSH DIFF_TREE,DIFF_V[V_KP1+1]
      ELSE
       DIFF_V[V_K]=DIFF_V[V_KM1]+1
       DIFF_V[V_K+1]=LEN(DIFF_TREE)
       PUSH DIFF_TREE,ADD
       PUSH DIFF_TREE,DIFF_V[V_KM1+1]
      ENDIF
     ENDIF
     VAR V_K_Y=DIFF_V[V_K]
     WHILE V_K_Y-K<OL&&V_K_Y<NL&&DIFF_A$[V_K_Y-K]==DIFF_B$[V_K_Y]
      VAR OT=DIFF_V[V_K+1]
      DIFF_V[V_K+1]=LEN(DIFF_TREE)
      PUSH DIFF_TREE,COMMON_
      PUSH DIFF_TREE,OT
      INC V_K_Y
      INC DIFF_V[V_K]
     WEND
     IF V_K_Y-K>=OL&&V_K_Y>=NL THEN
      DIFF_TAIL=DIFF_V[V_K+1]
      GOTO @EXIT
     ENDIF
   NEXT
  IF DIFF_D>=OL+NL THEN @EXIT
  INC DIFF_D
  BREAK
' NEXT
  @EXIT
  DIFF_PHASE=2
  BREAK
  @SES
  DIFF_SES=NewArray(0)
  VAR I=DIFF_TAIL
  WHILE I!=-1
   PUSH DIFF_SES,DIFF_TREE[I]
   I=DIFF_TREE[I+1]
  WEND
  DIFF_PHASE=3
  DIFF_I=LEN(DIFF_SES)-1
  DIFF_OI=0
  DIFF_NI=0
  BREAK
  @DUMP
  VAR MX=MAX(0,DIFF_I-128)
  FOR I=DIFF_I TO MX STEP -1
   WHILE 1
   ON DIFF_SES[I] GOTO @DEL,@COM,@ADD
    PrintConsole "?"
    BREAK
    @DEL
     PrintConsole "-"
     IF LEN(DIFF_A$)>DIFF_OI THEN
      PrintConsoleln DIFF_A$[DIFF_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_OI
    BREAK
    @COM
     PrintConsole " "
     IF LEN(DIFF_A$)>DIFF_OI THEN
      PrintConsoleln DIFF_A$[DIFF_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_OI
     INC DIFF_NI
    BREAK
    @ADD
     PrintConsole "+"
     IF LEN(DIFF_B$)>DIFF_NI THEN
      PrintConsoleln DIFF_B$[DIFF_NI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_NI
    BREAK
    WEND
   NEXT
   DIFF_I=I
   IF DIFF_I==-1 THEN DIFF_PHASE=4
  BREAK
  @END
  ExitProcess 0
  BREAK
 WEND
END

COMMON DEF I_FREEMEM
END
COMMON DEF L_FREEMEM
 VAR OX=CSRX,OY=CSRY
 LOCATE 49-LEN(STR$(FREEMEM)),0
 COLOR 0,15
 ?FREEMEM
 COLOR 15,0
 LOCATE OX,OY
END

COmMON DEF EXITMORE
 VAR PTR=GetProcessVar()
 VAR CONIN=ReadInt(PTR+1)
 VOID FileClose(CONIN)
 FREE PTR
END
COMMON DEF I_MORE
 VAR CONIN,E
 InConsoleOpen OUT CONIN,E
 VAR PTR=malloc(3)
 WriteInt PTR,0
 WriteInt PTR+1,CONIN
 SetProcessVar PTR
 VAR I,RT
 FOR I=0TO 28
  RT=DOMORE()
  IF RT==1THEN EXITMORE:RETURN
  IF RT==2 THEN WriteInt PTR,1:BREAK
 NEXT
 WriteInt PTR+3,I
END
COMMON DEF L_MORE
 VAR PTR=GetProcessVar()
 VAR STATE=ReadInt(PTR)
 VAR CONIN=ReadInt(PTR+1)
 VAR COUNT=ReadInt(PTR+3)
 VAR KEY$,ERR
 FileRead CONIN,1 OUT KEY$,ERR
 IF INSTR(KEY$,LF$())!=-1||STATE THEN
  VAR RT=DOMORE()
  IF RT==1THEN EXITMORE:RETURN
  IF RT==2THEN
   WriteInt PTR,1
  ELSE
   IF COUNT+1<=28THEN
    WriteInt PTR+3,COUNT+1
    WriteInt PTR,1
   ELSE
    WriteInt PTR,0
   ENDIF
  ENDIF
 ENDIF
END
COMMON DEF DOMORE()
 VAR FILE=GetSTDIN()
 IF !FILE THEN ExitProcess SUCCESS:RETURN 1
 VAR DAT$,ERR
 VAR LINEW=50
 FileRead FILE,LINEW OUT DAT$,ERR
 IF LEN(DAT$)==0THEN
  IF IsFileEOF(FILE)THEN
   RETURN 1
  ELSE
   RETURN 2
  ENDIF
 ENDIF
' IF LEN(DAT$)==0THEN
'  ERR=FileClose(FILE)
'  ExitProcess SUCCESS
'  RETURN 1
' ENDIF
 VAR LFPOS=INSTR(DAT$,LF$)
 IF LFPOS==0THEN
  VOID FileSeekCUR(FILE,-48)
  PrintConsoleln ""
  RETURN 0
 ENDIF
 VAR LEN=LINEW
 IF LFPOS!=-1THEN LEN=MIN(LFPOS+1,LINEW)
 IF LEN-LINEW THEN
  VOID FileSeekCUR(FILE,LEN-LINEW)
 ENDIF
 PrintConsole LEFT$(DAT$,LEN)
 IF LFPOS==-1THEN PrintConsoleln ""
 IF LFPOS==-1&&LEN<LINEW THEN RETURN 2
 RETURN 0
END
COMMON DEF I_ECHO
END
COMMON DEF L_ECHO
 VAR FILE,ERR,CMD$,I
 PrintConsoleln GetCommandArgsWithoutName$(GetProcessArgs$())
 ExitProcess 0
END

