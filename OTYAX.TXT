?"
VAR STARTSHELL
'SAVE"OTYAX"
'SAVE"PRG1:OTW
USE 1
ACLS
OPTION STRICT
OPTION DEFINT
VAR ISDIR=0
COMMON DEF IsDirectMode()
 RETURN ISDIR
END
VAR LF$=CHR$(10)
VAR CR$=CHR$(13)
VAR BS$=CHR$(8)
VAR HTAB$=CHR$(9)
VAR INF#=POW(2,1024)
VAR NAN#=INF#/INF#
'GETTER
COMMON DEF VOID EXP
END
COMMON DEF LF$()
 RETURN LF$
END
COMMON DEF CR$()
 RETURN CR$
END
COMMON DEF BS$()
 RETURN BS$
END
COMMON DEF HTAB$()
 RETURN HTAB$
END
COMMON DEF INF#()
 RETURN INF#
END
COMMON DEF NAN#()
 RETURN NAN#
END
COMMON DEF NOIMPL MSG$
 ?MSG$
END
@OTYAX
 VAR FIRSTPID=0
 VAR FIRSTNUPID=0
 VAR RUNPID
 VAR RUNPRC=0
 VAR PIDSHIFT=12,NUPIDMASK=4095
GOSUB @OTYAXINIT
IF RUNPID THEN ?"FAIL":END
GOSUB @OTYAX_MAIN
?"OK
END
'しょきかルーチン
@OTYAXINIT
 '?"OTYAX 5.0-6
 VAR KILLPRCBTN=64+128+512
 VAR VER$="5.0-6"
 GOSUB @OTYAXERRORINIT
 GOSUB @OTYAXPROCESSINIT
 GOSUB @OTYAXFILEINIT
 OTYAXMEMINIT
 OTYAXSTRINI
 OTX_INIT_SBARRAY
' OTYFS_INIT
 VAR INITPROC$="OTW"
 VAR SHPROC$="SH"
 IF BUTTON()AND 8192THEN STARTSHELL=TRUE
 IF STARTSHELL THEN INITPROC$=SHPROC$
 NewProcess INITPROC$,"" OUT RUNPRC,RUNPID
 FIRSTPID=RUNPRC>>PIDSHIFT
 FIRSTNUPID=RUNPRC AND NUPIDMASK
 IF RUNPID THEN
  ?"Process ";INITPROC$;" ";"のきどうにしっぱいしました。:";RUNPID
  NewProcess SHPROC$,"" OUT RUNPRC,RUNPID
  FIRSTPID=RUNPRC>>PIDSHIFT
  FIRSTNUPID=RUNPRC AND NUPIDMASK
 ENDIF
RETURN

@OTYAXERRORINIT
 VAR SUCCESS=0
 VAR ERROR_ERROR=1
 VAR ERROR_NOIMPL=2
RETURN
@OTYAXPROCESSINIT
 VAR PROCESS_MAX=128
 DIM PRC_NAME$[PROCESS_MAX]
 DIM PRC_ARGS$[PROCESS_MAX]
 DIM PRC_PID[PROCESS_MAX]
 DIM PRC_STDOUT[PROCESS_MAX]
 DIM PRC_STDERR[PROCESS_MAX]
 DIM PRC_STDIN[PROCESS_MAX]
 DIM PRC_NEXT[PROCESS_MAX]
 DIM PRC_PREV[PROCESS_MAX]
 DIM PRC_CHILD[PROCESS_MAX]
 DIM PRC_PARENT[PROCESS_MAX]
 DIM PRC_FLG[PROCESS_MAX]
 DIM PRC_DAT[PROCESS_MAX]
 DIM PRC_PTR[PROCESS_MAX]
 VAR PRC_FLG_INIT=1
 VAR PRC_FLG_FUN=2
 VAR PIDCNT=0
 VAR PRC_FREE=1
 _INITFREEPROC
 DEF _INITFREEPROC
  VAR I
  FOR I=1 TO PROCESS_MAX-2
   PRC_NEXT[I]=I+1
  NEXT
 END
 PRC_PID[0]=&HCAFEBABE
 VAR RUNNUPID=0
 VAR ERROR_NEW_PROC=1
 VAR ERROR_NO_PROC=2
RETURN
@OTYAXFILEINIT
 VAR FIDSHIFT=12,NUFIDMASK=4095
 VAR FILES_MAX=1024
 DIM FILES_PID[FILES_MAX]
 DIM FILES_FID[FILES_MAX]
 DIM FILES_NAME$[FILES_MAX]
 DIM FILES_DAT[FILES_MAX]
 DIM FILES_DATSTR$[FILES_MAX]
 DIM FILES_WRITER$[FILES_MAX]
 DIM FILES_READER$[FILES_MAX]
 DIM FILES_READLN$[FILES_MAX]
 DIM FILES_CLOSE$[FILES_MAX]
 DIM FILES_NEXT[FILES_MAX]
 DIM FILES_POS[FILES_MAX]
 DIM FILES_ISEOF[FILES_MAX]
 VAR ERROR_NOFILE=201
 VAR ERROR_NOPENFILE=202
 VAR ERROR_NOALLOCFILE=203
 VAR ERROR_NOFILECONTENT=204
 VAR FILES_FREE=1
 VAR FILES_FIDCNT=0
 _INITFREEFIL
 DEF _INITFREEFIL
  VAR I
  FOR I=1 TO FILES_MAX-2
   FILES_NEXT[I]=I+1
  NEXT
 END
 VAR OTYAX_STDOUT_OPENER$="OUTCONSOLE_OPEN"
 VAR OTYAX_STDIN_OPENER$="INCONSOLE_OPEN"
RETURN

COMMON DEF LoadLinkFile FILE$ OUT TYPE$,NAME$,CONTENT$
 TYPE$=""
 CONTENT$=""
 VAR I=INSTR(FILE$,"END"+LF$)
 IF I!=0THEN RETURN
 INC I,4
 VAR J=INSTR(I,FILE$,LF$)
 IF J==-1 THEN RETURN
 TYPE$=MID$(FILE$,I,J-I)
 INC J
 I=INSTR(J,FILE$,LF$)
 IF I==-1 THEN RETURN
 NAME$=MID$(FILE$,J,I-J)
'IF LEN(CONTENT$)&&CONTENT$[LEN(CONTENT$)-1]==LF$THEN
' CONTENT$=LEFT$(CONTENT$,LEN(CONTENT$)-1)
'ENDIF
 INC I
 J=INSTR(I,FILE$,LF$)
 IF J==-1 THEN RETURN
 CONTENT$=MID$(FILE$,I,J-I)
END
@OTYAX_MAIN
 IF RUNNUPID THEN
 ''DEBUGCODE
' VAR CX=CSRX,CY=CSRY,FFF=0
' LOCATE 40,0
' ?RUNNUPID;PRC_NAME$[RUNNUPID];
' IF CX>=50 THEN DEC CX:FFF=1
' LOCATE CX,CY
' IF FFF THEN
'  ?CHR$(CHKCHR(CX,CY));
' ENDIF
 ''
  RUNPRC=PRC_PID[RUNNUPID]<<PIDSHIFT OR RUNNUPID
  IF PRC_FLG[RUNNUPID] AND PRC_FLG_INIT THEN
   IF!CHKLABEL("@I_"+PRC_NAME$[RUNNUPID])THEN
    IF CHKCALL("I_"+PRC_NAME$[RUNNUPID])THEN
     VAR __R=RUNNUPID
     CALL "I_"+PRC_NAME$[RUNNUPID]
     IF __R==RUNNUPID THEN
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]XOR PRC_FLG_INIT
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]OR PRC_FLG_FUN
      PRC_NAME$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
      IF!CHKCALL(PRC_NAME$[RUNNUPID]) THEN
       ExitProcess 1
       GOTO@OTYAX_MAIN
      ENDIF
     ENDIF
    ELSE
     ExitProcess 1
     GOTO@OTYAX_MAIN
    ENDIF
   ELSE
    GOSUB "@I_"+PRC_NAME$[RUNNUPID]
    PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID] XOR PRC_FLG_INIT
    PRC_NAME$[RUNNUPID]="@L_"+PRC_NAME$[RUNNUPID]
    IF!CHKLABEL(PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
   ENDIF
  ELSE
   IF PRC_FLG[RUNNUPID] AND PRC_FLG_FUN THEN
    CALL PRC_NAME$[RUNNUPID]
   ELSE
    GOSUB PRC_NAME$[RUNNUPID]
   ENDIF
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    __R=RUNNUPID
    RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
    IF!RUNNUPID THEN
     RUNNUPID=PRC_PARENT[__R]
     WHILE 1
      __R=RUNNUPID
      RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
      IF!RUNNUPID THEN
       RUNNUPID=PRC_PARENT[__R]
       IF!RUNNUPID THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
RETURN
COMMON DEF OTX_CONT
ISDIR=1
@OTYAX_MAIN
 IF RUNNUPID THEN
 ''DEBUGCODE
' VAR CX=CSRX,CY=CSRY,FFF=0
' LOCATE 40,0
' ?RUNNUPID;PRC_NAME$[RUNNUPID];
' IF CX>=50 THEN DEC CX:FFF=1
' LOCATE CX,CY
' IF FFF THEN
'  ?CHR$(CHKCHR(CX,CY));
' ENDIF
 ''
  IF PRC_FLG[RUNNUPID] AND PRC_FLG_INIT THEN
   IF!CHKLABEL("@I_"+PRC_NAME$[RUNNUPID])THEN
    IF CHKCALL("I_"+PRC_NAME$[RUNNUPID])THEN
     VAR __R=RUNNUPID
     CALL "I_"+PRC_NAME$[RUNNUPID]
     IF __R==RUNNUPID THEN
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]XOR PRC_FLG_INIT
      PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID]OR PRC_FLG_FUN
      PRC_NAME$[RUNNUPID]="L_"+PRC_NAME$[RUNNUPID]
      IF!CHKCALL(PRC_NAME$[RUNNUPID]) THEN
       ExitProcess 1
       GOTO@OTYAX_MAIN
      ENDIF
     ENDIF
    ELSE
     ExitProcess 1
     GOTO@OTYAX_MAIN
    ENDIF
   ELSE
    GOSUB "@I_"+PRC_NAME$[RUNNUPID]
    PRC_FLG[RUNNUPID]=PRC_FLG[RUNNUPID] XOR PRC_FLG_INIT
    PRC_NAME$[RUNNUPID]="@L_"+PRC_NAME$[RUNNUPID]
    IF!CHKLABEL(PRC_NAME$[RUNNUPID]) THEN ExitProcess 1:GOTO@OTYAX_MAIN
   ENDIF
  ELSE
   IF PRC_FLG[RUNNUPID] AND PRC_FLG_FUN THEN
    CALL PRC_NAME$[RUNNUPID]
   ELSE
    GOSUB PRC_NAME$[RUNNUPID]
   ENDIF
  ENDIF
  IF PRC_CHILD[RUNNUPID] THEN
   RUNNUPID=PRC_CHILD[RUNNUPID]
  ELSE 
   IF PRC_NEXT[RUNNUPID] THEN
    RUNNUPID=PRC_NEXT[RUNNUPID]
   ELSE
    __R=RUNNUPID
    RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
    IF!RUNNUPID THEN
     RUNNUPID=PRC_PARENT[__R]
     WHILE 1
      __R=RUNNUPID
      RUNNUPID=PRC_NEXT[PRC_PARENT[RUNNUPID]]
      IF!RUNNUPID THEN
       RUNNUPID=PRC_PARENT[__R]
       IF!RUNNUPID THEN BREAK
       CONTINUE
      ENDIF
      BREAK
     WEND
    ENDIF
   ENDIF
  ENDIF
 ELSE
  RUNNUPID=FIRSTNUPID
  IF!FIRSTNUPID THEN
   RETURN
  ENDIF
 ENDIF
 GOTO @OTYAX_MAIN
END
'OTYAX UTIL
COMMON DEF NewArray#(LEN)
 DIM ARY#[LEN]
 RETURN ARY#
END
COMMON DEF NewArray%(LEN)
 DIM ARY%[LEN]
 RETURN ARY%
END
COMMON DEF NewArray$(LEN)
 DIM ARY$[LEN]
 RETURN ARY$
END
COMMON DEF NewArray(LEN)
 DIM ARY[LEN]
 RETURN ARY
END
COMMON DEF NewArray2#(LEN,L2)
 DIM ARY#[LEN,L2]
 RETURN ARY#
END
COMMON DEF NewArray2%(LEN,L2)
 DIM ARY%[LEN,L2]
 RETURN ARY%
END
COMMON DEF NewArray2$(LEN,L2)
 DIM ARY$[LEN,L2]
 RETURN ARY$
END
COMMON DEF NewArray2(LEN,L2)
 DIM ARY[LEN,L2]
 RETURN ARY
END

COMMON DEF NewArray3#(LEN,L2,L3)
 DIM ARY#[LEN,L2,L3]
 RETURN ARY#
END
COMMON DEF NewArray3%(LEN,L2,L3)
 DIM ARY%[LEN,L2,L3]
 RETURN ARY%
END
COMMON DEF NewArray3$(LEN,L2,L3)
 DIM ARY$[LEN,L2,L3]
 RETURN ARY$
END
COMMON DEF NewArray3(LEN,L2,L3)
 DIM ARY[LEN,L2,L3]
 RETURN ARY
END

COMMON DEF NewArray4#(LEN,L2,L3,L4)
 DIM ARY#[LEN,L2,L3,L4]
 RETURN ARY#
END
COMMON DEF NewArray4%(LEN,L2,L3,L4)
 DIM ARY%[LEN,L2,L3,L4]
 RETURN ARY%
END
COMMON DEF NewArray4$(LEN,L2,L3,L4)
 DIM ARY$[LEN,L2,L3,L4]
 RETURN ARY$
END
COMMON DEF NewArray4(LEN,L2,L3,L4)
 DIM ARY[LEN,L2,L3,L4]
 RETURN ARY
END
COMMON DEF FindArray(ARY[],V)
 VAR I,L=LEN(ARY)-1
 FOR I=0TO L
  IF ARY[I]==V THEN RETURN I
 NEXT
 RETURN -1
END
COMMON DEF ShortToRGB(IN)
 VAR R=IN>>11AND 31
 VAR G=IN>>6AND 31
 VAR B=IN>>1AND 31
 VAR A=(IN AND 1)*255
 RETURN RGB(A,R<<3,G<<3,B<<3)
END
COMMON DEF RGBToShort(IN)
 VAR A=IN>>24
 VAR R=IN>>16AND 255
 VAR G=IN>>8AND 255
 VAR B=IN AND 255
' RETURN !!A<<15OR R>>3<<10OR G>>3<<5OR B>>3
RETURN R>>3<<11OR G>>3<<6OR B>>3<<1OR !!A'==255
END
COMMON DEF SplitInt IN OUT X,Y
 X=IN AND 65535
 Y=IN>>16
END
COMMON DEF JoinInt(X,Y)
 RETURN (X AND 65535)OR Y<<16
END
COMMON DEF BIN$(IN)
 VAR R$="",S$="01"
 WHILE IN
  R$=S$[IN AND 1]+R$
  IN=IN>>1
 WEND
 RETURN R$
END
COMMON DEF InsertStr$(BASE$,POS,INS$)
' RETURN LEFT$(BASE$,POS)+INS$+RIGHT$(BASE$,LEN(BASE$)-POS)
 RETURN SUBST$(BASE$,POS,0,INS$)
END
COMMON DEF InsertStrB BASE$,POS,INS$
 IF POS==LEN(BASE$)THEN
  PUSH BASE$,INS$
  RETURN
 ENDIF
 BASE$[POS]=INS$+BASE$[POS]
END
COMMON DEF RemoveStr$(THIS$,POS,LEN)
 RETURN SUBST$(THIS$,POS,LEN,"")'LEFT$(THIS$,POS)+RIGHT$(THIS$,LEN(THIS$)-POS-LEN)
END
COMMON DEF RemoveStrB THIS$,POS,LEN
 FOR LEN=LEN TO 1 STEP -1
  THIS$[POS]=""
 NEXT
END
COMMON DEF ReplaceStr$(THIS$,STR$,TO$)
 VAR I,L=LEN(STR$)
 WHILE 1
  I=INSTR(I,THIS$,STR$)
  IF I==-1THEN BREAK
  THIS$=SUBST$(THIS$,I,L,TO$)
  INC I,L
 WEND
 RETURN THIS$
END
COMMON DEF GetFileExtension$(FILE$)
 VAR D=INSTR(FILE$,".")
 IF D==-1THEN RETURN ""
 VAR E
 WHILE 1
  E=INSTR(D+1,FILE$,".")
  IF E==-1THEN
   RETURN RIGHT$(FILE$,LEN(FILE$)-(D+1))
  ENDIF
  D=E
 WEND
END
COMMON DEF ArrayFill ARY[],V,OFF,L
 IF!L THEN RETURN
 VAR E=OFF+L,O2=OFF
 VAR L1=1
 ARY[OFF]=V
 COPY ARY,OFF+L1,ARY,OFF,L1
' ?L1,OFF
 WHILE 1
 VAR _=L1
' ?L1,OFF
 IF OFF+L1+1+_*2>E THEN
' STOP
  COPY ARY,OFF+L1+1,ARY,O2,E-(OFF+L1+1)'E-OFF DIV 2
  RETURN
 ENDIF
 COPY ARY,OFF+L1+1,ARY,O2,_*2'L1
' ?"COPY ARY",OFF+L1+1,"ARY",O2,_*2
 INC OFF,L1
 INC L1,L1
 
 WEND
END
COMMON DEF Split(STR$,SP$)
 DIM R$[0]
 VAR I,J,SPL=LEN(SP$)
 WHILE 1
  J=INSTR(I,STR$,SP$)
  IF J==-1THEN
   IF I==LEN(STR$)-1THEN RETURN R$
   PUSH R$,MID$(STR$,I,LEN(STR$)-I)
   RETURN R$
  ENDIF
  PUSH R$,MID$(STR$,I,J-I)
  I=J+SPL
 WEND
END
'Memory Library
DIM OTX_STR$[0]
DIM OTX_STRNXT[0]
DIM OTX_STRPRV[0]
VAR OTX_STRFR
DEF OTYAXSTRINI
 OTX_STR$=NewArray$(512)
 OTX_STRNXT=NewArray(512)
 OTX_STRPRV=NewArray(512)
 VAR I
 FOR I=1TO 510
  OTX_STRNXT[I]=I+1
 NEXT
 OTX_STRFR=1
END
COMMON DEF AllocString(STR$)
 IF!OTX_STRFR THEN
  PUSH OTX_STR$,STR$
  PUSH OTX_STRNXT,0
  PUSH OTX_STRPRV,0
  RETURN LEN(OTX_STR$)-1
 ENDIF
 VAR I=OTX_STRFR
 OTX_STR$[I]=STR$
 OTX_STRFR=OTX_STRNXT[I]
 RETURN I
END
COMMON DEF SetString PTR,STR$
 OTX_STR$[PTR]=STR$
END
COMMON DEF GetString$(PTR)
 RETURN OTX_STR$[PTR]
END
'COMMON DEF SetStringArray32 PTR,I,V
' RETURN OTX_STR$[PTR]
'END
COMMON DEF FreeString PTR
 OTX_STRNXT[PTR]=OTX_STRFR
 OTX_STRFR=PTR
END
VAR OTX_MEMSIZ
DIM OTX_MEM[0]
DIM OTX_MEM#[0]
DIM OTX_MEM$[0]
VAR OTX_FREESIZ
VAR OTX_FREELEN
DIM OTX_FREE[0]
DIM OTX_FREEADDR[0]
VAR OTX_MEMHEAD
DEF OTYAXMEMINIT
 OTX_MEMSIZ=65536
 OTX_MEM=NewArray(OTX_MEMSIZ)
 OTX_FREESIZ=256
 OTX_FREE=NewArray(OTX_FREESIZ)
 OTX_FREEADDR=NewArray(OTX_FREESIZ)
 OTX_MEMHEAD=&Hdeadbeef
 OTYAXMEMFREEINIT
 RETURN


 
 ?"TEST"
 VAR PTR=malloc(128)
 ?"PTR=malloc(128)";PTR
 VAR PTR2=malloc(128)
 ?"PTR2=malloc(128)";PTR2
 free PTR
 ?"free PTR"
 PTR=malloc(32)
 ?"PTR=malloc(128)";PTR
 VAR PTR3=malloc(32)
 ?"PTR3=malloc(128)";PTR
 VAR PTR4=malloc(128)
 ?"PTR4=malloc(128)";PTR
 OTX_FREEDUMP
END
DEF OTYAXMEMFREEINIT
 OTX_FREELEN=1
 OTX_FREE[0]=OTX_MEMSIZ-1
 OTX_FREEADDR[0]=1
END
DEF OTX_FREEDUMP
 VAR I
 FOR I=0TO OTX_FREELEN-1
  ?OTX_FREEADDR[I];":";OTX_FREE[I]
 NEXT
END
COMMON DEF malloc(SIZE)
 VAR I=OTX_FREELEN/2,A=I
 VAR U=-1
 INC SIZE,3'HEADER SIZE
 WHILE 1
  VAR N=OTX_FREE[I]
  'ちょうどいい
  IF I==SIZE THEN
   U=I
   BREAK
  ENDIF
  IF I<SIZE THEN
   IF!A THEN BREAK
'  IF OTX_FREE[I+A]<=SIZE THEN BREAK
   DEC I,A
   IF I<0THEN I=0
   A=A/2
   CONTINUE
  ENDIF
  IF I>SIZE THEN
   IF!A THEN BREAK
 '  IF OTX_FREE[I-A]<=SIZE THEN BREAK
   INC I,A
   IF I>=OTX_FREELEN THEN I=0
   A=A/2
   CONTINUE
  ENDIF
 WEND
 IF OTX_FREE[I]<SIZE THEN RETURN 0
 VAR ADDR=OTX_FREEADDR[I]
 DEC OTX_FREE[I],SIZE
 IF!OTX_FREE[I]THEN DEC OTX_FREELEN
 INC OTX_FREEADDR[I],SIZE
 RSORT OTX_FREE,OTX_FREEADDR
 OTX_MEM[ADDR]=OTX_MEMHEAD
 OTX_MEM[ADDR+1]=SIZE
 OTX_MEM[ADDR+2]=0'NEXT
 RETURN ADDR+3
END
COMMON DEF free ADDR
 INC OTX_FREELEN
 IF OTX_FREELEN>=OTX_FREESIZ THEN
  PUSH OTX_FREE,0
  PUSH OTX_FREEADDR,0
 ENDIF
 DEC ADDR,3
 IF ADDR<=0||ADDR>=LEN(OTX_MEM)THEN RETURN
 IF OTX_MEM[ADDR]!=OTX_MEMHEAD THEN RETURN
 OTX_FREE[OTX_FREELEN]=OTX_MEM[ADDR+1]
 OTX_FREEADDR[OTX_FREELEN]=ADDR
 RSORT OTX_FREE,OTX_FREEADDR
END
COMMON DEF GetRawMemory()
 RETURN OTX_MEM
END
COMMON DEF ReadArray PTR,ARRAY[],POS,LEN
 IF PTR<0||PTR+LEN>LEN(OTX_MEM)THEN RETURN
 COPY ARRAY,POS,OTX_MEM,PTR,LEN
END
COMMON DEF WriteArray PTR,ARRAY[],POS,LEN
 IF PTR<0||PTR+LEN>LEN(OTX_MEM)THEN RETURN
 COPY OTX_MEM,PTR,ARRAY,POS,LEN
END
COMMON DEF WriteInt PTR,VALUE
 IF PTR<0||PTR>=LEN(OTX_MEM)THEN RETURN
 OTX_MEM[PTR]=VALUE
END
COMMON DEF ReadInt(PTR)
 IF PTR<0||PTR>=LEN(OTX_MEM)THEN RETURN PTR
 RETURN OTX_MEM[PTR]
END
COMMON DEF LoadDATA(NAME$,ARY)
 LOAD "DAT:"+NAME$,ARY,0
END
COMMON DEF LoadFile$(NAME$)
 RETURN LOAD("TXT:"+NAME$,0)
END
COMMON DEF SaveFile$ NAME$,T$
 SAVE "TXT:"+NAME$,T$
END
COMMON DEF GetSBFileName$(F$)
 IF F$[0]==" "THEN RETURN "DAT:"+MID$(F$,1,999)
 IF F$[0]=="*"THEN RETURN "TXT:"+MID$(F$,1,999)
 IF INSTR(F$,"TXT:")==0THEN RETURN F$
 IF INSTR(F$,"DAT:")==0THEN RETURN F$
 RETURN "TXT:"+F$
END
COMMON DEF DeleteFile NAME$
 DELETE GetSBFileName$(NAME$)
END
COMMON DEF RenameFile FROM$,TO$
 RENAME GetSBFileName$(FROM$),GetSBFileName$(TO$)
END
COMMON DEF GetFiles ARY,DIR$
 IF LEN(DIR$)THEN
  FILES DIR$,ARY
 ELSE
  FILES ARY
 ENDIF
END
'OTYAX PROCESS API
COMMON DEF NewProcess NAME$,ARGS$ OUT PRC,E
 VAR PID,NUPID
 IF PRC_FREE==0 THEN @ERROR
 IF !CHKCALL("I_"+NAME$) THEN @ERROR2
 IF !CHKCALL("L_"+NAME$) THEN @ERROR2
 INC PIDCNT
 PID=PIDCNT
 NUPID=PRC_FREE
 PRC_PID[NUPID]=PID
 PRC_FREE=PRC_NEXT[PRC_FREE]
 PRC_NAME$[NUPID]=NAME$
 PRC_ARGS$[NUPID]=NAME$+" "+ARGS$
 PRC_PREV[NUPID]=0
 PRC_CHILD[NUPID]=0
 PRC_PARENT[NUPID]=RUNNUPID
 'VAR 
 VAR C=PRC_CHILD[RunNUPID]
 PRC_CHILD[RunNUPID]=NUPID
 PRC_NEXT[NUPID]=C
 IF C THEN
  PRC_PREV[C]=NUPID
 ENDIF
 PRC_FLG[NUPID]=PRC_FLG_INIT
 IF RUNNUPID THEN
  'TODO:IMPL
  PRC_STDOUT[NUPID]=DupFile(PRC_STDOUT[RUNNUPID])

  PRC_STDIN[NUPID]=DupFile(PRC_STDIN[RUNNUPID])

  PRC_STDERR[NUPID]=DupFile(PRC_STDERR[RUNNUPID])
  
 ELSE
  OutConsoleOpen OUT PRC_STDOUT[NUPID],E
  InConsoleOpen OUT PRC_STDIN[NUPID],E
  PRC_STDERR[NUPID]=PRC_STDOUT[NUPID]
 ENDIF
 E=SUCCESS
 PRC=PID<<PIDSHIFT OR NUPID
 RETURN
 @ERROR
 PRC=0
 E=ERROR_NEW_PROC
 RETURN
 @ERROR2
 PRC=0
 E=ERROR_NO_PROC
END
COMMON DEF SetProcessVar DAT
 PRC_DAT[RUNNUPID]=DAT
END
COMMON DEF GetProcessVar()
 RETURN PRC_DAT[RUNNUPID]
END
COMMON DEF CheckProcess(PRC)
 RETURN PRC_PID[PRC AND NUPIDMASK]==PRC>>PIDSHIFT
END
DEF CheckProcess2(PID,NUPID)
 RETURN PRC_PID[NUPID]==PID
END
COMMON DEF GetProcessArgs$()
 RETURN PRC_ARGS$[RUNNUPID]
END
COMMON DEF GetSTDIN()
 RETURN PRC_STDIN[RUNNUPID]
END
COMMON DEF GetSTDOUT()
 RETURN PRC_STDOUT[RUNNUPID]
END
COMMON DEF GetSTDERR()
 RETURN PRC_STDERR[RUNNUPID]
END
COMMON DEF SetProcessSTDIN PRC,STDIN
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDIN[PRC AND NUPIDMASK]=STDIN
END
COMMON DEF SetProcessSTDOUT PRC,STDOUT
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDOUT[PRC AND NUPIDMASK]=STDOUT
END
COMMON DEF SetProcessSTDERR PRC,STDERR
 IF!CheckProcess(PRC)THEN RETURN
 PRC_STDERR[PRC AND NUPIDMASK]=STDERR
END
COMMON DEF GetProcessSTDIN(PRC)
 IF!CheckProcess(PRC)THEN RETURN 0
 RETURN PRC_STDIN[PRC AND NUPIDMASK]
END
COMMON DEF GetProcessSTDOUT(PRC)
 IF!CheckProcess(PRC)THEN RETURN
 RETURN PRC_STDOUT[PRC AND NUPIDMASK]
END
COMMON DEF GetProcessSTDERR(PRC)
 IF!CheckProcess(PRC)THEN RETURN
 RETURN PRC_STDERR[PRC AND NUPIDMASK]
END
COMMON DEF GetPID()
 RETURN PRC_PID[RUNNUPID]
END
COMMON DEF GetNUPID()
 RETURN RUNNUPID
END
COMMON DEF NUPIDToPID(NUPID)
 RETURN PRC_PID[NUPID]
END
COMMON DEF ExitProcess RESULT
 VAR ERR
 KillProcess RUNPRC OUT ERR
END
COMMON DEF KillProcess PRC OUT ERR
 VAR PID=PRC>>PIDSHIFT,NUPID=PRC AND NUPIDMASK
 IF!NUPID THEN RETURN
 IF !CheckProcess(PRC) THEN
  ERR=ERROR_NO_PROC
  RETURN
 ENDIF
 VAR PNUPID=PRC_PREV[NUPID]
 VAR NNUPID=PRC_NEXT[NUPID]
 IF PNUPID THEN
  PRC_NEXT[PNUPID]=NNUPID
 ENDIF
 IF PNUPID THEN
  PRC_PREV[NNUPID]=PNUPID
 ENDIF
 IF FIRSTNUPID==NUPID THEN
  FIRSTNUPID=PRC_NEXT[NUPID]
  IF!FIRSTNUPID THEN
   FIRSTNUPID=PRC_CHILD[NUPID]
  ENDIF
 ENDIF
 VAR PANUPID=PRC_PARENT[NUPID]
 IF PRC_CHILD[PANUPID]==NUPID THEN
  PRC_CHILD[PRC_PARENT[NUPID]]=NNUPID
 ENDIF
 VAR CNUPID=PRC_CHILD[NUPID]
 PRC_PID[NUPID]=0
 VAR NXT
 ' ころころしていく
 'こはころさない
 VAR WE
 WHILE CNUPID
  NXT=PRC_NEXT[CNUPID]
  PRC_PARENT[CNUPID]=FIRSTNUPID
  IF !NXT THEN WE=CNUPID:BREAK
  CNUPID=NXT
 WEND
 CNUPID=PRC_CHILD[NUPID]
 IF CNUPID THEN
  IF FIRSTNUPID THEN
   NXT=PRC_CHILD[FIRSTNUPID]
   PRC_CHILD[FIRSTNUPID]=CNUPID
   PRC_NEXT[WE]=NXT
  ELSE
   FIRSTNUPID=CNUPID
  ENDIF
 ENDIF
 RUNNUPID=PRC_PARENT[NUPID]
 PRC_NEXT[NUPID]=PRC_FREE
 PRC_FREE=NUPID
 PRC_NAME$[NUPID]=""
 ERR=SUCCESS
 VOID FileClose(PRC_STDOUT[NUPID])
 VOID FileClose(PRC_STDERR[NUPID])
 VOID FileClose(PRC_STDIN[NUPID])
END

'COMMAND
COMMON DEF ExecCommand LINE$ OUT PRC,ERR
 IF INSTR(LINE$,"|")==-1THEN
  ExecCommand_ LINE$ OUT PRC,ERR
  RETURN
 ENDIF
 DIM COMMAND$[0]
 COMMAND$=Split(LINE$,"|")
 VAR I
 VAR FIRST
 VAR OLD
 FOR I=0TO LEN(COMMAND$)-1
  ExecCommand_ COMMAND$[I] OUT PRC,ERR
  IF!I THEN
   FIRST=PRC
  ELSE
   VAR PIPEIN,PIPEOUT
   OpenPipeFile PRC,OLD OUT PIPEIN,PIPEOUT
   SetProcessSTDOUT OLD,PIPEOUT
   SetProcessSTDIN PRC,PIPEIN
  ENDIF
  OLD=PRC
 NEXT
END
DEF ExecCommand_ LINE$ OUT PRC,ERR
 ?"TRACE:ExecCommand ";LINE$
 VAR L=LEN(LINE$)-1
 VAR I,C$=""
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 FOR I=0TO L
  C$=MID$(LINE$,I,1)
  IF C$==" " AND S==RDNAME THEN
   ENDNAME=I
   BREAK
  ELSE
   IF C$!=" " AND S==RDSP THEN START=I:S=RDNAME
  ENDIF
 NEXT
 VAR NAME$="",ARG$=""
 IF !ENDNAME THEN
  IF START THEN
    NAME$=MID$(LINE$,START,L-START+1)
   ELSE
    NAME$=LINE$
   ENDIF
   ARG$=""'NAME$
 ELSE
  NAME$=MID$(LINE$,START,ENDNAME-START)
  VAR ARGSTART=ENDNAME+1,STARTARG=1,ARGEND=999
  FOR I=ENDNAME+1 TO L
   IF STARTARG&&LINE$[I]!=" "THEN
    ARGSTART=I
    STARTARG=0
    CONTINUE
   ENDIF
   IF!STARTARG&&LINE$[I]==" "THEN
    ARGEND=I
   ENDIF
  NEXT
  ARG$=MID$(LINE$,ARGSTART,ARGEND-ARGSTART)'ENDNAME+1,L-ENDNAME)
  'ARG$=MID$(LINE$,START,ENDNAME-START+L-ENDNAME+1)
 ENDIF
 ?"AAAAA";ARG$;"#
 L=LEN(ARG$)-1
 VAR FILE,ARG2$=ARG$,NXT
 VAR INFILE=1,PIPE=2
 VAR HASPIPE=INSTR(ARG$,"|")!=-1
 FOR I=0TO L
  C$=MID$(ARG2$,I,1)
  IF C$=="|"THEN
   VAR SI=ENDNAME+1+I
   IF!ENDNAME THEN SI=I
   VAR PRC2
   ExecCommand LEFT$(LINE$,SI-1) OUT PRC,ERR
   VAR PIPEFILE=OpenPipeFile()
   SetProcessSTDOUT PRC,PIPEFILE
   ExecCommand MID$(LINE$,SI+1,LEN(LINE$)-SI-1) OUT PRC2,ERR
   ?LEFT$(LINE$,SI-1);",";MID$(LINE$,SI+1,LEN(LINE$)-SI-1);",";PIPEFILE
   SetProcessSTDIN PRC2,PIPEFILE
   SWAP PRC,PRC2
   RETURN
  ENDIF
  IF HASPIPE THEN CONTINUE
  IF C$=="<" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
   DIALOG C$
   FileOpen C$ OUT FILE,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PRC,ERR
   IF ERR THEN RETURN
   SetProcessSTDIN PRC,FILE
   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
  IF C$==">" THEN
   'REDIR!!
   IF I==0 THEN ARG$="" ELSE ARG$=MID$(ARG$,0,I-1)
   GetCommandArg ARG2$,I+1 OUT C$,I
'   DIALOG C$
   FileOpen C$ OUT FILE,ERR
   NXT=INFILE
   NewProcess NAME$,ARG$ OUT PRC,ERR
   IF ERR THEN RETURN
   SetProcessSTDOUT PRC,FILE
'   BACKTRACE
   'IF I==-1 THEN
   RETURN
  ENDIF
 NEXT
' ?ARG$;"RUN:";NAME$
 NewProcess NAME$,ARG$ OUT PRC,ERR
END
COMMON DEF GetCommandArgsWithoutName$(ARGS$)
 VAR CMD$,I
 GetCommandArg ARGS$,I OUT CMD$,I
 ARGS$=MID$(ARGS$,I,LEN(ARGS$)-I)
 VAR SP=INSTR(ARGS$," ")
 IF SP==-1THEN RETURN ARGS$
 FOR I=0 TO LEN(ARGS$)-1
  VAR C$=ARGS$[I]
  IF C$!=" "THEN BREAK
 NEXT
 ARGS$=MID$(ARGS$,I,LEN(ARGS$)-I)
 RETURN ARGS$
END
COMMON DEF GetCommandArg ARGS$,I OUT CMD$,INDEX
 IF I==-1 THEN CMD$="":INDEX=-1:RETURN
 VAR L=LEN(ARGS$)-1
 VAR RDNAME=1
 VAR RDSP=2
 VAR S=RDSP
 VAR ENDNAME=0
 VAR START=0
 VAR C$=""
 CMD$=""INDEX=-1
 FOR I=I TO L
  C$=MID$(ARGS$,I,1)
  IF S==RDSP AND C$!=" " THEN
   START=I
   S=RDNAME
  ELSE
   IF S==RDNAME AND C$==" " THEN
    INDEX=I
    CMD$=MID$(ARGS$,START,I-START)
    RETURN
   ENDIF
  ENDIF
 NEXT
 IF S==RDNAME THEN
  CMD$=MID$(ARGS$,START,L-START+1)
  INDEX=L+1
 ENDIF
END
COMMON DEF CommandArgsToArray ARY$[],EXPAND OUT LEN
 VAR ARGS$=GetCommandArgs$()
 VAR C$=""
 LEN=0
 VAR I
 WHILE 1
  GetCommandArg I OUT C$,I
  IF I==-1 THEN BREAK
  'FLGがTRUEなら はいれつを かくちょう
  IF EXPAND THEN IF LEN>LEN(ARY$) THEN
   PUSH ARY$,""
  ELSE
   BREAK
  ENDIF
  ARY$[LEN]=C$
  INC LEN
 WEND
END

DEF OpenPipeFile INPRC,OUTPRC OUT INFILE,OUTFILE
 INFILE=AllocPipeFile(FALSE)
 OUTFILE=AllocPipeFile(TRUE)
 VAR PTR1=malloc(4)
 VAR PTR2=malloc(4)
 SetFileData OUTFILE,PTR1
 SetFileData INFILE,PTR2
 WriteInt PTR1+0,INPRC
 WriteInt PTR1+1,OUTPRC
 WriteInt PTR1+2,OUTFILE
 WriteInt PTR1+3,INFILE
 
 WriteInt PTR2+0,INPRC
 WriteInt PTR2+1,OUTPRC
 WriteInt PTR2+2,OUTFILE
 WriteInt PTR2+3,INFILE
END
DEF AllocPipeFile(WR)
 VAR E,FILE
 AllocFile OUT FILE,E
 IF E THEN RETURN 0
 IF WR THEN
  E=SetWriter(FILE,"PIPWRITER")
 ELSE
  E=SetReader(FILE,"PIPREADER")
  E=SetReadln(FILE,"TXTREADLN")
 ENDIF
 E=SetClose(FILE,"PIPCLOSE")
 ' E=SetFlush(FILE,"TXTFLUSH")
 RETURN FILE
END
DEF PipClose FILE
 VAR PTR
 GetFileData FILE OUT PTR
 free PTR
END
DEF PipReadln FILE OUT DAT$,ERR
 
END
DEF PipWriter(FILE,DAT$)
 VAR PTR
 GetFileData FILE OUT PTR
 FILE=ReadInt(PTR+3)
 SetFileDataStr FILE,GetFileDataStr$(FILE)+DAT$
 RETURN SUCCESS
END
DEF PipReader FILE,LEN OUT DAT$,ERR
 TxtReader FILE,LEN OUT DAT$,ERR
 SetFileEOF FILE,FALSE
 IF!LEN||LEN(DAT$)THEN
  RETURN SUCCESS
 ENDIF
 'EOF
 'TORIMA
 VAR PTR
 GetFileData FILE OUT PTR
 VAR OUTFILE=ReadInt(PTR+3)
 VAR INPRC=ReadInt(PTR+1)
 IF!CheckProcess(INPRC)||!CheckFile(OUTFILE)||IsFileEOF(OUTFILE)THEN
  SetFileEOF FILE,TRUE
 ELSE
  SetFileEOF FILE,FALSE
 ENDIF
END
'OTYAX FILE API
'TXT:FILE を OPEN
COMMON DEF FileOpen NAME$ OUT FILE,E
' IF!CHKFILE("TXT:"+NAME$) THEN E=ERROR_NOFILE:FID=0NUFID=0RETURN
 AllocFile OUT FILE,E
 IF E THEN RETURN
 VAR F$=""
 IF CHKFILE("TXT:"+NAME$) THEN
  F$=LOAD("TXT:"+NAME$,0)
 ENDIF
 SetFileDataStr FILE,F$
 SetFileNAME FILE,NAME$
 E=SetWriter(FILE,"TXTWRITER")
 E=SetReader(FILE,"TXTREADER")
 E=SetReadln(FILE,"TXTREADLN")
 E=SetClose(FILE,"TXTCLOSE")
' E=SetFlush(FID,NUFID,"TXTFLUSH")
 RETURN
END
DEF TxtClose FILE
 SAVE "TXT:"+GetFileName$(FILE,GetFileDataStr$(FILE))
END
DEF TxtReadLn FILE OUT DAT$,ERR
 ERR=SUCCESS
 VAR POS
 GetFilePos FILE OUT POS,ERR
 VAR STR$=GetFileDataStr$(FILE)
 IF LEN(STR$)<=POS THEN
  DAT$=""
  ERR=ERROR_NOFILECONTENT
  RETURN
 ENDIF
 VAR LEN=INSTR(POS,STR$,LF$())
 IF LEN==-1THEN
  LEN=LEN(STR$)-POS
 ELSE
  LEN=LEN-POS
 ENDIF
 TxtReader FILE,LEN OUT DAT$,ERR
END
DEF TxtReader FILE,LEN OUT DAT$,ERR
 ERR=SUCCESS
 VAR POS
 GetFilePos FILE OUT POS,ERR
 VAR STR$=GetFileDataStr$(FILE)
 DAT$=MID$(STR$,POS,MIN(LEN,MAX(0,LEN(STR$)-POS)))
 IF!LEN(DAT$)THEN
  SetFileEOF FILE,TRUE
 ELSE
  FileSeekCUR FILE,LEN(DAT$) OUT ERR
 ENDIF
END
DEF TxtWriter(FILE,DAT$)
 SetFileDataStr FILE,GetFileDataStr$(File)+DAT$
 RETURN SUCCESS
END
COMMON DEF FileWrite(FILE,DAT$)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF FILES_FID[NUFID]!=FID THEN
  ?"NOPEN";DAT$
  RETURN ERROR_NOPENFILE
 ENDIF
 VAR E=CALL(FILES_WRITER$[NUFID],FILE,DAT$)
 RETURN SUCCESS
END
COMMON DEF FileRead FILE,LEN OUT DAT$,E
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFile(FILE) THEN
  DAT$=""
  E=ERROR_NOPENFILE
  RETURN
 ENDIF
 IF !LEN THEN RETURN
 CALL FILES_READER$[NUFID],FILE,LEN OUT DAT$,E
 E=SUCCESS
END
COMMON DEF FileClose(FILE)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN
  RETURN ERROR_NOPENFILE
 ENDIF
 IF LEN(FILES_CLOSE$[NUFID]) THEN
  CALL FILES_CLOSE$[NUFID],FILE
 ENDIF
 FILES_NEXT[NUFID]=FILES_FREE
 FILES_FREE=NUFID
 RETURN SUCCESS
END
COMMON DEF IsFileEOF(FILE)
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF!CheckFID(FID,NUFID) THEN RETURN ERROR_NOPENFILE
 RETURN FILES_ISEOF[NUFID]
END
COMMON DEF DupFile(FILE)
 VAR N2=FILE AND NUFIDMASK
 VAR NUFID,E
 AllocFile OUT FILE,E
 IF E THEN RETURN FILE
 FILES_ISEOF[NUFID]=FILES_ISEOF[N2]
 NUFID=FILE AND NUFIDMASK
 FILES_PID[NUFID]=FILES_PID[N2]
 FILES_NAME$[NUFID]=FILES_NAME$[N2]
 FILES_DAT[NUFID]=FILES_DAT[N2]
 FILES_DATSTR$[NUFID]=FILES_DATSTR$[N2]+""
 FILES_WRITER$[NUFID]=FILES_WRITER$[N2]
 FILES_READER$[NUFID]=FILES_READER$[N2]
 FILES_READLN$[NUFID]=FILES_READLN$[N2]
 FILES_CLOSE$[NUFID]=FILES_CLOSE$[N2]
 FILES_POS[NUFID]=FILES_POS[N2]
 FILES_ISEOF[NUFID]=FILES_ISEOF[N2]
 RETURN NUFIDTOFILE(NUFID)
END
DEF AllocFile OUT FILE,E
 IF FILES_FREE==0 THEN
  FILE=0
  E=ERROR_NOALLOCFILE
  RETURN
 ENDIF
 INC FILES_FIDCNT
 VAR NUFID=FILES_FREE
 FILES_FID[NUFID]=FILES_FIDCNT
 FILES_ISEOF[NUFID]=0
 VAR FID=FILES_FIDCNT
 FILES_FREE=FILES_NEXT[FILES_FREE]
 E=SUCCESS
 FILE=NUFID OR FID<<FIDSHIFT
END
COMMON DEF NUFIDToFID(NUFID)
 RETURN FILES_FID[NUFID]
END
COMMON DEF NUFIDToFile(NUFID)
 RETURN NUFID OR FILES_FID[NUFID]<<FIDSHIFT
END
'FIDがせいじょうならTRUE
COMMON DEF CheckFID(FID,NUFID)
 RETURN FILES_FID[NUFID]==FID
END
COMMON DEF CheckFile(FILE)
 RETURN FILES_FID[FILE AND NUFIDMASK]==FILE>>FIDSHIFT
END
DEF SetWriter(FILE,FUNC$)
 IF!CheckFILE(FILE) THEN RETURN ERROR_NOFILE
 FILES_WRITER$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF SetFileData FILE,DAT
 IF!CheckFILE(FILE) THEN RETURN
 FILES_DAT[FILE AND NUFIDMASK]=DAT
END
DEF GetFileData(FILE)
 IF!CheckFILE(FILE) THEN RETURN -1
 RETURN FILES_DAT[FILE AND NUFIDMASK]
END
DEF SetFIDDataStr FID,NUFID,DAT$
 IF!CheckFID(FID,NUFID) THEN RETURN
 FILES_DATSTR$[NUFID]=DAT$
END
DEF GetFIDDataStr$(FID,NUFID)
 IF !CheckFID(FID,NUFID) THEN RETURN ""
 RETURN FILES_DATSTR$[NUFID]
END
DEF SetFileDataStr FILE,DAT$
 IF!CheckFile(FILE) THEN RETURN
 FILES_DATSTR$[FILE AND NUFIDMASK]=DAT$
END
DEF GetFileDataStr$(FILE)
 IF !CheckFile(FILE) THEN RETURN ""
 RETURN FILES_DATSTR$[FILE AND NUFIDMASK]
END
DEF SetFileName FILE,DAT$
 IF!CheckFile(FILE) THEN RETURN
 FILES_NAME$[FILE AND NUFIDMASK]=DAT$
END
DEF GetFileName$(FILE)
 IF !CheckFile(FILE) THEN RETURN ""
 RETURN FILES_NAME$[FILE AND NUFIDMASK]
END
DEF SetFileEOF FILE,EOF
 IF!CheckFile(FILE) THEN RETURN
 FILES_ISEOF[FILE AND NUFIDMASK]=EOF
END
DEF SetReader(FILE,FUNC$)
 IF !CheckFile(FILE) THEN RETURN ERROR_NOFILE
 FILES_READER$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF SetReadln(FILE,FUNC$)
 IF !CheckFile(FILE) THEN RETURN ERROR_NOFILE
 FILES_READLN$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF SetClose(FILE,FUNC$)
 IF !CheckFile(FILE) THEN RETURN ERROR_NOFILE
 FILES_CLOSE$[FILE AND NUFIDMASK]=FUNC$
 RETURN SUCCESS
END
DEF OutConsoleOpen OUT FILE,E
 AllocFile OUT FILE,E
 E=SETWRITER(FILE,"CONSOLEWRITERSTR")
END
DEF InConsoleOpen OUT FILE,E
 AllocFile OUT FILE,E
 E=SETREADER(FILE,"CONSOLEREADERSTR")
END
COMMON DEF FileSeekCUR FILE,LEN OUT ERR
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF !CheckFID(FID,NUFID) THEN ERR=ERROR_NOFILE:RETURN
 FILES_POS[NUFID]=MAX(FILES_POS[NUFID]+LEN,0)
 ERR=SUCCESS
END
COMMON DEF GetFilePos FILE OUT POS,ERR
 VAR FID=FILE>>FIDSHIFT,NUFID=FILE AND NUFIDMASK
 IF !CheckFID(FID,NUFID) THEN POS=0:ERR=ERROR_NOFILE:RETURN
 POS=FILES_POS[NUFID]
 ERR=ERROR_NOFILE
END
DEF ConsoleWriterStr(FILE,DAT$)
 'VAR 
 VAR L=LEN(DAT$)-1
 VAR I
 '?DAT$;
 FOR I=0 TO L
  VAR D$=MID$(DAT$,I,1)
  IF D$==HTAB$ THEN
   PRINT "",
  ELSE
   PRINT D$;
  ENDIF
 NEXT
 RETURN SUCCESS
END
DEF ConsoleReaderStr FILE,LEN OUT DAT$,E
 DAT$=INKEY$()
 IF DAT$==CR$THEN DAT$=LF$
 E=SUCCESS
 IF!LEN(DAT$) THEN
  RETURN
 ENDIF
 VAR K$,I
 FOR I=0TO LEN-2
  K$=INKEY$()
  IF !LEN(K$)THEN RETURN
  IF K$==CR$THEN K$=LF$
  DAT$=DAT$+K$
 NEXT
END
COMMON DEF PRINTCONSOLE STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],STR$)
END
COMMON DEF PRINTCONSOLELN STR$
 VAR E=FileWrite(PRC_STDOUT[RUNNUPID],STR$+LF$)
END
COMMON DEF INKEYCONSOLE$(LEN)
 VAR STR$="",E
 FileRead PRC_STDIN[RUNNUPID],LEN OUT STR$,E
 RETURN STR$
END
COMMON DEF LOCATECONSOLE X,Y
 LOCATE X,Y
END
COMMON DEF FORECOLORCONSOLE C
 COLOR C
END
COMMON DEF BACKCOLORCONSOLE C
 COLOR ,C
END
'OTYAX APPS
DIM SH_INPUT$[12]
DIM SH_PRC[12]
VAR SH_CNT=0
DEF I_SH
 PrintConsole "OTYAX SH"+LF$
 PrintConsole VER$

 IF SH_CNT==0 THEN
  SH_INPUT$=NewArray$(12)
  SH_PRC=NewArray(12)
 ENDIF
 INC SH_CNT
 SetProcessVar(SH_CNT)
 PrintConsole ">"
 VAR _
END
DEF L_SH
 VAR DAT=GetProcessVar()
 IF SH_PRC[DAT] THEN
  IF BUTTON()==KILLPRCBTN THEN
   VOID KillProcess(SH_PRC[DAT])
  ENDIF
  IF!CheckProcess(SH_PRC[DAT]) THEN
'?"EXIT:";SH_PID[DAT],SH_NUPID[DAT]
  'コマンドが0XDEAD
   @INIT
   SH_INPUT$[DAT]=""
   SH_PRC[DAT]=0
   PrintConsole STR$(DAT)+">"
'   PrintConsole ">"
  ELSE
   RETURN
  ENDIF
  RETURN
 ENDIF
 VAR KEY$=INKEYCONSOLE$(1)
 IF KEY$=="" THEN RETURN
 PrintConsole KEY$
 IF KEY$==LF$ THEN @EXEC_COMMAND
 IF KEY$==CR$ THEN @EXEC_COMMAND
 SH_INPUT$[DAT]=SH_INPUT$[DAT]+KEY$
 RETURN
 
 @EXEC_COMMAND
 VAR ERR
 VAR NAME$,I,ARGS$
 GetCommandArg SH_INPUT$[DAT],0 OUT NAME$,I
 IF NAME$=="EXIT"THEN
  ExitProcess SUCCESS
  SH_INPUT$[DAT]=""
  RETURN
 ENDIF
 IF NAME$=="BACK"THEN
  SH_BACK SH_INPUT$[DAT]
  SH_INPUT$[DAT]=""
  PrintConsole ">"
  RETURN
 ENDIF
 ExecCommand SH_INPUT$[DAT] OUT SH_PRC[DAT],ERR
 IF ERR==ERROR_NO_PROC THEN
  PrintConsole NAME$+"がみつかりません"+LF$()
  GOTO @INIT
 ENDIF
' ?"RUN:";RUNNUPID
END
RETURN

DEF SH_BACK A$
 VAR NAME$,I,ARGS$,PRC,ERR
 GetCommandArg A$,I OUT NAME$,I
 GetCommandArg A$,I OUT NAME$,I
 IF I==-1THEN
  PrintConsole "USAGE:BACK ARGS..."+LF$
  RETURN
 ENDIF
' GetCommandArg A$,I OUT ARGS$,I
 ARGS$=MID$(A$,I,LEN(A$)-1)
 NewProcess NAME$,ARGS$ OUT PRC,ERR
END
'I_AM_CAT
DEF I_CAT
 VAR FILE,ERR,CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN ExitProcess I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN
  FILE=GetSTDIN()
 ELSE
  FileOpen CMD$ OUT FILE,ERR
 ENDIF
 IF ERR THEN
  ExitProcess 1
  RETURN
 ENDIF
 SetProcessVar FILE
END
DEF L_CAT
 VAR FILE=GetProcessVar()
 IF !FILE THEN
  ExitProcess SUCCESS
  RETURN
 ENDIF
 VAR DAT$,ERR
 FileRead FILE,2048 OUT DAT$,ERR
 IF ERR THEN
  IF FILE!=GetSTDIN()THEN
   ERR=FileClose(FILE)
  ENDIF
  ExitProcess SUCCESS
  RETURN
 ENDIF
 IF LEN(DAT$)==0THEN
  IF IsFileEOF(FILE)THEN
   IF FILE!=GetSTDIN()THEN
    ERR=FileClose(FILE)
   ENDIF
   ExitProcess SUCCESS
   RETURN
  ENDIF
 ENDIF
' IF LEN(DAT$)==0THEN
'  ERR=FileClose(FILE)
'  ExitProcess SUCCESS
'  RETURN
' ENDIF
 PrintConsole DAT$
END
DEF I_PTREE
END
DEF L_PTREE
 DUMP_PS
 ExitProcess 0
END

DEF DUMP_PS
 DUMP_PS2 FIRSTNUPID,""
END
DEF DUMP_PS2 NUP,I$
 IF!NUP THEN RETURN
 IF PRC_PARENT[NUP]THEN IF PRC_NEXT[NUP] THEN ?I$+""; ELSE ?I$+"";
' ?I$;PRC_NAME$[NUP],NUP,"PID",PRC_PID[NUP]
 ?PRC_NAME$[NUP],NUP,"PID",PRC_PID[NUP]
' IF CSRY==29 THEN VAR II$INPUT "";II$
 IF LEN(I$) THEN
  VAR NM$=""
  IF PRC_NEXT[NUP] THEN
   NM$=""
  ELSE
   NM$=""
  ENDIF
  NM$=" "
  IF PRC_NEXT[PRC_PARENT[NUP]]THEN
   NM$=""+NM$
  ELSE
   IF PRC_NEXT[NUP] THEN
    NM$=" "
   ELSE
    NM$=" "+NM$
   ENDIF
  ENDIF
  DUMP_PS2 PRC_CHILD[NUP],MID$(I$,0,LEN(I$)-1)+NM$
 ELSE
  IF PRC_CHILD[NUP]&&PRC_NEXT[PRC_CHILD[NUP]]THEN
   DUMP_PS2 PRC_CHILD[NUP]," "'"
  ELSE
   DUMP_PS2 PRC_CHILD[NUP]," "'"
  ENDIF
 ENDIF
 DUMP_PS2 PRC_NEXT[NUP],I$
END
DEF I_PS
 PrintConsole FORMAT$("%SPID%SNUPID%SCOMMAND%S%S",HTAB$,HTAB$,HTAB$,HTAB$,LF$)
END
DEF L_PS
 ExitProcess SUCCESS
END
DEF I_BEEP
END
DEF L_BEEP
 IF !RND(1024) THEN BEEP RND(3)+88
END

VAR DIFF_LOCK
VAR DIFF_PHASE
DIM DIFF_A$[0]
DIM DIFF_B$[0]
DIM DIFF_V[0]
DIM DIFF_TREE[0]
DIM DIFF_SES[0]
VAR DIFF_OI
VAR DIFF_NI
DEF I_DIFF
 IF DIFF_LOCK THEN RETURN
 VAR CMD$,A$,B$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT A$,I
 IF I==-1THEN @USAGE
 GetCommandArg GetProcessArgs$(),I OUT B$,I
 IF I==-1THEN @USAGE
 VAR F$=LoadFile$(A$)
 DIFF_A$=SPLIT(F$,LF$())
 F$=LoadFile$(B$)
 DIFF_B$=SPLIT(F$,LF$())
 DIFF_PHASE=0
 RETURN
 @USAGE
 PrintConsoleln "USAGE: DIFF ORIGIN NEW"
 ExitProcess -1
END
VAR DIFF_D,DIFF_K,DIFF_TAIL
VAR DIFF_I
DEF L_DIFF
 IF!DIFF_LOCK THEN DIFF_LOCK=GetPID()
 IF DIFF_LOCK!=GetPID()THEN RETURN
 VAR OL=LEN(DIFF_A$),NL=LEN(DIFF_B$)
 VAR DELETE=0
 VAR COMMON_=1
 VAR ADD=2
 VAR D=DIFF_D,K=DIFF_K
 VAR OFFSET=OL
 WHILE 1
  ON DIFF_PHASE GOTO @INIT,@DIFF,@SES,@DUMP,@END
  BREAK
  @INIT
   DIFF_V=NewArray((OL+NL+1)*2)
   VAR VI
   FOR VI=1TO LEN(DIFF_V)-1 STEP 2
    DIFF_V[VI]=-1
   NEXT
   DIFF_TREE=NewArray(0)
   DIFF_PHASE=1
   DIFF_D=0
   DIFF_K=0
   DIFF_TAIL=-1
  BREAK
  @DIFF
' FOR D=0TO OL+NL
   FOR K=-D TO D STEP 2
    IF K<-OL||NL<K THEN CONTINUE
     VAR V_K=(K+OFFSET)*2
     VAR V_KP1=(V_K+2)
     VAR V_KM1=(V_K-2)
     IF D THEN
      IF K==-D||K==-OL||(K!=D&&K!=NL&&DIFF_V[V_KM1]+1<DIFF_V[V_KP1])THEN
       DIFF_V[V_K]=DIFF_V[V_KP1]
       DIFF_V[V_K+1]=LEN(DIFF_TREE)
       PUSH DIFF_TREE,DELETE
       PUSH DIFF_TREE,DIFF_V[V_KP1+1]
      ELSE
       DIFF_V[V_K]=DIFF_V[V_KM1]+1
       DIFF_V[V_K+1]=LEN(DIFF_TREE)
       PUSH DIFF_TREE,ADD
       PUSH DIFF_TREE,DIFF_V[V_KM1+1]
      ENDIF
     ENDIF
     VAR V_K_Y=DIFF_V[V_K]
     WHILE V_K_Y-K<OL&&V_K_Y<NL&&DIFF_A$[V_K_Y-K]==DIFF_B$[V_K_Y]
      VAR OT=DIFF_V[V_K+1]
      DIFF_V[V_K+1]=LEN(DIFF_TREE)
      PUSH DIFF_TREE,COMMON_
      PUSH DIFF_TREE,OT
      INC V_K_Y
      INC DIFF_V[V_K]
     WEND
     IF V_K_Y-K>=OL&&V_K_Y>=NL THEN
      DIFF_TAIL=DIFF_V[V_K+1]
      GOTO @EXIT
     ENDIF
   NEXT
  IF DIFF_D>=OL+NL THEN @EXIT
  INC DIFF_D
  BREAK
' NEXT
  @EXIT
  DIFF_PHASE=2
  BREAK
  @SES
  DIFF_SES=NewArray(0)
  VAR I=DIFF_TAIL
  WHILE I!=-1
   PUSH DIFF_SES,DIFF_TREE[I]
   I=DIFF_TREE[I+1]
  WEND
  DIFF_PHASE=3
  DIFF_I=LEN(DIFF_SES)-1
  DIFF_OI=0
  DIFF_NI=0
  BREAK
  @DUMP
  VAR MX=MAX(0,DIFF_I-128)
  FOR I=DIFF_I TO MX STEP -1
   WHILE 1
   ON DIFF_SES[I] GOTO @DEL,@COM,@ADD
    PrintConsole "?"
    BREAK
    @DEL
     PrintConsole "-"
     IF LEN(DIFF_A$)>DIFF_OI THEN
      PrintConsoleln DIFF_A$[DIFF_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_OI
    BREAK
    @COM
     PrintConsole " "
     IF LEN(DIFF_A$)>DIFF_OI THEN
      PrintConsoleln DIFF_A$[DIFF_OI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_OI
     INC DIFF_NI
    BREAK
    @ADD
     PrintConsole "+"
     IF LEN(DIFF_B$)>DIFF_NI THEN
      PrintConsoleln DIFF_B$[DIFF_NI]
     ELSE
      PrintConsoleln ""
     ENDIF
     INC DIFF_NI
    BREAK
    WEND
   NEXT
   DIFF_I=I
   IF DIFF_I==-1 THEN DIFF_PHASE=4
  BREAK
  @END
  ExitProcess 0
  BREAK
 WEND
END

COMMON DEF I_FREEMEM
END
COMMON DEF L_FREEMEM
 VAR OX=CSRX,OY=CSRY
 LOCATE 49-LEN(STR$(FREEMEM)),0
 COLOR 0,15
 ?FREEMEM
 COLOR 15,0
 LOCATE OX,OY
END

COmMON DEF EXITMORE
 VAR PTR=GetProcessVar()
 VAR CONIN=ReadInt(PTR+1)
 VOID FileClose(CONIN)
 FREE PTR
 ExitProcess 0
END
COMMON DEF I_MORE
 VAR CONIN,E
 InConsoleOpen OUT CONIN,E
 VAR PTR=malloc(3)
 WriteInt PTR,0
 WriteInt PTR+1,CONIN
 SetProcessVar PTR
 VAR I,RT
 FOR I=0TO 28
  RT=DOMORE()
  IF RT==1THEN EXITMORE:RETURN
  IF RT==2 THEN WriteInt PTR,1:BREAK
 NEXT
 WriteInt PTR+3,I
END
COMMON DEF L_MORE
 VAR PTR=GetProcessVar()
 VAR STATE=ReadInt(PTR)
 VAR CONIN=ReadInt(PTR+1)
 VAR COUNT=ReadInt(PTR+3)
 VAR KEY$,ERR
 FileRead CONIN,1 OUT KEY$,ERR
 IF INSTR(KEY$,LF$())!=-1||STATE THEN
  VAR RT=DOMORE()
  IF RT==1THEN EXITMORE:RETURN
  IF RT==2THEN
   WriteInt PTR,1
  ELSE
   IF COUNT+1<=28THEN
    WriteInt PTR+3,COUNT+1
    WriteInt PTR,1
   ELSE
    WriteInt PTR,0
   ENDIF
  ENDIF
 ENDIF
END
COMMON DEF DOMORE()
 VAR FILE=GetSTDIN()
 IF !FILE THEN ExitProcess SUCCESS:RETURN 1
 VAR DAT$,ERR
 VAR LINEW=50
 FileRead FILE,LINEW OUT DAT$,ERR
 IF LEN(DAT$)==0THEN
  IF IsFileEOF(FILE)THEN
   RETURN 1
  ELSE
   RETURN 2
  ENDIF
 ENDIF
' IF LEN(DAT$)==0THEN
'  ERR=FileClose(FILE)
'  ExitProcess SUCCESS
'  RETURN 1
' ENDIF
 VAR LFPOS=INSTR(DAT$,LF$)
 IF LFPOS==0THEN
  VOID FileSeekCUR(FILE,-48)
  PrintConsoleln ""
  RETURN 0
 ENDIF
 LINEW=LEN(DAT$)
 VAR LEN=LINEW
 IF LFPOS!=-1THEN LEN=MIN(LFPOS+1,LINEW)
 IF LEN-LINEW THEN
  VOID FileSeekCUR(FILE,LEN-LINEW)
 ENDIF
 PrintConsole LEFT$(DAT$,LEN)
 IF LFPOS==-1&&LEN(DAT$)==LINEW THEN PrintConsoleln ""
 IF LFPOS==-1&&LEN<LINEW THEN RETURN 2
 RETURN 0
END
COMMON DEF I_ECHO
END
COMMON DEF L_ECHO
 VAR FILE,ERR,CMD$,I
 PrintConsoleln GetCommandArgsWithoutName$(GetProcessArgs$())
 ExitProcess 0
END
COMMON DEF I_LS
END
COMMON DEF L_LS
 VAR CMD$,DIR$,I
 GetCommandArg GetProcessArgs$(),I OUT CMD$,I
 GetCommandArg GetProcessArgs$(),I OUT DIR$,I
 
 DIM ARY$[0]
 GetFiles ARY$,DIR$
 FOR I=0TO LEN(ARY$)-1
  PrintConsoleln ARY$[I]
 NEXT
 ExitProcess 0
END
COMMON DEF I_FIND
 SetProcessVar AllocString("")
END
COMMON DEF L_FIND
 IF!CheckFile(GetSTDIN())||IsFileEOF(GetSTDIN())THEN
  ExitProcess 0
  RETURN
 ENDIF
 VAR C$=INKEYCONSOLE$(1)
 VAR PTR=GetProcessVar()
 IF LEN(C$)THEN
  IF C$==LF$()THEN
   VAR CMD$=GetCommandArgsWithoutName$(GetProcessArgs$())
   VAR LINE$=GetString$(PTR)
   IF INSTR(LINE$,CMD$)!=-1THEN
    PrintConsoleln LINE$
   ENDIF
   SetString PTR,""
  ELSE
   SetString PTR,GetString$(PTR)+C$
  ENDIF
 ENDIF
END

'OTYFS LIBRARY
VAR OFS_MAGIC_OTYF
VAR OFS_MAGIC_SDIR
VAR OFS_MAGIC_SFIL
VAR OFS_MAGIC_SDEV
DEF OFS_STRTOBIN(S$)
 RETURN ASC(S$[0])<<24OR ASC(S$[1])<<16OR ASC(S$[2])<<8OR ASC(S$[3])
END
VAR OFS_ROOT$
VAR OFS_ROOTFOBJID
VAR OFS_CURPRJFOBJID
VAR OFS_PRJLSTFOBJID
VAR OFS_PERM_READ
VAR OFS_PERM_WRITE
VAR OFS_PERM_RW
VAR OFS_RAND_Y
VAR OFS_ERROR_PERM
VAR OFS_ERROR_ALREADY
VAR OFS_DIR_RESERVE_DEF
DEF OTYFS_INIT
 OFS_DIR_RESERVE_DEF=16
 OFS_ERROR_PERM=2
 OFS_ERROR_ALREADY=3
 OFS_MAGIC_OTYF=OFS_STRTOBIN("OTYF")
 OFS_MAGIC_SDIR=OFS_STRTOBIN("SDIR")
 OFS_MAGIC_SFIL=OFS_STRTOBIN("SFIL")
 OFS_MAGIC_SDEV=OFS_STRTOBIN("SDEV")
 OFS_ROOT$="DAT:@00000001.FS"
 OFS_ROOTFOBJID=1
 OFS_CURPRJFOBJID=2
 OFS_PRJLSTFOBJID=3
 OFS_PERM_READ=1
 OFS_PERM_WRITE=2
 OFS_PERM_RW=3

 RANDOMIZE 0
 OFS_RAND_Y=RND(&H7FFFFFFF)
 IF!CHKFILE(OFS_ROOT$)THEN
  'ROOT FILE
  VAR RW=OFS_PERM_READ OR OFS_PERM_WRITE
  IF OFS_NEWDIR("/",OFS_ROOTFOBJID,RW)THEN
   ?"FAILURE:INIT OTYFS"
   RETURN
  ENDIF
  'DEVICE
  VAR CURPROJ=OFS_NEWDEVICEFILE("PROJECT","",RW)
  VAR PROJS=OFS_NEWDEVICEFILE("PROJECTS","",RW)
  IF OFS_ADDOBJ(OFS_ROOTFOBJID,CURPROJ,"home")||OFS_ADDOBJ(OFS_ROOTFOBJID,PROJS,"projects")THEN
   ?"FAILURE:INIT OTYFS"
   RETURN
  ENDIF
 ENDIF
 DIM ARY$[0],I,ERR
 OFS_FILES "/" OUT ARY$,ERR
 IF ERR THEN ?ERR:RETURN
 ?"LIST OF /
 FOR I=0TO LEN(ARY$)-1
  ?ARY$[I]
 NEXT
 ARY$=NewArray$(0)
 OFS_FILES "/home" OUT ARY$,ERR
 IF ERR THEN ?ERR:RETURN
 ?"LIST OF /home
 FOR I=0TO LEN(ARY$)-1
  ?ARY$[I]
 NEXT
END
DEF OFS_GETFOBJ PATH$ OUT FOBJID,ERR
 OFS_GETFOBJ2 0,PATH$ OUT FOBJID,ERR
END
DEF OFS_GETFOBJ2 INOBJID,PATH$ OUT FOBJID,ERR
 VAR I=0
 ERR=0
 IF!LEN(PATH$)THEN
  'TODO:CURRENT DIR
  FOBJID=OFS_ROOTFOBJID
  RETURN
 ENDIF
 IF PATH$[0]=="/"THEN
  FOBJID=OFS_ROOTFOBJID
  PATH$=RIGHT$(PATH$,LEN(PATH$)-1)
  IF LEN(PATH$)==0THEN
   RETURN
  ENDIF
  OFS_GETFOBJ2 FOBJID,PATH$ OUT FOBJID,ERR
  RETURN
 ENDIF
 VAR J=INSTR(I,PATH$,"/")
 IF J==-1THEN J=LEN(PATH$)
 VAR PATH2$=MID$(PATH$,I,J-I)
 OFS_GETFOBJ3 INOBJID,PATH2$ OUT FOBJID,ERR
END
DEF OFS_GETFOBJ3 DIROBJ,DIR$ OUT FOBJID,ERR
 VAR DIROBJ$="DAT:@"+HEX$(DIROBJ,8)+".FS"
'VAR OBJ$="DAT@:"+HEX$(OBJ,8)+".FS"
 DIM FDATA[0]
 LOAD DIROBJ$,FDATA,0
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_READ) THEN ERR=OFS_ERROR_PERM:RETURN

 VAR NAMELEN=FDATA[6]
 
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 FOBJID=OFS_SEARCH_L_DIR(FDATA,DIR$)
 IF!FOBJID THEN@ERR
 
 ERR=FALSE
 
 RETURN
 @ERR
 ERR=TRUE
END
DEF OFS_FILES_L_DIR(DIR[],OUT$)
 VAR I,L=LEN(DIR)-1
 FOR I=8TO L
  VAR RLEN=DIR[I]+1
  I=I+1
' VAR FOBJ=DIR[I]'unused
  I=I+1
  VAR LEN=DIR[I],J,L2=I+LEN
  
  VAR K=0,NAME$=""
  FOR J=I+1 TO L2
   INC NAME$,CHR$(DIR[J])
  NEXT
  PUSH OUT$,NAME$
  I=I+RLEN
 NEXT
 RETURN FALSE
END
DEF OFS_FILES PATH$ OUT A$[],ERR
 DIM DIR$[0]
 VAR PATH,DIROBJ
 OFS_GETFOBJ PATH$ OUT DIROBJ,ERR
 IF ERR THEN RETURN

 VAR DIROBJ$="DAT:@"+HEX$(DIROBJ,8)+".FS"
'VAR OBJ$="DAT@:"+HEX$(OBJ,8)+".FS"
 DIM FDATA[0]
 LOAD DIROBJ$,FDATA,0

 IF FDATA[0]!=OFS_MAGIC_OTYF THEN @ERR
 IF FDATA[1]==OFS_MAGIC_SDEV THEN @DEV
 IF FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_READ) THEN ERR=OFS_ERROR_PERM:RETURN

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 IF OFS_FILES_L_DIR(FDATA,DIR$)THEN@ERR
 
 A$=DIR$
 ERR=FALSE
 RETURN
 @DEV
 VAR DEVNAME$,DEVARG$
 OFS_READ_DEVICE DIROBJ OUT DEVNAME$,DEVARG$,ERR
 IF ERR THEN RETURN
 CALL "OFS_DEVICE_FILES_"+DEVNAME$,DEVARG$,"" OUT A$,ERR
 
 RETURN
 @ERR
 ERR=TRUE
END
DEF OFS_DEVICE_FILES_PROJECT PROJECT$,PATH$ OUT A$,ERR
 DIM F$[0]
 FILES F$
 A$=F$
 ERR=0
END
DEF OFS_READ_DEVICE DIROBJ OUT DEVNAME$,DEVARG$,ERR
 VAR DIROBJ$="DAT:@"+HEX$(DIROBJ,8)+".FS"
'VAR OBJ$="DAT@:"+HEX$(OBJ,8)+".FS"
 DIM FDATA[0]
 LOAD DIROBJ$,FDATA,0
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDEV THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_READ) THEN ERR=OFS_ERROR_PERM:RETURN
 OFS_READ_STR FDATA,6 OUT DEVNAME$
 STOP
 OFS_READ_STR FDATA,6+LEN(DEVNAME$)+1OUT DEVARG$
 ERR=FALSE
 RETURN
 @ERR
 ERR=TRUE
END
'RANDOMIZEで らんすう が おかしく なる かのうせい が ある
DEF OFS_RAND()
 OFS_RAND_Y=OFS_RAND_Y XOR (OFS_RAND_Y<<13)
 OFS_RAND_Y=OFS_RAND_Y XOR (OFS_RAND_Y>>17)
 OFS_RAND_Y=OFS_RAND_Y XOR (OFS_RAND_Y<<5)
 RETURN OFS_RAND_Y
END
DEF OFS_GEN_FOBJFILE OUT FILE$,ID
 @LOOP
 ID=OFS_RAND()
 FILE$="DAT:@"+HEX$(ID,8)+".FS"
 IF CHKFILE(FILE$)THEN
  'らんすうに もんだいが ないかぎり ありえない
  GOTO @LOOP
 ENDIF
 RETURN FILE$
END
DEF OFS_NEWDEVICEFILE(NAME$,ARG$,PERM)
 DIM FDATA[2+1+3+(1+LEN(NAME$))+(1+LEN(ARG$))]
 FDATA[0]=OFS_MAGIC_OTYF
 FDATA[1]=OFS_MAGIC_SDEV
 FDATA[2]=PERM
 OFS_WRITE_DATETIME FDATA,3
 OFS_WRITE_STR FDATA,6,NAME$
 OFS_WRITE_STR FDATA,6+LEN(NAME$)+1,ARG$
 VAR FILE$,FOBJID
 OFS_GEN_FOBJFILE OUT FILE$,FOBJID
 IF OFS_SAVE(FILE$,FDATA)THEN RETURN 0
 RETURN FOBJID
END
DEF OFS_SAVE(FILE$,DAT[])
 SAVE FILE$,DAT
 IF RESULT!=1THEN RETURN TRUE
 RETURN FALSE
END
DEF OFS_WRITE_STR_EXPAND ARY[],S$
 PUSH ARY,LEN(S$)
 VAR J
 FOR J=0 TO LEN(S$)-1
  PUSH ARY,ASC(S$[J])
 NEXT
END
DEF OFS_WRITE_STR ARY[],I,S$
 ARY[I]=LEN(S$)
 VAR J
 FOR J=0 TO LEN(S$)-1
  I=I+1
  ARY[I]=ASC(S$[J])
 NEXT
END
DEF OFS_READ_STR ARY[],I OUT S$
 VAR L=I+1+ARY[I]-1
 S$=""
 FOR I=I+1 TO L
  INC S$,CHR$(ARY[I])
 NEXT
END
DEF OFS_SEARCH_L_DIR(DIR[],NAME$)
 VAR I,L=LEN(DIR)-1
 VAR LNAME=LEN(NAME$)
 FOR I=8TO L
  VAR RLEN=DIR[I]+1
  I=I+1
  VAR FOBJ=DIR[I]
  I=I+1
  VAR LEN=DIR[I],J,L2=I+LEN
  IF LNAME!=LEN THEN
   I=I+RLEN
   CONTINUE
  ENDIF
  VAR K=0
  FOR J=I+1 TO L2
   IF ASC(NAME$[K])!=DIR[J]THEN
    GOTO @MISMATCH
    BREAK
   ENDIF
   K=K+1
  NEXT
  RETURN FOBJ
  @MISMATCH
  I=I+RLEN
 NEXT
 RETURN FALSE
END
DEF OFS_ADDOBJ(DIROBJ,OBJ,NAME$)
 VAR DIROBJ$="DAT:@"+HEX$(DIROBJ,8)+".FS"
'VAR OBJ$="DAT@:"+HEX$(OBJ,8)+".FS"
 DIM FDATA[0]
 LOAD DIROBJ$,FDATA,0
 IF FDATA[0]!=OFS_MAGIC_OTYF||FDATA[1]!=OFS_MAGIC_SDIR THEN @ERR
 IF!(FDATA[2] AND OFS_PERM_WRITE) THEN RETURN OFS_ERROR_PERM

 VAR FILECOUNT=FDATA[6]
 VAR TYPE=FDATA[7]
 ON TYPE GOTO @LINEAR

 @LINEAR
 IF OFS_SEARCH_L_DIR(FDATA,NAME$)THEN
  RETURN OFS_ERROR_ALREADY
 ENDIF
 VAR LN=LEN(NAME$)
 VAR RESERVE=MAX(LN,OFS_DIR_RESERVE_DEF)
 PUSH FDATA,RESERVE
 PUSH FDATA,OBJ
 OFS_WRITE_STR_EXPAND FDATA,NAME$
 VAR I
 FOR I=LEN(NAME$)-1TO RESERVE-1
  PUSH FDATA,0
 NEXT
 SAVE DIROBJ$,FDATA
 RETURN FALSE
 @ERR
 RETURN TRUE
END
'DEF OFS_NEWFILE(PATH$,
DEF OFS_NEWDIR(PATH$,FOBJID,PERM)
 DIM FDATA[2+1+3+1+1]
 FDATA[0]=OFS_MAGIC_OTYF
 FDATA[1]=OFS_MAGIC_SDIR
 FDATA[2]=PERM
 OFS_WRITE_DATETIME FDATA,3
 FDATA[6]=0'FILECOUNT
 FDATA[7]=0'LINEAR
 IF OFS_SAVE("DAT:@"+HEX$(FOBJID,8)+".FS",FDATA)THEN RETURN TRUE
 RETURN FALSE
END
DEF OFS_WRITE_DATETIME ARY[],I
 VAR Y,M,D
 DTREAD OUT Y,M,D
 VAR H,MI,S
 TMREAD OUT H,MI,S
 ARY[I]=Y<<16+M<<8+D
 ARY[I+1]=H<<24+MI<<16+S<<8
 ARY[I+2]=0
END
COMMON DEF NewFile PATH$
 
END
COMMON DEF AddFile PATH$,SBFILE$
 
END

DIM SBARY[0]
VAR SBARYMAX
VAR SBARYFREE
DEF OTX_INIT_SBARRAY
 SBARYMAX=256
 SBARY=NewArray(SBARYMAX)
 VAR I
 FOR I=0TO SBARYMAX-2
  SBARY[I]=I+1
 NEXT
 SBARY[SBARYMAX-1]=-1
 SBARYFREE=0
END
COMMON DEF AllocSBArray()
 VAR A=SBARYFREE
 IF A==-1THEN RETURN -1
 SBARYFREE=SBARY[A]
 RETURN A
END
COMMON DEF FreeSBArray A
 SBARY[A]=SBARYFREE
 SBARYFREE=A
END
COMMON DEF GetSBArray(A)
 RETURN VAR("_"+HEX$(A))
END
COMMON DEF SetSBArray A,ARY
 VAR("_"+HEX$(A))=ARY
END
DIM _0[0]
DIM _1[0]
DIM _2[0]
DIM _3[0]
DIM _4[0]
DIM _5[0]
DIM _6[0]
DIM _7[0]
DIM _8[0]
DIM _9[0]
DIM _A[0]
DIM _B[0]
DIM _C[0]
DIM _D[0]
DIM _E[0]
DIM _F[0]
DIM _10[0]
DIM _11[0]
DIM _12[0]
DIM _13[0]
DIM _14[0]
DIM _15[0]
DIM _16[0]
DIM _17[0]
DIM _18[0]
DIM _19[0]
DIM _1A[0]
DIM _1B[0]
DIM _1C[0]
DIM _1D[0]
DIM _1E[0]
DIM _1F[0]
DIM _20[0]
DIM _21[0]
DIM _22[0]
DIM _23[0]
DIM _24[0]
DIM _25[0]
DIM _26[0]
DIM _27[0]
DIM _28[0]
DIM _29[0]
DIM _2A[0]
DIM _2B[0]
DIM _2C[0]
DIM _2D[0]
DIM _2E[0]
DIM _2F[0]
DIM _30[0]
DIM _31[0]
DIM _32[0]
DIM _33[0]
DIM _34[0]
DIM _35[0]
DIM _36[0]
DIM _37[0]
DIM _38[0]
DIM _39[0]
DIM _3A[0]
DIM _3B[0]
DIM _3C[0]
DIM _3D[0]
DIM _3E[0]
DIM _3F[0]
DIM _40[0]
DIM _41[0]
DIM _42[0]
DIM _43[0]
DIM _44[0]
DIM _45[0]
DIM _46[0]
DIM _47[0]
DIM _48[0]
DIM _49[0]
DIM _4A[0]
DIM _4B[0]
DIM _4C[0]
DIM _4D[0]
DIM _4E[0]
DIM _4F[0]
DIM _50[0]
DIM _51[0]
DIM _52[0]
DIM _53[0]
DIM _54[0]
DIM _55[0]
DIM _56[0]
DIM _57[0]
DIM _58[0]
DIM _59[0]
DIM _5A[0]
DIM _5B[0]
DIM _5C[0]
DIM _5D[0]
DIM _5E[0]
DIM _5F[0]
DIM _60[0]
DIM _61[0]
DIM _62[0]
DIM _63[0]
DIM _64[0]
DIM _65[0]
DIM _66[0]
DIM _67[0]
DIM _68[0]
DIM _69[0]
DIM _6A[0]
DIM _6B[0]
DIM _6C[0]
DIM _6D[0]
DIM _6E[0]
DIM _6F[0]
DIM _70[0]
DIM _71[0]
DIM _72[0]
DIM _73[0]
DIM _74[0]
DIM _75[0]
DIM _76[0]
DIM _77[0]
DIM _78[0]
DIM _79[0]
DIM _7A[0]
DIM _7B[0]
DIM _7C[0]
DIM _7D[0]
DIM _7E[0]
DIM _7F[0]
DIM _80[0]
DIM _81[0]
DIM _82[0]
DIM _83[0]
DIM _84[0]
DIM _85[0]
DIM _86[0]
DIM _87[0]
DIM _88[0]
DIM _89[0]
DIM _8A[0]
DIM _8B[0]
DIM _8C[0]
DIM _8D[0]
DIM _8E[0]
DIM _8F[0]
DIM _90[0]
DIM _91[0]
DIM _92[0]
DIM _93[0]
DIM _94[0]
DIM _95[0]
DIM _96[0]
DIM _97[0]
DIM _98[0]
DIM _99[0]
DIM _9A[0]
DIM _9B[0]
DIM _9C[0]
DIM _9D[0]
DIM _9E[0]
DIM _9F[0]
DIM _A0[0]
DIM _A1[0]
DIM _A2[0]
DIM _A3[0]
DIM _A4[0]
DIM _A5[0]
DIM _A6[0]
DIM _A7[0]
DIM _A8[0]
DIM _A9[0]
DIM _AA[0]
DIM _AB[0]
DIM _AC[0]
DIM _AD[0]
DIM _AE[0]
DIM _AF[0]
DIM _B0[0]
DIM _B1[0]
DIM _B2[0]
DIM _B3[0]
DIM _B4[0]
DIM _B5[0]
DIM _B6[0]
DIM _B7[0]
DIM _B8[0]
DIM _B9[0]
DIM _BA[0]
DIM _BB[0]
DIM _BC[0]
DIM _BD[0]
DIM _BE[0]
DIM _BF[0]
DIM _C0[0]
DIM _C1[0]
DIM _C2[0]
DIM _C3[0]
DIM _C4[0]
DIM _C5[0]
DIM _C6[0]
DIM _C7[0]
DIM _C8[0]
DIM _C9[0]
DIM _CA[0]
DIM _CB[0]
DIM _CC[0]
DIM _CD[0]
DIM _CE[0]
DIM _CF[0]
DIM _D0[0]
DIM _D1[0]
DIM _D2[0]
DIM _D3[0]
DIM _D4[0]
DIM _D5[0]
DIM _D6[0]
DIM _D7[0]
DIM _D8[0]
DIM _D9[0]
DIM _DA[0]
DIM _DB[0]
DIM _DC[0]
DIM _DD[0]
DIM _DE[0]
DIM _DF[0]
DIM _E0[0]
DIM _E1[0]
DIM _E2[0]
DIM _E3[0]
DIM _E4[0]
DIM _E5[0]
DIM _E6[0]
DIM _E7[0]
DIM _E8[0]
DIM _E9[0]
DIM _EA[0]
DIM _EB[0]
DIM _EC[0]
DIM _ED[0]
DIM _EE[0]
DIM _EF[0]
DIM _F0[0]
DIM _F1[0]
DIM _F2[0]
DIM _F3[0]
DIM _F4[0]
DIM _F5[0]
DIM _F6[0]
DIM _F7[0]
DIM _F8[0]
DIM _F9[0]
DIM _FA[0]
DIM _FB[0]
DIM _FC[0]
DIM _FD[0]
DIM _FE[0]
DIM _FF[0]

